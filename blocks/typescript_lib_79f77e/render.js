var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/@netless+slide@1.4.2/node_modules/@netless/slide/lib/Slide.js
var require_Slide = __commonJS({
  "../../node_modules/.pnpm/@netless+slide@1.4.2/node_modules/@netless/slide/lib/Slide.js"(exports, module) {
    module.exports = function(t) {
      var e = {};
      function i(n) {
        if (e[n]) return e[n].exports;
        var r = e[n] = { i: n, l: false, exports: {} };
        return t[n].call(r.exports, r, r.exports, i), r.l = true, r.exports;
      }
      return i.m = t, i.c = e, i.d = function(t2, e2, n) {
        i.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: n });
      }, i.r = function(t2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, i.t = function(t2, e2) {
        if (1 & e2 && (t2 = i(t2)), 8 & e2) return t2;
        if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule) return t2;
        var n = /* @__PURE__ */ Object.create(null);
        if (i.r(n), Object.defineProperty(n, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2) for (var r in t2) i.d(n, r, function(e3) {
          return t2[e3];
        }.bind(null, r));
        return n;
      }, i.n = function(t2) {
        var e2 = t2 && t2.__esModule ? function() {
          return t2.default;
        } : function() {
          return t2;
        };
        return i.d(e2, "a", e2), e2;
      }, i.o = function(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }, i.p = "", i(i.s = 229);
    }([function(t, e, i) {
      "use strict";
      var n, r, o, s, a, l, h, u, c, d, p, f, m, g, v, _, y, x, b;
      i.d(e, "a", function() {
        return m;
      }), i.d(e, "b", function() {
        return s;
      }), i.d(e, "c", function() {
        return o;
      }), i.d(e, "d", function() {
        return b;
      }), i.d(e, "e", function() {
        return g;
      }), i.d(e, "f", function() {
        return a;
      }), i.d(e, "g", function() {
        return n;
      }), i.d(e, "h", function() {
        return l;
      }), i.d(e, "i", function() {
        return v;
      }), i.d(e, "j", function() {
        return y;
      }), i.d(e, "k", function() {
        return f;
      }), i.d(e, "l", function() {
        return x;
      }), i.d(e, "m", function() {
        return _;
      }), i.d(e, "n", function() {
        return r;
      }), i.d(e, "o", function() {
        return c;
      }), i.d(e, "p", function() {
        return d;
      }), i.d(e, "q", function() {
        return h;
      }), i.d(e, "r", function() {
        return u;
      }), i.d(e, "s", function() {
        return p;
      }), function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(n || (n = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(r || (r = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(o || (o = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(s || (s = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(a || (a = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(l || (l = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(h || (h = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(u || (u = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(c || (c = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(d || (d = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(p || (p = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(f || (f = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(m || (m = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(g || (g = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(v || (v = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(_ || (_ = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(y || (y = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(x || (x = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(b || (b = {}));
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return u;
      }), i.d(e, "b", function() {
        return s;
      }), i.d(e, "c", function() {
        return c;
      }), i.d(e, "d", function() {
        return m;
      }), i.d(e, "e", function() {
        return f;
      }), i.d(e, "f", function() {
        return r;
      }), i.d(e, "g", function() {
        return a;
      }), i.d(e, "h", function() {
        return d;
      }), i.d(e, "i", function() {
        return o;
      }), i.d(e, "j", function() {
        return h;
      }), i.d(e, "k", function() {
        return p;
      }), i.d(e, "l", function() {
        return n;
      }), i.d(e, "m", function() {
        return S;
      }), i.d(e, "n", function() {
        return E;
      });
      var n, r = 2 * Math.PI, o = 180 / Math.PI, s = Math.PI / 180;
      !function(t2) {
        t2[t2.POLY = 0] = "POLY", t2[t2.RECT = 1] = "RECT", t2[t2.CIRC = 2] = "CIRC", t2[t2.ELIP = 3] = "ELIP", t2[t2.RREC = 4] = "RREC";
      }(n || (n = {}));
      var a = function() {
        function t2(t3, e2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 0), this.x = 0, this.y = 0, this.x = t3, this.y = e2;
        }
        return t2.prototype.clone = function() {
          return new t2(this.x, this.y);
        }, t2.prototype.copyFrom = function(t3) {
          return this.set(t3.x, t3.y), this;
        }, t2.prototype.copyTo = function(t3) {
          return t3.set(this.x, this.y), t3;
        }, t2.prototype.equals = function(t3) {
          return t3.x === this.x && t3.y === this.y;
        }, t2.prototype.set = function(t3, e2) {
          return void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = t3), this.x = t3, this.y = e2, this;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
        }, t2;
      }(), l = [new a(), new a(), new a(), new a()], h = function() {
        function t2(t3, e2, i2, r2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === r2 && (r2 = 0), this.x = Number(t3), this.y = Number(e2), this.width = Number(i2), this.height = Number(r2), this.type = n.RECT;
        }
        return Object.defineProperty(t2.prototype, "left", { get: function() {
          return this.x;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "right", { get: function() {
          return this.x + this.width;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "top", { get: function() {
          return this.y;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "bottom", { get: function() {
          return this.y + this.height;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "EMPTY", { get: function() {
          return new t2(0, 0, 0, 0);
        }, enumerable: false, configurable: true }), t2.prototype.clone = function() {
          return new t2(this.x, this.y, this.width, this.height);
        }, t2.prototype.copyFrom = function(t3) {
          return this.x = t3.x, this.y = t3.y, this.width = t3.width, this.height = t3.height, this;
        }, t2.prototype.copyTo = function(t3) {
          return t3.x = this.x, t3.y = this.y, t3.width = this.width, t3.height = this.height, t3;
        }, t2.prototype.contains = function(t3, e2) {
          return !(this.width <= 0 || this.height <= 0) && (t3 >= this.x && t3 < this.x + this.width && e2 >= this.y && e2 < this.y + this.height);
        }, t2.prototype.intersects = function(t3, e2) {
          if (!e2) {
            var i2 = this.x < t3.x ? t3.x : this.x;
            if ((this.right > t3.right ? t3.right : this.right) <= i2) return false;
            var n2 = this.y < t3.y ? t3.y : this.y;
            return (this.bottom > t3.bottom ? t3.bottom : this.bottom) > n2;
          }
          var r2 = this.left, o2 = this.right, s2 = this.top, a2 = this.bottom;
          if (o2 <= r2 || a2 <= s2) return false;
          var h2 = l[0].set(t3.left, t3.top), u2 = l[1].set(t3.left, t3.bottom), c2 = l[2].set(t3.right, t3.top), d2 = l[3].set(t3.right, t3.bottom);
          if (c2.x <= h2.x || u2.y <= h2.y) return false;
          var p2 = Math.sign(e2.a * e2.d - e2.b * e2.c);
          if (0 === p2) return false;
          if (e2.apply(h2, h2), e2.apply(u2, u2), e2.apply(c2, c2), e2.apply(d2, d2), Math.max(h2.x, u2.x, c2.x, d2.x) <= r2 || Math.min(h2.x, u2.x, c2.x, d2.x) >= o2 || Math.max(h2.y, u2.y, c2.y, d2.y) <= s2 || Math.min(h2.y, u2.y, c2.y, d2.y) >= a2) return false;
          var f2 = p2 * (u2.y - h2.y), m2 = p2 * (h2.x - u2.x), g2 = f2 * r2 + m2 * s2, v2 = f2 * o2 + m2 * s2, _2 = f2 * r2 + m2 * a2, y2 = f2 * o2 + m2 * a2;
          if (Math.max(g2, v2, _2, y2) <= f2 * h2.x + m2 * h2.y || Math.min(g2, v2, _2, y2) >= f2 * d2.x + m2 * d2.y) return false;
          var x2 = p2 * (h2.y - c2.y), b2 = p2 * (c2.x - h2.x), T2 = x2 * r2 + b2 * s2, E2 = x2 * o2 + b2 * s2, S2 = x2 * r2 + b2 * a2, w = x2 * o2 + b2 * a2;
          return !(Math.max(T2, E2, S2, w) <= x2 * h2.x + b2 * h2.y || Math.min(T2, E2, S2, w) >= x2 * d2.x + b2 * d2.y);
        }, t2.prototype.pad = function(t3, e2) {
          return void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = t3), this.x -= t3, this.y -= e2, this.width += 2 * t3, this.height += 2 * e2, this;
        }, t2.prototype.fit = function(t3) {
          var e2 = Math.max(this.x, t3.x), i2 = Math.min(this.x + this.width, t3.x + t3.width), n2 = Math.max(this.y, t3.y), r2 = Math.min(this.y + this.height, t3.y + t3.height);
          return this.x = e2, this.width = Math.max(i2 - e2, 0), this.y = n2, this.height = Math.max(r2 - n2, 0), this;
        }, t2.prototype.ceil = function(t3, e2) {
          void 0 === t3 && (t3 = 1), void 0 === e2 && (e2 = 1e-3);
          var i2 = Math.ceil((this.x + this.width - e2) * t3) / t3, n2 = Math.ceil((this.y + this.height - e2) * t3) / t3;
          return this.x = Math.floor((this.x + e2) * t3) / t3, this.y = Math.floor((this.y + e2) * t3) / t3, this.width = i2 - this.x, this.height = n2 - this.y, this;
        }, t2.prototype.enlarge = function(t3) {
          var e2 = Math.min(this.x, t3.x), i2 = Math.max(this.x + this.width, t3.x + t3.width), n2 = Math.min(this.y, t3.y), r2 = Math.max(this.y + this.height, t3.y + t3.height);
          return this.x = e2, this.width = i2 - e2, this.y = n2, this.height = r2 - n2, this;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
        }, t2;
      }(), u = function() {
        function t2(t3, e2, i2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), this.x = t3, this.y = e2, this.radius = i2, this.type = n.CIRC;
        }
        return t2.prototype.clone = function() {
          return new t2(this.x, this.y, this.radius);
        }, t2.prototype.contains = function(t3, e2) {
          if (this.radius <= 0) return false;
          var i2 = this.radius * this.radius, n2 = this.x - t3, r2 = this.y - e2;
          return (n2 *= n2) + (r2 *= r2) <= i2;
        }, t2.prototype.getBounds = function() {
          return new h(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius);
        }, t2.prototype.toString = function() {
          return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
        }, t2;
      }(), c = function() {
        function t2(t3, e2, i2, r2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === r2 && (r2 = 0), this.x = t3, this.y = e2, this.width = i2, this.height = r2, this.type = n.ELIP;
        }
        return t2.prototype.clone = function() {
          return new t2(this.x, this.y, this.width, this.height);
        }, t2.prototype.contains = function(t3, e2) {
          if (this.width <= 0 || this.height <= 0) return false;
          var i2 = (t3 - this.x) / this.width, n2 = (e2 - this.y) / this.height;
          return (i2 *= i2) + (n2 *= n2) <= 1;
        }, t2.prototype.getBounds = function() {
          return new h(this.x - this.width, this.y - this.height, this.width, this.height);
        }, t2.prototype.toString = function() {
          return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
        }, t2;
      }(), d = function() {
        function t2() {
          for (var t3 = arguments, e2 = [], i2 = 0; i2 < arguments.length; i2++) e2[i2] = t3[i2];
          var r2 = Array.isArray(e2[0]) ? e2[0] : e2;
          if ("number" != typeof r2[0]) {
            for (var o2 = [], s2 = 0, a2 = r2.length; s2 < a2; s2++) o2.push(r2[s2].x, r2[s2].y);
            r2 = o2;
          }
          this.points = r2, this.type = n.POLY, this.closeStroke = true;
        }
        return t2.prototype.clone = function() {
          var e2 = new t2(this.points.slice());
          return e2.closeStroke = this.closeStroke, e2;
        }, t2.prototype.contains = function(t3, e2) {
          for (var i2 = false, n2 = this.points.length / 2, r2 = 0, o2 = n2 - 1; r2 < n2; o2 = r2++) {
            var s2 = this.points[2 * r2], a2 = this.points[2 * r2 + 1], l2 = this.points[2 * o2], h2 = this.points[2 * o2 + 1];
            a2 > e2 != h2 > e2 && t3 < (e2 - a2) / (h2 - a2) * (l2 - s2) + s2 && (i2 = !i2);
          }
          return i2;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:PolygoncloseStroke=" + this.closeStroke + "points=" + this.points.reduce(function(t3, e2) {
            return t3 + ", " + e2;
          }, "") + "]";
        }, t2;
      }(), p = function() {
        function t2(t3, e2, i2, r2, o2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 20), this.x = t3, this.y = e2, this.width = i2, this.height = r2, this.radius = o2, this.type = n.RREC;
        }
        return t2.prototype.clone = function() {
          return new t2(this.x, this.y, this.width, this.height, this.radius);
        }, t2.prototype.contains = function(t3, e2) {
          if (this.width <= 0 || this.height <= 0) return false;
          if (t3 >= this.x && t3 <= this.x + this.width && e2 >= this.y && e2 <= this.y + this.height) {
            var i2 = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (e2 >= this.y + i2 && e2 <= this.y + this.height - i2 || t3 >= this.x + i2 && t3 <= this.x + this.width - i2) return true;
            var n2 = t3 - (this.x + i2), r2 = e2 - (this.y + i2), o2 = i2 * i2;
            if (n2 * n2 + r2 * r2 <= o2) return true;
            if ((n2 = t3 - (this.x + this.width - i2)) * n2 + r2 * r2 <= o2) return true;
            if (n2 * n2 + (r2 = e2 - (this.y + this.height - i2)) * r2 <= o2) return true;
            if ((n2 = t3 - (this.x + i2)) * n2 + r2 * r2 <= o2) return true;
          }
          return false;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + "width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]";
        }, t2;
      }(), f = function() {
        function t2(t3, e2, i2, n2) {
          void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 0), this._x = i2, this._y = n2, this.cb = t3, this.scope = e2;
        }
        return t2.prototype.clone = function(e2, i2) {
          return void 0 === e2 && (e2 = this.cb), void 0 === i2 && (i2 = this.scope), new t2(e2, i2, this._x, this._y);
        }, t2.prototype.set = function(t3, e2) {
          return void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = t3), this._x === t3 && this._y === e2 || (this._x = t3, this._y = e2, this.cb.call(this.scope)), this;
        }, t2.prototype.copyFrom = function(t3) {
          return this._x === t3.x && this._y === t3.y || (this._x = t3.x, this._y = t3.y, this.cb.call(this.scope)), this;
        }, t2.prototype.copyTo = function(t3) {
          return t3.set(this._x, this._y), t3;
        }, t2.prototype.equals = function(t3) {
          return t3.x === this._x && t3.y === this._y;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
        }, Object.defineProperty(t2.prototype, "x", { get: function() {
          return this._x;
        }, set: function(t3) {
          this._x !== t3 && (this._x = t3, this.cb.call(this.scope));
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "y", { get: function() {
          return this._y;
        }, set: function(t3) {
          this._y !== t3 && (this._y = t3, this.cb.call(this.scope));
        }, enumerable: false, configurable: true }), t2;
      }(), m = function() {
        function t2(t3, e2, i2, n2, r2, o2) {
          void 0 === t3 && (t3 = 1), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), this.array = null, this.a = t3, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2;
        }
        return t2.prototype.fromArray = function(t3) {
          this.a = t3[0], this.b = t3[1], this.c = t3[3], this.d = t3[4], this.tx = t3[2], this.ty = t3[5];
        }, t2.prototype.set = function(t3, e2, i2, n2, r2, o2) {
          return this.a = t3, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2, this;
        }, t2.prototype.toArray = function(t3, e2) {
          this.array || (this.array = new Float32Array(9));
          var i2 = e2 || this.array;
          return t3 ? (i2[0] = this.a, i2[1] = this.b, i2[2] = 0, i2[3] = this.c, i2[4] = this.d, i2[5] = 0, i2[6] = this.tx, i2[7] = this.ty, i2[8] = 1) : (i2[0] = this.a, i2[1] = this.c, i2[2] = this.tx, i2[3] = this.b, i2[4] = this.d, i2[5] = this.ty, i2[6] = 0, i2[7] = 0, i2[8] = 1), i2;
        }, t2.prototype.apply = function(t3, e2) {
          e2 = e2 || new a();
          var i2 = t3.x, n2 = t3.y;
          return e2.x = this.a * i2 + this.c * n2 + this.tx, e2.y = this.b * i2 + this.d * n2 + this.ty, e2;
        }, t2.prototype.applyInverse = function(t3, e2) {
          e2 = e2 || new a();
          var i2 = 1 / (this.a * this.d + this.c * -this.b), n2 = t3.x, r2 = t3.y;
          return e2.x = this.d * i2 * n2 + -this.c * i2 * r2 + (this.ty * this.c - this.tx * this.d) * i2, e2.y = this.a * i2 * r2 + -this.b * i2 * n2 + (-this.ty * this.a + this.tx * this.b) * i2, e2;
        }, t2.prototype.translate = function(t3, e2) {
          return this.tx += t3, this.ty += e2, this;
        }, t2.prototype.scale = function(t3, e2) {
          return this.a *= t3, this.d *= e2, this.c *= t3, this.b *= e2, this.tx *= t3, this.ty *= e2, this;
        }, t2.prototype.rotate = function(t3) {
          var e2 = Math.cos(t3), i2 = Math.sin(t3), n2 = this.a, r2 = this.c, o2 = this.tx;
          return this.a = n2 * e2 - this.b * i2, this.b = n2 * i2 + this.b * e2, this.c = r2 * e2 - this.d * i2, this.d = r2 * i2 + this.d * e2, this.tx = o2 * e2 - this.ty * i2, this.ty = o2 * i2 + this.ty * e2, this;
        }, t2.prototype.append = function(t3) {
          var e2 = this.a, i2 = this.b, n2 = this.c, r2 = this.d;
          return this.a = t3.a * e2 + t3.b * n2, this.b = t3.a * i2 + t3.b * r2, this.c = t3.c * e2 + t3.d * n2, this.d = t3.c * i2 + t3.d * r2, this.tx = t3.tx * e2 + t3.ty * n2 + this.tx, this.ty = t3.tx * i2 + t3.ty * r2 + this.ty, this;
        }, t2.prototype.setTransform = function(t3, e2, i2, n2, r2, o2, s2, a2, l2) {
          return this.a = Math.cos(s2 + l2) * r2, this.b = Math.sin(s2 + l2) * r2, this.c = -Math.sin(s2 - a2) * o2, this.d = Math.cos(s2 - a2) * o2, this.tx = t3 - (i2 * this.a + n2 * this.c), this.ty = e2 - (i2 * this.b + n2 * this.d), this;
        }, t2.prototype.prepend = function(t3) {
          var e2 = this.tx;
          if (1 !== t3.a || 0 !== t3.b || 0 !== t3.c || 1 !== t3.d) {
            var i2 = this.a, n2 = this.c;
            this.a = i2 * t3.a + this.b * t3.c, this.b = i2 * t3.b + this.b * t3.d, this.c = n2 * t3.a + this.d * t3.c, this.d = n2 * t3.b + this.d * t3.d;
          }
          return this.tx = e2 * t3.a + this.ty * t3.c + t3.tx, this.ty = e2 * t3.b + this.ty * t3.d + t3.ty, this;
        }, t2.prototype.decompose = function(t3) {
          var e2 = this.a, i2 = this.b, n2 = this.c, o2 = this.d, s2 = t3.pivot, a2 = -Math.atan2(-n2, o2), l2 = Math.atan2(i2, e2), h2 = Math.abs(a2 + l2);
          return h2 < 1e-5 || Math.abs(r - h2) < 1e-5 ? (t3.rotation = l2, t3.skew.x = t3.skew.y = 0) : (t3.rotation = 0, t3.skew.x = a2, t3.skew.y = l2), t3.scale.x = Math.sqrt(e2 * e2 + i2 * i2), t3.scale.y = Math.sqrt(n2 * n2 + o2 * o2), t3.position.x = this.tx + (s2.x * e2 + s2.y * n2), t3.position.y = this.ty + (s2.x * i2 + s2.y * o2), t3;
        }, t2.prototype.invert = function() {
          var t3 = this.a, e2 = this.b, i2 = this.c, n2 = this.d, r2 = this.tx, o2 = t3 * n2 - e2 * i2;
          return this.a = n2 / o2, this.b = -e2 / o2, this.c = -i2 / o2, this.d = t3 / o2, this.tx = (i2 * this.ty - n2 * r2) / o2, this.ty = -(t3 * this.ty - e2 * r2) / o2, this;
        }, t2.prototype.identity = function() {
          return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
        }, t2.prototype.clone = function() {
          var e2 = new t2();
          return e2.a = this.a, e2.b = this.b, e2.c = this.c, e2.d = this.d, e2.tx = this.tx, e2.ty = this.ty, e2;
        }, t2.prototype.copyTo = function(t3) {
          return t3.a = this.a, t3.b = this.b, t3.c = this.c, t3.d = this.d, t3.tx = this.tx, t3.ty = this.ty, t3;
        }, t2.prototype.copyFrom = function(t3) {
          return this.a = t3.a, this.b = t3.b, this.c = t3.c, this.d = t3.d, this.tx = t3.tx, this.ty = t3.ty, this;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
        }, Object.defineProperty(t2, "IDENTITY", { get: function() {
          return new t2();
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "TEMP_MATRIX", { get: function() {
          return new t2();
        }, enumerable: false, configurable: true }), t2;
      }(), g = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], v = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], _ = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], y = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], x = [], b = [], T = Math.sign;
      !function() {
        for (var t2 = 0; t2 < 16; t2++) {
          var e2 = [];
          x.push(e2);
          for (var i2 = 0; i2 < 16; i2++) for (var n2 = T(g[t2] * g[i2] + _[t2] * v[i2]), r2 = T(v[t2] * g[i2] + y[t2] * v[i2]), o2 = T(g[t2] * _[i2] + _[t2] * y[i2]), s2 = T(v[t2] * _[i2] + y[t2] * y[i2]), a2 = 0; a2 < 16; a2++) if (g[a2] === n2 && v[a2] === r2 && _[a2] === o2 && y[a2] === s2) {
            e2.push(a2);
            break;
          }
        }
        for (t2 = 0; t2 < 16; t2++) {
          var l2 = new m();
          l2.set(g[t2], v[t2], _[t2], y[t2], 0, 0), b.push(l2);
        }
      }();
      var E = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function(t2) {
        return g[t2];
      }, uY: function(t2) {
        return v[t2];
      }, vX: function(t2) {
        return _[t2];
      }, vY: function(t2) {
        return y[t2];
      }, inv: function(t2) {
        return 8 & t2 ? 15 & t2 : 7 & -t2;
      }, add: function(t2, e2) {
        return x[t2][e2];
      }, sub: function(t2, e2) {
        return x[t2][E.inv(e2)];
      }, rotate180: function(t2) {
        return 4 ^ t2;
      }, isVertical: function(t2) {
        return 2 == (3 & t2);
      }, byDirection: function(t2, e2) {
        return 2 * Math.abs(t2) <= Math.abs(e2) ? e2 >= 0 ? E.S : E.N : 2 * Math.abs(e2) <= Math.abs(t2) ? t2 > 0 ? E.E : E.W : e2 > 0 ? t2 > 0 ? E.SE : E.SW : t2 > 0 ? E.NE : E.NW;
      }, matrixAppendRotationInv: function(t2, e2, i2, n2) {
        void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 0);
        var r2 = b[E.inv(e2)];
        r2.tx = i2, r2.ty = n2, t2.append(r2);
      } }, S = function() {
        function t2() {
          this.worldTransform = new m(), this.localTransform = new m(), this.position = new f(this.onChange, this, 0, 0), this.scale = new f(this.onChange, this, 1, 1), this.pivot = new f(this.onChange, this, 0, 0), this.skew = new f(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
        }
        return t2.prototype.onChange = function() {
          this._localID++;
        }, t2.prototype.updateSkew = function() {
          this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
        }, t2.prototype.toString = function() {
          return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]";
        }, t2.prototype.updateLocalTransform = function() {
          var t3 = this.localTransform;
          this._localID !== this._currentLocalID && (t3.a = this._cx * this.scale.x, t3.b = this._sx * this.scale.x, t3.c = this._cy * this.scale.y, t3.d = this._sy * this.scale.y, t3.tx = this.position.x - (this.pivot.x * t3.a + this.pivot.y * t3.c), t3.ty = this.position.y - (this.pivot.x * t3.b + this.pivot.y * t3.d), this._currentLocalID = this._localID, this._parentID = -1);
        }, t2.prototype.updateTransform = function(t3) {
          var e2 = this.localTransform;
          if (this._localID !== this._currentLocalID && (e2.a = this._cx * this.scale.x, e2.b = this._sx * this.scale.x, e2.c = this._cy * this.scale.y, e2.d = this._sy * this.scale.y, e2.tx = this.position.x - (this.pivot.x * e2.a + this.pivot.y * e2.c), e2.ty = this.position.y - (this.pivot.x * e2.b + this.pivot.y * e2.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t3._worldID) {
            var i2 = t3.worldTransform, n2 = this.worldTransform;
            n2.a = e2.a * i2.a + e2.b * i2.c, n2.b = e2.a * i2.b + e2.b * i2.d, n2.c = e2.c * i2.a + e2.d * i2.c, n2.d = e2.c * i2.b + e2.d * i2.d, n2.tx = e2.tx * i2.a + e2.ty * i2.c + i2.tx, n2.ty = e2.tx * i2.b + e2.ty * i2.d + i2.ty, this._parentID = t3._worldID, this._worldID++;
          }
        }, t2.prototype.setFromMatrix = function(t3) {
          t3.decompose(this), this._localID++;
        }, Object.defineProperty(t2.prototype, "rotation", { get: function() {
          return this._rotation;
        }, set: function(t3) {
          this._rotation !== t3 && (this._rotation = t3, this.updateSkew());
        }, enumerable: false, configurable: true }), t2.IDENTITY = new t2(), t2;
      }();
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return le;
      }), i.d(e, "b", function() {
        return I;
      }), i.d(e, "c", function() {
        return v;
      }), i.d(e, "d", function() {
        return me;
      }), i.d(e, "e", function() {
        return xe;
      }), i.d(e, "f", function() {
        return Ee;
      }), i.d(e, "g", function() {
        return ge;
      }), i.d(e, "h", function() {
        return k;
      }), i.d(e, "i", function() {
        return m;
      }), i.d(e, "j", function() {
        return b;
      }), i.d(e, "k", function() {
        return Lt;
      }), i.d(e, "l", function() {
        return V;
      }), i.d(e, "m", function() {
        return $;
      }), i.d(e, "n", function() {
        return Pt;
      }), i.d(e, "o", function() {
        return W;
      }), i.d(e, "p", function() {
        return D;
      }), i.d(e, "q", function() {
        return ce;
      }), i.d(e, "r", function() {
        return Ot;
      }), i.d(e, "s", function() {
        return Nt;
      }), i.d(e, "t", function() {
        return L;
      }), i.d(e, "u", function() {
        return Ft;
      }), i.d(e, "v", function() {
        return q;
      }), i.d(e, "w", function() {
        return w;
      }), i.d(e, "x", function() {
        return ve;
      }), i.d(e, "y", function() {
        return de;
      }), i.d(e, "z", function() {
        return fe;
      }), i.d(e, "A", function() {
        return pe;
      });
      var n = i(4), r = i(0), o = i(3), s = i(12), a = i(7), l = i(1);
      n.b.PREFER_ENV = o.isMobile.any ? r.g.WEBGL : r.g.WEBGL2, n.b.STRICT_TEXTURE_CACHE = false;
      var h = [];
      function u(t2, e2) {
        if (!t2) return null;
        var i2 = "";
        if ("string" == typeof t2) {
          var n2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(t2);
          n2 && (i2 = n2[1].toLowerCase());
        }
        for (var r2 = h.length - 1; r2 >= 0; --r2) {
          var o2 = h[r2];
          if (o2.test && o2.test(t2, i2)) return new o2(t2, e2);
        }
        throw new Error("Unrecognized source type to auto-detect Resource");
      }
      var c = function(t2, e2) {
        return (c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function d(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        c(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var p = function() {
        return (p = Object.assign || function(t2) {
          for (var e2, i2 = arguments, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var o2 in e2 = i2[n2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t2[o2] = e2[o2]);
          return t2;
        }).apply(this, arguments);
      };
      var f = function() {
        function t2(t3, e2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = 0), this._width = t3, this._height = e2, this.destroyed = false, this.internal = false, this.onResize = new s.a("setRealSize"), this.onUpdate = new s.a("update"), this.onError = new s.a("onError");
        }
        return t2.prototype.bind = function(t3) {
          this.onResize.add(t3), this.onUpdate.add(t3), this.onError.add(t3), (this._width || this._height) && this.onResize.emit(this._width, this._height);
        }, t2.prototype.unbind = function(t3) {
          this.onResize.remove(t3), this.onUpdate.remove(t3), this.onError.remove(t3);
        }, t2.prototype.resize = function(t3, e2) {
          t3 === this._width && e2 === this._height || (this._width = t3, this._height = e2, this.onResize.emit(t3, e2));
        }, Object.defineProperty(t2.prototype, "valid", { get: function() {
          return !!this._width && !!this._height;
        }, enumerable: false, configurable: true }), t2.prototype.update = function() {
          this.destroyed || this.onUpdate.emit();
        }, t2.prototype.load = function() {
          return Promise.resolve(this);
        }, Object.defineProperty(t2.prototype, "width", { get: function() {
          return this._width;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "height", { get: function() {
          return this._height;
        }, enumerable: false, configurable: true }), t2.prototype.style = function(t3, e2, i2) {
          return false;
        }, t2.prototype.dispose = function() {
        }, t2.prototype.destroy = function() {
          this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
        }, t2.test = function(t3, e2) {
          return false;
        }, t2;
      }(), m = function(t2) {
        function e2(e3, i2) {
          var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
          if (!o2 || !s2) throw new Error("BufferResource width or height invalid");
          return (n2 = t2.call(this, o2, s2) || this).data = e3, n2;
        }
        return d(e2, t2), e2.prototype.upload = function(t3, e3, i2) {
          var n2 = t3.gl;
          n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
          var o2 = e3.realWidth, s2 = e3.realHeight;
          return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
        }, e2.prototype.dispose = function() {
          this.data = null;
        }, e2.test = function(t3) {
          return t3 instanceof Float32Array || t3 instanceof Uint8Array || t3 instanceof Uint32Array;
        }, e2;
      }(f), g = { scaleMode: r.p.NEAREST, format: r.h.RGBA, alphaMode: r.a.NPM }, v = function(t2) {
        function e2(e3, i2) {
          void 0 === e3 && (e3 = null), void 0 === i2 && (i2 = null);
          var s2 = t2.call(this) || this, a2 = (i2 = i2 || {}).alphaMode, l2 = i2.mipmap, h2 = i2.anisotropicLevel, c2 = i2.scaleMode, d2 = i2.width, p2 = i2.height, m2 = i2.wrapMode, g2 = i2.format, v2 = i2.type, _2 = i2.target, y2 = i2.resolution, x2 = i2.resourceOptions;
          return !e3 || e3 instanceof f || ((e3 = u(e3, x2)).internal = true), s2.resolution = y2 || n.b.RESOLUTION, s2.width = Math.round((d2 || 0) * s2.resolution) / s2.resolution, s2.height = Math.round((p2 || 0) * s2.resolution) / s2.resolution, s2._mipmap = void 0 !== l2 ? l2 : n.b.MIPMAP_TEXTURES, s2.anisotropicLevel = void 0 !== h2 ? h2 : n.b.ANISOTROPIC_LEVEL, s2._wrapMode = m2 || n.b.WRAP_MODE, s2._scaleMode = void 0 !== c2 ? c2 : n.b.SCALE_MODE, s2.format = g2 || r.h.RGBA, s2.type = v2 || r.r.UNSIGNED_BYTE, s2.target = _2 || r.q.TEXTURE_2D, s2.alphaMode = void 0 !== a2 ? a2 : r.a.UNPACK, s2.uid = Object(o.uid)(), s2.touched = 0, s2.isPowerOfTwo = false, s2._refreshPOT(), s2._glTextures = {}, s2.dirtyId = 0, s2.dirtyStyleId = 0, s2.cacheId = null, s2.valid = d2 > 0 && p2 > 0, s2.textureCacheIds = [], s2.destroyed = false, s2.resource = null, s2._batchEnabled = 0, s2._batchLocation = 0, s2.parentTextureArray = null, s2.setResource(e3), s2;
        }
        return d(e2, t2), Object.defineProperty(e2.prototype, "realWidth", { get: function() {
          return Math.round(this.width * this.resolution);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "realHeight", { get: function() {
          return Math.round(this.height * this.resolution);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mipmap", { get: function() {
          return this._mipmap;
        }, set: function(t3) {
          this._mipmap !== t3 && (this._mipmap = t3, this.dirtyStyleId++);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scaleMode", { get: function() {
          return this._scaleMode;
        }, set: function(t3) {
          this._scaleMode !== t3 && (this._scaleMode = t3, this.dirtyStyleId++);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "wrapMode", { get: function() {
          return this._wrapMode;
        }, set: function(t3) {
          this._wrapMode !== t3 && (this._wrapMode = t3, this.dirtyStyleId++);
        }, enumerable: false, configurable: true }), e2.prototype.setStyle = function(t3, e3) {
          var i2;
          return void 0 !== t3 && t3 !== this.scaleMode && (this.scaleMode = t3, i2 = true), void 0 !== e3 && e3 !== this.mipmap && (this.mipmap = e3, i2 = true), i2 && this.dirtyStyleId++, this;
        }, e2.prototype.setSize = function(t3, e3, i2) {
          return i2 = i2 || this.resolution, this.setRealSize(t3 * i2, e3 * i2, i2);
        }, e2.prototype.setRealSize = function(t3, e3, i2) {
          return this.resolution = i2 || this.resolution, this.width = Math.round(t3) / this.resolution, this.height = Math.round(e3) / this.resolution, this._refreshPOT(), this.update(), this;
        }, e2.prototype._refreshPOT = function() {
          this.isPowerOfTwo = Object(o.isPow2)(this.realWidth) && Object(o.isPow2)(this.realHeight);
        }, e2.prototype.setResolution = function(t3) {
          var e3 = this.resolution;
          return e3 === t3 || (this.resolution = t3, this.valid && (this.width = Math.round(this.width * e3) / t3, this.height = Math.round(this.height * e3) / t3, this.emit("update", this)), this._refreshPOT()), this;
        }, e2.prototype.setResource = function(t3) {
          if (this.resource === t3) return this;
          if (this.resource) throw new Error("Resource can be set only once");
          return t3.bind(this), this.resource = t3, this;
        }, e2.prototype.update = function() {
          this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
        }, e2.prototype.onError = function(t3) {
          this.emit("error", this, t3);
        }, e2.prototype.destroy = function() {
          this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete o.BaseTextureCache[this.cacheId], delete o.TextureCache[this.cacheId], this.cacheId = null), this.dispose(), e2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true;
        }, e2.prototype.dispose = function() {
          this.emit("dispose", this);
        }, e2.prototype.castToBaseTexture = function() {
          return this;
        }, e2.from = function(t3, i2, r2) {
          void 0 === r2 && (r2 = n.b.STRICT_TEXTURE_CACHE);
          var s2 = "string" == typeof t3, a2 = null;
          if (s2) a2 = t3;
          else {
            if (!t3._pixiId) {
              var l2 = i2 && i2.pixiIdPrefix || "pixiid";
              t3._pixiId = l2 + "_" + Object(o.uid)();
            }
            a2 = t3._pixiId;
          }
          var h2 = o.BaseTextureCache[a2];
          if (s2 && r2 && !h2) throw new Error('The cacheId "' + a2 + '" does not exist in BaseTextureCache.');
          return h2 || ((h2 = new e2(t3, i2)).cacheId = a2, e2.addToCache(h2, a2)), h2;
        }, e2.fromBuffer = function(t3, i2, n2, o2) {
          t3 = t3 || new Float32Array(i2 * n2 * 4);
          var s2 = new m(t3, { width: i2, height: n2 }), a2 = t3 instanceof Float32Array ? r.r.FLOAT : r.r.UNSIGNED_BYTE;
          return new e2(s2, Object.assign(g, o2 || { width: i2, height: n2, type: a2 }));
        }, e2.addToCache = function(t3, e3) {
          e3 && (-1 === t3.textureCacheIds.indexOf(e3) && t3.textureCacheIds.push(e3), o.BaseTextureCache[e3] && console.warn("BaseTexture added to the cache with an id [" + e3 + "] that already had an entry"), o.BaseTextureCache[e3] = t3);
        }, e2.removeFromCache = function(t3) {
          if ("string" == typeof t3) {
            var e3 = o.BaseTextureCache[t3];
            if (e3) {
              var i2 = e3.textureCacheIds.indexOf(t3);
              return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete o.BaseTextureCache[t3], e3;
            }
          } else if (t3 && t3.textureCacheIds) {
            for (var n2 = 0; n2 < t3.textureCacheIds.length; ++n2) delete o.BaseTextureCache[t3.textureCacheIds[n2]];
            return t3.textureCacheIds.length = 0, t3;
          }
          return null;
        }, e2._globalBatch = 0, e2;
      }(o.EventEmitter), _ = function(t2) {
        function e2(e3, i2) {
          var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
          (n2 = t2.call(this, o2, s2) || this).items = [], n2.itemDirtyIds = [];
          for (var a2 = 0; a2 < e3; a2++) {
            var l2 = new v();
            n2.items.push(l2), n2.itemDirtyIds.push(-2);
          }
          return n2.length = e3, n2._load = null, n2.baseTexture = null, n2;
        }
        return d(e2, t2), e2.prototype.initFromArray = function(t3, e3) {
          for (var i2 = 0; i2 < this.length; i2++) t3[i2] && (t3[i2].castToBaseTexture ? this.addBaseTextureAt(t3[i2].castToBaseTexture(), i2) : t3[i2] instanceof f ? this.addResourceAt(t3[i2], i2) : this.addResourceAt(u(t3[i2], e3), i2));
        }, e2.prototype.dispose = function() {
          for (var t3 = 0, e3 = this.length; t3 < e3; t3++) this.items[t3].destroy();
          this.items = null, this.itemDirtyIds = null, this._load = null;
        }, e2.prototype.addResourceAt = function(t3, e3) {
          if (!this.items[e3]) throw new Error("Index " + e3 + " is out of bounds");
          return t3.valid && !this.valid && this.resize(t3.width, t3.height), this.items[e3].setResource(t3), this;
        }, e2.prototype.bind = function(e3) {
          if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
          t2.prototype.bind.call(this, e3);
          for (var i2 = 0; i2 < this.length; i2++) this.items[i2].parentTextureArray = e3, this.items[i2].on("update", e3.update, e3);
        }, e2.prototype.unbind = function(e3) {
          t2.prototype.unbind.call(this, e3);
          for (var i2 = 0; i2 < this.length; i2++) this.items[i2].parentTextureArray = null, this.items[i2].off("update", e3.update, e3);
        }, e2.prototype.load = function() {
          var t3 = this;
          if (this._load) return this._load;
          var e3 = this.items.map(function(t4) {
            return t4.resource;
          }).filter(function(t4) {
            return t4;
          }).map(function(t4) {
            return t4.load();
          });
          return this._load = Promise.all(e3).then(function() {
            var e4 = t3.items[0], i2 = e4.realWidth, n2 = e4.realHeight;
            return t3.resize(i2, n2), Promise.resolve(t3);
          }), this._load;
        }, e2;
      }(f), y = function(t2) {
        function e2(e3, i2) {
          var n2, r2, o2 = this, s2 = i2 || {}, a2 = s2.width, l2 = s2.height;
          return Array.isArray(e3) ? (n2 = e3, r2 = e3.length) : r2 = e3, o2 = t2.call(this, r2, { width: a2, height: l2 }) || this, n2 && o2.initFromArray(n2, i2), o2;
        }
        return d(e2, t2), e2.prototype.addBaseTextureAt = function(t3, e3) {
          if (!t3.resource) throw new Error("ArrayResource does not support RenderTexture");
          return this.addResourceAt(t3.resource, e3), this;
        }, e2.prototype.bind = function(e3) {
          t2.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_2D_ARRAY;
        }, e2.prototype.upload = function(t3, e3, i2) {
          var n2 = this.length, r2 = this.itemDirtyIds, o2 = this.items, s2 = t3.gl;
          i2.dirtyId < 0 && s2.texImage3D(s2.TEXTURE_2D_ARRAY, 0, i2.internalFormat, this._width, this._height, n2, 0, e3.format, i2.type, null);
          for (var a2 = 0; a2 < n2; a2++) {
            var l2 = o2[a2];
            r2[a2] < l2.dirtyId && (r2[a2] = l2.dirtyId, l2.valid && s2.texSubImage3D(s2.TEXTURE_2D_ARRAY, 0, 0, 0, a2, l2.resource.width, l2.resource.height, 1, e3.format, i2.type, l2.resource.source));
          }
          return true;
        }, e2;
      }(_), x = function(t2) {
        function e2(e3) {
          var i2 = this, n2 = e3, r2 = n2.naturalWidth || n2.videoWidth || n2.width, o2 = n2.naturalHeight || n2.videoHeight || n2.height;
          return (i2 = t2.call(this, r2, o2) || this).source = e3, i2.noSubImage = false, i2;
        }
        return d(e2, t2), e2.crossOrigin = function(t3, e3, i2) {
          void 0 === i2 && 0 !== e3.indexOf("data:") ? t3.crossOrigin = Object(o.determineCrossOrigin)(e3) : false !== i2 && (t3.crossOrigin = "string" == typeof i2 ? i2 : "anonymous");
        }, e2.prototype.upload = function(t3, e3, i2, n2) {
          var o2 = t3.gl, s2 = e3.realWidth, a2 = e3.realHeight;
          if ((n2 = n2 || this.source) instanceof HTMLImageElement) {
            if (!n2.complete || 0 === n2.naturalWidth) return false;
          } else if (n2 instanceof HTMLVideoElement && n2.readyState <= 1) return false;
          return o2.pixelStorei(o2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK), this.noSubImage || e3.target !== o2.TEXTURE_2D || i2.width !== s2 || i2.height !== a2 ? (i2.width = s2, i2.height = a2, o2.texImage2D(e3.target, 0, i2.internalFormat, e3.format, i2.type, n2)) : o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e3.format, i2.type, n2), true;
        }, e2.prototype.update = function() {
          if (!this.destroyed) {
            var e3 = this.source, i2 = e3.naturalWidth || e3.videoWidth || e3.width, n2 = e3.naturalHeight || e3.videoHeight || e3.height;
            this.resize(i2, n2), t2.prototype.update.call(this);
          }
        }, e2.prototype.dispose = function() {
          this.source = null;
        }, e2;
      }(f), b = function(t2) {
        function e2(e3) {
          return t2.call(this, e3) || this;
        }
        return d(e2, t2), e2.test = function(t3) {
          var e3 = globalThis.OffscreenCanvas;
          return !!(e3 && t3 instanceof e3) || globalThis.HTMLCanvasElement && t3 instanceof HTMLCanvasElement;
        }, e2;
      }(x), T = function(t2) {
        function e2(i2, n2) {
          var o2 = this, s2 = n2 || {}, a2 = s2.width, l2 = s2.height, h2 = s2.autoLoad, u2 = s2.linkBaseTexture;
          if (i2 && i2.length !== e2.SIDES) throw new Error("Invalid length. Got " + i2.length + ", expected 6");
          o2 = t2.call(this, 6, { width: a2, height: l2 }) || this;
          for (var c2 = 0; c2 < e2.SIDES; c2++) o2.items[c2].target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + c2;
          return o2.linkBaseTexture = false !== u2, i2 && o2.initFromArray(i2, n2), false !== h2 && o2.load(), o2;
        }
        return d(e2, t2), e2.prototype.bind = function(e3) {
          t2.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_CUBE_MAP;
        }, e2.prototype.addBaseTextureAt = function(t3, e3, i2) {
          if (!this.items[e3]) throw new Error("Index " + e3 + " is out of bounds");
          if (!this.linkBaseTexture || t3.parentTextureArray || Object.keys(t3._glTextures).length > 0) {
            if (!t3.resource) throw new Error("CubeResource does not support copying of renderTexture.");
            this.addResourceAt(t3.resource, e3);
          } else t3.target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + e3, t3.parentTextureArray = this.baseTexture, this.items[e3] = t3;
          return t3.valid && !this.valid && this.resize(t3.realWidth, t3.realHeight), this.items[e3] = t3, this;
        }, e2.prototype.upload = function(t3, i2, n2) {
          for (var r2 = this.itemDirtyIds, o2 = 0; o2 < e2.SIDES; o2++) {
            var s2 = this.items[o2];
            r2[o2] < s2.dirtyId && (s2.valid && s2.resource ? (s2.resource.upload(t3, s2, n2), r2[o2] = s2.dirtyId) : r2[o2] < -1 && (t3.gl.texImage2D(s2.target, 0, n2.internalFormat, i2.realWidth, i2.realHeight, 0, i2.format, n2.type, null), r2[o2] = -1));
          }
          return true;
        }, e2.test = function(t3) {
          return Array.isArray(t3) && t3.length === e2.SIDES;
        }, e2.SIDES = 6, e2;
      }(_), E = function(t2) {
        function e2(e3, i2) {
          var r2 = this;
          if (i2 = i2 || {}, !(e3 instanceof HTMLImageElement)) {
            var o2 = new Image();
            x.crossOrigin(o2, e3, i2.crossorigin), o2.src = e3, e3 = o2;
          }
          return r2 = t2.call(this, e3) || this, !e3.complete && r2._width && r2._height && (r2._width = 0, r2._height = 0), r2.url = e3.src, r2._process = null, r2.preserveBitmap = false, r2.createBitmap = (void 0 !== i2.createBitmap ? i2.createBitmap : n.b.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, r2.alphaMode = "number" == typeof i2.alphaMode ? i2.alphaMode : null, r2.bitmap = null, r2._load = null, false !== i2.autoLoad && r2.load(), r2;
        }
        return d(e2, t2), e2.prototype.load = function(t3) {
          var e3 = this;
          return this._load || (void 0 !== t3 && (this.createBitmap = t3), this._load = new Promise(function(t4, i2) {
            var n2 = e3.source;
            e3.url = n2.src;
            var r2 = function() {
              e3.destroyed || (n2.onload = null, n2.onerror = null, e3.resize(n2.width, n2.height), e3._load = null, e3.createBitmap ? t4(e3.process()) : t4(e3));
            };
            n2.complete && n2.src ? r2() : (n2.onload = r2, n2.onerror = function(t5) {
              i2(t5), e3.onError.emit(t5);
            });
          })), this._load;
        }, e2.prototype.process = function() {
          var t3 = this, e3 = this.source;
          if (null !== this._process) return this._process;
          if (null !== this.bitmap || !globalThis.createImageBitmap) return Promise.resolve(this);
          var i2 = globalThis.createImageBitmap, n2 = !e3.crossOrigin || "anonymous" === e3.crossOrigin;
          return this._process = fetch(e3.src, { mode: n2 ? "cors" : "no-cors" }).then(function(t4) {
            return t4.blob();
          }).then(function(n3) {
            return i2(n3, 0, 0, e3.width, e3.height, { premultiplyAlpha: t3.alphaMode === r.a.UNPACK ? "premultiply" : "none" });
          }).then(function(e4) {
            return t3.destroyed ? Promise.reject() : (t3.bitmap = e4, t3.update(), t3._process = null, Promise.resolve(t3));
          }), this._process;
        }, e2.prototype.upload = function(e3, i2, n2) {
          if ("number" == typeof this.alphaMode && (i2.alphaMode = this.alphaMode), !this.createBitmap) return t2.prototype.upload.call(this, e3, i2, n2);
          if (!this.bitmap && (this.process(), !this.bitmap)) return false;
          if (t2.prototype.upload.call(this, e3, i2, n2, this.bitmap), !this.preserveBitmap) {
            var r2 = true, o2 = i2._glTextures;
            for (var s2 in o2) {
              var a2 = o2[s2];
              if (a2 !== n2 && a2.dirtyId !== i2.dirtyId) {
                r2 = false;
                break;
              }
            }
            r2 && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
          }
          return true;
        }, e2.prototype.dispose = function() {
          this.source.onload = null, this.source.onerror = null, t2.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
        }, e2.test = function(t3) {
          return "string" == typeof t3 || t3 instanceof HTMLImageElement;
        }, e2;
      }(x), S = function(t2) {
        function e2(e3, i2) {
          var n2 = this;
          return i2 = i2 || {}, (n2 = t2.call(this, document.createElement("canvas")) || this)._width = 0, n2._height = 0, n2.svg = e3, n2.scale = i2.scale || 1, n2._overrideWidth = i2.width, n2._overrideHeight = i2.height, n2._resolve = null, n2._crossorigin = i2.crossorigin, n2._load = null, false !== i2.autoLoad && n2.load(), n2;
        }
        return d(e2, t2), e2.prototype.load = function() {
          var t3 = this;
          return this._load || (this._load = new Promise(function(i2) {
            if (t3._resolve = function() {
              t3.resize(t3.source.width, t3.source.height), i2(t3);
            }, e2.SVG_XML.test(t3.svg.trim())) {
              if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
              t3.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t3.svg)));
            }
            t3._loadSvg();
          })), this._load;
        }, e2.prototype._loadSvg = function() {
          var t3 = this, e3 = new Image();
          x.crossOrigin(e3, this.svg, this._crossorigin), e3.src = this.svg, e3.onerror = function(i2) {
            t3._resolve && (e3.onerror = null, t3.onError.emit(i2));
          }, e3.onload = function() {
            if (t3._resolve) {
              var i2 = e3.width, n2 = e3.height;
              if (!i2 || !n2) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
              var r2 = i2 * t3.scale, s2 = n2 * t3.scale;
              (t3._overrideWidth || t3._overrideHeight) && (r2 = t3._overrideWidth || t3._overrideHeight / n2 * i2, s2 = t3._overrideHeight || t3._overrideWidth / i2 * n2), r2 = Math.round(r2), s2 = Math.round(s2);
              var a2 = t3.source;
              a2.width = r2, a2.height = s2, a2._pixiId = "canvas_" + Object(o.uid)(), a2.getContext("2d").drawImage(e3, 0, 0, i2, n2, 0, 0, r2, s2), t3._resolve(), t3._resolve = null;
            }
          };
        }, e2.getSize = function(t3) {
          var i2 = e2.SVG_SIZE.exec(t3), n2 = {};
          return i2 && (n2[i2[1]] = Math.round(parseFloat(i2[3])), n2[i2[5]] = Math.round(parseFloat(i2[7]))), n2;
        }, e2.prototype.dispose = function() {
          t2.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
        }, e2.test = function(t3, i2) {
          return "svg" === i2 || "string" == typeof t3 && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t3) || "string" == typeof t3 && e2.SVG_XML.test(t3);
        }, e2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e2;
      }(x), w = function(t2) {
        function e2(i2, n2) {
          var r2 = this;
          if (n2 = n2 || {}, !(i2 instanceof HTMLVideoElement)) {
            var o2 = document.createElement("video");
            o2.setAttribute("preload", "auto"), o2.setAttribute("webkit-playsinline", ""), o2.setAttribute("playsinline", ""), "string" == typeof i2 && (i2 = [i2]);
            var s2 = i2[0].src || i2[0];
            x.crossOrigin(o2, s2, n2.crossorigin);
            for (var a2 = 0; a2 < i2.length; ++a2) {
              var l2 = document.createElement("source"), h2 = i2[a2], u2 = h2.src, c2 = h2.mime, d2 = (u2 = u2 || i2[a2]).split("?").shift().toLowerCase(), p2 = d2.slice(d2.lastIndexOf(".") + 1);
              c2 = c2 || e2.MIME_TYPES[p2] || "video/" + p2, l2.src = u2, l2.type = c2, o2.appendChild(l2);
            }
            i2 = o2;
          }
          return (r2 = t2.call(this, i2) || this).noSubImage = true, r2._autoUpdate = true, r2._isConnectedToTicker = false, r2._updateFPS = n2.updateFPS || 0, r2._msToNextUpdate = 0, r2.autoPlay = false !== n2.autoPlay, r2._load = null, r2._resolve = null, r2._onCanPlay = r2._onCanPlay.bind(r2), r2._onError = r2._onError.bind(r2), false !== n2.autoLoad && r2.load(), r2;
        }
        return d(e2, t2), e2.prototype.update = function(e3) {
          if (!this.destroyed) {
            var i2 = a.a.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - i2), (!this._updateFPS || this._msToNextUpdate <= 0) && (t2.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
          }
        }, e2.prototype.load = function() {
          var t3 = this;
          if (this._load) return this._load;
          var e3 = this.source;
          return (e3.readyState === e3.HAVE_ENOUGH_DATA || e3.readyState === e3.HAVE_FUTURE_DATA) && e3.width && e3.height && (e3.complete = true), e3.addEventListener("play", this._onPlayStart.bind(this)), e3.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e3.addEventListener("canplay", this._onCanPlay), e3.addEventListener("canplaythrough", this._onCanPlay), e3.addEventListener("error", this._onError, true)), this._load = new Promise(function(i2) {
            t3.valid ? i2(t3) : (t3._resolve = i2, e3.load());
          }), this._load;
        }, e2.prototype._onError = function(t3) {
          this.source.removeEventListener("error", this._onError, true), this.onError.emit(t3);
        }, e2.prototype._isSourcePlaying = function() {
          var t3 = this.source;
          return t3.currentTime > 0 && false === t3.paused && false === t3.ended && t3.readyState > 2;
        }, e2.prototype._isSourceReady = function() {
          var t3 = this.source;
          return 3 === t3.readyState || 4 === t3.readyState;
        }, e2.prototype._onPlayStart = function() {
          this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (a.a.shared.add(this.update, this), this._isConnectedToTicker = true);
        }, e2.prototype._onPlayStop = function() {
          this._isConnectedToTicker && (a.a.shared.remove(this.update, this), this._isConnectedToTicker = false);
        }, e2.prototype._onCanPlay = function() {
          var t3 = this.source;
          t3.removeEventListener("canplay", this._onCanPlay), t3.removeEventListener("canplaythrough", this._onCanPlay);
          var e3 = this.valid;
          this.resize(t3.videoWidth, t3.videoHeight), !e3 && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t3.play();
        }, e2.prototype.dispose = function() {
          this._isConnectedToTicker && (a.a.shared.remove(this.update, this), this._isConnectedToTicker = false);
          var e3 = this.source;
          e3 && (e3.removeEventListener("error", this._onError, true), e3.pause(), e3.src = "", e3.load()), t2.prototype.dispose.call(this);
        }, Object.defineProperty(e2.prototype, "autoUpdate", { get: function() {
          return this._autoUpdate;
        }, set: function(t3) {
          t3 !== this._autoUpdate && (this._autoUpdate = t3, !this._autoUpdate && this._isConnectedToTicker ? (a.a.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (a.a.shared.add(this.update, this), this._isConnectedToTicker = true));
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "updateFPS", { get: function() {
          return this._updateFPS;
        }, set: function(t3) {
          t3 !== this._updateFPS && (this._updateFPS = t3);
        }, enumerable: false, configurable: true }), e2.test = function(t3, i2) {
          return globalThis.HTMLVideoElement && t3 instanceof HTMLVideoElement || e2.TYPES.indexOf(i2) > -1;
        }, e2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e2.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e2;
      }(x), A = function(t2) {
        function e2(e3) {
          return t2.call(this, e3) || this;
        }
        return d(e2, t2), e2.test = function(t3) {
          return !!globalThis.createImageBitmap && t3 instanceof ImageBitmap;
        }, e2;
      }(x);
      h.push(E, A, b, w, S, m, T, y);
      var M = { __proto__: null, Resource: f, BaseImageResource: x, INSTALLED: h, autoDetectResource: u, AbstractMultiResource: _, ArrayResource: y, BufferResource: m, CanvasResource: b, CubeResource: T, ImageResource: E, SVGResource: S, VideoResource: w, ImageBitmapResource: A }, C = function(t2) {
        function e2() {
          return null !== t2 && t2.apply(this, arguments) || this;
        }
        return d(e2, t2), e2.prototype.upload = function(t3, e3, i2) {
          var n2 = t3.gl;
          n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
          var o2 = e3.realWidth, s2 = e3.realHeight;
          return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
        }, e2;
      }(m), R = function() {
        function t2(t3, e2) {
          this.width = Math.round(t3 || 100), this.height = Math.round(e2 || 100), this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new s.a("disposeFramebuffer"), this.multisample = r.l.NONE;
        }
        return Object.defineProperty(t2.prototype, "colorTexture", { get: function() {
          return this.colorTextures[0];
        }, enumerable: false, configurable: true }), t2.prototype.addColorTexture = function(t3, e2) {
          return void 0 === t3 && (t3 = 0), this.colorTextures[t3] = e2 || new v(null, { scaleMode: r.p.NEAREST, resolution: 1, mipmap: r.k.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this;
        }, t2.prototype.addDepthTexture = function(t3) {
          return this.depthTexture = t3 || new v(new C(null, { width: this.width, height: this.height }), { scaleMode: r.p.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: r.k.OFF, format: r.h.DEPTH_COMPONENT, type: r.r.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this;
        }, t2.prototype.enableDepth = function() {
          return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
        }, t2.prototype.enableStencil = function() {
          return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
        }, t2.prototype.resize = function(t3, e2) {
          if (t3 = Math.round(t3), e2 = Math.round(e2), t3 !== this.width || e2 !== this.height) {
            this.width = t3, this.height = e2, this.dirtyId++, this.dirtySize++;
            for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
              var n2 = this.colorTextures[i2], r2 = n2.resolution;
              n2.setSize(t3 / r2, e2 / r2);
            }
            if (this.depthTexture) {
              r2 = this.depthTexture.resolution;
              this.depthTexture.setSize(t3 / r2, e2 / r2);
            }
          }
        }, t2.prototype.dispose = function() {
          this.disposeRunner.emit(this, false);
        }, t2.prototype.destroyDepthTexture = function() {
          this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
        }, t2;
      }(), I = function(t2) {
        function e2(e3) {
          void 0 === e3 && (e3 = {});
          var i2 = this;
          if ("number" == typeof e3) {
            var n2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            e3 = { width: n2, height: o2, scaleMode: s2, resolution: a2 };
          }
          return e3.width = e3.width || 100, e3.height = e3.height || 100, e3.multisample = void 0 !== e3.multisample ? e3.multisample : r.l.NONE, (i2 = t2.call(this, null, e3) || this).mipmap = r.k.OFF, i2.valid = true, i2.clearColor = [0, 0, 0, 0], i2.framebuffer = new R(i2.realWidth, i2.realHeight).addColorTexture(0, i2), i2.framebuffer.multisample = e3.multisample, i2.maskStack = [], i2.filterStack = [{}], i2;
        }
        return d(e2, t2), e2.prototype.resize = function(t3, e3) {
          this.framebuffer.resize(t3 * this.resolution, e3 * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
        }, e2.prototype.dispose = function() {
          this.framebuffer.dispose(), t2.prototype.dispose.call(this);
        }, e2.prototype.destroy = function() {
          t2.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
        }, e2;
      }(v), P = function() {
        function t2() {
          this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
        }
        return t2.prototype.set = function(t3, e2, i2) {
          var n2 = e2.width, r2 = e2.height;
          if (i2) {
            var o2 = t3.width / 2 / n2, s2 = t3.height / 2 / r2, a2 = t3.x / n2 + o2, h2 = t3.y / r2 + s2;
            i2 = l.n.add(i2, l.n.NW), this.x0 = a2 + o2 * l.n.uX(i2), this.y0 = h2 + s2 * l.n.uY(i2), i2 = l.n.add(i2, 2), this.x1 = a2 + o2 * l.n.uX(i2), this.y1 = h2 + s2 * l.n.uY(i2), i2 = l.n.add(i2, 2), this.x2 = a2 + o2 * l.n.uX(i2), this.y2 = h2 + s2 * l.n.uY(i2), i2 = l.n.add(i2, 2), this.x3 = a2 + o2 * l.n.uX(i2), this.y3 = h2 + s2 * l.n.uY(i2);
          } else this.x0 = t3.x / n2, this.y0 = t3.y / r2, this.x1 = (t3.x + t3.width) / n2, this.y1 = t3.y / r2, this.x2 = (t3.x + t3.width) / n2, this.y2 = (t3.y + t3.height) / r2, this.x3 = t3.x / n2, this.y3 = (t3.y + t3.height) / r2;
          this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
        }, t2.prototype.toString = function() {
          return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]";
        }, t2;
      }(), O = new P();
      function N(t2) {
        t2.destroy = function() {
        }, t2.on = function() {
        }, t2.once = function() {
        }, t2.emit = function() {
        };
      }
      var L = function(t2) {
        function e2(i2, n2, r2, o2, s2, a2) {
          var h2 = t2.call(this) || this;
          if (h2.noFrame = false, n2 || (h2.noFrame = true, n2 = new l.j(0, 0, 1, 1)), i2 instanceof e2 && (i2 = i2.baseTexture), h2.baseTexture = i2, h2._frame = n2, h2.trim = o2, h2.valid = false, h2._uvs = O, h2.uvMatrix = null, h2.orig = r2 || n2, h2._rotate = Number(s2 || 0), true === s2) h2._rotate = 2;
          else if (h2._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
          return h2.defaultAnchor = a2 ? new l.g(a2.x, a2.y) : new l.g(0, 0), h2._updateID = 0, h2.textureCacheIds = [], i2.valid ? h2.noFrame ? i2.valid && h2.onBaseTextureUpdated(i2) : h2.frame = n2 : i2.once("loaded", h2.onBaseTextureUpdated, h2), h2.noFrame && i2.on("update", h2.onBaseTextureUpdated, h2), h2;
        }
        return d(e2, t2), e2.prototype.update = function() {
          this.baseTexture.resource && this.baseTexture.resource.update();
        }, e2.prototype.onBaseTextureUpdated = function(t3) {
          if (this.noFrame) {
            if (!this.baseTexture.valid) return;
            this._frame.width = t3.width, this._frame.height = t3.height, this.valid = true, this.updateUvs();
          } else this.frame = this._frame;
          this.emit("update", this);
        }, e2.prototype.destroy = function(t3) {
          if (this.baseTexture) {
            if (t3) {
              var i2 = this.baseTexture.resource;
              i2 && i2.url && o.TextureCache[i2.url] && e2.removeFromCache(i2.url), this.baseTexture.destroy();
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
          }
          this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, e2.removeFromCache(this), this.textureCacheIds = null;
        }, e2.prototype.clone = function() {
          var t3 = this._frame.clone(), i2 = this._frame === this.orig ? t3 : this.orig.clone(), n2 = new e2(this.baseTexture, !this.noFrame && t3, i2, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
          return this.noFrame && (n2._frame = t3), n2;
        }, e2.prototype.updateUvs = function() {
          this._uvs === O && (this._uvs = new P()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
        }, e2.from = function(t3, i2, r2) {
          void 0 === i2 && (i2 = {}), void 0 === r2 && (r2 = n.b.STRICT_TEXTURE_CACHE);
          var s2 = "string" == typeof t3, a2 = null;
          if (s2) a2 = t3;
          else if (t3 instanceof v) {
            if (!t3.cacheId) {
              var l2 = i2 && i2.pixiIdPrefix || "pixiid";
              t3.cacheId = l2 + "-" + Object(o.uid)(), v.addToCache(t3, t3.cacheId);
            }
            a2 = t3.cacheId;
          } else {
            if (!t3._pixiId) {
              l2 = i2 && i2.pixiIdPrefix || "pixiid";
              t3._pixiId = l2 + "_" + Object(o.uid)();
            }
            a2 = t3._pixiId;
          }
          var h2 = o.TextureCache[a2];
          if (s2 && r2 && !h2) throw new Error('The cacheId "' + a2 + '" does not exist in TextureCache.');
          return h2 || t3 instanceof v ? !h2 && t3 instanceof v && (h2 = new e2(t3), e2.addToCache(h2, a2)) : (i2.resolution || (i2.resolution = Object(o.getResolutionOfUrl)(t3)), (h2 = new e2(new v(t3, i2))).baseTexture.cacheId = a2, v.addToCache(h2.baseTexture, a2), e2.addToCache(h2, a2)), h2;
        }, e2.fromURL = function(t3, i2) {
          var n2 = Object.assign({ autoLoad: false }, null == i2 ? void 0 : i2.resourceOptions), r2 = e2.from(t3, Object.assign({ resourceOptions: n2 }, i2), false), o2 = r2.baseTexture.resource;
          return r2.baseTexture.valid ? Promise.resolve(r2) : o2.load().then(function() {
            return Promise.resolve(r2);
          });
        }, e2.fromBuffer = function(t3, i2, n2, r2) {
          return new e2(v.fromBuffer(t3, i2, n2, r2));
        }, e2.fromLoader = function(t3, i2, r2, s2) {
          var a2 = new v(t3, Object.assign({ scaleMode: n.b.SCALE_MODE, resolution: Object(o.getResolutionOfUrl)(i2) }, s2)), l2 = a2.resource;
          l2 instanceof E && (l2.url = i2);
          var h2 = new e2(a2);
          return r2 || (r2 = i2), v.addToCache(h2.baseTexture, r2), e2.addToCache(h2, r2), r2 !== i2 && (v.addToCache(h2.baseTexture, i2), e2.addToCache(h2, i2)), h2.baseTexture.valid ? Promise.resolve(h2) : new Promise(function(t4) {
            h2.baseTexture.once("loaded", function() {
              return t4(h2);
            });
          });
        }, e2.addToCache = function(t3, e3) {
          e3 && (-1 === t3.textureCacheIds.indexOf(e3) && t3.textureCacheIds.push(e3), o.TextureCache[e3] && console.warn("Texture added to the cache with an id [" + e3 + "] that already had an entry"), o.TextureCache[e3] = t3);
        }, e2.removeFromCache = function(t3) {
          if ("string" == typeof t3) {
            var e3 = o.TextureCache[t3];
            if (e3) {
              var i2 = e3.textureCacheIds.indexOf(t3);
              return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete o.TextureCache[t3], e3;
            }
          } else if (t3 && t3.textureCacheIds) {
            for (var n2 = 0; n2 < t3.textureCacheIds.length; ++n2) o.TextureCache[t3.textureCacheIds[n2]] === t3 && delete o.TextureCache[t3.textureCacheIds[n2]];
            return t3.textureCacheIds.length = 0, t3;
          }
          return null;
        }, Object.defineProperty(e2.prototype, "resolution", { get: function() {
          return this.baseTexture.resolution;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "frame", { get: function() {
          return this._frame;
        }, set: function(t3) {
          this._frame = t3, this.noFrame = false;
          var e3 = t3.x, i2 = t3.y, n2 = t3.width, r2 = t3.height, o2 = e3 + n2 > this.baseTexture.width, s2 = i2 + r2 > this.baseTexture.height;
          if (o2 || s2) {
            var a2 = o2 && s2 ? "and" : "or", l2 = "X: " + e3 + " + " + n2 + " = " + (e3 + n2) + " > " + this.baseTexture.width, h2 = "Y: " + i2 + " + " + r2 + " = " + (i2 + r2) + " > " + this.baseTexture.height;
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l2 + " " + a2 + " " + h2);
          }
          this.valid = n2 && r2 && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t3), this.valid && this.updateUvs();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotate", { get: function() {
          return this._rotate;
        }, set: function(t3) {
          this._rotate = t3, this.valid && this.updateUvs();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
          return this.orig.width;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this.orig.height;
        }, enumerable: false, configurable: true }), e2.prototype.castToBaseTexture = function() {
          return this.baseTexture;
        }, Object.defineProperty(e2, "EMPTY", { get: function() {
          return e2._EMPTY || (e2._EMPTY = new e2(new v()), N(e2._EMPTY), N(e2._EMPTY.baseTexture)), e2._EMPTY;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2, "WHITE", { get: function() {
          if (!e2._WHITE) {
            var t3 = document.createElement("canvas"), i2 = t3.getContext("2d");
            t3.width = 16, t3.height = 16, i2.fillStyle = "white", i2.fillRect(0, 0, 16, 16), e2._WHITE = new e2(new v(new b(t3))), N(e2._WHITE), N(e2._WHITE.baseTexture);
          }
          return e2._WHITE;
        }, enumerable: false, configurable: true }), e2;
      }(o.EventEmitter), D = function(t2) {
        function e2(e3, i2) {
          var n2 = t2.call(this, e3, i2) || this;
          return n2.valid = true, n2.filterFrame = null, n2.filterPoolKey = null, n2.updateUvs(), n2;
        }
        return d(e2, t2), Object.defineProperty(e2.prototype, "framebuffer", { get: function() {
          return this.baseTexture.framebuffer;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "multisample", { get: function() {
          return this.framebuffer.multisample;
        }, set: function(t3) {
          this.framebuffer.multisample = t3;
        }, enumerable: false, configurable: true }), e2.prototype.resize = function(t3, e3, i2) {
          void 0 === i2 && (i2 = true);
          var n2 = this.baseTexture.resolution, r2 = Math.round(t3 * n2) / n2, o2 = Math.round(e3 * n2) / n2;
          this.valid = r2 > 0 && o2 > 0, this._frame.width = this.orig.width = r2, this._frame.height = this.orig.height = o2, i2 && this.baseTexture.resize(r2, o2), this.updateUvs();
        }, e2.prototype.setResolution = function(t3) {
          var e3 = this.baseTexture;
          e3.resolution !== t3 && (e3.setResolution(t3), this.resize(e3.width, e3.height, false));
        }, e2.create = function(t3) {
          for (var i2 = arguments, n2 = [], r2 = 1; r2 < arguments.length; r2++) n2[r2 - 1] = i2[r2];
          return "number" == typeof t3 && (Object(o.deprecation)("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t3 = { width: t3, height: n2[0], scaleMode: n2[1], resolution: n2[2] }), new e2(new I(t3));
        }, e2;
      }(L), F = function() {
        function t2(t3) {
          this.texturePool = {}, this.textureOptions = t3 || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
        }
        return t2.prototype.createTexture = function(t3, e2, i2) {
          void 0 === i2 && (i2 = r.l.NONE);
          var n2 = new I(Object.assign({ width: t3, height: e2, resolution: 1, multisample: i2 }, this.textureOptions));
          return new D(n2);
        }, t2.prototype.getOptimalTexture = function(t3, e2, i2, n2) {
          var s2;
          void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = r.l.NONE), t3 = Math.ceil(t3 * i2 - 1e-6), e2 = Math.ceil(e2 * i2 - 1e-6), this.enableFullScreen && t3 === this._pixelsWidth && e2 === this._pixelsHeight ? s2 = n2 > 1 ? -n2 : -1 : (s2 = ((65535 & (t3 = Object(o.nextPow2)(t3))) << 16 | 65535 & (e2 = Object(o.nextPow2)(e2))) >>> 0, n2 > 1 && (s2 += 4294967296 * n2)), this.texturePool[s2] || (this.texturePool[s2] = []);
          var a2 = this.texturePool[s2].pop();
          return a2 || (a2 = this.createTexture(t3, e2, n2)), a2.filterPoolKey = s2, a2.setResolution(i2), a2;
        }, t2.prototype.getFilterTexture = function(t3, e2, i2) {
          var n2 = this.getOptimalTexture(t3.width, t3.height, e2 || t3.resolution, i2 || r.l.NONE);
          return n2.filterFrame = t3.filterFrame, n2;
        }, t2.prototype.returnTexture = function(t3) {
          var e2 = t3.filterPoolKey;
          t3.filterFrame = null, this.texturePool[e2].push(t3);
        }, t2.prototype.returnFilterTexture = function(t3) {
          this.returnTexture(t3);
        }, t2.prototype.clear = function(t3) {
          if (t3 = false !== t3) for (var e2 in this.texturePool) {
            var i2 = this.texturePool[e2];
            if (i2) for (var n2 = 0; n2 < i2.length; n2++) i2[n2].destroy(true);
          }
          this.texturePool = {};
        }, t2.prototype.setScreenSize = function(t3) {
          if (t3.width !== this._pixelsWidth || t3.height !== this._pixelsHeight) {
            for (var e2 in this.enableFullScreen = t3.width > 0 && t3.height > 0, this.texturePool) if (Number(e2) < 0) {
              var i2 = this.texturePool[e2];
              if (i2) for (var n2 = 0; n2 < i2.length; n2++) i2[n2].destroy(true);
              this.texturePool[e2] = [];
            }
            this._pixelsWidth = t3.width, this._pixelsHeight = t3.height;
          }
        }, t2.SCREEN_KEY = -1, t2;
      }(), B = function() {
        function t2(t3, e2, i2, n2, o2, s2, a2) {
          void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = false), void 0 === n2 && (n2 = r.r.FLOAT), this.buffer = t3, this.size = e2, this.normalized = i2, this.type = n2, this.stride = o2, this.start = s2, this.instance = a2;
        }
        return t2.prototype.destroy = function() {
          this.buffer = null;
        }, t2.from = function(e2, i2, n2, r2, o2) {
          return new t2(e2, i2, n2, r2, o2);
        }, t2;
      }(), U = 0, k = function() {
        function t2(t3, e2, i2) {
          void 0 === e2 && (e2 = true), void 0 === i2 && (i2 = false), this.data = t3 || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i2, this.static = e2, this.id = U++, this.disposeRunner = new s.a("disposeBuffer");
        }
        return t2.prototype.update = function(t3) {
          t3 instanceof Array && (t3 = new Float32Array(t3)), this.data = t3 || this.data, this._updateID++;
        }, t2.prototype.dispose = function() {
          this.disposeRunner.emit(this, false);
        }, t2.prototype.destroy = function() {
          this.dispose(), this.data = null;
        }, Object.defineProperty(t2.prototype, "index", { get: function() {
          return this.type === r.d.ELEMENT_ARRAY_BUFFER;
        }, set: function(t3) {
          this.type = t3 ? r.d.ELEMENT_ARRAY_BUFFER : r.d.ARRAY_BUFFER;
        }, enumerable: false, configurable: true }), t2.from = function(e2) {
          return e2 instanceof Array && (e2 = new Float32Array(e2)), new t2(e2);
        }, t2;
      }(), G = { Float32Array, Uint32Array, Int32Array, Uint8Array };
      var H = { 5126: 4, 5123: 2, 5121: 1 }, j = 0, z = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array }, V = function() {
        function t2(t3, e2) {
          void 0 === t3 && (t3 = []), void 0 === e2 && (e2 = {}), this.buffers = t3, this.indexBuffer = null, this.attributes = e2, this.glVertexArrayObjects = {}, this.id = j++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new s.a("disposeGeometry"), this.refCount = 0;
        }
        return t2.prototype.addAttribute = function(t3, e2, i2, n2, r2, o2, s2, a2) {
          if (void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = false), void 0 === a2 && (a2 = false), !e2) throw new Error("You must pass a buffer when creating an attribute");
          e2 instanceof k || (e2 instanceof Array && (e2 = new Float32Array(e2)), e2 = new k(e2));
          var l2 = t3.split("|");
          if (l2.length > 1) {
            for (var h2 = 0; h2 < l2.length; h2++) this.addAttribute(l2[h2], e2, i2, n2, r2);
            return this;
          }
          var u2 = this.buffers.indexOf(e2);
          return -1 === u2 && (this.buffers.push(e2), u2 = this.buffers.length - 1), this.attributes[t3] = new B(u2, i2, n2, r2, o2, s2, a2), this.instanced = this.instanced || a2, this;
        }, t2.prototype.getAttribute = function(t3) {
          return this.attributes[t3];
        }, t2.prototype.getBuffer = function(t3) {
          return this.buffers[this.getAttribute(t3).buffer];
        }, t2.prototype.addIndex = function(t3) {
          return t3 instanceof k || (t3 instanceof Array && (t3 = new Uint16Array(t3)), t3 = new k(t3)), t3.type = r.d.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t3, -1 === this.buffers.indexOf(t3) && this.buffers.push(t3), this;
        }, t2.prototype.getIndex = function() {
          return this.indexBuffer;
        }, t2.prototype.interleave = function() {
          if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
          var t3, e2 = [], i2 = [], n2 = new k();
          for (t3 in this.attributes) {
            var r2 = this.attributes[t3], s2 = this.buffers[r2.buffer];
            e2.push(s2.data), i2.push(r2.size * H[r2.type] / 4), r2.buffer = 0;
          }
          for (n2.data = function(t4, e3) {
            for (var i3 = 0, n3 = 0, r3 = {}, s3 = 0; s3 < t4.length; s3++) n3 += e3[s3], i3 += t4[s3].length;
            var a2 = new ArrayBuffer(4 * i3), l2 = null, h2 = 0;
            for (s3 = 0; s3 < t4.length; s3++) {
              var u2 = e3[s3], c2 = t4[s3], d2 = Object(o.getBufferType)(c2);
              r3[d2] || (r3[d2] = new G[d2](a2)), l2 = r3[d2];
              for (var p2 = 0; p2 < c2.length; p2++) {
                l2[(p2 / u2 | 0) * n3 + h2 + p2 % u2] = c2[p2];
              }
              h2 += u2;
            }
            return new Float32Array(a2);
          }(e2, i2), t3 = 0; t3 < this.buffers.length; t3++) this.buffers[t3] !== this.indexBuffer && this.buffers[t3].destroy();
          return this.buffers = [n2], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
        }, t2.prototype.getSize = function() {
          for (var t3 in this.attributes) {
            var e2 = this.attributes[t3];
            return this.buffers[e2.buffer].data.length / (e2.stride / 4 || e2.size);
          }
          return 0;
        }, t2.prototype.dispose = function() {
          this.disposeRunner.emit(this, false);
        }, t2.prototype.destroy = function() {
          this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
        }, t2.prototype.clone = function() {
          for (var e2 = new t2(), i2 = 0; i2 < this.buffers.length; i2++) e2.buffers[i2] = new k(this.buffers[i2].data.slice(0));
          for (var i2 in this.attributes) {
            var n2 = this.attributes[i2];
            e2.attributes[i2] = new B(n2.buffer, n2.size, n2.normalized, n2.type, n2.stride, n2.start, n2.instance);
          }
          return this.indexBuffer && (e2.indexBuffer = e2.buffers[this.buffers.indexOf(this.indexBuffer)], e2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER), e2;
        }, t2.merge = function(e2) {
          for (var i2, n2 = new t2(), s2 = [], a2 = [], l2 = [], h2 = 0; h2 < e2.length; h2++) {
            i2 = e2[h2];
            for (var u2 = 0; u2 < i2.buffers.length; u2++) a2[u2] = a2[u2] || 0, a2[u2] += i2.buffers[u2].data.length, l2[u2] = 0;
          }
          for (h2 = 0; h2 < i2.buffers.length; h2++) s2[h2] = new z[Object(o.getBufferType)(i2.buffers[h2].data)](a2[h2]), n2.buffers[h2] = new k(s2[h2]);
          for (h2 = 0; h2 < e2.length; h2++) {
            i2 = e2[h2];
            for (u2 = 0; u2 < i2.buffers.length; u2++) s2[u2].set(i2.buffers[u2].data, l2[u2]), l2[u2] += i2.buffers[u2].data.length;
          }
          if (n2.attributes = i2.attributes, i2.indexBuffer) {
            n2.indexBuffer = n2.buffers[i2.buffers.indexOf(i2.indexBuffer)], n2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER;
            var c2 = 0, d2 = 0, p2 = 0, f2 = 0;
            for (h2 = 0; h2 < i2.buffers.length; h2++) if (i2.buffers[h2] !== i2.indexBuffer) {
              f2 = h2;
              break;
            }
            for (var h2 in i2.attributes) {
              var m2 = i2.attributes[h2];
              (0 | m2.buffer) === f2 && (d2 += m2.size * H[m2.type] / 4);
            }
            for (h2 = 0; h2 < e2.length; h2++) {
              var g2 = e2[h2].indexBuffer.data;
              for (u2 = 0; u2 < g2.length; u2++) n2.indexBuffer.data[u2 + p2] += c2;
              c2 += e2[h2].buffers[f2].data.length / d2, p2 += g2.length;
            }
          }
          return n2;
        }, t2;
      }(), X = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e3;
        }
        return d(e2, t2), e2;
      }(V), W = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e3.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e3.vertexBuffer = new k(e3.vertices), e3.uvBuffer = new k(e3.uvs), e3.addAttribute("aVertexPosition", e3.vertexBuffer).addAttribute("aTextureCoord", e3.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e3;
        }
        return d(e2, t2), e2.prototype.map = function(t3, e3) {
          var i2 = 0, n2 = 0;
          return this.uvs[0] = i2, this.uvs[1] = n2, this.uvs[2] = i2 + e3.width / t3.width, this.uvs[3] = n2, this.uvs[4] = i2 + e3.width / t3.width, this.uvs[5] = n2 + e3.height / t3.height, this.uvs[6] = i2, this.uvs[7] = n2 + e3.height / t3.height, i2 = e3.x, n2 = e3.y, this.vertices[0] = i2, this.vertices[1] = n2, this.vertices[2] = i2 + e3.width, this.vertices[3] = n2, this.vertices[4] = i2 + e3.width, this.vertices[5] = n2 + e3.height, this.vertices[6] = i2, this.vertices[7] = n2 + e3.height, this.invalidate(), this;
        }, e2.prototype.invalidate = function() {
          return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
        }, e2;
      }(V), Y = 0, q = function() {
        function t2(t3, e2, i2) {
          this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = Y++, this.static = !!e2, this.ubo = !!i2, t3 instanceof k ? (this.buffer = t3, this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = t3, this.ubo && (this.buffer = new k(new Float32Array(1)), this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = true));
        }
        return t2.prototype.update = function() {
          this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
        }, t2.prototype.add = function(e2, i2, n2) {
          if (this.ubo) throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
          this.uniforms[e2] = new t2(i2, n2);
        }, t2.from = function(e2, i2, n2) {
          return new t2(e2, i2, n2);
        }, t2.uboFrom = function(e2, i2) {
          return new t2(e2, null == i2 || i2, true);
        }, t2;
      }(), Z = function() {
        function t2() {
          this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = r.l.NONE, this.sourceFrame = new l.j(), this.destinationFrame = new l.j(), this.bindingSourceFrame = new l.j(), this.bindingDestinationFrame = new l.j(), this.filters = [], this.transform = null;
        }
        return t2.prototype.clear = function() {
          this.target = null, this.filters = null, this.renderTexture = null;
        }, t2;
      }(), J = [new l.g(), new l.g(), new l.g(), new l.g()], K = new l.d(), Q = function() {
        function t2(t3) {
          this.renderer = t3, this.defaultFilterStack = [{}], this.texturePool = new F(), this.texturePool.setScreenSize(t3.view), this.statePool = [], this.quad = new X(), this.quadUv = new W(), this.tempRect = new l.j(), this.activeState = {}, this.globalUniforms = new q({ outputFrame: new l.j(), inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, true), this.forceClear = false, this.useMaxPadding = false;
        }
        return t2.prototype.push = function(t3, e2) {
          for (var i2, n2, r2 = this.renderer, o2 = this.defaultFilterStack, s2 = this.statePool.pop() || new Z(), a2 = this.renderer.renderTexture, l2 = e2[0].resolution, h2 = e2[0].multisample, u2 = e2[0].padding, c2 = e2[0].autoFit, d2 = null === (i2 = e2[0].legacy) || void 0 === i2 || i2, p2 = 1; p2 < e2.length; p2++) {
            var f2 = e2[p2];
            l2 = Math.min(l2, f2.resolution), h2 = Math.min(h2, f2.multisample), u2 = this.useMaxPadding ? Math.max(u2, f2.padding) : u2 + f2.padding, c2 = c2 && f2.autoFit, d2 = d2 || null === (n2 = f2.legacy) || void 0 === n2 || n2;
          }
          1 === o2.length && (this.defaultFilterStack[0].renderTexture = a2.current), o2.push(s2), s2.resolution = l2, s2.multisample = h2, s2.legacy = d2, s2.target = t3, s2.sourceFrame.copyFrom(t3.filterArea || t3.getBounds(true)), s2.sourceFrame.pad(u2);
          var m2 = this.tempRect.copyFrom(a2.sourceFrame);
          r2.projection.transform && this.transformAABB(K.copyFrom(r2.projection.transform).invert(), m2), c2 ? (s2.sourceFrame.fit(m2), (s2.sourceFrame.width <= 0 || s2.sourceFrame.height <= 0) && (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0)) : s2.sourceFrame.intersects(m2) || (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0), this.roundFrame(s2.sourceFrame, a2.current ? a2.current.resolution : r2.resolution, a2.sourceFrame, a2.destinationFrame, r2.projection.transform), s2.renderTexture = this.getOptimalFilterTexture(s2.sourceFrame.width, s2.sourceFrame.height, l2, h2), s2.filters = e2, s2.destinationFrame.width = s2.renderTexture.width, s2.destinationFrame.height = s2.renderTexture.height;
          var g2 = this.tempRect;
          g2.x = 0, g2.y = 0, g2.width = s2.sourceFrame.width, g2.height = s2.sourceFrame.height, s2.renderTexture.filterFrame = s2.sourceFrame, s2.bindingSourceFrame.copyFrom(a2.sourceFrame), s2.bindingDestinationFrame.copyFrom(a2.destinationFrame), s2.transform = r2.projection.transform, r2.projection.transform = null, a2.bind(s2.renderTexture, s2.sourceFrame, g2), r2.framebuffer.clear(0, 0, 0, 0);
        }, t2.prototype.pop = function() {
          var t3 = this.defaultFilterStack, e2 = t3.pop(), i2 = e2.filters;
          this.activeState = e2;
          var n2 = this.globalUniforms.uniforms;
          n2.outputFrame = e2.sourceFrame, n2.resolution = e2.resolution;
          var o2 = n2.inputSize, s2 = n2.inputPixel, a2 = n2.inputClamp;
          if (o2[0] = e2.destinationFrame.width, o2[1] = e2.destinationFrame.height, o2[2] = 1 / o2[0], o2[3] = 1 / o2[1], s2[0] = Math.round(o2[0] * e2.resolution), s2[1] = Math.round(o2[1] * e2.resolution), s2[2] = 1 / s2[0], s2[3] = 1 / s2[1], a2[0] = 0.5 * s2[2], a2[1] = 0.5 * s2[3], a2[2] = e2.sourceFrame.width * o2[2] - 0.5 * s2[2], a2[3] = e2.sourceFrame.height * o2[3] - 0.5 * s2[3], e2.legacy) {
            var l2 = n2.filterArea;
            l2[0] = e2.destinationFrame.width, l2[1] = e2.destinationFrame.height, l2[2] = e2.sourceFrame.x, l2[3] = e2.sourceFrame.y, n2.filterClamp = n2.inputClamp;
          }
          this.globalUniforms.update();
          var h2 = t3[t3.length - 1];
          if (this.renderer.framebuffer.blit(), 1 === i2.length) i2[0].apply(this, e2.renderTexture, h2.renderTexture, r.e.BLEND, e2), this.returnFilterTexture(e2.renderTexture);
          else {
            var u2 = e2.renderTexture, c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution);
            c2.filterFrame = u2.filterFrame;
            var d2 = 0;
            for (d2 = 0; d2 < i2.length - 1; ++d2) {
              1 === d2 && e2.multisample > 1 && ((c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution)).filterFrame = u2.filterFrame), i2[d2].apply(this, u2, c2, r.e.CLEAR, e2);
              var p2 = u2;
              u2 = c2, c2 = p2;
            }
            i2[d2].apply(this, u2, h2.renderTexture, r.e.BLEND, e2), d2 > 1 && e2.multisample > 1 && this.returnFilterTexture(e2.renderTexture), this.returnFilterTexture(u2), this.returnFilterTexture(c2);
          }
          e2.clear(), this.statePool.push(e2);
        }, t2.prototype.bindAndClear = function(t3, e2) {
          void 0 === e2 && (e2 = r.e.CLEAR);
          var i2 = this.renderer, n2 = i2.renderTexture, o2 = i2.state;
          if (t3 === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t3 && t3.filterFrame) {
            var s2 = this.tempRect;
            s2.x = 0, s2.y = 0, s2.width = t3.filterFrame.width, s2.height = t3.filterFrame.height, n2.bind(t3, t3.filterFrame, s2);
          } else t3 !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n2.bind(t3) : this.renderer.renderTexture.bind(t3, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
          var a2 = 1 & o2.stateId || this.forceClear;
          (e2 === r.e.CLEAR || e2 === r.e.BLIT && a2) && this.renderer.framebuffer.clear(0, 0, 0, 0);
        }, t2.prototype.applyFilter = function(t3, e2, i2, n2) {
          var o2 = this.renderer;
          o2.state.set(t3.state), this.bindAndClear(i2, n2), t3.uniforms.uSampler = e2, t3.uniforms.filterGlobals = this.globalUniforms, o2.shader.bind(t3), t3.legacy = !!t3.program.attributeData.aTextureCoord, t3.legacy ? (this.quadUv.map(e2._frame, e2.filterFrame), o2.geometry.bind(this.quadUv), o2.geometry.draw(r.f.TRIANGLES)) : (o2.geometry.bind(this.quad), o2.geometry.draw(r.f.TRIANGLE_STRIP));
        }, t2.prototype.calculateSpriteMatrix = function(t3, e2) {
          var i2 = this.activeState, n2 = i2.sourceFrame, r2 = i2.destinationFrame, o2 = e2._texture.orig, s2 = t3.set(r2.width, 0, 0, r2.height, n2.x, n2.y), a2 = e2.worldTransform.copyTo(l.d.TEMP_MATRIX);
          return a2.invert(), s2.prepend(a2), s2.scale(1 / o2.width, 1 / o2.height), s2.translate(e2.anchor.x, e2.anchor.y), s2;
        }, t2.prototype.destroy = function() {
          this.renderer = null, this.texturePool.clear(false);
        }, t2.prototype.getOptimalFilterTexture = function(t3, e2, i2, n2) {
          return void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = r.l.NONE), this.texturePool.getOptimalTexture(t3, e2, i2, n2);
        }, t2.prototype.getFilterTexture = function(t3, e2, i2) {
          if ("number" == typeof t3) {
            var n2 = t3;
            t3 = e2, e2 = n2;
          }
          t3 = t3 || this.activeState.renderTexture;
          var o2 = this.texturePool.getOptimalTexture(t3.width, t3.height, e2 || t3.resolution, i2 || r.l.NONE);
          return o2.filterFrame = t3.filterFrame, o2;
        }, t2.prototype.returnFilterTexture = function(t3) {
          this.texturePool.returnTexture(t3);
        }, t2.prototype.emptyPool = function() {
          this.texturePool.clear(true);
        }, t2.prototype.resize = function() {
          this.texturePool.setScreenSize(this.renderer.view);
        }, t2.prototype.transformAABB = function(t3, e2) {
          var i2 = J[0], n2 = J[1], r2 = J[2], o2 = J[3];
          i2.set(e2.left, e2.top), n2.set(e2.left, e2.bottom), r2.set(e2.right, e2.top), o2.set(e2.right, e2.bottom), t3.apply(i2, i2), t3.apply(n2, n2), t3.apply(r2, r2), t3.apply(o2, o2);
          var s2 = Math.min(i2.x, n2.x, r2.x, o2.x), a2 = Math.min(i2.y, n2.y, r2.y, o2.y), l2 = Math.max(i2.x, n2.x, r2.x, o2.x), h2 = Math.max(i2.y, n2.y, r2.y, o2.y);
          e2.x = s2, e2.y = a2, e2.width = l2 - s2, e2.height = h2 - a2;
        }, t2.prototype.roundFrame = function(t3, e2, i2, n2, r2) {
          if (!(t3.width <= 0 || t3.height <= 0 || i2.width <= 0 || i2.height <= 0)) {
            if (r2) {
              var o2 = r2.a, s2 = r2.b, a2 = r2.c, l2 = r2.d;
              if ((Math.abs(s2) > 1e-4 || Math.abs(a2) > 1e-4) && (Math.abs(o2) > 1e-4 || Math.abs(l2) > 1e-4)) return;
            }
            (r2 = r2 ? K.copyFrom(r2) : K.identity()).translate(-i2.x, -i2.y).scale(n2.width / i2.width, n2.height / i2.height).translate(n2.x, n2.y), this.transformAABB(r2, t3), t3.ceil(e2), this.transformAABB(r2.invert(), t3);
          }
        }, t2;
      }(), $ = function() {
        function t2(t3) {
          this.renderer = t3;
        }
        return t2.prototype.flush = function() {
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2.prototype.start = function() {
        }, t2.prototype.stop = function() {
          this.flush();
        }, t2.prototype.render = function(t3) {
        }, t2;
      }(), tt = function() {
        function t2(t3) {
          this.renderer = t3, this.emptyRenderer = new $(t3), this.currentRenderer = this.emptyRenderer;
        }
        return t2.prototype.setObjectRenderer = function(t3) {
          this.currentRenderer !== t3 && (this.currentRenderer.stop(), this.currentRenderer = t3, this.currentRenderer.start());
        }, t2.prototype.flush = function() {
          this.setObjectRenderer(this.emptyRenderer);
        }, t2.prototype.reset = function() {
          this.setObjectRenderer(this.emptyRenderer);
        }, t2.prototype.copyBoundTextures = function(t3, e2) {
          for (var i2 = this.renderer.texture.boundTextures, n2 = e2 - 1; n2 >= 0; --n2) t3[n2] = i2[n2] || null, t3[n2] && (t3[n2]._batchLocation = n2);
        }, t2.prototype.boundArray = function(t3, e2, i2, n2) {
          for (var r2 = t3.elements, o2 = t3.ids, s2 = t3.count, a2 = 0, l2 = 0; l2 < s2; l2++) {
            var h2 = r2[l2], u2 = h2._batchLocation;
            if (u2 >= 0 && u2 < n2 && e2[u2] === h2) o2[l2] = u2;
            else for (; a2 < n2; ) {
              var c2 = e2[a2];
              if (!c2 || c2._batchEnabled !== i2 || c2._batchLocation !== a2) {
                o2[l2] = a2, h2._batchLocation = a2, e2[a2] = h2;
                break;
              }
              a2++;
            }
          }
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), et = 0, it = function() {
        function t2(t3) {
          this.renderer = t3, this.webGLVersion = 1, this.extensions = {}, this.supports = { uint32Indices: false }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t3.view.addEventListener("webglcontextlost", this.handleContextLost, false), t3.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
        }
        return Object.defineProperty(t2.prototype, "isLost", { get: function() {
          return !this.gl || this.gl.isContextLost();
        }, enumerable: false, configurable: true }), t2.prototype.contextChange = function(t3) {
          this.gl = t3, this.renderer.gl = t3, this.renderer.CONTEXT_UID = et++, t3.isContextLost() && t3.getExtension("WEBGL_lose_context") && t3.getExtension("WEBGL_lose_context").restoreContext();
        }, t2.prototype.initFromContext = function(t3) {
          this.gl = t3, this.validateContext(t3), this.renderer.gl = t3, this.renderer.CONTEXT_UID = et++, this.renderer.runners.contextChange.emit(t3);
        }, t2.prototype.initFromOptions = function(t3) {
          var e2 = this.createContext(this.renderer.view, t3);
          this.initFromContext(e2);
        }, t2.prototype.createContext = function(t3, e2) {
          var i2;
          if (n.b.PREFER_ENV >= r.g.WEBGL2 && (i2 = t3.getContext("webgl2", e2)), i2) this.webGLVersion = 2;
          else if (this.webGLVersion = 1, !(i2 = t3.getContext("webgl", e2) || t3.getContext("experimental-webgl", e2))) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          return this.gl = i2, this.getExtensions(), this.gl;
        }, t2.prototype.getExtensions = function() {
          var t3 = this.gl, e2 = { anisotropicFiltering: t3.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t3.getExtension("OES_texture_float_linear"), s3tc: t3.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t3.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t3.getExtension("WEBGL_compressed_texture_etc"), etc1: t3.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t3.getExtension("WEBGL_compressed_texture_pvrtc") || t3.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t3.getExtension("WEBGL_compressed_texture_atc"), astc: t3.getExtension("WEBGL_compressed_texture_astc") };
          1 === this.webGLVersion ? Object.assign(this.extensions, e2, { drawBuffers: t3.getExtension("WEBGL_draw_buffers"), depthTexture: t3.getExtension("WEBGL_depth_texture"), loseContext: t3.getExtension("WEBGL_lose_context"), vertexArrayObject: t3.getExtension("OES_vertex_array_object") || t3.getExtension("MOZ_OES_vertex_array_object") || t3.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t3.getExtension("OES_element_index_uint"), floatTexture: t3.getExtension("OES_texture_float"), floatTextureLinear: t3.getExtension("OES_texture_float_linear"), textureHalfFloat: t3.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t3.getExtension("OES_texture_half_float_linear") }) : 2 === this.webGLVersion && Object.assign(this.extensions, e2, { colorBufferFloat: t3.getExtension("EXT_color_buffer_float") });
        }, t2.prototype.handleContextLost = function(t3) {
          t3.preventDefault();
        }, t2.prototype.handleContextRestored = function() {
          this.renderer.runners.contextChange.emit(this.gl);
        }, t2.prototype.destroy = function() {
          var t3 = this.renderer.view;
          this.renderer = null, t3.removeEventListener("webglcontextlost", this.handleContextLost), t3.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
        }, t2.prototype.postrender = function() {
          this.renderer.renderingToScreen && this.gl.flush();
        }, t2.prototype.validateContext = function(t3) {
          var e2 = t3.getContextAttributes(), i2 = "WebGL2RenderingContext" in globalThis && t3 instanceof globalThis.WebGL2RenderingContext;
          i2 && (this.webGLVersion = 2), e2 && !e2.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
          var n2 = i2 || !!t3.getExtension("OES_element_index_uint");
          this.supports.uint32Indices = n2, n2 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
        }, t2;
      }(), nt = function(t2) {
        this.framebuffer = t2, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = r.l.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
      }, rt = new l.j(), ot = function() {
        function t2(t3) {
          this.renderer = t3, this.managedFramebuffers = [], this.unknownFramebuffer = new R(10, 10), this.msaaSamples = null;
        }
        return t2.prototype.contextChange = function() {
          var t3 = this.gl = this.renderer.gl;
          if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new l.j(), this.hasMRT = true, this.writeDepthTexture = true, this.disposeAll(true), 1 === this.renderer.context.webGLVersion) {
            var e2 = this.renderer.context.extensions.drawBuffers, i2 = this.renderer.context.extensions.depthTexture;
            n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (e2 = null, i2 = null), e2 ? t3.drawBuffers = function(t4) {
              return e2.drawBuffersWEBGL(t4);
            } : (this.hasMRT = false, t3.drawBuffers = function() {
            }), i2 || (this.writeDepthTexture = false);
          } else this.msaaSamples = t3.getInternalformatParameter(t3.RENDERBUFFER, t3.RGBA8, t3.SAMPLES);
        }, t2.prototype.bind = function(t3, e2, i2) {
          void 0 === i2 && (i2 = 0);
          var n2 = this.gl;
          if (t3) {
            var r2 = t3.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t3);
            this.current !== t3 && (this.current = t3, n2.bindFramebuffer(n2.FRAMEBUFFER, r2.framebuffer)), r2.mipLevel !== i2 && (t3.dirtyId++, t3.dirtyFormat++, r2.mipLevel = i2), r2.dirtyId !== t3.dirtyId && (r2.dirtyId = t3.dirtyId, r2.dirtyFormat !== t3.dirtyFormat ? (r2.dirtyFormat = t3.dirtyFormat, r2.dirtySize = t3.dirtySize, this.updateFramebuffer(t3, i2)) : r2.dirtySize !== t3.dirtySize && (r2.dirtySize = t3.dirtySize, this.resizeFramebuffer(t3)));
            for (var o2 = 0; o2 < t3.colorTextures.length; o2++) {
              var s2 = t3.colorTextures[o2];
              this.renderer.texture.unbind(s2.parentTextureArray || s2);
            }
            if (t3.depthTexture && this.renderer.texture.unbind(t3.depthTexture), e2) {
              var a2 = e2.width >> i2, l2 = e2.height >> i2, h2 = a2 / e2.width;
              this.setViewport(e2.x * h2, e2.y * h2, a2, l2);
            } else {
              a2 = t3.width >> i2, l2 = t3.height >> i2;
              this.setViewport(0, 0, a2, l2);
            }
          } else this.current && (this.current = null, n2.bindFramebuffer(n2.FRAMEBUFFER, null)), e2 ? this.setViewport(e2.x, e2.y, e2.width, e2.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
        }, t2.prototype.setViewport = function(t3, e2, i2, n2) {
          var r2 = this.viewport;
          t3 = Math.round(t3), e2 = Math.round(e2), i2 = Math.round(i2), n2 = Math.round(n2), r2.width === i2 && r2.height === n2 && r2.x === t3 && r2.y === e2 || (r2.x = t3, r2.y = e2, r2.width = i2, r2.height = n2, this.gl.viewport(t3, e2, i2, n2));
        }, Object.defineProperty(t2.prototype, "size", { get: function() {
          return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
        }, enumerable: false, configurable: true }), t2.prototype.clear = function(t3, e2, i2, n2, o2) {
          void 0 === o2 && (o2 = r.c.COLOR | r.c.DEPTH);
          var s2 = this.gl;
          s2.clearColor(t3, e2, i2, n2), s2.clear(o2);
        }, t2.prototype.initFramebuffer = function(t3) {
          var e2 = this.gl, i2 = new nt(e2.createFramebuffer());
          return i2.multisample = this.detectSamples(t3.multisample), t3.glFramebuffers[this.CONTEXT_UID] = i2, this.managedFramebuffers.push(t3), t3.disposeRunner.add(this), i2;
        }, t2.prototype.resizeFramebuffer = function(t3) {
          var e2 = this.gl, i2 = t3.glFramebuffers[this.CONTEXT_UID];
          i2.msaaBuffer && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.msaaBuffer), e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.RGBA8, t3.width, t3.height)), i2.stencil && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.stencil), i2.msaaBuffer ? e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.DEPTH24_STENCIL8, t3.width, t3.height) : e2.renderbufferStorage(e2.RENDERBUFFER, e2.DEPTH_STENCIL, t3.width, t3.height));
          var n2 = t3.colorTextures, r2 = n2.length;
          e2.drawBuffers || (r2 = Math.min(r2, 1));
          for (var o2 = 0; o2 < r2; o2++) {
            var s2 = n2[o2], a2 = s2.parentTextureArray || s2;
            this.renderer.texture.bind(a2, 0);
          }
          t3.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t3.depthTexture, 0);
        }, t2.prototype.updateFramebuffer = function(t3, e2) {
          var i2 = this.gl, n2 = t3.glFramebuffers[this.CONTEXT_UID], r2 = t3.colorTextures, o2 = r2.length;
          i2.drawBuffers || (o2 = Math.min(o2, 1)), n2.multisample > 1 && this.canMultisampleFramebuffer(t3) ? (n2.msaaBuffer = n2.msaaBuffer || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.msaaBuffer), i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.RGBA8, t3.width, t3.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.RENDERBUFFER, n2.msaaBuffer)) : n2.msaaBuffer && (i2.deleteRenderbuffer(n2.msaaBuffer), n2.msaaBuffer = null, n2.blitFramebuffer && (n2.blitFramebuffer.dispose(), n2.blitFramebuffer = null));
          for (var s2 = [], a2 = 0; a2 < o2; a2++) {
            var l2 = r2[a2], h2 = l2.parentTextureArray || l2;
            this.renderer.texture.bind(h2, 0), 0 === a2 && n2.msaaBuffer || (i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0 + a2, l2.target, h2._glTextures[this.CONTEXT_UID].texture, e2), s2.push(i2.COLOR_ATTACHMENT0 + a2));
          }
          if ((s2.length > 1 && i2.drawBuffers(s2), t3.depthTexture) && this.writeDepthTexture) {
            var u2 = t3.depthTexture;
            this.renderer.texture.bind(u2, 0), i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.DEPTH_ATTACHMENT, i2.TEXTURE_2D, u2._glTextures[this.CONTEXT_UID].texture, e2);
          }
          !t3.stencil && !t3.depth || t3.depthTexture && this.writeDepthTexture ? n2.stencil && (i2.deleteRenderbuffer(n2.stencil), n2.stencil = null) : (n2.stencil = n2.stencil || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.stencil), n2.msaaBuffer ? i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.DEPTH24_STENCIL8, t3.width, t3.height) : i2.renderbufferStorage(i2.RENDERBUFFER, i2.DEPTH_STENCIL, t3.width, t3.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.DEPTH_STENCIL_ATTACHMENT, i2.RENDERBUFFER, n2.stencil));
        }, t2.prototype.canMultisampleFramebuffer = function(t3) {
          return 1 !== this.renderer.context.webGLVersion && t3.colorTextures.length <= 1 && !t3.depthTexture;
        }, t2.prototype.detectSamples = function(t3) {
          var e2 = this.msaaSamples, i2 = r.l.NONE;
          if (t3 <= 1 || null === e2) return i2;
          for (var n2 = 0; n2 < e2.length; n2++) if (e2[n2] <= t3) {
            i2 = e2[n2];
            break;
          }
          return 1 === i2 && (i2 = r.l.NONE), i2;
        }, t2.prototype.blit = function(t3, e2, i2) {
          var n2 = this.current, r2 = this.renderer, o2 = this.gl, s2 = this.CONTEXT_UID;
          if (2 === r2.context.webGLVersion && n2) {
            var a2 = n2.glFramebuffers[s2];
            if (a2) {
              if (!t3) {
                if (!a2.msaaBuffer) return;
                var l2 = n2.colorTextures[0];
                if (!l2) return;
                a2.blitFramebuffer || (a2.blitFramebuffer = new R(n2.width, n2.height), a2.blitFramebuffer.addColorTexture(0, l2)), (t3 = a2.blitFramebuffer).colorTextures[0] !== l2 && (t3.colorTextures[0] = l2, t3.dirtyId++, t3.dirtyFormat++), t3.width === n2.width && t3.height === n2.height || (t3.width = n2.width, t3.height = n2.height, t3.dirtyId++, t3.dirtySize++);
              }
              e2 || ((e2 = rt).width = n2.width, e2.height = n2.height), i2 || (i2 = e2);
              var h2 = e2.width === i2.width && e2.height === i2.height;
              this.bind(t3), o2.bindFramebuffer(o2.READ_FRAMEBUFFER, a2.framebuffer), o2.blitFramebuffer(e2.left, e2.top, e2.right, e2.bottom, i2.left, i2.top, i2.right, i2.bottom, o2.COLOR_BUFFER_BIT, h2 ? o2.NEAREST : o2.LINEAR);
            }
          }
        }, t2.prototype.disposeFramebuffer = function(t3, e2) {
          var i2 = t3.glFramebuffers[this.CONTEXT_UID], n2 = this.gl;
          if (i2) {
            delete t3.glFramebuffers[this.CONTEXT_UID];
            var r2 = this.managedFramebuffers.indexOf(t3);
            r2 >= 0 && this.managedFramebuffers.splice(r2, 1), t3.disposeRunner.remove(this), e2 || (n2.deleteFramebuffer(i2.framebuffer), i2.msaaBuffer && n2.deleteRenderbuffer(i2.msaaBuffer), i2.stencil && n2.deleteRenderbuffer(i2.stencil)), i2.blitFramebuffer && i2.blitFramebuffer.dispose();
          }
        }, t2.prototype.disposeAll = function(t3) {
          var e2 = this.managedFramebuffers;
          this.managedFramebuffers = [];
          for (var i2 = 0; i2 < e2.length; i2++) this.disposeFramebuffer(e2[i2], t3);
        }, t2.prototype.forceStencil = function() {
          var t3 = this.current;
          if (t3) {
            var e2 = t3.glFramebuffers[this.CONTEXT_UID];
            if (e2 && !e2.stencil) {
              t3.stencil = true;
              var i2 = t3.width, n2 = t3.height, r2 = this.gl, o2 = r2.createRenderbuffer();
              r2.bindRenderbuffer(r2.RENDERBUFFER, o2), e2.msaaBuffer ? r2.renderbufferStorageMultisample(r2.RENDERBUFFER, e2.multisample, r2.DEPTH24_STENCIL8, i2, n2) : r2.renderbufferStorage(r2.RENDERBUFFER, r2.DEPTH_STENCIL, i2, n2), e2.stencil = o2, r2.framebufferRenderbuffer(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.RENDERBUFFER, o2);
            }
          }
        }, t2.prototype.reset = function() {
          this.current = this.unknownFramebuffer, this.viewport = new l.j();
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), st = { 5126: 4, 5123: 2, 5121: 1 }, at = function() {
        function t2(t3) {
          this.renderer = t3, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
        }
        return t2.prototype.contextChange = function() {
          this.disposeAll(true);
          var t3 = this.gl = this.renderer.gl, e2 = this.renderer.context;
          if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== e2.webGLVersion) {
            var i2 = this.renderer.context.extensions.vertexArrayObject;
            n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (i2 = null), i2 ? (t3.createVertexArray = function() {
              return i2.createVertexArrayOES();
            }, t3.bindVertexArray = function(t4) {
              return i2.bindVertexArrayOES(t4);
            }, t3.deleteVertexArray = function(t4) {
              return i2.deleteVertexArrayOES(t4);
            }) : (this.hasVao = false, t3.createVertexArray = function() {
              return null;
            }, t3.bindVertexArray = function() {
              return null;
            }, t3.deleteVertexArray = function() {
              return null;
            });
          }
          if (2 !== e2.webGLVersion) {
            var o2 = t3.getExtension("ANGLE_instanced_arrays");
            o2 ? (t3.vertexAttribDivisor = function(t4, e3) {
              return o2.vertexAttribDivisorANGLE(t4, e3);
            }, t3.drawElementsInstanced = function(t4, e3, i3, n2, r2) {
              return o2.drawElementsInstancedANGLE(t4, e3, i3, n2, r2);
            }, t3.drawArraysInstanced = function(t4, e3, i3, n2) {
              return o2.drawArraysInstancedANGLE(t4, e3, i3, n2);
            }) : this.hasInstance = false;
          }
          this.canUseUInt32ElementIndex = 2 === e2.webGLVersion || !!e2.extensions.uint32ElementIndex;
        }, t2.prototype.bind = function(t3, e2) {
          e2 = e2 || this.renderer.shader.shader;
          var i2 = this.gl, n2 = t3.glVertexArrayObjects[this.CONTEXT_UID], r2 = false;
          n2 || (this.managedGeometries[t3.id] = t3, t3.disposeRunner.add(this), t3.glVertexArrayObjects[this.CONTEXT_UID] = n2 = {}, r2 = true);
          var o2 = n2[e2.program.id] || this.initGeometryVao(t3, e2, r2);
          this._activeGeometry = t3, this._activeVao !== o2 && (this._activeVao = o2, this.hasVao ? i2.bindVertexArray(o2) : this.activateVao(t3, e2.program)), this.updateBuffers();
        }, t2.prototype.reset = function() {
          this.unbind();
        }, t2.prototype.updateBuffers = function() {
          for (var t3 = this._activeGeometry, e2 = this.renderer.buffer, i2 = 0; i2 < t3.buffers.length; i2++) {
            var n2 = t3.buffers[i2];
            e2.update(n2);
          }
        }, t2.prototype.checkCompatibility = function(t3, e2) {
          var i2 = t3.attributes, n2 = e2.attributeData;
          for (var r2 in n2) if (!i2[r2]) throw new Error('shader and geometry incompatible, geometry missing the "' + r2 + '" attribute');
        }, t2.prototype.getSignature = function(t3, e2) {
          var i2 = t3.attributes, n2 = e2.attributeData, r2 = ["g", t3.id];
          for (var o2 in i2) n2[o2] && r2.push(o2, n2[o2].location);
          return r2.join("-");
        }, t2.prototype.initGeometryVao = function(t3, e2, i2) {
          void 0 === i2 && (i2 = true);
          var n2 = this.gl, r2 = this.CONTEXT_UID, o2 = this.renderer.buffer, s2 = e2.program;
          s2.glPrograms[r2] || this.renderer.shader.generateProgram(e2), this.checkCompatibility(t3, s2);
          var a2 = this.getSignature(t3, s2), l2 = t3.glVertexArrayObjects[this.CONTEXT_UID], h2 = l2[a2];
          if (h2) return l2[s2.id] = h2, h2;
          var u2 = t3.buffers, c2 = t3.attributes, d2 = {}, p2 = {};
          for (var f2 in u2) d2[f2] = 0, p2[f2] = 0;
          for (var f2 in c2) !c2[f2].size && s2.attributeData[f2] ? c2[f2].size = s2.attributeData[f2].size : c2[f2].size || console.warn("PIXI Geometry attribute '" + f2 + "' size cannot be determined (likely the bound shader does not have the attribute)"), d2[c2[f2].buffer] += c2[f2].size * st[c2[f2].type];
          for (var f2 in c2) {
            var m2 = c2[f2], g2 = m2.size;
            void 0 === m2.stride && (d2[m2.buffer] === g2 * st[m2.type] ? m2.stride = 0 : m2.stride = d2[m2.buffer]), void 0 === m2.start && (m2.start = p2[m2.buffer], p2[m2.buffer] += g2 * st[m2.type]);
          }
          h2 = n2.createVertexArray(), n2.bindVertexArray(h2);
          for (var v2 = 0; v2 < u2.length; v2++) {
            var _2 = u2[v2];
            o2.bind(_2), i2 && _2._glBuffers[r2].refCount++;
          }
          return this.activateVao(t3, s2), this._activeVao = h2, l2[s2.id] = h2, l2[a2] = h2, h2;
        }, t2.prototype.disposeGeometry = function(t3, e2) {
          var i2;
          if (this.managedGeometries[t3.id]) {
            delete this.managedGeometries[t3.id];
            var n2 = t3.glVertexArrayObjects[this.CONTEXT_UID], r2 = this.gl, o2 = t3.buffers, s2 = null === (i2 = this.renderer) || void 0 === i2 ? void 0 : i2.buffer;
            if (t3.disposeRunner.remove(this), n2) {
              if (s2) for (var a2 = 0; a2 < o2.length; a2++) {
                var l2 = o2[a2]._glBuffers[this.CONTEXT_UID];
                l2 && (l2.refCount--, 0 !== l2.refCount || e2 || s2.dispose(o2[a2], e2));
              }
              if (!e2) {
                for (var h2 in n2) if ("g" === h2[0]) {
                  var u2 = n2[h2];
                  this._activeVao === u2 && this.unbind(), r2.deleteVertexArray(u2);
                }
              }
              delete t3.glVertexArrayObjects[this.CONTEXT_UID];
            }
          }
        }, t2.prototype.disposeAll = function(t3) {
          for (var e2 = Object.keys(this.managedGeometries), i2 = 0; i2 < e2.length; i2++) this.disposeGeometry(this.managedGeometries[e2[i2]], t3);
        }, t2.prototype.activateVao = function(t3, e2) {
          var i2 = this.gl, n2 = this.CONTEXT_UID, r2 = this.renderer.buffer, o2 = t3.buffers, s2 = t3.attributes;
          t3.indexBuffer && r2.bind(t3.indexBuffer);
          var a2 = null;
          for (var l2 in s2) {
            var h2 = s2[l2], u2 = o2[h2.buffer], c2 = u2._glBuffers[n2];
            if (e2.attributeData[l2]) {
              a2 !== c2 && (r2.bind(u2), a2 = c2);
              var d2 = e2.attributeData[l2].location;
              if (i2.enableVertexAttribArray(d2), i2.vertexAttribPointer(d2, h2.size, h2.type || i2.FLOAT, h2.normalized, h2.stride, h2.start), h2.instance) {
                if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
                i2.vertexAttribDivisor(d2, 1);
              }
            }
          }
        }, t2.prototype.draw = function(t3, e2, i2, n2) {
          var r2 = this.gl, o2 = this._activeGeometry;
          if (o2.indexBuffer) {
            var s2 = o2.indexBuffer.data.BYTES_PER_ELEMENT, a2 = 2 === s2 ? r2.UNSIGNED_SHORT : r2.UNSIGNED_INT;
            2 === s2 || 4 === s2 && this.canUseUInt32ElementIndex ? o2.instanced ? r2.drawElementsInstanced(t3, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2, n2 || 1) : r2.drawElements(t3, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2) : console.warn("unsupported index buffer type: uint32");
          } else o2.instanced ? r2.drawArraysInstanced(t3, i2, e2 || o2.getSize(), n2 || 1) : r2.drawArrays(t3, i2, e2 || o2.getSize());
          return this;
        }, t2.prototype.unbind = function() {
          this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), lt = function() {
        function t2(t3) {
          void 0 === t3 && (t3 = null), this.type = r.j.NONE, this.autoDetect = true, this.maskObject = t3 || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = n.b.FILTER_MULTISAMPLE, this.enabled = true, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null;
        }
        return Object.defineProperty(t2.prototype, "filter", { get: function() {
          return this._filters ? this._filters[0] : null;
        }, set: function(t3) {
          t3 ? this._filters ? this._filters[0] = t3 : this._filters = [t3] : this._filters = null;
        }, enumerable: false, configurable: true }), t2.prototype.reset = function() {
          this.pooled && (this.maskObject = null, this.type = r.j.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
        }, t2.prototype.copyCountersOrReset = function(t3) {
          t3 ? (this._stencilCounter = t3._stencilCounter, this._scissorCounter = t3._scissorCounter, this._scissorRect = t3._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
        }, t2;
      }();
      function ht(t2, e2, i2) {
        var n2 = t2.createShader(e2);
        return t2.shaderSource(n2, i2), t2.compileShader(n2), n2;
      }
      function ut(t2, e2) {
        var i2 = t2.getShaderSource(e2).split("\n").map(function(t3, e3) {
          return e3 + ": " + t3;
        }), n2 = t2.getShaderInfoLog(e2), r2 = n2.split("\n"), o2 = {}, s2 = r2.map(function(t3) {
          return parseFloat(t3.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
        }).filter(function(t3) {
          return !(!t3 || o2[t3]) && (o2[t3] = true, true);
        }), a2 = [""];
        s2.forEach(function(t3) {
          i2[t3 - 1] = "%c" + i2[t3 - 1] + "%c", a2.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
        });
        var l2 = i2.join("\n");
        a2[0] = l2, console.error(n2), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a2), console.groupEnd();
      }
      function ct(t2) {
        for (var e2 = new Array(t2), i2 = 0; i2 < e2.length; i2++) e2[i2] = false;
        return e2;
      }
      function dt(t2, e2) {
        switch (t2) {
          case "float":
            return 0;
          case "vec2":
            return new Float32Array(2 * e2);
          case "vec3":
            return new Float32Array(3 * e2);
          case "vec4":
            return new Float32Array(4 * e2);
          case "int":
          case "uint":
          case "sampler2D":
          case "sampler2DArray":
            return 0;
          case "ivec2":
            return new Int32Array(2 * e2);
          case "ivec3":
            return new Int32Array(3 * e2);
          case "ivec4":
            return new Int32Array(4 * e2);
          case "uvec2":
            return new Uint32Array(2 * e2);
          case "uvec3":
            return new Uint32Array(3 * e2);
          case "uvec4":
            return new Uint32Array(4 * e2);
          case "bool":
            return false;
          case "bvec2":
            return ct(2 * e2);
          case "bvec3":
            return ct(3 * e2);
          case "bvec4":
            return ct(4 * e2);
          case "mat2":
            return new Float32Array([1, 0, 0, 1]);
          case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
          case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
        }
        return null;
      }
      var pt, ft = {}, mt = ft;
      function gt() {
        if (!pt) {
          pt = r.m.MEDIUM;
          var t2 = function() {
            if (mt === ft || mt && mt.isContextLost()) {
              var t3 = document.createElement("canvas"), e3 = void 0;
              n.b.PREFER_ENV >= r.g.WEBGL2 && (e3 = t3.getContext("webgl2", {})), e3 || ((e3 = t3.getContext("webgl", {}) || t3.getContext("experimental-webgl", {})) ? e3.getExtension("WEBGL_draw_buffers") : e3 = null), mt = e3;
            }
            return mt;
          }();
          if (t2 && t2.getShaderPrecisionFormat) {
            var e2 = t2.getShaderPrecisionFormat(t2.FRAGMENT_SHADER, t2.HIGH_FLOAT);
            pt = e2.precision ? r.m.HIGH : r.m.MEDIUM;
          }
        }
        return pt;
      }
      function vt(t2, e2, i2) {
        if ("precision" !== t2.substring(0, 9)) {
          var n2 = e2;
          return e2 === r.m.HIGH && i2 !== r.m.HIGH && (n2 = r.m.MEDIUM), "precision " + n2 + " float;\n" + t2;
        }
        return i2 !== r.m.HIGH && "precision highp" === t2.substring(0, 15) ? t2.replace("precision highp", "precision mediump") : t2;
      }
      var _t = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 };
      function yt(t2) {
        return _t[t2];
      }
      var xt = null, bt = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" };
      function Tt(t2, e2) {
        if (!xt) {
          var i2 = Object.keys(bt);
          xt = {};
          for (var n2 = 0; n2 < i2.length; ++n2) {
            var r2 = i2[n2];
            xt[t2[r2]] = bt[r2];
          }
        }
        return xt[e2];
      }
      var Et = [{ test: function(t2) {
        return "float" === t2.type && 1 === t2.size;
      }, code: function(t2) {
        return '\n            if(uv["' + t2 + '"] !== ud["' + t2 + '"].value)\n            {\n                ud["' + t2 + '"].value = uv["' + t2 + '"]\n                gl.uniform1f(ud["' + t2 + '"].location, uv["' + t2 + '"])\n            }\n            ';
      } }, { test: function(t2) {
        return ("sampler2D" === t2.type || "samplerCube" === t2.type || "sampler2DArray" === t2.type) && 1 === t2.size && !t2.isArray;
      }, code: function(t2) {
        return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t2 + '"], t);\n\n            if(ud["' + t2 + '"].value !== t)\n            {\n                ud["' + t2 + '"].value = t;\n                gl.uniform1i(ud["' + t2 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
      } }, { test: function(t2, e2) {
        return "mat3" === t2.type && 1 === t2.size && void 0 !== e2.a;
      }, code: function(t2) {
        return '\n            gl.uniformMatrix3fv(ud["' + t2 + '"].location, false, uv["' + t2 + '"].toArray(true));\n            ';
      }, codeUbo: function(t2) {
        return "\n                var " + t2 + "_matrix = uv." + t2 + ".toArray(true);\n\n                data[offset] = " + t2 + "_matrix[0];\n                data[offset+1] = " + t2 + "_matrix[1];\n                data[offset+2] = " + t2 + "_matrix[2];\n        \n                data[offset + 4] = " + t2 + "_matrix[3];\n                data[offset + 5] = " + t2 + "_matrix[4];\n                data[offset + 6] = " + t2 + "_matrix[5];\n        \n                data[offset + 8] = " + t2 + "_matrix[6];\n                data[offset + 9] = " + t2 + "_matrix[7];\n                data[offset + 10] = " + t2 + "_matrix[8];\n            ";
      } }, { test: function(t2, e2) {
        return "vec2" === t2.type && 1 === t2.size && void 0 !== e2.x;
      }, code: function(t2) {
        return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t2 + '"].location, v.x, v.y);\n                }';
      }, codeUbo: function(t2) {
        return "\n                v = uv." + t2 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
      } }, { test: function(t2) {
        return "vec2" === t2.type && 1 === t2.size;
      }, code: function(t2) {
        return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t2 + '"].location, v[0], v[1]);\n                }\n            ';
      } }, { test: function(t2, e2) {
        return "vec4" === t2.type && 1 === t2.size && void 0 !== e2.width;
      }, code: function(t2) {
        return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t2 + '"].location, v.x, v.y, v.width, v.height)\n                }';
      }, codeUbo: function(t2) {
        return "\n                    v = uv." + t2 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
      } }, { test: function(t2) {
        return "vec4" === t2.type && 1 === t2.size;
      }, code: function(t2) {
        return '\n                cv = ud["' + t2 + '"].value;\n                v = uv["' + t2 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t2 + '"].location, v[0], v[1], v[2], v[3])\n                }';
      } }], St = { float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }", vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }", bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "gl.uniform1i(location, v)", samplerCube: "gl.uniform1i(location, v)", sampler2DArray: "gl.uniform1i(location, v)" }, wt = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", uint: "gl.uniform1uiv(location, v)", uvec2: "gl.uniform2uiv(location, v)", uvec3: "gl.uniform3uiv(location, v)", uvec4: "gl.uniform4uiv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" };
      var At, Mt = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
      function Ct(t2) {
        for (var e2 = "", i2 = 0; i2 < t2; ++i2) i2 > 0 && (e2 += "\nelse "), i2 < t2 - 1 && (e2 += "if(test == " + i2 + ".0){}");
        return e2;
      }
      var Rt = 0, It = {}, Pt = function() {
        function t2(e2, i2, o2) {
          void 0 === o2 && (o2 = "pixi-shader"), this.id = Rt++, this.vertexSrc = e2 || t2.defaultVertexSrc, this.fragmentSrc = i2 || t2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (o2 = o2.replace(/\s+/g, "-"), It[o2] ? (It[o2]++, o2 += "-" + It[o2]) : It[o2] = 1, this.vertexSrc = "#define SHADER_NAME " + o2 + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + o2 + "\n" + this.fragmentSrc, this.vertexSrc = vt(this.vertexSrc, n.b.PRECISION_VERTEX, r.m.HIGH), this.fragmentSrc = vt(this.fragmentSrc, n.b.PRECISION_FRAGMENT, gt())), this.glPrograms = {}, this.syncUniforms = null;
        }
        return Object.defineProperty(t2, "defaultVertexSrc", { get: function() {
          return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "defaultFragmentSrc", { get: function() {
          return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
        }, enumerable: false, configurable: true }), t2.from = function(e2, i2, n2) {
          var r2 = e2 + i2, s2 = o.ProgramCache[r2];
          return s2 || (o.ProgramCache[r2] = s2 = new t2(e2, i2, n2)), s2;
        }, t2;
      }(), Ot = function() {
        function t2(t3, e2) {
          this.uniformBindCount = 0, this.program = t3, this.uniformGroup = e2 ? e2 instanceof q ? e2 : new q(e2) : new q({});
        }
        return t2.prototype.checkUniformExists = function(t3, e2) {
          if (e2.uniforms[t3]) return true;
          for (var i2 in e2.uniforms) {
            var n2 = e2.uniforms[i2];
            if (n2.group && this.checkUniformExists(t3, n2)) return true;
          }
          return false;
        }, t2.prototype.destroy = function() {
          this.uniformGroup = null;
        }, Object.defineProperty(t2.prototype, "uniforms", { get: function() {
          return this.uniformGroup.uniforms;
        }, enumerable: false, configurable: true }), t2.from = function(e2, i2, n2) {
          return new t2(Pt.from(e2, i2), n2);
        }, t2;
      }(), Nt = function() {
        function t2() {
          this.data = 0, this.blendMode = r.b.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
        }
        return Object.defineProperty(t2.prototype, "blend", { get: function() {
          return !!(1 & this.data);
        }, set: function(t3) {
          !!(1 & this.data) !== t3 && (this.data ^= 1);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "offsets", { get: function() {
          return !!(2 & this.data);
        }, set: function(t3) {
          !!(2 & this.data) !== t3 && (this.data ^= 2);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "culling", { get: function() {
          return !!(4 & this.data);
        }, set: function(t3) {
          !!(4 & this.data) !== t3 && (this.data ^= 4);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "depthTest", { get: function() {
          return !!(8 & this.data);
        }, set: function(t3) {
          !!(8 & this.data) !== t3 && (this.data ^= 8);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "depthMask", { get: function() {
          return !!(32 & this.data);
        }, set: function(t3) {
          !!(32 & this.data) !== t3 && (this.data ^= 32);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "clockwiseFrontFace", { get: function() {
          return !!(16 & this.data);
        }, set: function(t3) {
          !!(16 & this.data) !== t3 && (this.data ^= 16);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "blendMode", { get: function() {
          return this._blendMode;
        }, set: function(t3) {
          this.blend = t3 !== r.b.NONE, this._blendMode = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "polygonOffset", { get: function() {
          return this._polygonOffset;
        }, set: function(t3) {
          this.offsets = !!t3, this._polygonOffset = t3;
        }, enumerable: false, configurable: true }), t2.prototype.toString = function() {
          return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]";
        }, t2.for2d = function() {
          var e2 = new t2();
          return e2.depthTest = false, e2.blend = true, e2;
        }, t2;
      }(), Lt = function(t2) {
        function e2(i2, r2, o2) {
          var s2 = this, a2 = Pt.from(i2 || e2.defaultVertexSrc, r2 || e2.defaultFragmentSrc);
          return (s2 = t2.call(this, a2, o2) || this).padding = 0, s2.resolution = n.b.FILTER_RESOLUTION, s2.multisample = n.b.FILTER_MULTISAMPLE, s2.enabled = true, s2.autoFit = true, s2.state = new Nt(), s2;
        }
        return d(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2, r2) {
          t3.applyFilter(this, e3, i2, n2);
        }, Object.defineProperty(e2.prototype, "blendMode", { get: function() {
          return this.state.blendMode;
        }, set: function(t3) {
          this.state.blendMode = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
          return this._resolution;
        }, set: function(t3) {
          this._resolution = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultVertexSrc", { get: function() {
          return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
        }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultFragmentSrc", { get: function() {
          return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
        }, enumerable: false, configurable: true }), e2;
      }(Ot), Dt = new l.d(), Ft = function() {
        function t2(t3, e2) {
          this._texture = t3, this.mapCoord = new l.d(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e2 ? 0.5 : e2, this.isSimple = false;
        }
        return Object.defineProperty(t2.prototype, "texture", { get: function() {
          return this._texture;
        }, set: function(t3) {
          this._texture = t3, this._textureID = -1;
        }, enumerable: false, configurable: true }), t2.prototype.multiplyUvs = function(t3, e2) {
          void 0 === e2 && (e2 = t3);
          for (var i2 = this.mapCoord, n2 = 0; n2 < t3.length; n2 += 2) {
            var r2 = t3[n2], o2 = t3[n2 + 1];
            e2[n2] = r2 * i2.a + o2 * i2.c + i2.tx, e2[n2 + 1] = r2 * i2.b + o2 * i2.d + i2.ty;
          }
          return e2;
        }, t2.prototype.update = function(t3) {
          var e2 = this._texture;
          if (!e2 || !e2.valid) return false;
          if (!t3 && this._textureID === e2._updateID) return false;
          this._textureID = e2._updateID, this._updateID++;
          var i2 = e2._uvs;
          this.mapCoord.set(i2.x1 - i2.x0, i2.y1 - i2.y0, i2.x3 - i2.x0, i2.y3 - i2.y0, i2.x0, i2.y0);
          var n2 = e2.orig, r2 = e2.trim;
          r2 && (Dt.set(n2.width / r2.width, 0, 0, n2.height / r2.height, -r2.x / r2.width, -r2.y / r2.height), this.mapCoord.append(Dt));
          var o2 = e2.baseTexture, s2 = this.uClampFrame, a2 = this.clampMargin / o2.resolution, l2 = this.clampOffset;
          return s2[0] = (e2._frame.x + a2 + l2) / o2.width, s2[1] = (e2._frame.y + a2 + l2) / o2.height, s2[2] = (e2._frame.x + e2._frame.width - a2 + l2) / o2.width, s2[3] = (e2._frame.y + e2._frame.height - a2 + l2) / o2.height, this.uClampOffset[0] = l2 / o2.realWidth, this.uClampOffset[1] = l2 / o2.realHeight, this.isSimple = e2._frame.width === o2.width && e2._frame.height === o2.height && 0 === e2.rotate, true;
        }, t2;
      }(), Bt = function(t2) {
        function e2(e3, i2, n2) {
          var r2 = this, o2 = null;
          return "string" != typeof e3 && void 0 === i2 && void 0 === n2 && (o2 = e3, e3 = void 0, i2 = void 0, n2 = void 0), (r2 = t2.call(this, e3 || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", i2 || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", n2) || this).maskSprite = o2, r2.maskMatrix = new l.d(), r2;
        }
        return d(e2, t2), Object.defineProperty(e2.prototype, "maskSprite", { get: function() {
          return this._maskSprite;
        }, set: function(t3) {
          this._maskSprite = t3, this._maskSprite && (this._maskSprite.renderable = false);
        }, enumerable: false, configurable: true }), e2.prototype.apply = function(t3, e3, i2, n2) {
          var r2 = this._maskSprite, o2 = r2._texture;
          o2.valid && (o2.uvMatrix || (o2.uvMatrix = new Ft(o2, 0)), o2.uvMatrix.update(), this.uniforms.npmAlpha = o2.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o2, this.uniforms.otherMatrix = t3.calculateSpriteMatrix(this.maskMatrix, r2).prepend(o2.uvMatrix.mapCoord), this.uniforms.alpha = r2.worldAlpha, this.uniforms.maskClamp = o2.uvMatrix.uClampFrame, t3.applyFilter(this, e3, i2, n2));
        }, e2;
      }(Lt), Ut = function() {
        function t2(t3) {
          this.renderer = t3, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
        }
        return t2.prototype.setMaskStack = function(t3) {
          this.maskStack = t3, this.renderer.scissor.setMaskStack(t3), this.renderer.stencil.setMaskStack(t3);
        }, t2.prototype.push = function(t3, e2) {
          var i2 = e2;
          if (!i2.isMaskData) {
            var n2 = this.maskDataPool.pop() || new lt();
            n2.pooled = true, n2.maskObject = e2, i2 = n2;
          }
          var o2 = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
          if (i2.copyCountersOrReset(o2), i2.autoDetect && this.detect(i2), i2._target = t3, i2.type !== r.j.SPRITE && this.maskStack.push(i2), i2.enabled) switch (i2.type) {
            case r.j.SCISSOR:
              this.renderer.scissor.push(i2);
              break;
            case r.j.STENCIL:
              this.renderer.stencil.push(i2);
              break;
            case r.j.SPRITE:
              i2.copyCountersOrReset(null), this.pushSpriteMask(i2);
          }
          i2.type === r.j.SPRITE && this.maskStack.push(i2);
        }, t2.prototype.pop = function(t3) {
          var e2 = this.maskStack.pop();
          if (e2 && e2._target === t3) {
            if (e2.enabled) switch (e2.type) {
              case r.j.SCISSOR:
                this.renderer.scissor.pop();
                break;
              case r.j.STENCIL:
                this.renderer.stencil.pop(e2.maskObject);
                break;
              case r.j.SPRITE:
                this.popSpriteMask(e2);
            }
            if (e2.reset(), e2.pooled && this.maskDataPool.push(e2), 0 !== this.maskStack.length) {
              var i2 = this.maskStack[this.maskStack.length - 1];
              i2.type === r.j.SPRITE && i2._filters && (i2._filters[0].maskSprite = i2.maskObject);
            }
          }
        }, t2.prototype.detect = function(t3) {
          t3.maskObject.isSprite ? t3.type = r.j.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t3) ? t3.type = r.j.SCISSOR : t3.type = r.j.STENCIL;
        }, t2.prototype.pushSpriteMask = function(t3) {
          var e2, i2, n2 = t3.maskObject, r2 = t3._target, o2 = t3._filters;
          o2 || (o2 = this.alphaMaskPool[this.alphaMaskIndex]) || (o2 = this.alphaMaskPool[this.alphaMaskIndex] = [new Bt()]);
          var s2, a2, l2 = this.renderer, h2 = l2.renderTexture;
          if (h2.current) {
            var u2 = h2.current;
            s2 = t3.resolution || u2.resolution, a2 = null !== (e2 = t3.multisample) && void 0 !== e2 ? e2 : u2.multisample;
          } else s2 = t3.resolution || l2.resolution, a2 = null !== (i2 = t3.multisample) && void 0 !== i2 ? i2 : l2.multisample;
          o2[0].resolution = s2, o2[0].multisample = a2, o2[0].maskSprite = n2;
          var c2 = r2.filterArea;
          r2.filterArea = n2.getBounds(true), l2.filter.push(r2, o2), r2.filterArea = c2, t3._filters || this.alphaMaskIndex++;
        }, t2.prototype.popSpriteMask = function(t3) {
          this.renderer.filter.pop(), t3._filters ? t3._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), kt = function() {
        function t2(t3) {
          this.renderer = t3, this.maskStack = [], this.glConst = 0;
        }
        return t2.prototype.getStackLength = function() {
          return this.maskStack.length;
        }, t2.prototype.setMaskStack = function(t3) {
          var e2 = this.renderer.gl, i2 = this.getStackLength();
          this.maskStack = t3;
          var n2 = this.getStackLength();
          n2 !== i2 && (0 === n2 ? e2.disable(this.glConst) : (e2.enable(this.glConst), this._useCurrent()));
        }, t2.prototype._useCurrent = function() {
        }, t2.prototype.destroy = function() {
          this.renderer = null, this.maskStack = null;
        }, t2;
      }(), Gt = new l.d(), Ht = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return i2.glConst = WebGLRenderingContext.SCISSOR_TEST, i2;
        }
        return d(e2, t2), e2.prototype.getStackLength = function() {
          var t3 = this.maskStack[this.maskStack.length - 1];
          return t3 ? t3._scissorCounter : 0;
        }, e2.prototype.calcScissorRect = function(t3) {
          if (!t3._scissorRectLocal) {
            var e3 = t3._scissorRect, i2 = t3.maskObject, n2 = this.renderer, r2 = n2.renderTexture;
            i2.renderable = true;
            var o2 = i2.getBounds();
            this.roundFrameToPixels(o2, r2.current ? r2.current.resolution : n2.resolution, r2.sourceFrame, r2.destinationFrame, n2.projection.transform), i2.renderable = false, e3 && o2.fit(e3), t3._scissorRectLocal = o2;
          }
        }, e2.isMatrixRotated = function(t3) {
          if (!t3) return false;
          var e3 = t3.a, i2 = t3.b, n2 = t3.c, r2 = t3.d;
          return (Math.abs(i2) > 1e-4 || Math.abs(n2) > 1e-4) && (Math.abs(e3) > 1e-4 || Math.abs(r2) > 1e-4);
        }, e2.prototype.testScissor = function(t3) {
          var i2 = t3.maskObject;
          if (!i2.isFastRect || !i2.isFastRect()) return false;
          if (e2.isMatrixRotated(i2.worldTransform)) return false;
          if (e2.isMatrixRotated(this.renderer.projection.transform)) return false;
          this.calcScissorRect(t3);
          var n2 = t3._scissorRectLocal;
          return n2.width > 0 && n2.height > 0;
        }, e2.prototype.roundFrameToPixels = function(t3, i2, n2, r2, o2) {
          e2.isMatrixRotated(o2) || ((o2 = o2 ? Gt.copyFrom(o2) : Gt.identity()).translate(-n2.x, -n2.y).scale(r2.width / n2.width, r2.height / n2.height).translate(r2.x, r2.y), this.renderer.filter.transformAABB(o2, t3), t3.fit(r2), t3.x = Math.round(t3.x * i2), t3.y = Math.round(t3.y * i2), t3.width = Math.round(t3.width * i2), t3.height = Math.round(t3.height * i2));
        }, e2.prototype.push = function(t3) {
          t3._scissorRectLocal || this.calcScissorRect(t3);
          var e3 = this.renderer.gl;
          t3._scissorRect || e3.enable(e3.SCISSOR_TEST), t3._scissorCounter++, t3._scissorRect = t3._scissorRectLocal, this._useCurrent();
        }, e2.prototype.pop = function() {
          var t3 = this.renderer.gl;
          this.getStackLength() > 0 ? this._useCurrent() : t3.disable(t3.SCISSOR_TEST);
        }, e2.prototype._useCurrent = function() {
          var t3, e3 = this.maskStack[this.maskStack.length - 1]._scissorRect;
          t3 = this.renderer.renderTexture.current ? e3.y : this.renderer.height - e3.height - e3.y, this.renderer.gl.scissor(e3.x, t3, e3.width, e3.height);
        }, e2;
      }(kt), jt = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return i2.glConst = WebGLRenderingContext.STENCIL_TEST, i2;
        }
        return d(e2, t2), e2.prototype.getStackLength = function() {
          var t3 = this.maskStack[this.maskStack.length - 1];
          return t3 ? t3._stencilCounter : 0;
        }, e2.prototype.push = function(t3) {
          var e3 = t3.maskObject, i2 = this.renderer.gl, n2 = t3._stencilCounter;
          0 === n2 && (this.renderer.framebuffer.forceStencil(), i2.clearStencil(0), i2.clear(i2.STENCIL_BUFFER_BIT), i2.enable(i2.STENCIL_TEST)), t3._stencilCounter++, i2.colorMask(false, false, false, false), i2.stencilFunc(i2.EQUAL, n2, 4294967295), i2.stencilOp(i2.KEEP, i2.KEEP, i2.INCR), e3.renderable = true, e3.render(this.renderer), this.renderer.batch.flush(), e3.renderable = false, this._useCurrent();
        }, e2.prototype.pop = function(t3) {
          var e3 = this.renderer.gl;
          0 === this.getStackLength() ? e3.disable(e3.STENCIL_TEST) : (e3.colorMask(false, false, false, false), e3.stencilOp(e3.KEEP, e3.KEEP, e3.DECR), t3.renderable = true, t3.render(this.renderer), this.renderer.batch.flush(), t3.renderable = false, this._useCurrent());
        }, e2.prototype._useCurrent = function() {
          var t3 = this.renderer.gl;
          t3.colorMask(true, true, true, true), t3.stencilFunc(t3.EQUAL, this.getStackLength(), 4294967295), t3.stencilOp(t3.KEEP, t3.KEEP, t3.KEEP);
        }, e2;
      }(kt), zt = function() {
        function t2(t3) {
          this.renderer = t3, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new l.d(), this.transform = null;
        }
        return t2.prototype.update = function(t3, e2, i2, n2) {
          this.destinationFrame = t3 || this.destinationFrame || this.defaultFrame, this.sourceFrame = e2 || this.sourceFrame || t3, this.calculateProjection(this.destinationFrame, this.sourceFrame, i2, n2), this.transform && this.projectionMatrix.append(this.transform);
          var r2 = this.renderer;
          r2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r2.globalUniforms.update(), r2.shader.shader && r2.shader.syncUniformGroup(r2.shader.shader.uniforms.globals);
        }, t2.prototype.calculateProjection = function(t3, e2, i2, n2) {
          var r2 = this.projectionMatrix, o2 = n2 ? -1 : 1;
          r2.identity(), r2.a = 1 / e2.width * 2, r2.d = o2 * (1 / e2.height * 2), r2.tx = -1 - e2.x * r2.a, r2.ty = -o2 - e2.y * r2.d;
        }, t2.prototype.setTransform = function(t3) {
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), Vt = new l.j(), Xt = new l.j(), Wt = function() {
        function t2(t3) {
          this.renderer = t3, this.clearColor = t3._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new l.j(), this.destinationFrame = new l.j(), this.viewportFrame = new l.j();
        }
        return t2.prototype.bind = function(t3, e2, i2) {
          void 0 === t3 && (t3 = null);
          var n2, r2, o2, s2 = this.renderer;
          this.current = t3, t3 ? (o2 = (n2 = t3.baseTexture).resolution, e2 || (Vt.width = t3.frame.width, Vt.height = t3.frame.height, e2 = Vt), i2 || (Xt.x = t3.frame.x, Xt.y = t3.frame.y, Xt.width = e2.width, Xt.height = e2.height, i2 = Xt), r2 = n2.framebuffer) : (o2 = s2.resolution, e2 || (Vt.width = s2.screen.width, Vt.height = s2.screen.height, e2 = Vt), i2 || ((i2 = Vt).width = e2.width, i2.height = e2.height));
          var a2 = this.viewportFrame;
          a2.x = i2.x * o2, a2.y = i2.y * o2, a2.width = i2.width * o2, a2.height = i2.height * o2, t3 || (a2.y = s2.view.height - (a2.y + a2.height)), a2.ceil(), this.renderer.framebuffer.bind(r2, a2), this.renderer.projection.update(i2, e2, o2, !r2), t3 ? this.renderer.mask.setMaskStack(n2.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e2), this.destinationFrame.copyFrom(i2);
        }, t2.prototype.clear = function(t3, e2) {
          t3 = this.current ? t3 || this.current.baseTexture.clearColor : t3 || this.clearColor;
          var i2 = this.destinationFrame, n2 = this.current ? this.current.baseTexture : this.renderer.screen, r2 = i2.width !== n2.width || i2.height !== n2.height;
          if (r2) {
            var o2 = this.viewportFrame, s2 = o2.x, a2 = o2.y, l2 = o2.width, h2 = o2.height;
            s2 = Math.round(s2), a2 = Math.round(a2), l2 = Math.round(l2), h2 = Math.round(h2), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s2, a2, l2, h2);
          }
          this.renderer.framebuffer.clear(t3[0], t3[1], t3[2], t3[3], e2), r2 && this.renderer.scissor.pop();
        }, t2.prototype.resize = function() {
          this.bind(null);
        }, t2.prototype.reset = function() {
          this.bind(null);
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }();
      function Yt(t2, e2, i2, n2, r2) {
        i2.buffer.update(r2);
      }
      var qt = { float: "\n        data[offset] = v;\n    ", vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ", vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ", vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ", mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ", mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ", mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    " }, Zt = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 };
      function Jt(t2, e2) {
        if (!t2.autoManage) return { size: 0, syncFunc: Yt };
        for (var i2 = function(t3) {
          for (var e3 = t3.map(function(t4) {
            return { data: t4, offset: 0, dataLen: 0, dirty: 0 };
          }), i3 = 0, n3 = 0, r3 = 0, o3 = 0; o3 < e3.length; o3++) {
            var s3 = e3[o3];
            if (i3 = Zt[s3.data.type], s3.data.size > 1 && (i3 = Math.max(i3, 16) * s3.data.size), s3.dataLen = i3, n3 % i3 != 0 && n3 < 16) {
              var a3 = n3 % i3 % 16;
              n3 += a3, r3 += a3;
            }
            n3 + i3 > 16 ? (r3 = 16 * Math.ceil(r3 / 16), s3.offset = r3, r3 += i3, n3 = i3) : (s3.offset = r3, n3 += i3, r3 += i3);
          }
          return { uboElements: e3, size: r3 = 16 * Math.ceil(r3 / 16) };
        }(function(t3, e3) {
          var i3 = [];
          for (var n3 in t3) e3[n3] && i3.push(e3[n3]);
          return i3.sort(function(t4, e4) {
            return t4.index - e4.index;
          }), i3;
        }(t2.uniforms, e2)), n2 = i2.uboElements, r2 = i2.size, o2 = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], s2 = 0; s2 < n2.length; s2++) {
          for (var a2 = n2[s2], l2 = t2.uniforms[a2.data.name], h2 = a2.data.name, u2 = false, c2 = 0; c2 < Et.length; c2++) {
            var d2 = Et[c2];
            if (d2.codeUbo && d2.test(a2.data, l2)) {
              o2.push("offset = " + a2.offset / 4 + ";", Et[c2].codeUbo(a2.data.name, l2)), u2 = true;
              break;
            }
          }
          if (!u2) if (a2.data.size > 1) {
            var p2 = yt(a2.data.type), f2 = Math.max(Zt[a2.data.type] / 16, 1), m2 = p2 / f2, g2 = (4 - m2 % 4) % 4;
            o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + a2.data.size * f2 + "; i++)\n                {\n                    for(var j = 0; j < " + m2 + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g2 + ";\n                }\n\n                ");
          } else {
            var v2 = qt[a2.data.type];
            o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n                " + v2 + ";\n                ");
          }
        }
        return o2.push("\n       renderer.buffer.update(buffer);\n    "), { size: r2, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o2.join("\n")) };
      }
      var Kt = function() {
        function t2(t3, e2) {
          this.program = t3, this.uniformData = e2, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
        }
        return t2.prototype.destroy = function() {
          this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
        }, t2;
      }();
      function Qt(t2, e2) {
        var i2 = ht(t2, t2.VERTEX_SHADER, e2.vertexSrc), n2 = ht(t2, t2.FRAGMENT_SHADER, e2.fragmentSrc), r2 = t2.createProgram();
        if (t2.attachShader(r2, i2), t2.attachShader(r2, n2), t2.linkProgram(r2), t2.getProgramParameter(r2, t2.LINK_STATUS) || function(t3, e3, i3, n3) {
          t3.getProgramParameter(e3, t3.LINK_STATUS) || (t3.getShaderParameter(i3, t3.COMPILE_STATUS) || ut(t3, i3), t3.getShaderParameter(n3, t3.COMPILE_STATUS) || ut(t3, n3), console.error("PixiJS Error: Could not initialize shader."), "" !== t3.getProgramInfoLog(e3) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t3.getProgramInfoLog(e3)));
        }(t2, r2, i2, n2), e2.attributeData = function(t3, e3) {
          for (var i3 = {}, n3 = e3.getProgramParameter(t3, e3.ACTIVE_ATTRIBUTES), r3 = 0; r3 < n3; r3++) {
            var o3 = e3.getActiveAttrib(t3, r3);
            if (0 !== o3.name.indexOf("gl_")) {
              var s3 = Tt(e3, o3.type), a3 = { type: s3, name: o3.name, size: yt(s3), location: e3.getAttribLocation(t3, o3.name) };
              i3[o3.name] = a3;
            }
          }
          return i3;
        }(r2, t2), e2.uniformData = function(t3, e3) {
          for (var i3 = {}, n3 = e3.getProgramParameter(t3, e3.ACTIVE_UNIFORMS), r3 = 0; r3 < n3; r3++) {
            var o3 = e3.getActiveUniform(t3, r3), s3 = o3.name.replace(/\[.*?\]$/, ""), a3 = !!o3.name.match(/\[.*?\]$/), l3 = Tt(e3, o3.type);
            i3[s3] = { name: s3, index: r3, type: l3, size: o3.size, isArray: a3, value: dt(l3, o3.size) };
          }
          return i3;
        }(r2, t2), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e2.vertexSrc)) {
          var o2 = Object.keys(e2.attributeData);
          o2.sort(function(t3, e3) {
            return t3 > e3 ? 1 : -1;
          });
          for (var s2 = 0; s2 < o2.length; s2++) e2.attributeData[o2[s2]].location = s2, t2.bindAttribLocation(r2, s2, o2[s2]);
          t2.linkProgram(r2);
        }
        t2.deleteShader(i2), t2.deleteShader(n2);
        var a2 = {};
        for (var s2 in e2.uniformData) {
          var l2 = e2.uniformData[s2];
          a2[s2] = { location: t2.getUniformLocation(r2, s2), value: dt(l2.type, l2.size) };
        }
        return new Kt(r2, a2);
      }
      var $t = 0, te = { textureCount: 0, uboCount: 0 }, ee = function() {
        function t2(t3) {
          this.destroyed = false, this.renderer = t3, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = $t++;
        }
        return t2.prototype.systemCheck = function() {
          if (!function() {
            if ("boolean" == typeof At) return At;
            try {
              var t3 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
              At = true === t3({ a: "b" }, "a", "b");
            } catch (t4) {
              At = false;
            }
            return At;
          }()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
        }, t2.prototype.contextChange = function(t3) {
          this.gl = t3, this.reset();
        }, t2.prototype.bind = function(t3, e2) {
          t3.uniforms.globals = this.renderer.globalUniforms;
          var i2 = t3.program, n2 = i2.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t3);
          return this.shader = t3, this.program !== i2 && (this.program = i2, this.gl.useProgram(n2.program)), e2 || (te.textureCount = 0, te.uboCount = 0, this.syncUniformGroup(t3.uniformGroup, te)), n2;
        }, t2.prototype.setUniforms = function(t3) {
          var e2 = this.shader.program, i2 = e2.glPrograms[this.renderer.CONTEXT_UID];
          e2.syncUniforms(i2.uniformData, t3, this.renderer);
        }, t2.prototype.syncUniformGroup = function(t3, e2) {
          var i2 = this.getGlProgram();
          t3.static && t3.dirtyId === i2.uniformDirtyGroups[t3.id] || (i2.uniformDirtyGroups[t3.id] = t3.dirtyId, this.syncUniforms(t3, i2, e2));
        }, t2.prototype.syncUniforms = function(t3, e2, i2) {
          (t3.syncUniforms[this.shader.program.id] || this.createSyncGroups(t3))(e2.uniformData, t3.uniforms, this.renderer, i2);
        }, t2.prototype.createSyncGroups = function(t3) {
          var e2 = this.getSignature(t3, this.shader.program.uniformData, "u");
          return this.cache[e2] || (this.cache[e2] = function(t4, e3) {
            var i2, n2 = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
            for (var r2 in t4.uniforms) {
              var o2 = e3[r2];
              if (o2) {
                for (var s2 = t4.uniforms[r2], a2 = false, l2 = 0; l2 < Et.length; l2++) if (Et[l2].test(o2, s2)) {
                  n2.push(Et[l2].code(r2, s2)), a2 = true;
                  break;
                }
                if (!a2) {
                  var h2 = (1 === o2.size ? St : wt)[o2.type].replace("location", 'ud["' + r2 + '"].location');
                  n2.push('\n            cu = ud["' + r2 + '"];\n            cv = cu.value;\n            v = uv["' + r2 + '"];\n            ' + h2 + ";");
                }
              } else (null === (i2 = t4.uniforms[r2]) || void 0 === i2 ? void 0 : i2.group) && (t4.uniforms[r2].ubo ? n2.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + r2 + ", '" + r2 + "');\n                    ") : n2.push("\n                        renderer.shader.syncUniformGroup(uv." + r2 + ", syncData);\n                    "));
            }
            return new Function("ud", "uv", "renderer", "syncData", n2.join("\n"));
          }(t3, this.shader.program.uniformData)), t3.syncUniforms[this.shader.program.id] = this.cache[e2], t3.syncUniforms[this.shader.program.id];
        }, t2.prototype.syncUniformBufferGroup = function(t3, e2) {
          var i2 = this.getGlProgram();
          if (!t3.static || 0 !== t3.dirtyId || !i2.uniformGroups[t3.id]) {
            t3.dirtyId = 0;
            var n2 = i2.uniformGroups[t3.id] || this.createSyncBufferGroup(t3, i2, e2);
            t3.buffer.update(), n2(i2.uniformData, t3.uniforms, this.renderer, te, t3.buffer);
          }
          this.renderer.buffer.bindBufferBase(t3.buffer, i2.uniformBufferBindings[e2]);
        }, t2.prototype.createSyncBufferGroup = function(t3, e2, i2) {
          var n2 = this.renderer.gl;
          this.renderer.buffer.bind(t3.buffer);
          var r2 = this.gl.getUniformBlockIndex(e2.program, i2);
          e2.uniformBufferBindings[i2] = this.shader.uniformBindCount, n2.uniformBlockBinding(e2.program, r2, this.shader.uniformBindCount), this.shader.uniformBindCount++;
          var o2 = this.getSignature(t3, this.shader.program.uniformData, "ubo"), s2 = this._uboCache[o2];
          if (s2 || (s2 = this._uboCache[o2] = Jt(t3, this.shader.program.uniformData)), t3.autoManage) {
            var a2 = new Float32Array(s2.size / 4);
            t3.buffer.update(a2);
          }
          return e2.uniformGroups[t3.id] = s2.syncFunc, e2.uniformGroups[t3.id];
        }, t2.prototype.getSignature = function(t3, e2, i2) {
          var n2 = t3.uniforms, r2 = [i2 + "-"];
          for (var o2 in n2) r2.push(o2), e2[o2] && r2.push(e2[o2].type);
          return r2.join("-");
        }, t2.prototype.getGlProgram = function() {
          return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
        }, t2.prototype.generateProgram = function(t3) {
          var e2 = this.gl, i2 = t3.program, n2 = Qt(e2, i2);
          return i2.glPrograms[this.renderer.CONTEXT_UID] = n2, n2;
        }, t2.prototype.reset = function() {
          this.program = null, this.shader = null;
        }, t2.prototype.destroy = function() {
          this.renderer = null, this.destroyed = true;
        }, t2;
      }();
      var ie = function() {
        function t2() {
          this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = r.b.NONE, this._blendEq = false, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Nt(), this.defaultState.blend = true;
        }
        return t2.prototype.contextChange = function(t3) {
          this.gl = t3, this.blendModes = function(t4, e2) {
            return void 0 === e2 && (e2 = []), e2[r.b.NORMAL] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD] = [t4.ONE, t4.ONE], e2[r.b.MULTIPLY] = [t4.DST_COLOR, t4.ONE_MINUS_SRC_ALPHA, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SCREEN] = [t4.ONE, t4.ONE_MINUS_SRC_COLOR, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.OVERLAY] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DARKEN] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.LIGHTEN] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_DODGE] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_BURN] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.HARD_LIGHT] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SOFT_LIGHT] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DIFFERENCE] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.EXCLUSION] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.HUE] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SATURATION] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.LUMINOSITY] = [t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.NONE] = [0, 0], e2[r.b.NORMAL_NPM] = [t4.SRC_ALPHA, t4.ONE_MINUS_SRC_ALPHA, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD_NPM] = [t4.SRC_ALPHA, t4.ONE, t4.ONE, t4.ONE], e2[r.b.SCREEN_NPM] = [t4.SRC_ALPHA, t4.ONE_MINUS_SRC_COLOR, t4.ONE, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SRC_IN] = [t4.DST_ALPHA, t4.ZERO], e2[r.b.SRC_OUT] = [t4.ONE_MINUS_DST_ALPHA, t4.ZERO], e2[r.b.SRC_ATOP] = [t4.DST_ALPHA, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_OVER] = [t4.ONE_MINUS_DST_ALPHA, t4.ONE], e2[r.b.DST_IN] = [t4.ZERO, t4.SRC_ALPHA], e2[r.b.DST_OUT] = [t4.ZERO, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_ATOP] = [t4.ONE_MINUS_DST_ALPHA, t4.SRC_ALPHA], e2[r.b.XOR] = [t4.ONE_MINUS_DST_ALPHA, t4.ONE_MINUS_SRC_ALPHA], e2[r.b.SUBTRACT] = [t4.ONE, t4.ONE, t4.ONE, t4.ONE, t4.FUNC_REVERSE_SUBTRACT, t4.FUNC_ADD], e2;
          }(t3), this.set(this.defaultState), this.reset();
        }, t2.prototype.set = function(t3) {
          if (t3 = t3 || this.defaultState, this.stateId !== t3.data) {
            for (var e2 = this.stateId ^ t3.data, i2 = 0; e2; ) 1 & e2 && this.map[i2].call(this, !!(t3.data & 1 << i2)), e2 >>= 1, i2++;
            this.stateId = t3.data;
          }
          for (i2 = 0; i2 < this.checks.length; i2++) this.checks[i2](this, t3);
        }, t2.prototype.forceState = function(t3) {
          t3 = t3 || this.defaultState;
          for (var e2 = 0; e2 < this.map.length; e2++) this.map[e2].call(this, !!(t3.data & 1 << e2));
          for (e2 = 0; e2 < this.checks.length; e2++) this.checks[e2](this, t3);
          this.stateId = t3.data;
        }, t2.prototype.setBlend = function(e2) {
          this.updateCheck(t2.checkBlendMode, e2), this.gl[e2 ? "enable" : "disable"](this.gl.BLEND);
        }, t2.prototype.setOffset = function(e2) {
          this.updateCheck(t2.checkPolygonOffset, e2), this.gl[e2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
        }, t2.prototype.setDepthTest = function(t3) {
          this.gl[t3 ? "enable" : "disable"](this.gl.DEPTH_TEST);
        }, t2.prototype.setDepthMask = function(t3) {
          this.gl.depthMask(t3);
        }, t2.prototype.setCullFace = function(t3) {
          this.gl[t3 ? "enable" : "disable"](this.gl.CULL_FACE);
        }, t2.prototype.setFrontFace = function(t3) {
          this.gl.frontFace(this.gl[t3 ? "CW" : "CCW"]);
        }, t2.prototype.setBlendMode = function(t3) {
          if (t3 !== this.blendMode) {
            this.blendMode = t3;
            var e2 = this.blendModes[t3], i2 = this.gl;
            2 === e2.length ? i2.blendFunc(e2[0], e2[1]) : i2.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), 6 === e2.length ? (this._blendEq = true, i2.blendEquationSeparate(e2[4], e2[5])) : this._blendEq && (this._blendEq = false, i2.blendEquationSeparate(i2.FUNC_ADD, i2.FUNC_ADD));
          }
        }, t2.prototype.setPolygonOffset = function(t3, e2) {
          this.gl.polygonOffset(t3, e2);
        }, t2.prototype.reset = function() {
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
        }, t2.prototype.updateCheck = function(t3, e2) {
          var i2 = this.checks.indexOf(t3);
          e2 && -1 === i2 ? this.checks.push(t3) : e2 || -1 === i2 || this.checks.splice(i2, 1);
        }, t2.checkBlendMode = function(t3, e2) {
          t3.setBlendMode(e2.blendMode);
        }, t2.checkPolygonOffset = function(t3, e2) {
          t3.setPolygonOffset(1, e2.polygonOffset);
        }, t2.prototype.destroy = function() {
          this.gl = null;
        }, t2;
      }(), ne = function() {
        function t2(t3) {
          this.renderer = t3, this.count = 0, this.checkCount = 0, this.maxIdle = n.b.GC_MAX_IDLE, this.checkCountMax = n.b.GC_MAX_CHECK_COUNT, this.mode = n.b.GC_MODE;
        }
        return t2.prototype.postrender = function() {
          this.renderer.renderingToScreen && (this.count++, this.mode !== r.i.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
        }, t2.prototype.run = function() {
          for (var t3 = this.renderer.texture, e2 = t3.managedTextures, i2 = false, n2 = 0; n2 < e2.length; n2++) {
            var r2 = e2[n2];
            !r2.framebuffer && this.count - r2.touched > this.maxIdle && (t3.destroyTexture(r2, true), e2[n2] = null, i2 = true);
          }
          if (i2) {
            var o2 = 0;
            for (n2 = 0; n2 < e2.length; n2++) null !== e2[n2] && (e2[o2++] = e2[n2]);
            e2.length = o2;
          }
        }, t2.prototype.unload = function(t3) {
          var e2 = this.renderer.texture, i2 = t3._texture;
          i2 && !i2.framebuffer && e2.destroyTexture(i2);
          for (var n2 = t3.children.length - 1; n2 >= 0; n2--) this.unload(t3.children[n2]);
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }();
      var re = function(t2) {
        this.texture = t2, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = r.r.UNSIGNED_BYTE, this.internalFormat = r.h.RGBA, this.samplerType = 0;
      }, oe = function() {
        function t2(t3) {
          this.renderer = t3, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new v(), this.hasIntegerTextures = false;
        }
        return t2.prototype.contextChange = function() {
          var t3 = this.gl = this.renderer.gl;
          this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = function(t4) {
            var e3, i3, n3, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, E2, S2;
            return "WebGL2RenderingContext" in globalThis && t4 instanceof globalThis.WebGL2RenderingContext ? ((e3 = {})[r.r.UNSIGNED_BYTE] = ((i3 = {})[r.h.RGBA] = t4.RGBA8, i3[r.h.RGB] = t4.RGB8, i3[r.h.RG] = t4.RG8, i3[r.h.RED] = t4.R8, i3[r.h.RGBA_INTEGER] = t4.RGBA8UI, i3[r.h.RGB_INTEGER] = t4.RGB8UI, i3[r.h.RG_INTEGER] = t4.RG8UI, i3[r.h.RED_INTEGER] = t4.R8UI, i3[r.h.ALPHA] = t4.ALPHA, i3[r.h.LUMINANCE] = t4.LUMINANCE, i3[r.h.LUMINANCE_ALPHA] = t4.LUMINANCE_ALPHA, i3), e3[r.r.BYTE] = ((n3 = {})[r.h.RGBA] = t4.RGBA8_SNORM, n3[r.h.RGB] = t4.RGB8_SNORM, n3[r.h.RG] = t4.RG8_SNORM, n3[r.h.RED] = t4.R8_SNORM, n3[r.h.RGBA_INTEGER] = t4.RGBA8I, n3[r.h.RGB_INTEGER] = t4.RGB8I, n3[r.h.RG_INTEGER] = t4.RG8I, n3[r.h.RED_INTEGER] = t4.R8I, n3), e3[r.r.UNSIGNED_SHORT] = ((o2 = {})[r.h.RGBA_INTEGER] = t4.RGBA16UI, o2[r.h.RGB_INTEGER] = t4.RGB16UI, o2[r.h.RG_INTEGER] = t4.RG16UI, o2[r.h.RED_INTEGER] = t4.R16UI, o2[r.h.DEPTH_COMPONENT] = t4.DEPTH_COMPONENT16, o2), e3[r.r.SHORT] = ((s2 = {})[r.h.RGBA_INTEGER] = t4.RGBA16I, s2[r.h.RGB_INTEGER] = t4.RGB16I, s2[r.h.RG_INTEGER] = t4.RG16I, s2[r.h.RED_INTEGER] = t4.R16I, s2), e3[r.r.UNSIGNED_INT] = ((a2 = {})[r.h.RGBA_INTEGER] = t4.RGBA32UI, a2[r.h.RGB_INTEGER] = t4.RGB32UI, a2[r.h.RG_INTEGER] = t4.RG32UI, a2[r.h.RED_INTEGER] = t4.R32UI, a2[r.h.DEPTH_COMPONENT] = t4.DEPTH_COMPONENT24, a2), e3[r.r.INT] = ((l2 = {})[r.h.RGBA_INTEGER] = t4.RGBA32I, l2[r.h.RGB_INTEGER] = t4.RGB32I, l2[r.h.RG_INTEGER] = t4.RG32I, l2[r.h.RED_INTEGER] = t4.R32I, l2), e3[r.r.FLOAT] = ((h2 = {})[r.h.RGBA] = t4.RGBA32F, h2[r.h.RGB] = t4.RGB32F, h2[r.h.RG] = t4.RG32F, h2[r.h.RED] = t4.R32F, h2[r.h.DEPTH_COMPONENT] = t4.DEPTH_COMPONENT32F, h2), e3[r.r.HALF_FLOAT] = ((u2 = {})[r.h.RGBA] = t4.RGBA16F, u2[r.h.RGB] = t4.RGB16F, u2[r.h.RG] = t4.RG16F, u2[r.h.RED] = t4.R16F, u2), e3[r.r.UNSIGNED_SHORT_5_6_5] = ((c2 = {})[r.h.RGB] = t4.RGB565, c2), e3[r.r.UNSIGNED_SHORT_4_4_4_4] = ((d2 = {})[r.h.RGBA] = t4.RGBA4, d2), e3[r.r.UNSIGNED_SHORT_5_5_5_1] = ((p2 = {})[r.h.RGBA] = t4.RGB5_A1, p2), e3[r.r.UNSIGNED_INT_2_10_10_10_REV] = ((f2 = {})[r.h.RGBA] = t4.RGB10_A2, f2[r.h.RGBA_INTEGER] = t4.RGB10_A2UI, f2), e3[r.r.UNSIGNED_INT_10F_11F_11F_REV] = ((m2 = {})[r.h.RGB] = t4.R11F_G11F_B10F, m2), e3[r.r.UNSIGNED_INT_5_9_9_9_REV] = ((g2 = {})[r.h.RGB] = t4.RGB9_E5, g2), e3[r.r.UNSIGNED_INT_24_8] = ((v2 = {})[r.h.DEPTH_STENCIL] = t4.DEPTH24_STENCIL8, v2), e3[r.r.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((_2 = {})[r.h.DEPTH_STENCIL] = t4.DEPTH32F_STENCIL8, _2), S2 = e3) : ((y2 = {})[r.r.UNSIGNED_BYTE] = ((x2 = {})[r.h.RGBA] = t4.RGBA, x2[r.h.RGB] = t4.RGB, x2[r.h.ALPHA] = t4.ALPHA, x2[r.h.LUMINANCE] = t4.LUMINANCE, x2[r.h.LUMINANCE_ALPHA] = t4.LUMINANCE_ALPHA, x2), y2[r.r.UNSIGNED_SHORT_5_6_5] = ((b2 = {})[r.h.RGB] = t4.RGB, b2), y2[r.r.UNSIGNED_SHORT_4_4_4_4] = ((T2 = {})[r.h.RGBA] = t4.RGBA, T2), y2[r.r.UNSIGNED_SHORT_5_5_5_1] = ((E2 = {})[r.h.RGBA] = t4.RGBA, E2), S2 = y2), S2;
          }(t3);
          var e2 = t3.getParameter(t3.MAX_TEXTURE_IMAGE_UNITS);
          this.boundTextures.length = e2;
          for (var i2 = 0; i2 < e2; i2++) this.boundTextures[i2] = null;
          this.emptyTextures = {};
          var n2 = new re(t3.createTexture());
          t3.bindTexture(t3.TEXTURE_2D, n2.texture), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, 1, 1, 0, t3.RGBA, t3.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t3.TEXTURE_2D] = n2, this.emptyTextures[t3.TEXTURE_CUBE_MAP] = new re(t3.createTexture()), t3.bindTexture(t3.TEXTURE_CUBE_MAP, this.emptyTextures[t3.TEXTURE_CUBE_MAP].texture);
          for (i2 = 0; i2 < 6; i2++) t3.texImage2D(t3.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, t3.RGBA, 1, 1, 0, t3.RGBA, t3.UNSIGNED_BYTE, null);
          t3.texParameteri(t3.TEXTURE_CUBE_MAP, t3.TEXTURE_MAG_FILTER, t3.LINEAR), t3.texParameteri(t3.TEXTURE_CUBE_MAP, t3.TEXTURE_MIN_FILTER, t3.LINEAR);
          for (i2 = 0; i2 < this.boundTextures.length; i2++) this.bind(null, i2);
        }, t2.prototype.bind = function(t3, e2) {
          void 0 === e2 && (e2 = 0);
          var i2 = this.gl;
          if ((t3 = null == t3 ? void 0 : t3.castToBaseTexture()) && t3.valid && !t3.parentTextureArray) {
            t3.touched = this.renderer.textureGC.count;
            var n2 = t3._glTextures[this.CONTEXT_UID] || this.initTexture(t3);
            this.boundTextures[e2] !== t3 && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(t3.target, n2.texture)), n2.dirtyId !== t3.dirtyId && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), this.updateTexture(t3)), this.boundTextures[e2] = t3;
          } else this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(i2.TEXTURE_2D, this.emptyTextures[i2.TEXTURE_2D].texture), this.boundTextures[e2] = null;
        }, t2.prototype.reset = function() {
          this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
          for (var t3 = 0; t3 < this.boundTextures.length; t3++) this.boundTextures[t3] = this.unknownTexture;
        }, t2.prototype.unbind = function(t3) {
          var e2 = this.gl, i2 = this.boundTextures;
          if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            for (var n2 = 0; n2 < i2.length; n2++) i2[n2] === this.unknownTexture && this.bind(null, n2);
          }
          for (n2 = 0; n2 < i2.length; n2++) i2[n2] === t3 && (this.currentLocation !== n2 && (e2.activeTexture(e2.TEXTURE0 + n2), this.currentLocation = n2), e2.bindTexture(t3.target, this.emptyTextures[t3.target].texture), i2[n2] = null);
        }, t2.prototype.ensureSamplerType = function(t3) {
          var e2 = this.boundTextures, i2 = this.hasIntegerTextures, n2 = this.CONTEXT_UID;
          if (i2) for (var o2 = t3 - 1; o2 >= 0; --o2) {
            var s2 = e2[o2];
            if (s2) s2._glTextures[n2].samplerType !== r.o.FLOAT && this.renderer.texture.unbind(s2);
          }
        }, t2.prototype.initTexture = function(t3) {
          var e2 = new re(this.gl.createTexture());
          return e2.dirtyId = -1, t3._glTextures[this.CONTEXT_UID] = e2, this.managedTextures.push(t3), t3.on("dispose", this.destroyTexture, this), e2;
        }, t2.prototype.initTextureType = function(t3, e2) {
          var i2, n2;
          e2.internalFormat = null !== (n2 = null === (i2 = this.internalFormats[t3.type]) || void 0 === i2 ? void 0 : i2[t3.format]) && void 0 !== n2 ? n2 : t3.format, 2 === this.webGLVersion && t3.type === r.r.HALF_FLOAT ? e2.type = this.gl.HALF_FLOAT : e2.type = t3.type;
        }, t2.prototype.updateTexture = function(t3) {
          var e2 = t3._glTextures[this.CONTEXT_UID];
          if (e2) {
            var i2 = this.renderer;
            if (this.initTextureType(t3, e2), t3.resource && t3.resource.upload(i2, t3, e2)) e2.samplerType !== r.o.FLOAT && (this.hasIntegerTextures = true);
            else {
              var n2 = t3.realWidth, o2 = t3.realHeight, s2 = i2.gl;
              (e2.width !== n2 || e2.height !== o2 || e2.dirtyId < 0) && (e2.width = n2, e2.height = o2, s2.texImage2D(t3.target, 0, e2.internalFormat, n2, o2, 0, t3.format, e2.type, null));
            }
            t3.dirtyStyleId !== e2.dirtyStyleId && this.updateTextureStyle(t3), e2.dirtyId = t3.dirtyId;
          }
        }, t2.prototype.destroyTexture = function(t3, e2) {
          var i2 = this.gl;
          if ((t3 = t3.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t3), i2.deleteTexture(t3._glTextures[this.CONTEXT_UID].texture), t3.off("dispose", this.destroyTexture, this), delete t3._glTextures[this.CONTEXT_UID], !e2)) {
            var n2 = this.managedTextures.indexOf(t3);
            -1 !== n2 && Object(o.removeItems)(this.managedTextures, n2, 1);
          }
        }, t2.prototype.updateTextureStyle = function(t3) {
          var e2 = t3._glTextures[this.CONTEXT_UID];
          e2 && (t3.mipmap !== r.k.POW2 && 2 === this.webGLVersion || t3.isPowerOfTwo ? e2.mipmap = t3.mipmap >= 1 : e2.mipmap = false, 2 === this.webGLVersion || t3.isPowerOfTwo ? e2.wrapMode = t3.wrapMode : e2.wrapMode = r.s.CLAMP, t3.resource && t3.resource.style(this.renderer, t3, e2) || this.setStyle(t3, e2), e2.dirtyStyleId = t3.dirtyStyleId);
        }, t2.prototype.setStyle = function(t3, e2) {
          var i2 = this.gl;
          if (e2.mipmap && t3.mipmap !== r.k.ON_MANUAL && i2.generateMipmap(t3.target), i2.texParameteri(t3.target, i2.TEXTURE_WRAP_S, e2.wrapMode), i2.texParameteri(t3.target, i2.TEXTURE_WRAP_T, e2.wrapMode), e2.mipmap) {
            i2.texParameteri(t3.target, i2.TEXTURE_MIN_FILTER, t3.scaleMode === r.p.LINEAR ? i2.LINEAR_MIPMAP_LINEAR : i2.NEAREST_MIPMAP_NEAREST);
            var n2 = this.renderer.context.extensions.anisotropicFiltering;
            if (n2 && t3.anisotropicLevel > 0 && t3.scaleMode === r.p.LINEAR) {
              var o2 = Math.min(t3.anisotropicLevel, i2.getParameter(n2.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
              i2.texParameterf(t3.target, n2.TEXTURE_MAX_ANISOTROPY_EXT, o2);
            }
          } else i2.texParameteri(t3.target, i2.TEXTURE_MIN_FILTER, t3.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
          i2.texParameteri(t3.target, i2.TEXTURE_MAG_FILTER, t3.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), se = { __proto__: null, FilterSystem: Q, BatchSystem: tt, ContextSystem: it, FramebufferSystem: ot, GeometrySystem: at, MaskSystem: Ut, ScissorSystem: Ht, StencilSystem: jt, ProjectionSystem: zt, RenderTextureSystem: Wt, ShaderSystem: ee, StateSystem: ie, TextureGCSystem: ne, TextureSystem: oe }, ae = new l.d(), le = function(t2) {
        function e2(e3, i2) {
          void 0 === e3 && (e3 = r.n.UNKNOWN);
          var s2 = t2.call(this) || this;
          return i2 = Object.assign({}, n.b.RENDER_OPTIONS, i2), s2.options = i2, s2.type = e3, s2.screen = new l.j(0, 0, i2.width, i2.height), s2.view = i2.view || document.createElement("canvas"), s2.resolution = i2.resolution || n.b.RESOLUTION, s2.useContextAlpha = i2.useContextAlpha, s2.autoDensity = !!i2.autoDensity, s2.preserveDrawingBuffer = i2.preserveDrawingBuffer, s2.clearBeforeRender = i2.clearBeforeRender, s2._backgroundColor = 0, s2._backgroundColorRgba = [0, 0, 0, 1], s2._backgroundColorString = "#000000", s2.backgroundColor = i2.backgroundColor || s2._backgroundColor, s2.backgroundAlpha = i2.backgroundAlpha, void 0 !== i2.transparent && (Object(o.deprecation)("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), s2.useContextAlpha = i2.transparent, s2.backgroundAlpha = i2.transparent ? 0 : 1), s2._lastObjectRendered = null, s2.plugins = {}, s2;
        }
        return d(e2, t2), e2.prototype.initPlugins = function(t3) {
          for (var e3 in t3) this.plugins[e3] = new t3[e3](this);
        }, Object.defineProperty(e2.prototype, "width", { get: function() {
          return this.view.width;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this.view.height;
        }, enumerable: false, configurable: true }), e2.prototype.resize = function(t3, e3) {
          this.view.width = Math.round(t3 * this.resolution), this.view.height = Math.round(e3 * this.resolution);
          var i2 = this.view.width / this.resolution, n2 = this.view.height / this.resolution;
          this.screen.width = i2, this.screen.height = n2, this.autoDensity && (this.view.style.width = i2 + "px", this.view.style.height = n2 + "px"), this.emit("resize", i2, n2);
        }, e2.prototype.generateTexture = function(t3, e3, i2, n2) {
          void 0 === e3 && (e3 = {}), "number" == typeof e3 && (Object(o.deprecation)("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e3 = { scaleMode: e3, resolution: i2, region: n2 });
          var r2 = e3.region, s2 = function(t4, e4) {
            var i3 = {};
            for (var n3 in t4) Object.prototype.hasOwnProperty.call(t4, n3) && e4.indexOf(n3) < 0 && (i3[n3] = t4[n3]);
            if (null != t4 && "function" == typeof Object.getOwnPropertySymbols) {
              var r3 = 0;
              for (n3 = Object.getOwnPropertySymbols(t4); r3 < n3.length; r3++) e4.indexOf(n3[r3]) < 0 && (i3[n3[r3]] = t4[n3[r3]]);
            }
            return i3;
          }(e3, ["region"]);
          0 === (n2 = r2 || t3.getLocalBounds(null, true)).width && (n2.width = 1), 0 === n2.height && (n2.height = 1);
          var a2 = D.create(p({ width: n2.width, height: n2.height }, s2));
          return ae.tx = -n2.x, ae.ty = -n2.y, this.render(t3, { renderTexture: a2, clear: false, transform: ae, skipUpdateTransform: !!t3.parent }), a2;
        }, e2.prototype.destroy = function(t3) {
          for (var e3 in this.plugins) this.plugins[e3].destroy(), this.plugins[e3] = null;
          t3 && this.view.parentNode && this.view.parentNode.removeChild(this.view);
          this.plugins = null, this.type = r.n.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
        }, Object.defineProperty(e2.prototype, "backgroundColor", { get: function() {
          return this._backgroundColor;
        }, set: function(t3) {
          this._backgroundColor = t3, this._backgroundColorString = Object(o.hex2string)(t3), Object(o.hex2rgb)(t3, this._backgroundColorRgba);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "backgroundAlpha", { get: function() {
          return this._backgroundColorRgba[3];
        }, set: function(t3) {
          this._backgroundColorRgba[3] = t3;
        }, enumerable: false, configurable: true }), e2;
      }(o.EventEmitter), he = function(t2) {
        this.buffer = t2 || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
      }, ue = function() {
        function t2(t3) {
          this.renderer = t3, this.managedBuffers = {}, this.boundBufferBases = {};
        }
        return t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2.prototype.contextChange = function() {
          this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        }, t2.prototype.bind = function(t3) {
          var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t3._glBuffers[i2] || this.createGLBuffer(t3);
          e2.bindBuffer(t3.type, n2.buffer);
        }, t2.prototype.bindBufferBase = function(t3, e2) {
          var i2 = this.gl, n2 = this.CONTEXT_UID;
          if (this.boundBufferBases[e2] !== t3) {
            var r2 = t3._glBuffers[n2] || this.createGLBuffer(t3);
            this.boundBufferBases[e2] = t3, i2.bindBufferBase(i2.UNIFORM_BUFFER, e2, r2.buffer);
          }
        }, t2.prototype.bindBufferRange = function(t3, e2, i2) {
          var n2 = this.gl, r2 = this.CONTEXT_UID;
          i2 = i2 || 0;
          var o2 = t3._glBuffers[r2] || this.createGLBuffer(t3);
          n2.bindBufferRange(n2.UNIFORM_BUFFER, e2 || 0, o2.buffer, 256 * i2, 256);
        }, t2.prototype.update = function(t3) {
          var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t3._glBuffers[i2];
          if (t3._updateID !== n2.updateID) if (n2.updateID = t3._updateID, e2.bindBuffer(t3.type, n2.buffer), n2.byteLength >= t3.data.byteLength) e2.bufferSubData(t3.type, 0, t3.data);
          else {
            var r2 = t3.static ? e2.STATIC_DRAW : e2.DYNAMIC_DRAW;
            n2.byteLength = t3.data.byteLength, e2.bufferData(t3.type, t3.data, r2);
          }
        }, t2.prototype.dispose = function(t3, e2) {
          if (this.managedBuffers[t3.id]) {
            delete this.managedBuffers[t3.id];
            var i2 = t3._glBuffers[this.CONTEXT_UID], n2 = this.gl;
            t3.disposeRunner.remove(this), i2 && (e2 || n2.deleteBuffer(i2.buffer), delete t3._glBuffers[this.CONTEXT_UID]);
          }
        }, t2.prototype.disposeAll = function(t3) {
          for (var e2 = Object.keys(this.managedBuffers), i2 = 0; i2 < e2.length; i2++) this.dispose(this.managedBuffers[e2[i2]], t3);
        }, t2.prototype.createGLBuffer = function(t3) {
          var e2 = this.CONTEXT_UID, i2 = this.gl;
          return t3._glBuffers[e2] = new he(i2.createBuffer()), this.managedBuffers[t3.id] = t3, t3.disposeRunner.add(this), t3._glBuffers[e2];
        }, t2;
      }(), ce = function(t2) {
        function e2(i2) {
          var n2 = t2.call(this, r.n.WEBGL, i2) || this;
          return i2 = n2.options, n2.gl = null, n2.CONTEXT_UID = 0, n2.runners = { destroy: new s.a("destroy"), contextChange: new s.a("contextChange"), reset: new s.a("reset"), update: new s.a("update"), postrender: new s.a("postrender"), prerender: new s.a("prerender"), resize: new s.a("resize") }, n2.runners.contextChange.add(n2), n2.globalUniforms = new q({ projectionMatrix: new l.d() }, true), n2.addSystem(Ut, "mask").addSystem(it, "context").addSystem(ie, "state").addSystem(ee, "shader").addSystem(oe, "texture").addSystem(ue, "buffer").addSystem(at, "geometry").addSystem(ot, "framebuffer").addSystem(Ht, "scissor").addSystem(jt, "stencil").addSystem(zt, "projection").addSystem(ne, "textureGC").addSystem(Q, "filter").addSystem(Wt, "renderTexture").addSystem(tt, "batch"), n2.initPlugins(e2.__plugins), n2.multisample = void 0, i2.context ? n2.context.initFromContext(i2.context) : n2.context.initFromOptions({ alpha: !!n2.useContextAlpha, antialias: i2.antialias, premultipliedAlpha: n2.useContextAlpha && "notMultiplied" !== n2.useContextAlpha, stencil: true, preserveDrawingBuffer: i2.preserveDrawingBuffer, powerPreference: n2.options.powerPreference }), n2.renderingToScreen = true, Object(o.sayHello)(2 === n2.context.webGLVersion ? "WebGL 2" : "WebGL 1"), n2.resize(n2.options.width, n2.options.height), n2;
        }
        return d(e2, t2), e2.create = function(t3) {
          if (Object(o.isWebGLSupported)()) return new e2(t3);
          throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
        }, e2.prototype.contextChange = function() {
          var t3, e3 = this.gl;
          if (1 === this.context.webGLVersion) {
            var i2 = e3.getParameter(e3.FRAMEBUFFER_BINDING);
            e3.bindFramebuffer(e3.FRAMEBUFFER, null), t3 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.FRAMEBUFFER, i2);
          } else {
            i2 = e3.getParameter(e3.DRAW_FRAMEBUFFER_BINDING);
            e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, null), t3 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, i2);
          }
          t3 >= r.l.HIGH ? this.multisample = r.l.HIGH : t3 >= r.l.MEDIUM ? this.multisample = r.l.MEDIUM : t3 >= r.l.LOW ? this.multisample = r.l.LOW : this.multisample = r.l.NONE;
        }, e2.prototype.addSystem = function(t3, e3) {
          var i2 = new t3(this);
          if (this[e3]) throw new Error('Whoops! The name "' + e3 + '" is already in use');
          for (var n2 in this[e3] = i2, this.runners) this.runners[n2].add(i2);
          return this;
        }, e2.prototype.render = function(t3, e3) {
          var i2, n2, r2, s2;
          if (e3 && (e3 instanceof D ? (Object(o.deprecation)("6.0.0", "Renderer#render arguments changed, use options instead."), i2 = e3, n2 = arguments[2], r2 = arguments[3], s2 = arguments[4]) : (i2 = e3.renderTexture, n2 = e3.clear, r2 = e3.transform, s2 = e3.skipUpdateTransform)), this.renderingToScreen = !i2, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = r2, !this.context.isLost) {
            if (i2 || (this._lastObjectRendered = t3), !s2) {
              var a2 = t3.enableTempParent();
              t3.updateTransform(), t3.disableTempParent(a2);
            }
            this.renderTexture.bind(i2), this.batch.currentRenderer.start(), (void 0 !== n2 ? n2 : this.clearBeforeRender) && this.renderTexture.clear(), t3.render(this), this.batch.currentRenderer.flush(), i2 && i2.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
          }
        }, e2.prototype.generateTexture = function(e3, i2, n2, r2) {
          void 0 === i2 && (i2 = {});
          var o2 = t2.prototype.generateTexture.call(this, e3, i2, n2, r2);
          return this.framebuffer.blit(), o2;
        }, e2.prototype.resize = function(e3, i2) {
          t2.prototype.resize.call(this, e3, i2), this.runners.resize.emit(this.screen.height, this.screen.width);
        }, e2.prototype.reset = function() {
          return this.runners.reset.emit(), this;
        }, e2.prototype.clear = function() {
          this.renderTexture.bind(), this.renderTexture.clear();
        }, e2.prototype.destroy = function(e3) {
          for (var i2 in this.runners.destroy.emit(), this.runners) this.runners[i2].destroy();
          t2.prototype.destroy.call(this, e3), this.gl = null;
        }, Object.defineProperty(e2.prototype, "extract", { get: function() {
          return Object(o.deprecation)("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
        }, enumerable: false, configurable: true }), e2.registerPlugin = function(t3, i2) {
          e2.__plugins = e2.__plugins || {}, e2.__plugins[t3] = i2;
        }, e2;
      }(le);
      function de(t2) {
        return ce.create(t2);
      }
      var pe = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}", fe = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n", me = (function() {
        function t2(t3) {
          Object(o.deprecation)("6.1.0", "System class is deprecated, implemement ISystem interface instead."), this.renderer = t3;
        }
        t2.prototype.destroy = function() {
          this.renderer = null;
        };
      }(), function() {
        this.texArray = null, this.blend = 0, this.type = r.f.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
      }), ge = function() {
        function t2() {
          this.elements = [], this.ids = [], this.count = 0;
        }
        return t2.prototype.clear = function() {
          for (var t3 = 0; t3 < this.count; t3++) this.elements[t3] = null;
          this.count = 0;
        }, t2;
      }(), ve = function() {
        function t2(t3) {
          "number" == typeof t3 ? this.rawBinaryData = new ArrayBuffer(t3) : t3 instanceof Uint8Array ? this.rawBinaryData = t3.buffer : this.rawBinaryData = t3, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
        }
        return Object.defineProperty(t2.prototype, "int8View", { get: function() {
          return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "uint8View", { get: function() {
          return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "int16View", { get: function() {
          return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "uint16View", { get: function() {
          return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "int32View", { get: function() {
          return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
        }, enumerable: false, configurable: true }), t2.prototype.view = function(t3) {
          return this[t3 + "View"];
        }, t2.prototype.destroy = function() {
          this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
        }, t2.sizeOf = function(t3) {
          switch (t3) {
            case "int8":
            case "uint8":
              return 1;
            case "int16":
            case "uint16":
              return 2;
            case "int32":
            case "uint32":
            case "float32":
              return 4;
            default:
              throw new Error(t3 + " isn't a valid view type");
          }
        }, t2;
      }(), _e = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return i2.shaderGenerator = null, i2.geometryClass = null, i2.vertexSize = null, i2.state = Nt.for2d(), i2.size = 4 * n.b.SPRITE_BATCH_SIZE, i2._vertexCount = 0, i2._indexCount = 0, i2._bufferedElements = [], i2._bufferedTextures = [], i2._bufferSize = 0, i2._shader = null, i2._packedGeometries = [], i2._packedGeometryPoolSize = 2, i2._flushId = 0, i2._aBuffers = {}, i2._iBuffers = {}, i2.MAX_TEXTURES = 1, i2.renderer.on("prerender", i2.onPrerender, i2), e3.runners.contextChange.add(i2), i2._dcIndex = 0, i2._aIndex = 0, i2._iIndex = 0, i2._attributeBuffer = null, i2._indexBuffer = null, i2._tempBoundTextures = [], i2;
        }
        return d(e2, t2), e2.prototype.contextChange = function() {
          var t3 = this.renderer.gl;
          n.b.PREFER_ENV === r.g.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t3.getParameter(t3.MAX_TEXTURE_IMAGE_UNITS), n.b.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = function(t4, e4) {
            if (0 === t4) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
            for (var i2 = e4.createShader(e4.FRAGMENT_SHADER); ; ) {
              var n2 = Mt.replace(/%forloop%/gi, Ct(t4));
              if (e4.shaderSource(i2, n2), e4.compileShader(i2), e4.getShaderParameter(i2, e4.COMPILE_STATUS)) break;
              t4 = t4 / 2 | 0;
            }
            return t4;
          }(this.MAX_TEXTURES, t3)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
          for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++) this._packedGeometries[e3] = new this.geometryClass();
          this.initFlushBuffers();
        }, e2.prototype.initFlushBuffers = function() {
          for (var t3 = e2._drawCallPool, i2 = e2._textureArrayPool, n2 = this.size / 4, r2 = Math.floor(n2 / this.MAX_TEXTURES) + 1; t3.length < n2; ) t3.push(new me());
          for (; i2.length < r2; ) i2.push(new ge());
          for (var o2 = 0; o2 < this.MAX_TEXTURES; o2++) this._tempBoundTextures[o2] = null;
        }, e2.prototype.onPrerender = function() {
          this._flushId = 0;
        }, e2.prototype.render = function(t3) {
          t3._texture.valid && (this._vertexCount + t3.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t3.vertexData.length / 2, this._indexCount += t3.indices.length, this._bufferedTextures[this._bufferSize] = t3._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t3);
        }, e2.prototype.buildTexturesAndDrawCalls = function() {
          var t3 = this._bufferedTextures, i2 = this.MAX_TEXTURES, n2 = e2._textureArrayPool, r2 = this.renderer.batch, o2 = this._tempBoundTextures, s2 = this.renderer.textureGC.count, a2 = ++v._globalBatch, l2 = 0, h2 = n2[0], u2 = 0;
          r2.copyBoundTextures(o2, i2);
          for (var c2 = 0; c2 < this._bufferSize; ++c2) {
            var d2 = t3[c2];
            t3[c2] = null, d2._batchEnabled !== a2 && (h2.count >= i2 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, c2), u2 = c2, h2 = n2[++l2], ++a2), d2._batchEnabled = a2, d2.touched = s2, h2.elements[h2.count++] = d2);
          }
          h2.count > 0 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, this._bufferSize), ++l2, ++a2);
          for (c2 = 0; c2 < o2.length; c2++) o2[c2] = null;
          v._globalBatch = a2;
        }, e2.prototype.buildDrawCalls = function(t3, i2, n2) {
          var r2 = this._bufferedElements, s2 = this._attributeBuffer, a2 = this._indexBuffer, l2 = this.vertexSize, h2 = e2._drawCallPool, u2 = this._dcIndex, c2 = this._aIndex, d2 = this._iIndex, p2 = h2[u2];
          p2.start = this._iIndex, p2.texArray = t3;
          for (var f2 = i2; f2 < n2; ++f2) {
            var m2 = r2[f2], g2 = m2._texture.baseTexture, v2 = o.premultiplyBlendMode[g2.alphaMode ? 1 : 0][m2.blendMode];
            r2[f2] = null, i2 < f2 && p2.blend !== v2 && (p2.size = d2 - p2.start, i2 = f2, (p2 = h2[++u2]).texArray = t3, p2.start = d2), this.packInterleavedGeometry(m2, s2, a2, c2, d2), c2 += m2.vertexData.length / 2 * l2, d2 += m2.indices.length, p2.blend = v2;
          }
          i2 < n2 && (p2.size = d2 - p2.start, ++u2), this._dcIndex = u2, this._aIndex = c2, this._iIndex = d2;
        }, e2.prototype.bindAndClearTexArray = function(t3) {
          for (var e3 = this.renderer.texture, i2 = 0; i2 < t3.count; i2++) e3.bind(t3.elements[i2], t3.ids[i2]), t3.elements[i2] = null;
          t3.count = 0;
        }, e2.prototype.updateGeometry = function() {
          var t3 = this._packedGeometries, e3 = this._attributeBuffer, i2 = this._indexBuffer;
          n.b.CAN_UPLOAD_SAME_BUFFER ? (t3[this._flushId]._buffer.update(e3.rawBinaryData), t3[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t3[this._flushId] = new this.geometryClass()), t3[this._flushId]._buffer.update(e3.rawBinaryData), t3[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.bind(t3[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
        }, e2.prototype.drawBatches = function() {
          for (var t3 = this._dcIndex, i2 = this.renderer, n2 = i2.gl, r2 = i2.state, o2 = e2._drawCallPool, s2 = null, a2 = 0; a2 < t3; a2++) {
            var l2 = o2[a2], h2 = l2.texArray, u2 = l2.type, c2 = l2.size, d2 = l2.start, p2 = l2.blend;
            s2 !== h2 && (s2 = h2, this.bindAndClearTexArray(h2)), this.state.blendMode = p2, r2.set(this.state), n2.drawElements(u2, c2, n2.UNSIGNED_SHORT, 2 * d2);
          }
        }, e2.prototype.flush = function() {
          0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
        }, e2.prototype.start = function() {
          this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), n.b.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
        }, e2.prototype.stop = function() {
          this.flush();
        }, e2.prototype.destroy = function() {
          for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++) this._packedGeometries[e3] && this._packedGeometries[e3].destroy();
          this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t2.prototype.destroy.call(this);
        }, e2.prototype.getAttributeBuffer = function(t3) {
          var e3 = Object(o.nextPow2)(Math.ceil(t3 / 8)), i2 = Object(o.log2)(e3), n2 = 8 * e3;
          this._aBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
          var r2 = this._aBuffers[n2];
          return r2 || (this._aBuffers[n2] = r2 = new ve(n2 * this.vertexSize * 4)), r2;
        }, e2.prototype.getIndexBuffer = function(t3) {
          var e3 = Object(o.nextPow2)(Math.ceil(t3 / 12)), i2 = Object(o.log2)(e3), n2 = 12 * e3;
          this._iBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
          var r2 = this._iBuffers[i2];
          return r2 || (this._iBuffers[i2] = r2 = new Uint16Array(n2)), r2;
        }, e2.prototype.packInterleavedGeometry = function(t3, e3, i2, n2, r2) {
          for (var s2 = e3.uint32View, a2 = e3.float32View, l2 = n2 / this.vertexSize, h2 = t3.uvs, u2 = t3.indices, c2 = t3.vertexData, d2 = t3._texture.baseTexture._batchLocation, p2 = Math.min(t3.worldAlpha, 1), f2 = p2 < 1 && t3._texture.baseTexture.alphaMode ? Object(o.premultiplyTint)(t3._tintRGB, p2) : t3._tintRGB + (255 * p2 << 24), m2 = 0; m2 < c2.length; m2 += 2) a2[n2++] = c2[m2], a2[n2++] = c2[m2 + 1], a2[n2++] = h2[m2], a2[n2++] = h2[m2 + 1], s2[n2++] = f2, a2[n2++] = d2;
          for (m2 = 0; m2 < u2.length; m2++) i2[r2++] = l2 + u2[m2];
        }, e2._drawCallPool = [], e2._textureArrayPool = [], e2;
      }($), ye = function() {
        function t2(t3, e2) {
          if (this.vertexSrc = t3, this.fragTemplate = e2, this.programCache = {}, this.defaultGroupCache = {}, e2.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".');
          if (e2.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".');
        }
        return t2.prototype.generateShader = function(t3) {
          if (!this.programCache[t3]) {
            for (var e2 = new Int32Array(t3), i2 = 0; i2 < t3; i2++) e2[i2] = i2;
            this.defaultGroupCache[t3] = q.from({ uSamplers: e2 }, true);
            var n2 = this.fragTemplate;
            n2 = (n2 = n2.replace(/%count%/gi, "" + t3)).replace(/%forloop%/gi, this.generateSampleSrc(t3)), this.programCache[t3] = new Pt(this.vertexSrc, n2);
          }
          var r2 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new l.d(), default: this.defaultGroupCache[t3] };
          return new Ot(this.programCache[t3], r2);
        }, t2.prototype.generateSampleSrc = function(t3) {
          var e2 = "";
          e2 += "\n", e2 += "\n";
          for (var i2 = 0; i2 < t3; i2++) i2 > 0 && (e2 += "\nelse "), i2 < t3 - 1 && (e2 += "if(vTextureId < " + i2 + ".5)"), e2 += "\n{", e2 += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);", e2 += "\n}";
          return e2 += "\n", e2 += "\n";
        }, t2;
      }(), xe = function(t2) {
        function e2(e3) {
          void 0 === e3 && (e3 = false);
          var i2 = t2.call(this) || this;
          return i2._buffer = new k(null, e3, false), i2._indexBuffer = new k(null, e3, true), i2.addAttribute("aVertexPosition", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aTextureCoord", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aColor", i2._buffer, 4, true, r.r.UNSIGNED_BYTE).addAttribute("aTextureId", i2._buffer, 1, true, r.r.FLOAT).addIndex(i2._indexBuffer), i2;
        }
        return d(e2, t2), e2;
      }(V), be = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", Te = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n", Ee = function() {
        function t2() {
        }
        return t2.create = function(t3) {
          var e2 = Object.assign({ vertex: be, fragment: Te, geometryClass: xe, vertexSize: 6 }, t3), i2 = e2.vertex, n2 = e2.fragment, r2 = e2.vertexSize, o2 = e2.geometryClass;
          return function(t4) {
            function e3(e4) {
              var s2 = t4.call(this, e4) || this;
              return s2.shaderGenerator = new ye(i2, n2), s2.geometryClass = o2, s2.vertexSize = r2, s2;
            }
            return d(e3, t4), e3;
          }(_e);
        }, Object.defineProperty(t2, "defaultVertexSrc", { get: function() {
          return be;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "defaultFragmentTemplate", { get: function() {
          return Te;
        }, enumerable: false, configurable: true }), t2;
      }().create(), Se = {}, we = function(t2) {
        Object.defineProperty(Se, t2, { get: function() {
          return Object(o.deprecation)("6.0.0", "PIXI.systems." + t2 + " has moved to PIXI." + t2), M[t2];
        } });
      };
      for (var Ae in M) we(Ae);
      var Me = {}, Ce = function(t2) {
        Object.defineProperty(Me, t2, { get: function() {
          return Object(o.deprecation)("6.0.0", "PIXI.resources." + t2 + " has moved to PIXI." + t2), se[t2];
        } });
      };
      for (var Ae in se) Ce(Ae);
    }, function(t, e, i) {
      "use strict";
      i.r(e), i.d(e, "BaseTextureCache", function() {
        return H;
      }), i.d(e, "CanvasRenderTarget", function() {
        return V;
      }), i.d(e, "DATA_URI", function() {
        return Y;
      }), i.d(e, "ProgramCache", function() {
        return k;
      }), i.d(e, "TextureCache", function() {
        return G;
      }), i.d(e, "clearTextureCache", function() {
        return z;
      }), i.d(e, "correctBlendMode", function() {
        return T;
      }), i.d(e, "createIndicesForQuads", function() {
        return A;
      }), i.d(e, "decomposeDataUri", function() {
        return q;
      }), i.d(e, "deprecation", function() {
        return U;
      }), i.d(e, "destroyTextureCache", function() {
        return j;
      }), i.d(e, "determineCrossOrigin", function() {
        return Z;
      }), i.d(e, "getBufferType", function() {
        return M;
      }), i.d(e, "getResolutionOfUrl", function() {
        return J;
      }), i.d(e, "hex2rgb", function() {
        return v;
      }), i.d(e, "hex2string", function() {
        return _;
      }), i.d(e, "interleaveTypedArrays", function() {
        return R;
      }), i.d(e, "isPow2", function() {
        return P;
      }), i.d(e, "isWebGLSupported", function() {
        return m;
      }), i.d(e, "log2", function() {
        return O;
      }), i.d(e, "nextPow2", function() {
        return I;
      }), i.d(e, "premultiplyBlendMode", function() {
        return b;
      }), i.d(e, "premultiplyRgba", function() {
        return E;
      }), i.d(e, "premultiplyTint", function() {
        return S;
      }), i.d(e, "premultiplyTintToRgba", function() {
        return w;
      }), i.d(e, "removeItems", function() {
        return N;
      }), i.d(e, "rgb2hex", function() {
        return x;
      }), i.d(e, "sayHello", function() {
        return f;
      }), i.d(e, "sign", function() {
        return L;
      }), i.d(e, "skipHello", function() {
        return p;
      }), i.d(e, "string2hex", function() {
        return y;
      }), i.d(e, "trimCanvas", function() {
        return X;
      }), i.d(e, "uid", function() {
        return F;
      }), i.d(e, "url", function() {
        return u;
      });
      var n = i(4);
      i.d(e, "isMobile", function() {
        return n.a;
      });
      var r = i(52), o = i.n(r);
      i.d(e, "EventEmitter", function() {
        return o.a;
      });
      var s = i(53), a = i.n(s);
      i.d(e, "earcut", function() {
        return a.a;
      });
      var l = i(35), h = i(0), u = { parse: l.parse, format: l.format, resolve: l.resolve };
      n.b.RETINA_PREFIX = /@([0-9\.]+)x/, n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
      var c, d = false;
      function p() {
        d = true;
      }
      function f(t2) {
        var e2;
        if (!d) {
          if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
            var i2 = ["\n %c %c %c PixiJS 6.4.2 - \u2730 " + t2 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
            (e2 = globalThis.console).log.apply(e2, i2);
          } else globalThis.console && globalThis.console.log("PixiJS 6.4.2 - " + t2 + " - http://www.pixijs.com/");
          d = true;
        }
      }
      function m() {
        return void 0 === c && (c = function() {
          var t2 = { stencil: true, failIfMajorPerformanceCaveat: n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT };
          try {
            if (!globalThis.WebGLRenderingContext) return false;
            var e2 = document.createElement("canvas"), i2 = e2.getContext("webgl", t2) || e2.getContext("experimental-webgl", t2), r2 = !(!i2 || !i2.getContextAttributes().stencil);
            if (i2) {
              var o2 = i2.getExtension("WEBGL_lose_context");
              o2 && o2.loseContext();
            }
            return i2 = null, r2;
          } catch (t3) {
            return false;
          }
        }()), c;
      }
      var g = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", goldenrod: "#daa520", gold: "#ffd700", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavenderblush: "#fff0f5", lavender: "#e6e6fa", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
      function v(t2, e2) {
        return void 0 === e2 && (e2 = []), e2[0] = (t2 >> 16 & 255) / 255, e2[1] = (t2 >> 8 & 255) / 255, e2[2] = (255 & t2) / 255, e2;
      }
      function _(t2) {
        var e2 = t2.toString(16);
        return "#" + (e2 = "000000".substring(0, 6 - e2.length) + e2);
      }
      function y(t2) {
        return "string" == typeof t2 && "#" === (t2 = g[t2.toLowerCase()] || t2)[0] && (t2 = t2.slice(1)), parseInt(t2, 16);
      }
      function x(t2) {
        return (255 * t2[0] << 16) + (255 * t2[1] << 8) + (255 * t2[2] | 0);
      }
      var b = function() {
        for (var t2 = [], e2 = [], i2 = 0; i2 < 32; i2++) t2[i2] = i2, e2[i2] = i2;
        t2[h.b.NORMAL_NPM] = h.b.NORMAL, t2[h.b.ADD_NPM] = h.b.ADD, t2[h.b.SCREEN_NPM] = h.b.SCREEN, e2[h.b.NORMAL] = h.b.NORMAL_NPM, e2[h.b.ADD] = h.b.ADD_NPM, e2[h.b.SCREEN] = h.b.SCREEN_NPM;
        var n2 = [];
        return n2.push(e2), n2.push(t2), n2;
      }();
      function T(t2, e2) {
        return b[e2 ? 1 : 0][t2];
      }
      function E(t2, e2, i2, n2) {
        return i2 = i2 || new Float32Array(4), n2 || void 0 === n2 ? (i2[0] = t2[0] * e2, i2[1] = t2[1] * e2, i2[2] = t2[2] * e2) : (i2[0] = t2[0], i2[1] = t2[1], i2[2] = t2[2]), i2[3] = e2, i2;
      }
      function S(t2, e2) {
        if (1 === e2) return (255 * e2 << 24) + t2;
        if (0 === e2) return 0;
        var i2 = t2 >> 16 & 255, n2 = t2 >> 8 & 255, r2 = 255 & t2;
        return (255 * e2 << 24) + ((i2 = i2 * e2 + 0.5 | 0) << 16) + ((n2 = n2 * e2 + 0.5 | 0) << 8) + (r2 = r2 * e2 + 0.5 | 0);
      }
      function w(t2, e2, i2, n2) {
        return (i2 = i2 || new Float32Array(4))[0] = (t2 >> 16 & 255) / 255, i2[1] = (t2 >> 8 & 255) / 255, i2[2] = (255 & t2) / 255, (n2 || void 0 === n2) && (i2[0] *= e2, i2[1] *= e2, i2[2] *= e2), i2[3] = e2, i2;
      }
      function A(t2, e2) {
        void 0 === e2 && (e2 = null);
        var i2 = 6 * t2;
        if ((e2 = e2 || new Uint16Array(i2)).length !== i2) throw new Error("Out buffer length is incorrect, got " + e2.length + " and expected " + i2);
        for (var n2 = 0, r2 = 0; n2 < i2; n2 += 6, r2 += 4) e2[n2 + 0] = r2 + 0, e2[n2 + 1] = r2 + 1, e2[n2 + 2] = r2 + 2, e2[n2 + 3] = r2 + 0, e2[n2 + 4] = r2 + 2, e2[n2 + 5] = r2 + 3;
        return e2;
      }
      function M(t2) {
        if (4 === t2.BYTES_PER_ELEMENT) return t2 instanceof Float32Array ? "Float32Array" : t2 instanceof Uint32Array ? "Uint32Array" : "Int32Array";
        if (2 === t2.BYTES_PER_ELEMENT) {
          if (t2 instanceof Uint16Array) return "Uint16Array";
        } else if (1 === t2.BYTES_PER_ELEMENT && t2 instanceof Uint8Array) return "Uint8Array";
        return null;
      }
      var C = { Float32Array, Uint32Array, Int32Array, Uint8Array };
      function R(t2, e2) {
        for (var i2 = 0, n2 = 0, r2 = {}, o2 = 0; o2 < t2.length; o2++) n2 += e2[o2], i2 += t2[o2].length;
        var s2 = new ArrayBuffer(4 * i2), a2 = null, l2 = 0;
        for (o2 = 0; o2 < t2.length; o2++) {
          var h2 = e2[o2], u2 = t2[o2], c2 = M(u2);
          r2[c2] || (r2[c2] = new C[c2](s2)), a2 = r2[c2];
          for (var d2 = 0; d2 < u2.length; d2++) {
            a2[(d2 / h2 | 0) * n2 + l2 + d2 % h2] = u2[d2];
          }
          l2 += h2;
        }
        return new Float32Array(s2);
      }
      function I(t2) {
        return t2 += 0 === t2 ? 1 : 0, --t2, t2 |= t2 >>> 1, t2 |= t2 >>> 2, t2 |= t2 >>> 4, t2 |= t2 >>> 8, (t2 |= t2 >>> 16) + 1;
      }
      function P(t2) {
        return !(t2 & t2 - 1 || !t2);
      }
      function O(t2) {
        var e2 = (t2 > 65535 ? 1 : 0) << 4, i2 = ((t2 >>>= e2) > 255 ? 1 : 0) << 3;
        return e2 |= i2, e2 |= i2 = ((t2 >>>= i2) > 15 ? 1 : 0) << 2, (e2 |= i2 = ((t2 >>>= i2) > 3 ? 1 : 0) << 1) | (t2 >>>= i2) >> 1;
      }
      function N(t2, e2, i2) {
        var n2, r2 = t2.length;
        if (!(e2 >= r2 || 0 === i2)) {
          var o2 = r2 - (i2 = e2 + i2 > r2 ? r2 - e2 : i2);
          for (n2 = e2; n2 < o2; ++n2) t2[n2] = t2[n2 + i2];
          t2.length = o2;
        }
      }
      function L(t2) {
        return 0 === t2 ? 0 : t2 < 0 ? -1 : 1;
      }
      var D = 0;
      function F() {
        return ++D;
      }
      var B = {};
      function U(t2, e2, i2) {
        if (void 0 === i2 && (i2 = 3), !B[e2]) {
          var n2 = new Error().stack;
          void 0 === n2 ? console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t2) : (n2 = n2.split("\n").splice(i2).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e2 + "\nDeprecated since v" + t2), console.warn(n2), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t2), console.warn(n2))), B[e2] = true;
        }
      }
      var k = {}, G = /* @__PURE__ */ Object.create(null), H = /* @__PURE__ */ Object.create(null);
      function j() {
        var t2;
        for (t2 in G) G[t2].destroy();
        for (t2 in H) H[t2].destroy();
      }
      function z() {
        var t2;
        for (t2 in G) delete G[t2];
        for (t2 in H) delete H[t2];
      }
      var V = function() {
        function t2(t3, e2, i2) {
          this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = i2 || n.b.RESOLUTION, this.resize(t3, e2);
        }
        return t2.prototype.clear = function() {
          this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }, t2.prototype.resize = function(t3, e2) {
          this.canvas.width = Math.round(t3 * this.resolution), this.canvas.height = Math.round(e2 * this.resolution);
        }, t2.prototype.destroy = function() {
          this.context = null, this.canvas = null;
        }, Object.defineProperty(t2.prototype, "width", { get: function() {
          return this.canvas.width;
        }, set: function(t3) {
          this.canvas.width = Math.round(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "height", { get: function() {
          return this.canvas.height;
        }, set: function(t3) {
          this.canvas.height = Math.round(t3);
        }, enumerable: false, configurable: true }), t2;
      }();
      function X(t2) {
        var e2, i2, n2, r2 = t2.width, o2 = t2.height, s2 = t2.getContext("2d"), a2 = s2.getImageData(0, 0, r2, o2).data, l2 = a2.length, h2 = { top: null, left: null, right: null, bottom: null }, u2 = null;
        for (e2 = 0; e2 < l2; e2 += 4) 0 !== a2[e2 + 3] && (i2 = e2 / 4 % r2, n2 = ~~(e2 / 4 / r2), null === h2.top && (h2.top = n2), (null === h2.left || i2 < h2.left) && (h2.left = i2), (null === h2.right || h2.right < i2) && (h2.right = i2 + 1), (null === h2.bottom || h2.bottom < n2) && (h2.bottom = n2));
        return null !== h2.top && (r2 = h2.right - h2.left, o2 = h2.bottom - h2.top + 1, u2 = s2.getImageData(h2.left, h2.top, r2, o2)), { height: o2, width: r2, data: u2 };
      }
      var W, Y = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
      function q(t2) {
        var e2 = Y.exec(t2);
        if (e2) return { mediaType: e2[1] ? e2[1].toLowerCase() : void 0, subType: e2[2] ? e2[2].toLowerCase() : void 0, charset: e2[3] ? e2[3].toLowerCase() : void 0, encoding: e2[4] ? e2[4].toLowerCase() : void 0, data: e2[5] };
      }
      function Z(t2, e2) {
        if (void 0 === e2 && (e2 = globalThis.location), 0 === t2.indexOf("data:")) return "";
        e2 = e2 || globalThis.location, W || (W = document.createElement("a")), W.href = t2;
        var i2 = u.parse(W.href), n2 = !i2.port && "" === e2.port || i2.port === e2.port;
        return i2.hostname === e2.hostname && n2 && i2.protocol === e2.protocol ? "" : "anonymous";
      }
      function J(t2, e2) {
        var i2 = n.b.RETINA_PREFIX.exec(t2);
        return i2 ? parseFloat(i2[1]) : void 0 !== e2 ? e2 : 1;
      }
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return U;
      }), i.d(e, "b", function() {
        return k;
      });
      var n = /iPhone/i, r = /iPod/i, o = /iPad/i, s = /\biOS-universal(?:.+)Mac\b/i, a = /\bAndroid(?:.+)Mobile\b/i, l = /Android/i, h = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, u = /Silk/i, c = /Windows Phone/i, d = /\bWindows(?:.+)ARM\b/i, p = /BlackBerry/i, f = /BB10/i, m = /Opera Mini/i, g = /\b(CriOS|Chrome)(?:.+)Mobile/i, v = /Mobile(?:.+)Firefox\b/i, _ = function(t2) {
        return void 0 !== t2 && "MacIntel" === t2.platform && "number" == typeof t2.maxTouchPoints && t2.maxTouchPoints > 1 && "undefined" == typeof MSStream;
      };
      var y, x, b, T, E, S, w, A, M, C, R, I, P, O, N, L, D, F, B, U = function(t2) {
        var e2 = { userAgent: "", platform: "", maxTouchPoints: 0 };
        t2 || "undefined" == typeof navigator ? "string" == typeof t2 ? e2.userAgent = t2 : t2 && t2.userAgent && (e2 = { userAgent: t2.userAgent, platform: t2.platform, maxTouchPoints: t2.maxTouchPoints || 0 }) : e2 = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 };
        var i2 = e2.userAgent, y2 = i2.split("[FBAN");
        void 0 !== y2[1] && (i2 = y2[0]), void 0 !== (y2 = i2.split("Twitter"))[1] && (i2 = y2[0]);
        var x2 = /* @__PURE__ */ function(t3) {
          return function(e3) {
            return e3.test(t3);
          };
        }(i2), b2 = { apple: { phone: x2(n) && !x2(c), ipod: x2(r), tablet: !x2(n) && (x2(o) || _(e2)) && !x2(c), universal: x2(s), device: (x2(n) || x2(r) || x2(o) || x2(s) || _(e2)) && !x2(c) }, amazon: { phone: x2(h), tablet: !x2(h) && x2(u), device: x2(h) || x2(u) }, android: { phone: !x2(c) && x2(h) || !x2(c) && x2(a), tablet: !x2(c) && !x2(h) && !x2(a) && (x2(u) || x2(l)), device: !x2(c) && (x2(h) || x2(u) || x2(a) || x2(l)) || x2(/\bokhttp\b/i) }, windows: { phone: x2(c), tablet: x2(d), device: x2(c) || x2(d) }, other: { blackberry: x2(p), blackberry10: x2(f), opera: x2(m), firefox: x2(v), chrome: x2(g), device: x2(p) || x2(f) || x2(m) || x2(v) || x2(g) }, any: false, phone: false, tablet: false };
        return b2.any = b2.apple.device || b2.android.device || b2.windows.device || b2.other.device, b2.phone = b2.apple.phone || b2.android.phone || b2.windows.phone, b2.tablet = b2.apple.tablet || b2.android.tablet || b2.windows.tablet, b2;
      }(globalThis.navigator);
      !function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(y || (y = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(x || (x = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(b || (b = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(T || (T = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(E || (E = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(S || (S = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(w || (w = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(A || (A = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(M || (M = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(C || (C = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(R || (R = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(I || (I = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(P || (P = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(O || (O = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(N || (N = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(L || (L = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(D || (D = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(F || (F = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(B || (B = {}));
      var k = { MIPMAP_TEXTURES: I.POW2, ANISOTROPIC_LEVEL: 0, RESOLUTION: 1, FILTER_RESOLUTION: 1, FILTER_MULTISAMPLE: F.NONE, SPRITE_MAX_TEXTURES: function(t2) {
        var e2 = true;
        if (U.tablet || U.phone) {
          var i2;
          if (U.apple.device) {
            if (i2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) parseInt(i2[1], 10) < 11 && (e2 = false);
          }
          if (U.android.device) {
            if (i2 = navigator.userAgent.match(/Android\s([0-9.]*)/)) parseInt(i2[1], 10) < 7 && (e2 = false);
          }
        }
        return e2 ? t2 : 4;
      }(32), SPRITE_BATCH_SIZE: 4096, RENDER_OPTIONS: { view: null, antialias: false, autoDensity: false, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: true, clearBeforeRender: true, preserveDrawingBuffer: false, width: 800, height: 600, legacy: false }, GC_MODE: N.AUTO, GC_MAX_IDLE: 3600, GC_MAX_CHECK_COUNT: 600, WRAP_MODE: R.CLAMP, SCALE_MODE: C.LINEAR, PRECISION_VERTEX: L.HIGH, PRECISION_FRAGMENT: U.apple.device ? L.HIGH : L.MEDIUM, CAN_UPLOAD_SAME_BUFFER: !U.apple.device, CREATE_IMAGE_BITMAP: false, ROUND_PIXELS: false };
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return s;
      }), i.d(e, "b", function() {
        return P;
      }), i.d(e, "c", function() {
        return C;
      }), i.d(e, "d", function() {
        return R;
      });
      var n = i(4), r = i(1), o = i(3);
      n.b.SORTABLE_CHILDREN = false;
      var s = function() {
        function t2() {
          this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
        }
        return t2.prototype.isEmpty = function() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }, t2.prototype.clear = function() {
          this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
        }, t2.prototype.getRectangle = function(t3) {
          return this.minX > this.maxX || this.minY > this.maxY ? r.j.EMPTY : ((t3 = t3 || new r.j(0, 0, 1, 1)).x = this.minX, t3.y = this.minY, t3.width = this.maxX - this.minX, t3.height = this.maxY - this.minY, t3);
        }, t2.prototype.addPoint = function(t3) {
          this.minX = Math.min(this.minX, t3.x), this.maxX = Math.max(this.maxX, t3.x), this.minY = Math.min(this.minY, t3.y), this.maxY = Math.max(this.maxY, t3.y);
        }, t2.prototype.addPointMatrix = function(t3, e2) {
          var i2 = t3.a, n2 = t3.b, r2 = t3.c, o2 = t3.d, s2 = t3.tx, a2 = t3.ty, l2 = i2 * e2.x + r2 * e2.y + s2, h2 = n2 * e2.x + o2 * e2.y + a2;
          this.minX = Math.min(this.minX, l2), this.maxX = Math.max(this.maxX, l2), this.minY = Math.min(this.minY, h2), this.maxY = Math.max(this.maxY, h2);
        }, t2.prototype.addQuad = function(t3) {
          var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY, o2 = t3[0], s2 = t3[1];
          e2 = o2 < e2 ? o2 : e2, i2 = s2 < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[2]) < e2 ? o2 : e2, i2 = (s2 = t3[3]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[4]) < e2 ? o2 : e2, i2 = (s2 = t3[5]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[6]) < e2 ? o2 : e2, i2 = (s2 = t3[7]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, this.minX = e2, this.minY = i2, this.maxX = n2, this.maxY = r2;
        }, t2.prototype.addFrame = function(t3, e2, i2, n2, r2) {
          this.addFrameMatrix(t3.worldTransform, e2, i2, n2, r2);
        }, t2.prototype.addFrameMatrix = function(t3, e2, i2, n2, r2) {
          var o2 = t3.a, s2 = t3.b, a2 = t3.c, l2 = t3.d, h2 = t3.tx, u2 = t3.ty, c2 = this.minX, d2 = this.minY, p2 = this.maxX, f2 = this.maxY, m2 = o2 * e2 + a2 * i2 + h2, g2 = s2 * e2 + l2 * i2 + u2;
          c2 = m2 < c2 ? m2 : c2, d2 = g2 < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * i2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * i2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * e2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * e2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, this.minX = c2, this.minY = d2, this.maxX = p2, this.maxY = f2;
        }, t2.prototype.addVertexData = function(t3, e2, i2) {
          for (var n2 = this.minX, r2 = this.minY, o2 = this.maxX, s2 = this.maxY, a2 = e2; a2 < i2; a2 += 2) {
            var l2 = t3[a2], h2 = t3[a2 + 1];
            n2 = l2 < n2 ? l2 : n2, r2 = h2 < r2 ? h2 : r2, o2 = l2 > o2 ? l2 : o2, s2 = h2 > s2 ? h2 : s2;
          }
          this.minX = n2, this.minY = r2, this.maxX = o2, this.maxY = s2;
        }, t2.prototype.addVertices = function(t3, e2, i2, n2) {
          this.addVerticesMatrix(t3.worldTransform, e2, i2, n2);
        }, t2.prototype.addVerticesMatrix = function(t3, e2, i2, n2, r2, o2) {
          void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = r2);
          for (var s2 = t3.a, a2 = t3.b, l2 = t3.c, h2 = t3.d, u2 = t3.tx, c2 = t3.ty, d2 = this.minX, p2 = this.minY, f2 = this.maxX, m2 = this.maxY, g2 = i2; g2 < n2; g2 += 2) {
            var v2 = e2[g2], _2 = e2[g2 + 1], y2 = s2 * v2 + l2 * _2 + u2, x2 = h2 * _2 + a2 * v2 + c2;
            d2 = Math.min(d2, y2 - r2), f2 = Math.max(f2, y2 + r2), p2 = Math.min(p2, x2 - o2), m2 = Math.max(m2, x2 + o2);
          }
          this.minX = d2, this.minY = p2, this.maxX = f2, this.maxY = m2;
        }, t2.prototype.addBounds = function(t3) {
          var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY;
          this.minX = t3.minX < e2 ? t3.minX : e2, this.minY = t3.minY < i2 ? t3.minY : i2, this.maxX = t3.maxX > n2 ? t3.maxX : n2, this.maxY = t3.maxY > r2 ? t3.maxY : r2;
        }, t2.prototype.addBoundsMask = function(t3, e2) {
          var i2 = t3.minX > e2.minX ? t3.minX : e2.minX, n2 = t3.minY > e2.minY ? t3.minY : e2.minY, r2 = t3.maxX < e2.maxX ? t3.maxX : e2.maxX, o2 = t3.maxY < e2.maxY ? t3.maxY : e2.maxY;
          if (i2 <= r2 && n2 <= o2) {
            var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
            this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
          }
        }, t2.prototype.addBoundsMatrix = function(t3, e2) {
          this.addFrameMatrix(e2, t3.minX, t3.minY, t3.maxX, t3.maxY);
        }, t2.prototype.addBoundsArea = function(t3, e2) {
          var i2 = t3.minX > e2.x ? t3.minX : e2.x, n2 = t3.minY > e2.y ? t3.minY : e2.y, r2 = t3.maxX < e2.x + e2.width ? t3.maxX : e2.x + e2.width, o2 = t3.maxY < e2.y + e2.height ? t3.maxY : e2.y + e2.height;
          if (i2 <= r2 && n2 <= o2) {
            var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
            this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
          }
        }, t2.prototype.pad = function(t3, e2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = t3), this.isEmpty() || (this.minX -= t3, this.maxX += t3, this.minY -= e2, this.maxY += e2);
        }, t2.prototype.addFramePad = function(t3, e2, i2, n2, r2, o2) {
          t3 -= r2, e2 -= o2, i2 += r2, n2 += o2, this.minX = this.minX < t3 ? this.minX : t3, this.maxX = this.maxX > i2 ? this.maxX : i2, this.minY = this.minY < e2 ? this.minY : e2, this.maxY = this.maxY > n2 ? this.maxY : n2;
        }, t2;
      }(), a = function(t2, e2) {
        return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function l(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        a(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var h, u, c, d, p, f, m, g, v, _, y, x, b, T, E, S, w, A, M, C = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.tempDisplayObjectParent = null, e3.transform = new r.m(), e3.alpha = 1, e3.visible = true, e3.renderable = true, e3.cullable = false, e3.cullArea = null, e3.parent = null, e3.worldAlpha = 1, e3._lastSortedIndex = 0, e3._zIndex = 0, e3.filterArea = null, e3.filters = null, e3._enabledFilters = null, e3._bounds = new s(), e3._localBounds = null, e3._boundsID = 0, e3._boundsRect = null, e3._localBoundsRect = null, e3._mask = null, e3._maskRefCount = 0, e3._destroyed = false, e3.isSprite = false, e3.isMask = false, e3;
        }
        return l(e2, t2), e2.mixin = function(t3) {
          for (var i2 = Object.keys(t3), n2 = 0; n2 < i2.length; ++n2) {
            var r2 = i2[n2];
            Object.defineProperty(e2.prototype, r2, Object.getOwnPropertyDescriptor(t3, r2));
          }
        }, Object.defineProperty(e2.prototype, "destroyed", { get: function() {
          return this._destroyed;
        }, enumerable: false, configurable: true }), e2.prototype._recursivePostUpdateTransform = function() {
          this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }, e2.prototype.updateTransform = function() {
          this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
        }, e2.prototype.getBounds = function(t3, e3) {
          return t3 || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e3 || (this._boundsRect || (this._boundsRect = new r.j()), e3 = this._boundsRect), this._bounds.getRectangle(e3);
        }, e2.prototype.getLocalBounds = function(t3) {
          t3 || (this._localBoundsRect || (this._localBoundsRect = new r.j()), t3 = this._localBoundsRect), this._localBounds || (this._localBounds = new s());
          var e3 = this.transform, i2 = this.parent;
          this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
          var n2 = this._bounds, o2 = this._boundsID;
          this._bounds = this._localBounds;
          var a2 = this.getBounds(false, t3);
          return this.parent = i2, this.transform = e3, this._bounds = n2, this._bounds.updateID += this._boundsID - o2, a2;
        }, e2.prototype.toGlobal = function(t3, e3, i2) {
          return void 0 === i2 && (i2 = false), i2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t3, e3);
        }, e2.prototype.toLocal = function(t3, e3, i2, n2) {
          return e3 && (t3 = e3.toGlobal(t3, i2, n2)), n2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t3, i2);
        }, e2.prototype.setParent = function(t3) {
          if (!t3 || !t3.addChild) throw new Error("setParent: Argument must be a Container");
          return t3.addChild(this), t3;
        }, e2.prototype.setTransform = function(t3, e3, i2, n2, r2, o2, s2, a2, l2) {
          return void 0 === t3 && (t3 = 0), void 0 === e3 && (e3 = 0), void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), void 0 === s2 && (s2 = 0), void 0 === a2 && (a2 = 0), void 0 === l2 && (l2 = 0), this.position.x = t3, this.position.y = e3, this.scale.x = i2 || 1, this.scale.y = n2 || 1, this.rotation = r2, this.skew.x = o2, this.skew.y = s2, this.pivot.x = a2, this.pivot.y = l2, this;
        }, e2.prototype.destroy = function(t3) {
          this.parent && this.parent.removeChild(this), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = false, this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
        }, Object.defineProperty(e2.prototype, "_tempDisplayObjectParent", { get: function() {
          return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new R()), this.tempDisplayObjectParent;
        }, enumerable: false, configurable: true }), e2.prototype.enableTempParent = function() {
          var t3 = this.parent;
          return this.parent = this._tempDisplayObjectParent, t3;
        }, e2.prototype.disableTempParent = function(t3) {
          this.parent = t3;
        }, Object.defineProperty(e2.prototype, "x", { get: function() {
          return this.position.x;
        }, set: function(t3) {
          this.transform.position.x = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "y", { get: function() {
          return this.position.y;
        }, set: function(t3) {
          this.transform.position.y = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldTransform", { get: function() {
          return this.transform.worldTransform;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "localTransform", { get: function() {
          return this.transform.localTransform;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "position", { get: function() {
          return this.transform.position;
        }, set: function(t3) {
          this.transform.position.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scale", { get: function() {
          return this.transform.scale;
        }, set: function(t3) {
          this.transform.scale.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "pivot", { get: function() {
          return this.transform.pivot;
        }, set: function(t3) {
          this.transform.pivot.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "skew", { get: function() {
          return this.transform.skew;
        }, set: function(t3) {
          this.transform.skew.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotation", { get: function() {
          return this.transform.rotation;
        }, set: function(t3) {
          this.transform.rotation = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "angle", { get: function() {
          return this.transform.rotation * r.i;
        }, set: function(t3) {
          this.transform.rotation = t3 * r.b;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "zIndex", { get: function() {
          return this._zIndex;
        }, set: function(t3) {
          this._zIndex = t3, this.parent && (this.parent.sortDirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldVisible", { get: function() {
          var t3 = this;
          do {
            if (!t3.visible) return false;
            t3 = t3.parent;
          } while (t3);
          return true;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mask", { get: function() {
          return this._mask;
        }, set: function(t3) {
          if (this._mask !== t3) {
            var e3;
            if (this._mask) (e3 = this._mask.maskObject || this._mask)._maskRefCount--, 0 === e3._maskRefCount && (e3.renderable = true, e3.isMask = false);
            if (this._mask = t3, this._mask) 0 === (e3 = this._mask.maskObject || this._mask)._maskRefCount && (e3.renderable = false, e3.isMask = true), e3._maskRefCount++;
          }
        }, enumerable: false, configurable: true }), e2;
      }(o.EventEmitter), R = function(t2) {
        function e2() {
          var e3 = null !== t2 && t2.apply(this, arguments) || this;
          return e3.sortDirty = null, e3;
        }
        return l(e2, t2), e2;
      }(C);
      function I(t2, e2) {
        return t2.zIndex === e2.zIndex ? t2._lastSortedIndex - e2._lastSortedIndex : t2.zIndex - e2.zIndex;
      }
      C.prototype.displayObjectUpdateTransform = C.prototype.updateTransform, function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(h || (h = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(u || (u = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(c || (c = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(d || (d = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(p || (p = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(f || (f = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(m || (m = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(g || (g = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(v || (v = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(_ || (_ = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(y || (y = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(x || (x = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(b || (b = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(T || (T = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(E || (E = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(S || (S = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(w || (w = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(A || (A = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(M || (M = {}));
      var P = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.children = [], e3.sortableChildren = n.b.SORTABLE_CHILDREN, e3.sortDirty = false, e3;
        }
        return l(e2, t2), e2.prototype.onChildrenChange = function(t3) {
        }, e2.prototype.addChild = function() {
          for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++) e3[i2] = t3[i2];
          if (e3.length > 1) for (var n2 = 0; n2 < e3.length; n2++) this.addChild(e3[n2]);
          else {
            var r2 = e3[0];
            r2.parent && r2.parent.removeChild(r2), r2.parent = this, this.sortDirty = true, r2.transform._parentID = -1, this.children.push(r2), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", r2, this, this.children.length - 1), r2.emit("added", this);
          }
          return e3[0];
        }, e2.prototype.addChildAt = function(t3, e3) {
          if (e3 < 0 || e3 > this.children.length) throw new Error(t3 + "addChildAt: The index " + e3 + " supplied is out of bounds " + this.children.length);
          return t3.parent && t3.parent.removeChild(t3), t3.parent = this, this.sortDirty = true, t3.transform._parentID = -1, this.children.splice(e3, 0, t3), this._boundsID++, this.onChildrenChange(e3), t3.emit("added", this), this.emit("childAdded", t3, this, e3), t3;
        }, e2.prototype.swapChildren = function(t3, e3) {
          if (t3 !== e3) {
            var i2 = this.getChildIndex(t3), n2 = this.getChildIndex(e3);
            this.children[i2] = e3, this.children[n2] = t3, this.onChildrenChange(i2 < n2 ? i2 : n2);
          }
        }, e2.prototype.getChildIndex = function(t3) {
          var e3 = this.children.indexOf(t3);
          if (-1 === e3) throw new Error("The supplied DisplayObject must be a child of the caller");
          return e3;
        }, e2.prototype.setChildIndex = function(t3, e3) {
          if (e3 < 0 || e3 >= this.children.length) throw new Error("The index " + e3 + " supplied is out of bounds " + this.children.length);
          var i2 = this.getChildIndex(t3);
          Object(o.removeItems)(this.children, i2, 1), this.children.splice(e3, 0, t3), this.onChildrenChange(e3);
        }, e2.prototype.getChildAt = function(t3) {
          if (t3 < 0 || t3 >= this.children.length) throw new Error("getChildAt: Index (" + t3 + ") does not exist.");
          return this.children[t3];
        }, e2.prototype.removeChild = function() {
          for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++) e3[i2] = t3[i2];
          if (e3.length > 1) for (var n2 = 0; n2 < e3.length; n2++) this.removeChild(e3[n2]);
          else {
            var r2 = e3[0], s2 = this.children.indexOf(r2);
            if (-1 === s2) return null;
            r2.parent = null, r2.transform._parentID = -1, Object(o.removeItems)(this.children, s2, 1), this._boundsID++, this.onChildrenChange(s2), r2.emit("removed", this), this.emit("childRemoved", r2, this, s2);
          }
          return e3[0];
        }, e2.prototype.removeChildAt = function(t3) {
          var e3 = this.getChildAt(t3);
          return e3.parent = null, e3.transform._parentID = -1, Object(o.removeItems)(this.children, t3, 1), this._boundsID++, this.onChildrenChange(t3), e3.emit("removed", this), this.emit("childRemoved", e3, this, t3), e3;
        }, e2.prototype.removeChildren = function(t3, e3) {
          void 0 === t3 && (t3 = 0), void 0 === e3 && (e3 = this.children.length);
          var i2, n2 = t3, r2 = e3 - n2;
          if (r2 > 0 && r2 <= e3) {
            i2 = this.children.splice(n2, r2);
            for (var o2 = 0; o2 < i2.length; ++o2) i2[o2].parent = null, i2[o2].transform && (i2[o2].transform._parentID = -1);
            this._boundsID++, this.onChildrenChange(t3);
            for (o2 = 0; o2 < i2.length; ++o2) i2[o2].emit("removed", this), this.emit("childRemoved", i2[o2], this, o2);
            return i2;
          }
          if (0 === r2 && 0 === this.children.length) return [];
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        }, e2.prototype.sortChildren = function() {
          for (var t3 = false, e3 = 0, i2 = this.children.length; e3 < i2; ++e3) {
            var n2 = this.children[e3];
            n2._lastSortedIndex = e3, t3 || 0 === n2.zIndex || (t3 = true);
          }
          t3 && this.children.length > 1 && this.children.sort(I), this.sortDirty = false;
        }, e2.prototype.updateTransform = function() {
          this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
          for (var t3 = 0, e3 = this.children.length; t3 < e3; ++t3) {
            var i2 = this.children[t3];
            i2.visible && i2.updateTransform();
          }
        }, e2.prototype.calculateBounds = function() {
          this._bounds.clear(), this._calculateBounds();
          for (var t3 = 0; t3 < this.children.length; t3++) {
            var e3 = this.children[t3];
            if (e3.visible && e3.renderable) if (e3.calculateBounds(), e3._mask) {
              var i2 = e3._mask.maskObject || e3._mask;
              i2.calculateBounds(), this._bounds.addBoundsMask(e3._bounds, i2._bounds);
            } else e3.filterArea ? this._bounds.addBoundsArea(e3._bounds, e3.filterArea) : this._bounds.addBounds(e3._bounds);
          }
          this._bounds.updateID = this._boundsID;
        }, e2.prototype.getLocalBounds = function(e3, i2) {
          void 0 === i2 && (i2 = false);
          var n2 = t2.prototype.getLocalBounds.call(this, e3);
          if (!i2) for (var r2 = 0, o2 = this.children.length; r2 < o2; ++r2) {
            var s2 = this.children[r2];
            s2.visible && s2.updateTransform();
          }
          return n2;
        }, e2.prototype._calculateBounds = function() {
        }, e2.prototype._renderWithCulling = function(t3) {
          var i2 = t3.renderTexture.sourceFrame;
          if (i2.width > 0 && i2.height > 0) {
            var n2, r2;
            if (this.cullArea ? (n2 = this.cullArea, r2 = this.worldTransform) : this._render !== e2.prototype._render && (n2 = this.getBounds(true)), n2 && i2.intersects(n2, r2)) this._render(t3);
            else if (this.cullArea) return;
            for (var o2 = 0, s2 = this.children.length; o2 < s2; ++o2) {
              var a2 = this.children[o2], l2 = a2.cullable;
              a2.cullable = l2 || !this.cullArea, a2.render(t3), a2.cullable = l2;
            }
          }
        }, e2.prototype.render = function(t3) {
          if (this.visible && !(this.worldAlpha <= 0) && this.renderable) if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t3);
          else if (this.cullable) this._renderWithCulling(t3);
          else {
            this._render(t3);
            for (var e3 = 0, i2 = this.children.length; e3 < i2; ++e3) this.children[e3].render(t3);
          }
        }, e2.prototype.renderAdvanced = function(t3) {
          var e3 = this.filters, i2 = this._mask;
          if (e3) {
            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
            for (var n2 = 0; n2 < e3.length; n2++) e3[n2].enabled && this._enabledFilters.push(e3[n2]);
          }
          var r2 = e3 && this._enabledFilters && this._enabledFilters.length || i2 && (!i2.isMaskData || i2.enabled && (i2.autoDetect || i2.type !== w.NONE));
          if (r2 && t3.batch.flush(), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.push(this, this._enabledFilters), i2 && t3.mask.push(this, this._mask), this.cullable) this._renderWithCulling(t3);
          else {
            this._render(t3);
            n2 = 0;
            for (var o2 = this.children.length; n2 < o2; ++n2) this.children[n2].render(t3);
          }
          r2 && t3.batch.flush(), i2 && t3.mask.pop(this), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.pop();
        }, e2.prototype._render = function(t3) {
        }, e2.prototype.destroy = function(e3) {
          t2.prototype.destroy.call(this), this.sortDirty = false;
          var i2 = "boolean" == typeof e3 ? e3 : e3 && e3.children, n2 = this.removeChildren(0, this.children.length);
          if (i2) for (var r2 = 0; r2 < n2.length; ++r2) n2[r2].destroy(e3);
        }, Object.defineProperty(e2.prototype, "width", { get: function() {
          return this.scale.x * this.getLocalBounds().width;
        }, set: function(t3) {
          var e3 = this.getLocalBounds().width;
          this.scale.x = 0 !== e3 ? t3 / e3 : 1, this._width = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this.scale.y * this.getLocalBounds().height;
        }, set: function(t3) {
          var e3 = this.getLocalBounds().height;
          this.scale.y = 0 !== e3 ? t3 / e3 : 1, this._height = t3;
        }, enumerable: false, configurable: true }), e2;
      }(C);
      P.prototype.containerUpdateTransform = P.prototype.updateTransform;
    }, function(t, e, i) {
      "use strict";
      var n = Object.prototype.hasOwnProperty, r = "~";
      function o() {
      }
      function s(t2, e2, i2) {
        this.fn = t2, this.context = e2, this.once = i2 || false;
      }
      function a(t2, e2, i2, n2, o2) {
        if ("function" != typeof i2) throw new TypeError("The listener must be a function");
        var a2 = new s(i2, n2 || t2, o2), l2 = r ? r + e2 : e2;
        return t2._events[l2] ? t2._events[l2].fn ? t2._events[l2] = [t2._events[l2], a2] : t2._events[l2].push(a2) : (t2._events[l2] = a2, t2._eventsCount++), t2;
      }
      function l(t2, e2) {
        0 == --t2._eventsCount ? t2._events = new o() : delete t2._events[e2];
      }
      function h() {
        this._events = new o(), this._eventsCount = 0;
      }
      Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (r = false)), h.prototype.eventNames = function() {
        var t2, e2, i2 = [];
        if (0 === this._eventsCount) return i2;
        for (e2 in t2 = this._events) n.call(t2, e2) && i2.push(r ? e2.slice(1) : e2);
        return Object.getOwnPropertySymbols ? i2.concat(Object.getOwnPropertySymbols(t2)) : i2;
      }, h.prototype.listeners = function(t2) {
        var e2 = r ? r + t2 : t2, i2 = this._events[e2];
        if (!i2) return [];
        if (i2.fn) return [i2.fn];
        for (var n2 = 0, o2 = i2.length, s2 = new Array(o2); n2 < o2; n2++) s2[n2] = i2[n2].fn;
        return s2;
      }, h.prototype.listenerCount = function(t2) {
        var e2 = r ? r + t2 : t2, i2 = this._events[e2];
        return i2 ? i2.fn ? 1 : i2.length : 0;
      }, h.prototype.emit = function(t2, e2, i2, n2, o2, s2) {
        var a2 = r ? r + t2 : t2;
        if (!this._events[a2]) return false;
        var l2, h2, u = this._events[a2], c = arguments.length;
        if (u.fn) {
          switch (u.once && this.removeListener(t2, u.fn, void 0, true), c) {
            case 1:
              return u.fn.call(u.context), true;
            case 2:
              return u.fn.call(u.context, e2), true;
            case 3:
              return u.fn.call(u.context, e2, i2), true;
            case 4:
              return u.fn.call(u.context, e2, i2, n2), true;
            case 5:
              return u.fn.call(u.context, e2, i2, n2, o2), true;
            case 6:
              return u.fn.call(u.context, e2, i2, n2, o2, s2), true;
          }
          for (h2 = 1, l2 = new Array(c - 1); h2 < c; h2++) l2[h2 - 1] = arguments[h2];
          u.fn.apply(u.context, l2);
        } else {
          var d, p = u.length;
          for (h2 = 0; h2 < p; h2++) switch (u[h2].once && this.removeListener(t2, u[h2].fn, void 0, true), c) {
            case 1:
              u[h2].fn.call(u[h2].context);
              break;
            case 2:
              u[h2].fn.call(u[h2].context, e2);
              break;
            case 3:
              u[h2].fn.call(u[h2].context, e2, i2);
              break;
            case 4:
              u[h2].fn.call(u[h2].context, e2, i2, n2);
              break;
            default:
              if (!l2) for (d = 1, l2 = new Array(c - 1); d < c; d++) l2[d - 1] = arguments[d];
              u[h2].fn.apply(u[h2].context, l2);
          }
        }
        return true;
      }, h.prototype.on = function(t2, e2, i2) {
        return a(this, t2, e2, i2, false);
      }, h.prototype.once = function(t2, e2, i2) {
        return a(this, t2, e2, i2, true);
      }, h.prototype.removeListener = function(t2, e2, i2, n2) {
        var o2 = r ? r + t2 : t2;
        if (!this._events[o2]) return this;
        if (!e2) return l(this, o2), this;
        var s2 = this._events[o2];
        if (s2.fn) s2.fn !== e2 || n2 && !s2.once || i2 && s2.context !== i2 || l(this, o2);
        else {
          for (var a2 = 0, h2 = [], u = s2.length; a2 < u; a2++) (s2[a2].fn !== e2 || n2 && !s2[a2].once || i2 && s2[a2].context !== i2) && h2.push(s2[a2]);
          h2.length ? this._events[o2] = 1 === h2.length ? h2[0] : h2 : l(this, o2);
        }
        return this;
      }, h.prototype.removeAllListeners = function(t2) {
        var e2;
        return t2 ? (e2 = r ? r + t2 : t2, this._events[e2] && l(this, e2)) : (this._events = new o(), this._eventsCount = 0), this;
      }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = r, h.EventEmitter = h, t.exports = h;
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return s;
      }), i.d(e, "b", function() {
        return a;
      }), i.d(e, "c", function() {
        return n;
      });
      var n, r = i(4);
      r.b.TARGET_FPMS = 0.06, function(t2) {
        t2[t2.INTERACTION = 50] = "INTERACTION", t2[t2.HIGH = 25] = "HIGH", t2[t2.NORMAL = 0] = "NORMAL", t2[t2.LOW = -25] = "LOW", t2[t2.UTILITY = -50] = "UTILITY";
      }(n || (n = {}));
      var o = function() {
        function t2(t3, e2, i2, n2) {
          void 0 === e2 && (e2 = null), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = false), this.next = null, this.previous = null, this._destroyed = false, this.fn = t3, this.context = e2, this.priority = i2, this.once = n2;
        }
        return t2.prototype.match = function(t3, e2) {
          return void 0 === e2 && (e2 = null), this.fn === t3 && this.context === e2;
        }, t2.prototype.emit = function(t3) {
          this.fn && (this.context ? this.fn.call(this.context, t3) : this.fn(t3));
          var e2 = this.next;
          return this.once && this.destroy(true), this._destroyed && (this.next = null), e2;
        }, t2.prototype.connect = function(t3) {
          this.previous = t3, t3.next && (t3.next.previous = this), this.next = t3.next, t3.next = this;
        }, t2.prototype.destroy = function(t3) {
          void 0 === t3 && (t3 = false), this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
          var e2 = this.next;
          return this.next = t3 ? null : e2, this.previous = null, e2;
        }, t2;
      }(), s = function() {
        function t2() {
          var t3 = this;
          this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new o(null, null, 1 / 0), this.deltaMS = 1 / r.b.TARGET_FPMS, this.elapsedMS = 1 / r.b.TARGET_FPMS, this._tick = function(e2) {
            t3._requestId = null, t3.started && (t3.update(e2), t3.started && null === t3._requestId && t3._head.next && (t3._requestId = requestAnimationFrame(t3._tick)));
          };
        }
        return t2.prototype._requestIfNeeded = function() {
          null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
        }, t2.prototype._cancelIfNeeded = function() {
          null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null);
        }, t2.prototype._startIfPossible = function() {
          this.started ? this._requestIfNeeded() : this.autoStart && this.start();
        }, t2.prototype.add = function(t3, e2, i2) {
          return void 0 === i2 && (i2 = n.NORMAL), this._addListener(new o(t3, e2, i2));
        }, t2.prototype.addOnce = function(t3, e2, i2) {
          return void 0 === i2 && (i2 = n.NORMAL), this._addListener(new o(t3, e2, i2, true));
        }, t2.prototype._addListener = function(t3) {
          var e2 = this._head.next, i2 = this._head;
          if (e2) {
            for (; e2; ) {
              if (t3.priority > e2.priority) {
                t3.connect(i2);
                break;
              }
              i2 = e2, e2 = e2.next;
            }
            t3.previous || t3.connect(i2);
          } else t3.connect(i2);
          return this._startIfPossible(), this;
        }, t2.prototype.remove = function(t3, e2) {
          for (var i2 = this._head.next; i2; ) i2 = i2.match(t3, e2) ? i2.destroy() : i2.next;
          return this._head.next || this._cancelIfNeeded(), this;
        }, Object.defineProperty(t2.prototype, "count", { get: function() {
          if (!this._head) return 0;
          for (var t3 = 0, e2 = this._head; e2 = e2.next; ) t3++;
          return t3;
        }, enumerable: false, configurable: true }), t2.prototype.start = function() {
          this.started || (this.started = true, this._requestIfNeeded());
        }, t2.prototype.stop = function() {
          this.started && (this.started = false, this._cancelIfNeeded());
        }, t2.prototype.destroy = function() {
          if (!this._protected) {
            this.stop();
            for (var t3 = this._head.next; t3; ) t3 = t3.destroy(true);
            this._head.destroy(), this._head = null;
          }
        }, t2.prototype.update = function(t3) {
          var e2;
          if (void 0 === t3 && (t3 = performance.now()), t3 > this.lastTime) {
            if ((e2 = this.elapsedMS = t3 - this.lastTime) > this._maxElapsedMS && (e2 = this._maxElapsedMS), e2 *= this.speed, this._minElapsedMS) {
              var i2 = t3 - this._lastFrame | 0;
              if (i2 < this._minElapsedMS) return;
              this._lastFrame = t3 - i2 % this._minElapsedMS;
            }
            this.deltaMS = e2, this.deltaTime = this.deltaMS * r.b.TARGET_FPMS;
            for (var n2 = this._head, o2 = n2.next; o2; ) o2 = o2.emit(this.deltaTime);
            n2.next || this._cancelIfNeeded();
          } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
          this.lastTime = t3;
        }, Object.defineProperty(t2.prototype, "FPS", { get: function() {
          return 1e3 / this.elapsedMS;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "minFPS", { get: function() {
          return 1e3 / this._maxElapsedMS;
        }, set: function(t3) {
          var e2 = Math.min(this.maxFPS, t3), i2 = Math.min(Math.max(0, e2) / 1e3, r.b.TARGET_FPMS);
          this._maxElapsedMS = 1 / i2;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "maxFPS", { get: function() {
          return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
        }, set: function(t3) {
          if (0 === t3) this._minElapsedMS = 0;
          else {
            var e2 = Math.max(this.minFPS, t3);
            this._minElapsedMS = 1 / (e2 / 1e3);
          }
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "shared", { get: function() {
          if (!t2._shared) {
            var e2 = t2._shared = new t2();
            e2.autoStart = true, e2._protected = true;
          }
          return t2._shared;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "system", { get: function() {
          if (!t2._system) {
            var e2 = t2._system = new t2();
            e2.autoStart = true, e2._protected = true;
          }
          return t2._system;
        }, enumerable: false, configurable: true }), t2;
      }(), a = function() {
        function t2() {
        }
        return t2.init = function(t3) {
          var e2 = this;
          t3 = Object.assign({ autoStart: true, sharedTicker: false }, t3), Object.defineProperty(this, "ticker", { set: function(t4) {
            this._ticker && this._ticker.remove(this.render, this), this._ticker = t4, t4 && t4.add(this.render, this, n.LOW);
          }, get: function() {
            return this._ticker;
          } }), this.stop = function() {
            e2._ticker.stop();
          }, this.start = function() {
            e2._ticker.start();
          }, this._ticker = null, this.ticker = t3.sharedTicker ? s.shared : new s(), t3.autoStart && this.start();
        }, t2.destroy = function() {
          if (this._ticker) {
            var t3 = this._ticker;
            this.ticker = null, t3.destroy();
          }
        }, t2;
      }();
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return f;
      }), i.d(e, "b", function() {
        return g;
      }), i.d(e, "c", function() {
        return m;
      });
      var n = i(2), r = i(1), o = i(0), s = i(5), a = i(4), l = i(3), h = function(t2, e2) {
        return (h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function u(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        h(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var c = function() {
        function t2(t3, e2) {
          this.uvBuffer = t3, this.uvMatrix = e2, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
        }
        return t2.prototype.update = function(t3) {
          if (t3 || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
            this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
            var e2 = this.uvBuffer.data;
            this.data && this.data.length === e2.length || (this.data = new Float32Array(e2.length)), this.uvMatrix.multiplyUvs(e2, this.data), this._updateID++;
          }
        }, t2;
      }(), d = new r.g(), p = new r.h(), f = function(t2) {
        function e2(e3, i2, r2, s2) {
          void 0 === s2 && (s2 = o.f.TRIANGLES);
          var l2 = t2.call(this) || this;
          return l2.geometry = e3, l2.shader = i2, l2.state = r2 || n.s.for2d(), l2.drawMode = s2, l2.start = 0, l2.size = 0, l2.uvs = null, l2.indices = null, l2.vertexData = new Float32Array(1), l2.vertexDirty = -1, l2._transformID = -1, l2._roundPixels = a.b.ROUND_PIXELS, l2.batchUvs = null, l2;
        }
        return u(e2, t2), Object.defineProperty(e2.prototype, "geometry", { get: function() {
          return this._geometry;
        }, set: function(t3) {
          this._geometry !== t3 && (this._geometry && (this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose()), this._geometry = t3, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "uvBuffer", { get: function() {
          return this.geometry.buffers[1];
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "verticesBuffer", { get: function() {
          return this.geometry.buffers[0];
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "material", { get: function() {
          return this.shader;
        }, set: function(t3) {
          this.shader = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blendMode", { get: function() {
          return this.state.blendMode;
        }, set: function(t3) {
          this.state.blendMode = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "roundPixels", { get: function() {
          return this._roundPixels;
        }, set: function(t3) {
          this._roundPixels !== t3 && (this._transformID = -1), this._roundPixels = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
          return "tint" in this.shader ? this.shader.tint : null;
        }, set: function(t3) {
          this.shader.tint = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "texture", { get: function() {
          return "texture" in this.shader ? this.shader.texture : null;
        }, set: function(t3) {
          this.shader.texture = t3;
        }, enumerable: false, configurable: true }), e2.prototype._render = function(t3) {
          var i2 = this.geometry.buffers[0].data;
          this.shader.batchable && this.drawMode === o.f.TRIANGLES && i2.length < 2 * e2.BATCHABLE_SIZE ? this._renderToBatch(t3) : this._renderDefault(t3);
        }, e2.prototype._renderDefault = function(t3) {
          var e3 = this.shader;
          e3.alpha = this.worldAlpha, e3.update && e3.update(), t3.batch.flush(), e3.uniforms.translationMatrix = this.transform.worldTransform.toArray(true), t3.shader.bind(e3), t3.state.set(this.state), t3.geometry.bind(this.geometry, e3), t3.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
        }, e2.prototype._renderToBatch = function(t3) {
          var e3 = this.geometry, i2 = this.shader;
          i2.uvMatrix && (i2.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e3.indexBuffer.data, this._tintRGB = i2._tintRGB, this._texture = i2.texture;
          var n2 = this.material.pluginName;
          t3.batch.setObjectRenderer(t3.plugins[n2]), t3.plugins[n2].render(this);
        }, e2.prototype.calculateVertices = function() {
          var t3 = this.geometry.buffers[0], e3 = t3.data, i2 = t3._updateID;
          if (i2 !== this.vertexDirty || this._transformID !== this.transform._worldID) {
            this._transformID = this.transform._worldID, this.vertexData.length !== e3.length && (this.vertexData = new Float32Array(e3.length));
            for (var n2 = this.transform.worldTransform, r2 = n2.a, o2 = n2.b, s2 = n2.c, l2 = n2.d, h2 = n2.tx, u2 = n2.ty, c2 = this.vertexData, d2 = 0; d2 < c2.length / 2; d2++) {
              var p2 = e3[2 * d2], f2 = e3[2 * d2 + 1];
              c2[2 * d2] = r2 * p2 + s2 * f2 + h2, c2[2 * d2 + 1] = o2 * p2 + l2 * f2 + u2;
            }
            if (this._roundPixels) {
              var m2 = a.b.RESOLUTION;
              for (d2 = 0; d2 < c2.length; ++d2) c2[d2] = Math.round((c2[d2] * m2 | 0) / m2);
            }
            this.vertexDirty = i2;
          }
        }, e2.prototype.calculateUvs = function() {
          var t3 = this.geometry.buffers[1], e3 = this.shader;
          e3.uvMatrix.isSimple ? this.uvs = t3.data : (this.batchUvs || (this.batchUvs = new c(t3, e3.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
        }, e2.prototype._calculateBounds = function() {
          this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
        }, e2.prototype.containsPoint = function(t3) {
          if (!this.getBounds().contains(t3.x, t3.y)) return false;
          this.worldTransform.applyInverse(t3, d);
          for (var e3 = this.geometry.getBuffer("aVertexPosition").data, i2 = p.points, n2 = this.geometry.getIndex().data, r2 = n2.length, o2 = 4 === this.drawMode ? 3 : 1, s2 = 0; s2 + 2 < r2; s2 += o2) {
            var a2 = 2 * n2[s2], l2 = 2 * n2[s2 + 1], h2 = 2 * n2[s2 + 2];
            if (i2[0] = e3[a2], i2[1] = e3[a2 + 1], i2[2] = e3[l2], i2[3] = e3[l2 + 1], i2[4] = e3[h2], i2[5] = e3[h2 + 1], p.contains(d.x, d.y)) return true;
          }
          return false;
        }, e2.prototype.destroy = function(e3) {
          t2.prototype.destroy.call(this, e3), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
        }, e2.BATCHABLE_SIZE = 100, e2;
      }(s.b), m = function(t2) {
        function e2(e3, i2) {
          var o2 = this, s2 = { uSampler: e3, alpha: 1, uTextureMatrix: r.d.IDENTITY, uColor: new Float32Array([1, 1, 1, 1]) };
          return (i2 = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, i2)).uniforms && Object.assign(s2, i2.uniforms), (o2 = t2.call(this, i2.program || n.n.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), s2) || this)._colorDirty = false, o2.uvMatrix = new n.u(e3), o2.batchable = void 0 === i2.program, o2.pluginName = i2.pluginName, o2.tint = i2.tint, o2.alpha = i2.alpha, o2;
        }
        return u(e2, t2), Object.defineProperty(e2.prototype, "texture", { get: function() {
          return this.uniforms.uSampler;
        }, set: function(t3) {
          this.uniforms.uSampler !== t3 && (!this.uniforms.uSampler.baseTexture.alphaMode != !t3.baseTexture.alphaMode && (this._colorDirty = true), this.uniforms.uSampler = t3, this.uvMatrix.texture = t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "alpha", { get: function() {
          return this._alpha;
        }, set: function(t3) {
          t3 !== this._alpha && (this._alpha = t3, this._colorDirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
          return this._tint;
        }, set: function(t3) {
          t3 !== this._tint && (this._tint = t3, this._tintRGB = (t3 >> 16) + (65280 & t3) + ((255 & t3) << 16), this._colorDirty = true);
        }, enumerable: false, configurable: true }), e2.prototype.update = function() {
          if (this._colorDirty) {
            this._colorDirty = false;
            var t3 = this.texture.baseTexture;
            Object(l.premultiplyTintToRgba)(this._tint, this._alpha, this.uniforms.uColor, t3.alphaMode);
          }
          this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
        }, e2;
      }(n.r), g = function(t2) {
        function e2(e3, i2, r2) {
          var s2 = t2.call(this) || this, a2 = new n.h(e3), l2 = new n.h(i2, true), h2 = new n.h(r2, true, true);
          return s2.addAttribute("aVertexPosition", a2, 2, false, o.r.FLOAT).addAttribute("aTextureCoord", l2, 2, false, o.r.FLOAT).addIndex(h2), s2._updateId = -1, s2;
        }
        return u(e2, t2), Object.defineProperty(e2.prototype, "vertexDirtyId", { get: function() {
          return this.buffers[0]._updateID;
        }, enumerable: false, configurable: true }), e2;
      }(n.l);
    }, function(t, e) {
      t.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	filterCoord = aVertexPosition * outputFrame.zw;\n}\n";
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return p;
      }), i.d(e, "b", function() {
        return f;
      });
      var n = i(2), r = i(3), o = i(1), s = i(0), a = i(4), l = function(t2, e2) {
        return (l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var h = function() {
        function t2(t3) {
          this._foundShapes = [], this.renderer = t3;
        }
        return t2.prototype.pushMask = function(t3) {
          var e2 = this.renderer, i2 = t3.maskObject || t3;
          e2.context.save();
          var n2 = this._foundShapes;
          if (this.recursiveFindShapes(i2, n2), n2.length > 0) {
            var r2 = e2.context;
            r2.beginPath();
            for (var o2 = 0; o2 < n2.length; o2++) {
              var s2 = n2[o2], a2 = s2.transform.worldTransform;
              this.renderer.setContextTransform(a2), this.renderGraphicsShape(s2);
            }
            n2.length = 0, r2.clip();
          }
        }, t2.prototype.recursiveFindShapes = function(t3, e2) {
          t3.geometry && t3.geometry.graphicsData && e2.push(t3);
          var i2 = t3.children;
          if (i2) for (var n2 = 0; n2 < i2.length; n2++) this.recursiveFindShapes(i2[n2], e2);
        }, t2.prototype.renderGraphicsShape = function(t3) {
          t3.finishPoly();
          var e2 = this.renderer.context, i2 = t3.geometry.graphicsData, n2 = i2.length;
          if (0 !== n2) for (var r2 = 0; r2 < n2; r2++) {
            var s2 = i2[r2], a2 = s2.shape;
            if (a2.type === o.l.POLY) {
              var l2 = a2.points, h2 = s2.holes, u2 = void 0, c2 = void 0, d2 = void 0, p2 = void 0;
              e2.moveTo(l2[0], l2[1]);
              for (var f2 = 1; f2 < l2.length / 2; f2++) e2.lineTo(l2[2 * f2], l2[2 * f2 + 1]);
              if (h2.length > 0) {
                u2 = 0, d2 = l2[0], p2 = l2[1];
                for (f2 = 2; f2 + 2 < l2.length; f2 += 2) u2 += (l2[f2] - d2) * (l2[f2 + 3] - p2) - (l2[f2 + 2] - d2) * (l2[f2 + 1] - p2);
                for (var m2 = 0; m2 < h2.length; m2++) if (l2 = h2[m2].shape.points) {
                  c2 = 0, d2 = l2[0], p2 = l2[1];
                  for (f2 = 2; f2 + 2 < l2.length; f2 += 2) c2 += (l2[f2] - d2) * (l2[f2 + 3] - p2) - (l2[f2 + 2] - d2) * (l2[f2 + 1] - p2);
                  if (c2 * u2 < 0) {
                    e2.moveTo(l2[0], l2[1]);
                    for (f2 = 2; f2 < l2.length; f2 += 2) e2.lineTo(l2[f2], l2[f2 + 1]);
                  } else {
                    e2.moveTo(l2[l2.length - 2], l2[l2.length - 1]);
                    for (f2 = l2.length - 4; f2 >= 0; f2 -= 2) e2.lineTo(l2[f2], l2[f2 + 1]);
                  }
                  h2[m2].shape.closeStroke && e2.closePath();
                }
              }
              l2[0] === l2[l2.length - 2] && l2[1] === l2[l2.length - 1] && e2.closePath();
            } else if (a2.type === o.l.RECT) e2.rect(a2.x, a2.y, a2.width, a2.height), e2.closePath();
            else if (a2.type === o.l.CIRC) e2.arc(a2.x, a2.y, a2.radius, 0, 2 * Math.PI), e2.closePath();
            else if (a2.type === o.l.ELIP) {
              var g = 2 * a2.width, v = 2 * a2.height, _ = a2.x - g / 2, y = a2.y - v / 2, x = g / 2 * 0.5522848, b = v / 2 * 0.5522848, T = _ + g, E = y + v, S = _ + g / 2, w = y + v / 2;
              e2.moveTo(_, w), e2.bezierCurveTo(_, w - b, S - x, y, S, y), e2.bezierCurveTo(S + x, y, T, w - b, T, w), e2.bezierCurveTo(T, w + b, S + x, E, S, E), e2.bezierCurveTo(S - x, E, _, w + b, _, w), e2.closePath();
            } else if (a2.type === o.l.RREC) {
              var A = a2.x, M = a2.y, C = a2.width, R = a2.height, I = a2.radius, P = Math.min(C, R) / 2;
              I = I > P ? P : I, e2.moveTo(A, M + I), e2.lineTo(A, M + R - I), e2.quadraticCurveTo(A, M + R, A + I, M + R), e2.lineTo(A + C - I, M + R), e2.quadraticCurveTo(A + C, M + R, A + C, M + R - I), e2.lineTo(A + C, M + I), e2.quadraticCurveTo(A + C, M, A + C - I, M), e2.lineTo(A + I, M), e2.quadraticCurveTo(A, M, A, M + I), e2.closePath();
            }
          }
        }, t2.prototype.popMask = function(t3) {
          t3.context.restore(), t3.invalidateBlendMode();
        }, t2.prototype.destroy = function() {
        }, t2;
      }();
      function u(t2) {
        var e2 = document.createElement("canvas");
        e2.width = 6, e2.height = 1;
        var i2 = e2.getContext("2d");
        return i2.fillStyle = t2, i2.fillRect(0, 0, 6, 1), e2;
      }
      function c() {
        if ("undefined" == typeof document) return false;
        var t2 = u("#ff00ff"), e2 = u("#ffff00"), i2 = document.createElement("canvas");
        i2.width = 6, i2.height = 1;
        var n2 = i2.getContext("2d");
        n2.globalCompositeOperation = "multiply", n2.drawImage(t2, 0, 0), n2.drawImage(e2, 2, 0);
        var r2 = n2.getImageData(2, 0, 1, 1);
        if (!r2) return false;
        var o2 = r2.data;
        return 255 === o2[0] && 0 === o2[1] && 0 === o2[2];
      }
      var d = new o.d(), p = function(t2) {
        function e2(i2) {
          var n2, o2 = t2.call(this, s.n.CANVAS, i2) || this;
          if (o2.refresh = true, o2.maskManager = new h(o2), o2.smoothProperty = "imageSmoothingEnabled", o2.blendModes = (void 0 === n2 && (n2 = []), c() ? (n2[s.b.NORMAL] = "source-over", n2[s.b.ADD] = "lighter", n2[s.b.MULTIPLY] = "multiply", n2[s.b.SCREEN] = "screen", n2[s.b.OVERLAY] = "overlay", n2[s.b.DARKEN] = "darken", n2[s.b.LIGHTEN] = "lighten", n2[s.b.COLOR_DODGE] = "color-dodge", n2[s.b.COLOR_BURN] = "color-burn", n2[s.b.HARD_LIGHT] = "hard-light", n2[s.b.SOFT_LIGHT] = "soft-light", n2[s.b.DIFFERENCE] = "difference", n2[s.b.EXCLUSION] = "exclusion", n2[s.b.HUE] = "hue", n2[s.b.SATURATION] = "saturate", n2[s.b.COLOR] = "color", n2[s.b.LUMINOSITY] = "luminosity") : (n2[s.b.NORMAL] = "source-over", n2[s.b.ADD] = "lighter", n2[s.b.MULTIPLY] = "source-over", n2[s.b.SCREEN] = "source-over", n2[s.b.OVERLAY] = "source-over", n2[s.b.DARKEN] = "source-over", n2[s.b.LIGHTEN] = "source-over", n2[s.b.COLOR_DODGE] = "source-over", n2[s.b.COLOR_BURN] = "source-over", n2[s.b.HARD_LIGHT] = "source-over", n2[s.b.SOFT_LIGHT] = "source-over", n2[s.b.DIFFERENCE] = "source-over", n2[s.b.EXCLUSION] = "source-over", n2[s.b.HUE] = "source-over", n2[s.b.SATURATION] = "source-over", n2[s.b.COLOR] = "source-over", n2[s.b.LUMINOSITY] = "source-over"), n2[s.b.NORMAL_NPM] = n2[s.b.NORMAL], n2[s.b.ADD_NPM] = n2[s.b.ADD], n2[s.b.SCREEN_NPM] = n2[s.b.SCREEN], n2[s.b.SRC_IN] = "source-in", n2[s.b.SRC_OUT] = "source-out", n2[s.b.SRC_ATOP] = "source-atop", n2[s.b.DST_OVER] = "destination-over", n2[s.b.DST_IN] = "destination-in", n2[s.b.DST_OUT] = "destination-out", n2[s.b.DST_ATOP] = "destination-atop", n2[s.b.XOR] = "xor", n2[s.b.SUBTRACT] = "source-over", n2), o2.renderingToScreen = false, o2._activeBlendMode = null, o2._projTransform = null, o2._outerBlend = false, o2.rootContext = o2.view.getContext("2d", { alpha: o2.useContextAlpha }), o2.context = o2.rootContext, !o2.rootContext.imageSmoothingEnabled) {
            var a2 = o2.rootContext;
            a2.webkitImageSmoothingEnabled ? o2.smoothProperty = "webkitImageSmoothingEnabled" : a2.mozImageSmoothingEnabled ? o2.smoothProperty = "mozImageSmoothingEnabled" : a2.oImageSmoothingEnabled ? o2.smoothProperty = "oImageSmoothingEnabled" : a2.msImageSmoothingEnabled && (o2.smoothProperty = "msImageSmoothingEnabled");
          }
          return o2.initPlugins(e2.__plugins), Object(r.sayHello)("Canvas"), o2.resize(o2.options.width, o2.options.height), o2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          l(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype.addSystem = function() {
          return this;
        }, e2.prototype.render = function(t3, e3) {
          if (this.view) {
            var i2, o2, a2, l2;
            e3 && (e3 instanceof n.p || e3 instanceof n.b ? (Object(r.deprecation)("6.0.0", "CanvasRenderer#render arguments changed, use options instead."), i2 = e3, o2 = arguments[2], a2 = arguments[3], l2 = arguments[4]) : (i2 = e3.renderTexture, o2 = e3.clear, a2 = e3.transform, l2 = e3.skipUpdateTransform)), this.renderingToScreen = !i2, this.emit("prerender");
            var h2 = this.resolution;
            i2 ? ((i2 = i2.castToBaseTexture())._canvasRenderTarget || (i2._canvasRenderTarget = new r.CanvasRenderTarget(i2.width, i2.height, i2.resolution), i2.resource = new n.j(i2._canvasRenderTarget.canvas), i2.valid = true), this.context = i2._canvasRenderTarget.context, this.resolution = i2._canvasRenderTarget.resolution) : this.context = this.rootContext;
            var u2 = this.context;
            if (this._projTransform = a2 || null, i2 || (this._lastObjectRendered = t3), !l2) {
              var c2 = t3.enableTempParent();
              t3.updateTransform(), t3.disableTempParent(c2);
            }
            if (u2.save(), u2.setTransform(1, 0, 0, 1, 0, 0), u2.globalAlpha = 1, this._activeBlendMode = s.b.NORMAL, this._outerBlend = false, u2.globalCompositeOperation = this.blendModes[s.b.NORMAL], void 0 !== o2 ? o2 : this.clearBeforeRender) if (this.renderingToScreen) u2.clearRect(0, 0, this.width, this.height), this.backgroundAlpha > 0 && (u2.globalAlpha = this.useContextAlpha ? this.backgroundAlpha : 1, u2.fillStyle = this._backgroundColorString, u2.fillRect(0, 0, this.width, this.height), u2.globalAlpha = 1);
            else {
              (i2 = i2)._canvasRenderTarget.clear();
              var d2 = i2.clearColor;
              d2[3] > 0 && (u2.globalAlpha = this.useContextAlpha ? d2[3] : 1, u2.fillStyle = Object(r.hex2string)(Object(r.rgb2hex)(d2)), u2.fillRect(0, 0, i2.realWidth, i2.realHeight), u2.globalAlpha = 1);
            }
            var p2 = this.context;
            this.context = u2, t3.renderCanvas(this), this.context = p2, u2.restore(), this.resolution = h2, this._projTransform = null, this.emit("postrender");
          }
        }, e2.prototype.setContextTransform = function(t3, e3, i2) {
          var n2 = t3, r2 = this._projTransform, o2 = this.resolution;
          i2 = i2 || o2, r2 && ((n2 = d).copyFrom(t3), n2.prepend(r2)), e3 ? this.context.setTransform(n2.a * i2, n2.b * i2, n2.c * i2, n2.d * i2, n2.tx * o2 | 0, n2.ty * o2 | 0) : this.context.setTransform(n2.a * i2, n2.b * i2, n2.c * i2, n2.d * i2, n2.tx * o2, n2.ty * o2);
        }, e2.prototype.clear = function(t3, e3) {
          void 0 === t3 && (t3 = this._backgroundColorString), void 0 === e3 && (e3 = this.backgroundAlpha);
          var i2 = this.context;
          i2.clearRect(0, 0, this.width, this.height), t3 && (i2.globalAlpha = this.useContextAlpha ? e3 : 1, i2.fillStyle = t3, i2.fillRect(0, 0, this.width, this.height), i2.globalAlpha = 1);
        }, e2.prototype.setBlendMode = function(t3, e3) {
          var i2 = t3 === s.b.SRC_IN || t3 === s.b.SRC_OUT || t3 === s.b.DST_IN || t3 === s.b.DST_ATOP;
          !e3 && i2 && (t3 = s.b.NORMAL), this._activeBlendMode !== t3 && (this._activeBlendMode = t3, this._outerBlend = i2, this.context.globalCompositeOperation = this.blendModes[t3]);
        }, e2.prototype.destroy = function(e3) {
          t2.prototype.destroy.call(this, e3), this.context = null, this.refresh = true, this.maskManager.destroy(), this.maskManager = null, this.smoothProperty = null;
        }, e2.prototype.resize = function(e3, i2) {
          t2.prototype.resize.call(this, e3, i2), this.smoothProperty && (this.rootContext[this.smoothProperty] = a.b.SCALE_MODE === s.p.LINEAR);
        }, e2.prototype.invalidateBlendMode = function() {
          this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
        }, e2.registerPlugin = function(t3, i2) {
          e2.__plugins = e2.__plugins || {}, e2.__plugins[t3] = i2;
        }, e2;
      }(n.a), f = { canvas: null, getTintedCanvas: function(t2, e2) {
        var i2 = t2.texture, n2 = "#" + ("00000" + (0 | (e2 = f.roundColor(e2))).toString(16)).slice(-6);
        i2.tintCache = i2.tintCache || {};
        var r2, o2 = i2.tintCache[n2];
        if (o2) {
          if (o2.tintId === i2._updateID) return i2.tintCache[n2];
          r2 = i2.tintCache[n2];
        } else r2 = document.createElement("canvas");
        if (f.tintMethod(i2, e2, r2), r2.tintId = i2._updateID, f.convertTintToImage) {
          var s2 = new Image();
          s2.src = r2.toDataURL(), i2.tintCache[n2] = s2;
        } else i2.tintCache[n2] = r2;
        return r2;
      }, getTintedPattern: function(t2, e2) {
        var i2 = "#" + ("00000" + (0 | (e2 = f.roundColor(e2))).toString(16)).slice(-6);
        t2.patternCache = t2.patternCache || {};
        var n2 = t2.patternCache[i2];
        return n2 && n2.tintId === t2._updateID || (f.canvas || (f.canvas = document.createElement("canvas")), f.tintMethod(t2, e2, f.canvas), (n2 = f.canvas.getContext("2d").createPattern(f.canvas, "repeat")).tintId = t2._updateID, t2.patternCache[i2] = n2), n2;
      }, tintWithMultiply: function(t2, e2, i2) {
        var n2 = i2.getContext("2d"), r2 = t2._frame.clone(), o2 = t2.baseTexture.resolution;
        r2.x *= o2, r2.y *= o2, r2.width *= o2, r2.height *= o2, i2.width = Math.ceil(r2.width), i2.height = Math.ceil(r2.height), n2.save(), n2.fillStyle = "#" + ("00000" + (0 | e2).toString(16)).slice(-6), n2.fillRect(0, 0, r2.width, r2.height), n2.globalCompositeOperation = "multiply";
        var s2 = t2.baseTexture.getDrawableSource();
        n2.drawImage(s2, r2.x, r2.y, r2.width, r2.height, 0, 0, r2.width, r2.height), n2.globalCompositeOperation = "destination-atop", n2.drawImage(s2, r2.x, r2.y, r2.width, r2.height, 0, 0, r2.width, r2.height), n2.restore();
      }, tintWithOverlay: function(t2, e2, i2) {
        var n2 = i2.getContext("2d"), r2 = t2._frame.clone(), o2 = t2.baseTexture.resolution;
        r2.x *= o2, r2.y *= o2, r2.width *= o2, r2.height *= o2, i2.width = Math.ceil(r2.width), i2.height = Math.ceil(r2.height), n2.save(), n2.globalCompositeOperation = "copy", n2.fillStyle = "#" + ("00000" + (0 | e2).toString(16)).slice(-6), n2.fillRect(0, 0, r2.width, r2.height), n2.globalCompositeOperation = "destination-atop", n2.drawImage(t2.baseTexture.getDrawableSource(), r2.x, r2.y, r2.width, r2.height, 0, 0, r2.width, r2.height), n2.restore();
      }, tintWithPerPixel: function(t2, e2, i2) {
        var n2 = i2.getContext("2d"), o2 = t2._frame.clone(), s2 = t2.baseTexture.resolution;
        o2.x *= s2, o2.y *= s2, o2.width *= s2, o2.height *= s2, i2.width = Math.ceil(o2.width), i2.height = Math.ceil(o2.height), n2.save(), n2.globalCompositeOperation = "copy", n2.drawImage(t2.baseTexture.getDrawableSource(), o2.x, o2.y, o2.width, o2.height, 0, 0, o2.width, o2.height), n2.restore();
        for (var a2 = Object(r.hex2rgb)(e2), l2 = a2[0], h2 = a2[1], u2 = a2[2], c2 = n2.getImageData(0, 0, o2.width, o2.height), d2 = c2.data, p2 = 0; p2 < d2.length; p2 += 4) d2[p2 + 0] *= l2, d2[p2 + 1] *= h2, d2[p2 + 2] *= u2;
        n2.putImageData(c2, 0, 0);
      }, roundColor: function(t2) {
        var e2 = f.cacheStepsPerColorChannel, i2 = Object(r.hex2rgb)(t2);
        return i2[0] = Math.min(255, i2[0] / e2 * e2), i2[1] = Math.min(255, i2[1] / e2 * e2), i2[2] = Math.min(255, i2[2] / e2 * e2), Object(r.rgb2hex)(i2);
      }, cacheStepsPerColorChannel: 8, convertTintToImage: false, canUseMultiply: c(), tintMethod: null };
      f.tintMethod = f.canUseMultiply ? f.tintWithMultiply : f.tintWithPerPixel;
      var m = n.q.create;
      n.q.create = function(t2) {
        if (!(t2 && t2.forceCanvas)) try {
          return m(t2);
        } catch (t3) {
        }
        return new p(t2);
      }, n.c.prototype.getDrawableSource = function() {
        var t2 = this.resource;
        return t2 ? t2.bitmap || t2.source : null;
      }, n.b.prototype._canvasRenderTarget = null, n.t.prototype.patternCache = null, n.t.prototype.tintCache = null;
    }, function(t, e) {
      t.exports = function(t2) {
        return void 0 === t2;
      };
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return n;
      });
      var n = function() {
        function t2(t3) {
          this.items = [], this._name = t3, this._aliasCount = 0;
        }
        return t2.prototype.emit = function(t3, e2, i2, n2, r, o, s, a) {
          if (arguments.length > 8) throw new Error("max arguments reached");
          var l = this, h = l.name, u = l.items;
          this._aliasCount++;
          for (var c = 0, d = u.length; c < d; c++) u[c][h](t3, e2, i2, n2, r, o, s, a);
          return u === this.items && this._aliasCount--, this;
        }, t2.prototype.ensureNonAliasedItems = function() {
          this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
        }, t2.prototype.add = function(t3) {
          return t3[this._name] && (this.ensureNonAliasedItems(), this.remove(t3), this.items.push(t3)), this;
        }, t2.prototype.remove = function(t3) {
          var e2 = this.items.indexOf(t3);
          return -1 !== e2 && (this.ensureNonAliasedItems(), this.items.splice(e2, 1)), this;
        }, t2.prototype.contains = function(t3) {
          return -1 !== this.items.indexOf(t3);
        }, t2.prototype.removeAll = function() {
          return this.ensureNonAliasedItems(), this.items.length = 0, this;
        }, t2.prototype.destroy = function() {
          this.removeAll(), this.items = null, this._name = null;
        }, Object.defineProperty(t2.prototype, "empty", { get: function() {
          return 0 === this.items.length;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "name", { get: function() {
          return this._name;
        }, enumerable: false, configurable: true }), t2;
      }();
      Object.defineProperties(n.prototype, { dispatch: { value: n.prototype.emit }, run: { value: n.prototype.emit } });
    }, function(t, e, i) {
      var n = i(20), r = i(15);
      t.exports = function(t2) {
        return "number" == typeof t2 || r(t2) && "[object Number]" == n(t2);
      };
    }, function(t, e, i) {
      var n = i(51), r = "object" == typeof self && self && self.Object === Object && self, o = n || r || Function("return this")();
      t.exports = o;
    }, function(t, e) {
      t.exports = function(t2) {
        return null != t2 && "object" == typeof t2;
      };
    }, function(t, e, i) {
      "use strict";
      i.d(e, "a", function() {
        return p;
      }), i.d(e, "b", function() {
        return d;
      }), i.d(e, "c", function() {
        return u;
      });
      var n = i(8), r = i(0), o = i(2), s = function(t2, e2) {
        return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function a(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        s(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var l = function(t2) {
        function e2(e3, i2, n2, r2) {
          void 0 === e3 && (e3 = 100), void 0 === i2 && (i2 = 100), void 0 === n2 && (n2 = 10), void 0 === r2 && (r2 = 10);
          var o2 = t2.call(this) || this;
          return o2.segWidth = n2, o2.segHeight = r2, o2.width = e3, o2.height = i2, o2.build(), o2;
        }
        return a(e2, t2), e2.prototype.build = function() {
          for (var t3 = this.segWidth * this.segHeight, e3 = [], i2 = [], n2 = [], r2 = this.segWidth - 1, o2 = this.segHeight - 1, s2 = this.width / r2, a2 = this.height / o2, l2 = 0; l2 < t3; l2++) {
            var h2 = l2 % this.segWidth, u2 = l2 / this.segWidth | 0;
            e3.push(h2 * s2, u2 * a2), i2.push(h2 / r2, u2 / o2);
          }
          var c2 = r2 * o2;
          for (l2 = 0; l2 < c2; l2++) {
            var d2 = l2 % r2, p2 = l2 / r2 | 0, f = p2 * this.segWidth + d2, m = p2 * this.segWidth + d2 + 1, g = (p2 + 1) * this.segWidth + d2, v = (p2 + 1) * this.segWidth + d2 + 1;
            n2.push(f, m, g, m, v, g);
          }
          this.buffers[0].data = new Float32Array(e3), this.buffers[1].data = new Float32Array(i2), this.indexBuffer.data = new Uint16Array(n2), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
        }, e2;
      }(n.b), h = function(t2) {
        function e2(e3, i2, n2) {
          void 0 === e3 && (e3 = 200), void 0 === n2 && (n2 = 0);
          var r2 = t2.call(this, new Float32Array(4 * i2.length), new Float32Array(4 * i2.length), new Uint16Array(6 * (i2.length - 1))) || this;
          return r2.points = i2, r2._width = e3, r2.textureScale = n2, r2.build(), r2;
        }
        return a(e2, t2), Object.defineProperty(e2.prototype, "width", { get: function() {
          return this._width;
        }, enumerable: false, configurable: true }), e2.prototype.build = function() {
          var t3 = this.points;
          if (t3) {
            var e3 = this.getBuffer("aVertexPosition"), i2 = this.getBuffer("aTextureCoord"), n2 = this.getIndex();
            if (!(t3.length < 1)) {
              e3.data.length / 4 !== t3.length && (e3.data = new Float32Array(4 * t3.length), i2.data = new Float32Array(4 * t3.length), n2.data = new Uint16Array(6 * (t3.length - 1)));
              var r2 = i2.data, o2 = n2.data;
              r2[0] = 0, r2[1] = 0, r2[2] = 0, r2[3] = 1;
              for (var s2 = 0, a2 = t3[0], l2 = this._width * this.textureScale, h2 = t3.length, u2 = 0; u2 < h2; u2++) {
                var c2 = 4 * u2;
                if (this.textureScale > 0) {
                  var d2 = a2.x - t3[u2].x, p2 = a2.y - t3[u2].y, f = Math.sqrt(d2 * d2 + p2 * p2);
                  a2 = t3[u2], s2 += f / l2;
                } else s2 = u2 / (h2 - 1);
                r2[c2] = s2, r2[c2 + 1] = 0, r2[c2 + 2] = s2, r2[c2 + 3] = 1;
              }
              var m = 0;
              for (u2 = 0; u2 < h2 - 1; u2++) {
                c2 = 2 * u2;
                o2[m++] = c2, o2[m++] = c2 + 1, o2[m++] = c2 + 2, o2[m++] = c2 + 2, o2[m++] = c2 + 1, o2[m++] = c2 + 3;
              }
              i2.update(), n2.update(), this.updateVertices();
            }
          }
        }, e2.prototype.updateVertices = function() {
          var t3 = this.points;
          if (!(t3.length < 1)) {
            for (var e3, i2 = t3[0], n2 = 0, r2 = 0, o2 = this.buffers[0].data, s2 = t3.length, a2 = 0; a2 < s2; a2++) {
              var l2 = t3[a2], h2 = 4 * a2;
              r2 = -((e3 = a2 < t3.length - 1 ? t3[a2 + 1] : l2).x - i2.x), n2 = e3.y - i2.y;
              var u2 = Math.sqrt(n2 * n2 + r2 * r2), c2 = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
              n2 /= u2, r2 /= u2, n2 *= c2, r2 *= c2, o2[h2] = l2.x + n2, o2[h2 + 1] = l2.y + r2, o2[h2 + 2] = l2.x - n2, o2[h2 + 3] = l2.y - r2, i2 = l2;
            }
            this.buffers[0].update();
          }
        }, e2.prototype.update = function() {
          this.textureScale > 0 ? this.build() : this.updateVertices();
        }, e2;
      }(n.b), u = function(t2) {
        function e2(e3, i2, o2) {
          void 0 === o2 && (o2 = 0);
          var s2 = this, a2 = new h(e3.height, i2, o2), l2 = new n.c(e3);
          return o2 > 0 && (e3.baseTexture.wrapMode = r.s.REPEAT), (s2 = t2.call(this, a2, l2) || this).autoUpdate = true, s2;
        }
        return a(e2, t2), e2.prototype._render = function(e3) {
          var i2 = this.geometry;
          (this.autoUpdate || i2._width !== this.shader.texture.height) && (i2._width = this.shader.texture.height, i2.update()), t2.prototype._render.call(this, e3);
        }, e2;
      }(n.a), c = function(t2) {
        function e2(e3, i2, r2) {
          var s2 = this, a2 = new l(e3.width, e3.height, i2, r2), h2 = new n.c(o.t.WHITE);
          return (s2 = t2.call(this, a2, h2) || this).texture = e3, s2.autoResize = true, s2;
        }
        return a(e2, t2), e2.prototype.textureUpdated = function() {
          this._textureID = this.shader.texture._updateID;
          var t3 = this.geometry, e3 = this.shader.texture, i2 = e3.width, n2 = e3.height;
          !this.autoResize || t3.width === i2 && t3.height === n2 || (t3.width = this.shader.texture.width, t3.height = this.shader.texture.height, t3.build());
        }, Object.defineProperty(e2.prototype, "texture", { get: function() {
          return this.shader.texture;
        }, set: function(t3) {
          this.shader.texture !== t3 && (this.shader.texture = t3, this._textureID = -1, t3.baseTexture.valid ? this.textureUpdated() : t3.once("update", this.textureUpdated, this));
        }, enumerable: false, configurable: true }), e2.prototype._render = function(e3) {
          this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t2.prototype._render.call(this, e3);
        }, e2.prototype.destroy = function(e3) {
          this.shader.texture.off("update", this.textureUpdated, this), t2.prototype.destroy.call(this, e3);
        }, e2;
      }(n.a), d = function(t2) {
        function e2(e3, i2, r2, s2, a2) {
          void 0 === e3 && (e3 = o.t.EMPTY);
          var l2 = this, h2 = new n.b(i2, r2, s2);
          h2.getBuffer("aVertexPosition").static = false;
          var u2 = new n.c(e3);
          return (l2 = t2.call(this, h2, u2, null, a2) || this).autoUpdate = true, l2;
        }
        return a(e2, t2), Object.defineProperty(e2.prototype, "vertices", { get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        }, set: function(t3) {
          this.geometry.getBuffer("aVertexPosition").data = t3;
        }, enumerable: false, configurable: true }), e2.prototype._render = function(e3) {
          this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t2.prototype._render.call(this, e3);
        }, e2;
      }(n.a), p = function(t2) {
        function e2(e3, i2, n2, r2, s2) {
          void 0 === i2 && (i2 = 10), void 0 === n2 && (n2 = 10), void 0 === r2 && (r2 = 10), void 0 === s2 && (s2 = 10);
          var a2 = t2.call(this, o.t.WHITE, 4, 4) || this;
          return a2._origWidth = e3.orig.width, a2._origHeight = e3.orig.height, a2._width = a2._origWidth, a2._height = a2._origHeight, a2._leftWidth = i2, a2._rightWidth = r2, a2._topHeight = n2, a2._bottomHeight = s2, a2.texture = e3, a2;
        }
        return a(e2, t2), e2.prototype.textureUpdated = function() {
          this._textureID = this.shader.texture._updateID, this._refresh();
        }, Object.defineProperty(e2.prototype, "vertices", { get: function() {
          return this.geometry.getBuffer("aVertexPosition").data;
        }, set: function(t3) {
          this.geometry.getBuffer("aVertexPosition").data = t3;
        }, enumerable: false, configurable: true }), e2.prototype.updateHorizontalVertices = function() {
          var t3 = this.vertices, e3 = this._getMinScale();
          t3[9] = t3[11] = t3[13] = t3[15] = this._topHeight * e3, t3[17] = t3[19] = t3[21] = t3[23] = this._height - this._bottomHeight * e3, t3[25] = t3[27] = t3[29] = t3[31] = this._height;
        }, e2.prototype.updateVerticalVertices = function() {
          var t3 = this.vertices, e3 = this._getMinScale();
          t3[2] = t3[10] = t3[18] = t3[26] = this._leftWidth * e3, t3[4] = t3[12] = t3[20] = t3[28] = this._width - this._rightWidth * e3, t3[6] = t3[14] = t3[22] = t3[30] = this._width;
        }, e2.prototype._getMinScale = function() {
          var t3 = this._leftWidth + this._rightWidth, e3 = this._width > t3 ? 1 : this._width / t3, i2 = this._topHeight + this._bottomHeight, n2 = this._height > i2 ? 1 : this._height / i2;
          return Math.min(e3, n2);
        }, Object.defineProperty(e2.prototype, "width", { get: function() {
          return this._width;
        }, set: function(t3) {
          this._width = t3, this._refresh();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this._height;
        }, set: function(t3) {
          this._height = t3, this._refresh();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "leftWidth", { get: function() {
          return this._leftWidth;
        }, set: function(t3) {
          this._leftWidth = t3, this._refresh();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rightWidth", { get: function() {
          return this._rightWidth;
        }, set: function(t3) {
          this._rightWidth = t3, this._refresh();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "topHeight", { get: function() {
          return this._topHeight;
        }, set: function(t3) {
          this._topHeight = t3, this._refresh();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "bottomHeight", { get: function() {
          return this._bottomHeight;
        }, set: function(t3) {
          this._bottomHeight = t3, this._refresh();
        }, enumerable: false, configurable: true }), e2.prototype._refresh = function() {
          var t3 = this.texture, e3 = this.geometry.buffers[1].data;
          this._origWidth = t3.orig.width, this._origHeight = t3.orig.height;
          var i2 = 1 / this._origWidth, n2 = 1 / this._origHeight;
          e3[0] = e3[8] = e3[16] = e3[24] = 0, e3[1] = e3[3] = e3[5] = e3[7] = 0, e3[6] = e3[14] = e3[22] = e3[30] = 1, e3[25] = e3[27] = e3[29] = e3[31] = 1, e3[2] = e3[10] = e3[18] = e3[26] = i2 * this._leftWidth, e3[4] = e3[12] = e3[20] = e3[28] = 1 - i2 * this._rightWidth, e3[9] = e3[11] = e3[13] = e3[15] = n2 * this._topHeight, e3[17] = e3[19] = e3[21] = e3[23] = 1 - n2 * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
        }, e2;
      }(c);
    }, function(t, e) {
      var i;
      i = /* @__PURE__ */ function() {
        return this;
      }();
      try {
        i = i || new Function("return this")();
      } catch (t2) {
        "object" == typeof window && (i = window);
      }
      t.exports = i;
    }, function(t, e, i) {
      var n;
      !function(r) {
        "use strict";
        function o(t2, e2) {
          var i2 = (65535 & t2) + (65535 & e2);
          return (t2 >> 16) + (e2 >> 16) + (i2 >> 16) << 16 | 65535 & i2;
        }
        function s(t2, e2, i2, n2, r2, s2) {
          return o((a2 = o(o(e2, t2), o(n2, s2))) << (l2 = r2) | a2 >>> 32 - l2, i2);
          var a2, l2;
        }
        function a(t2, e2, i2, n2, r2, o2, a2) {
          return s(e2 & i2 | ~e2 & n2, t2, e2, r2, o2, a2);
        }
        function l(t2, e2, i2, n2, r2, o2, a2) {
          return s(e2 & n2 | i2 & ~n2, t2, e2, r2, o2, a2);
        }
        function h(t2, e2, i2, n2, r2, o2, a2) {
          return s(e2 ^ i2 ^ n2, t2, e2, r2, o2, a2);
        }
        function u(t2, e2, i2, n2, r2, o2, a2) {
          return s(i2 ^ (e2 | ~n2), t2, e2, r2, o2, a2);
        }
        function c(t2, e2) {
          var i2, n2, r2, s2, c2;
          t2[e2 >> 5] |= 128 << e2 % 32, t2[14 + (e2 + 64 >>> 9 << 4)] = e2;
          var d2 = 1732584193, p2 = -271733879, f2 = -1732584194, m2 = 271733878;
          for (i2 = 0; i2 < t2.length; i2 += 16) n2 = d2, r2 = p2, s2 = f2, c2 = m2, d2 = a(d2, p2, f2, m2, t2[i2], 7, -680876936), m2 = a(m2, d2, p2, f2, t2[i2 + 1], 12, -389564586), f2 = a(f2, m2, d2, p2, t2[i2 + 2], 17, 606105819), p2 = a(p2, f2, m2, d2, t2[i2 + 3], 22, -1044525330), d2 = a(d2, p2, f2, m2, t2[i2 + 4], 7, -176418897), m2 = a(m2, d2, p2, f2, t2[i2 + 5], 12, 1200080426), f2 = a(f2, m2, d2, p2, t2[i2 + 6], 17, -1473231341), p2 = a(p2, f2, m2, d2, t2[i2 + 7], 22, -45705983), d2 = a(d2, p2, f2, m2, t2[i2 + 8], 7, 1770035416), m2 = a(m2, d2, p2, f2, t2[i2 + 9], 12, -1958414417), f2 = a(f2, m2, d2, p2, t2[i2 + 10], 17, -42063), p2 = a(p2, f2, m2, d2, t2[i2 + 11], 22, -1990404162), d2 = a(d2, p2, f2, m2, t2[i2 + 12], 7, 1804603682), m2 = a(m2, d2, p2, f2, t2[i2 + 13], 12, -40341101), f2 = a(f2, m2, d2, p2, t2[i2 + 14], 17, -1502002290), d2 = l(d2, p2 = a(p2, f2, m2, d2, t2[i2 + 15], 22, 1236535329), f2, m2, t2[i2 + 1], 5, -165796510), m2 = l(m2, d2, p2, f2, t2[i2 + 6], 9, -1069501632), f2 = l(f2, m2, d2, p2, t2[i2 + 11], 14, 643717713), p2 = l(p2, f2, m2, d2, t2[i2], 20, -373897302), d2 = l(d2, p2, f2, m2, t2[i2 + 5], 5, -701558691), m2 = l(m2, d2, p2, f2, t2[i2 + 10], 9, 38016083), f2 = l(f2, m2, d2, p2, t2[i2 + 15], 14, -660478335), p2 = l(p2, f2, m2, d2, t2[i2 + 4], 20, -405537848), d2 = l(d2, p2, f2, m2, t2[i2 + 9], 5, 568446438), m2 = l(m2, d2, p2, f2, t2[i2 + 14], 9, -1019803690), f2 = l(f2, m2, d2, p2, t2[i2 + 3], 14, -187363961), p2 = l(p2, f2, m2, d2, t2[i2 + 8], 20, 1163531501), d2 = l(d2, p2, f2, m2, t2[i2 + 13], 5, -1444681467), m2 = l(m2, d2, p2, f2, t2[i2 + 2], 9, -51403784), f2 = l(f2, m2, d2, p2, t2[i2 + 7], 14, 1735328473), d2 = h(d2, p2 = l(p2, f2, m2, d2, t2[i2 + 12], 20, -1926607734), f2, m2, t2[i2 + 5], 4, -378558), m2 = h(m2, d2, p2, f2, t2[i2 + 8], 11, -2022574463), f2 = h(f2, m2, d2, p2, t2[i2 + 11], 16, 1839030562), p2 = h(p2, f2, m2, d2, t2[i2 + 14], 23, -35309556), d2 = h(d2, p2, f2, m2, t2[i2 + 1], 4, -1530992060), m2 = h(m2, d2, p2, f2, t2[i2 + 4], 11, 1272893353), f2 = h(f2, m2, d2, p2, t2[i2 + 7], 16, -155497632), p2 = h(p2, f2, m2, d2, t2[i2 + 10], 23, -1094730640), d2 = h(d2, p2, f2, m2, t2[i2 + 13], 4, 681279174), m2 = h(m2, d2, p2, f2, t2[i2], 11, -358537222), f2 = h(f2, m2, d2, p2, t2[i2 + 3], 16, -722521979), p2 = h(p2, f2, m2, d2, t2[i2 + 6], 23, 76029189), d2 = h(d2, p2, f2, m2, t2[i2 + 9], 4, -640364487), m2 = h(m2, d2, p2, f2, t2[i2 + 12], 11, -421815835), f2 = h(f2, m2, d2, p2, t2[i2 + 15], 16, 530742520), d2 = u(d2, p2 = h(p2, f2, m2, d2, t2[i2 + 2], 23, -995338651), f2, m2, t2[i2], 6, -198630844), m2 = u(m2, d2, p2, f2, t2[i2 + 7], 10, 1126891415), f2 = u(f2, m2, d2, p2, t2[i2 + 14], 15, -1416354905), p2 = u(p2, f2, m2, d2, t2[i2 + 5], 21, -57434055), d2 = u(d2, p2, f2, m2, t2[i2 + 12], 6, 1700485571), m2 = u(m2, d2, p2, f2, t2[i2 + 3], 10, -1894986606), f2 = u(f2, m2, d2, p2, t2[i2 + 10], 15, -1051523), p2 = u(p2, f2, m2, d2, t2[i2 + 1], 21, -2054922799), d2 = u(d2, p2, f2, m2, t2[i2 + 8], 6, 1873313359), m2 = u(m2, d2, p2, f2, t2[i2 + 15], 10, -30611744), f2 = u(f2, m2, d2, p2, t2[i2 + 6], 15, -1560198380), p2 = u(p2, f2, m2, d2, t2[i2 + 13], 21, 1309151649), d2 = u(d2, p2, f2, m2, t2[i2 + 4], 6, -145523070), m2 = u(m2, d2, p2, f2, t2[i2 + 11], 10, -1120210379), f2 = u(f2, m2, d2, p2, t2[i2 + 2], 15, 718787259), p2 = u(p2, f2, m2, d2, t2[i2 + 9], 21, -343485551), d2 = o(d2, n2), p2 = o(p2, r2), f2 = o(f2, s2), m2 = o(m2, c2);
          return [d2, p2, f2, m2];
        }
        function d(t2) {
          var e2, i2 = "", n2 = 32 * t2.length;
          for (e2 = 0; e2 < n2; e2 += 8) i2 += String.fromCharCode(t2[e2 >> 5] >>> e2 % 32 & 255);
          return i2;
        }
        function p(t2) {
          var e2, i2 = [];
          for (i2[(t2.length >> 2) - 1] = void 0, e2 = 0; e2 < i2.length; e2 += 1) i2[e2] = 0;
          var n2 = 8 * t2.length;
          for (e2 = 0; e2 < n2; e2 += 8) i2[e2 >> 5] |= (255 & t2.charCodeAt(e2 / 8)) << e2 % 32;
          return i2;
        }
        function f(t2) {
          var e2, i2, n2 = "";
          for (i2 = 0; i2 < t2.length; i2 += 1) e2 = t2.charCodeAt(i2), n2 += "0123456789abcdef".charAt(e2 >>> 4 & 15) + "0123456789abcdef".charAt(15 & e2);
          return n2;
        }
        function m(t2) {
          return unescape(encodeURIComponent(t2));
        }
        function g(t2) {
          return function(t3) {
            return d(c(p(t3), 8 * t3.length));
          }(m(t2));
        }
        function v(t2, e2) {
          return function(t3, e3) {
            var i2, n2, r2 = p(t3), o2 = [], s2 = [];
            for (o2[15] = s2[15] = void 0, r2.length > 16 && (r2 = c(r2, 8 * t3.length)), i2 = 0; i2 < 16; i2 += 1) o2[i2] = 909522486 ^ r2[i2], s2[i2] = 1549556828 ^ r2[i2];
            return n2 = c(o2.concat(p(e3)), 512 + 8 * e3.length), d(c(s2.concat(n2), 640));
          }(m(t2), m(e2));
        }
        function _(t2, e2, i2) {
          return e2 ? i2 ? v(e2, t2) : f(v(e2, t2)) : i2 ? g(t2) : f(g(t2));
        }
        void 0 === (n = function() {
          return _;
        }.call(e, i, e, t)) || (t.exports = n);
      }();
    }, function(t, e) {
      t.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	filterCoord = aVertexPosition * outputFrame.zw;\n}\n";
    }, function(t, e, i) {
      var n = i(24), r = i(137), o = i(138), s = n ? n.toStringTag : void 0;
      t.exports = function(t2) {
        return null == t2 ? void 0 === t2 ? "[object Undefined]" : "[object Null]" : s && s in Object(t2) ? r(t2) : o(t2);
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = typeof t2;
        return null != t2 && ("object" == e2 || "function" == e2);
      };
    }, function(t, e, i) {
      var n = i(162), r = i(165);
      t.exports = function(t2, e2) {
        var i2 = r(t2, e2);
        return n(i2) ? i2 : void 0;
      };
    }, function(t, e, i) {
      (function(e2) {
        t.exports = function t2(e3, i2, n) {
          function r(s2, a) {
            if (!i2[s2]) {
              if (!e3[s2]) {
                if (o) return o(s2, true);
                var l = new Error("Cannot find module '" + s2 + "'");
                throw l.code = "MODULE_NOT_FOUND", l;
              }
              var h = i2[s2] = { exports: {} };
              e3[s2][0].call(h.exports, function(t3) {
                var i3 = e3[s2][1][t3];
                return r(i3 || t3);
              }, h, h.exports, t2, e3, i2, n);
            }
            return i2[s2].exports;
          }
          for (var o = false, s = 0; s < n.length; s++) r(n[s]);
          return r;
        }({ 1: [function(t2, i2, n) {
          (function(t3) {
            "use strict";
            var e3, n2, r = t3.MutationObserver || t3.WebKitMutationObserver;
            if (r) {
              var o = 0, s = new r(u), a = t3.document.createTextNode("");
              s.observe(a, { characterData: true }), e3 = function() {
                a.data = o = ++o % 2;
              };
            } else if (t3.setImmediate || void 0 === t3.MessageChannel) e3 = "document" in t3 && "onreadystatechange" in t3.document.createElement("script") ? function() {
              var e4 = t3.document.createElement("script");
              e4.onreadystatechange = function() {
                u(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
              }, t3.document.documentElement.appendChild(e4);
            } : function() {
              setTimeout(u, 0);
            };
            else {
              var l = new t3.MessageChannel();
              l.port1.onmessage = u, e3 = function() {
                l.port2.postMessage(0);
              };
            }
            var h = [];
            function u() {
              var t4, e4;
              n2 = true;
              for (var i3 = h.length; i3; ) {
                for (e4 = h, h = [], t4 = -1; ++t4 < i3; ) e4[t4]();
                i3 = h.length;
              }
              n2 = false;
            }
            i2.exports = function(t4) {
              1 !== h.push(t4) || n2 || e3();
            };
          }).call(this, void 0 !== e2 ? e2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, {}], 2: [function(t2, e3, i2) {
          "use strict";
          var n = t2(1);
          function r() {
          }
          var o = {}, s = ["REJECTED"], a = ["FULFILLED"], l = ["PENDING"];
          function h(t3) {
            if ("function" != typeof t3) throw new TypeError("resolver must be a function");
            this.state = l, this.queue = [], this.outcome = void 0, t3 !== r && p(this, t3);
          }
          function u(t3, e4, i3) {
            this.promise = t3, "function" == typeof e4 && (this.onFulfilled = e4, this.callFulfilled = this.otherCallFulfilled), "function" == typeof i3 && (this.onRejected = i3, this.callRejected = this.otherCallRejected);
          }
          function c(t3, e4, i3) {
            n(function() {
              var n2;
              try {
                n2 = e4(i3);
              } catch (e5) {
                return o.reject(t3, e5);
              }
              n2 === t3 ? o.reject(t3, new TypeError("Cannot resolve promise with itself")) : o.resolve(t3, n2);
            });
          }
          function d(t3) {
            var e4 = t3 && t3.then;
            if (t3 && ("object" == typeof t3 || "function" == typeof t3) && "function" == typeof e4) return function() {
              e4.apply(t3, arguments);
            };
          }
          function p(t3, e4) {
            var i3 = false;
            function n2(e5) {
              i3 || (i3 = true, o.reject(t3, e5));
            }
            function r2(e5) {
              i3 || (i3 = true, o.resolve(t3, e5));
            }
            var s2 = f(function() {
              e4(r2, n2);
            });
            "error" === s2.status && n2(s2.value);
          }
          function f(t3, e4) {
            var i3 = {};
            try {
              i3.value = t3(e4), i3.status = "success";
            } catch (t4) {
              i3.status = "error", i3.value = t4;
            }
            return i3;
          }
          e3.exports = h, h.prototype.catch = function(t3) {
            return this.then(null, t3);
          }, h.prototype.then = function(t3, e4) {
            if ("function" != typeof t3 && this.state === a || "function" != typeof e4 && this.state === s) return this;
            var i3 = new this.constructor(r);
            return this.state !== l ? c(i3, this.state === a ? t3 : e4, this.outcome) : this.queue.push(new u(i3, t3, e4)), i3;
          }, u.prototype.callFulfilled = function(t3) {
            o.resolve(this.promise, t3);
          }, u.prototype.otherCallFulfilled = function(t3) {
            c(this.promise, this.onFulfilled, t3);
          }, u.prototype.callRejected = function(t3) {
            o.reject(this.promise, t3);
          }, u.prototype.otherCallRejected = function(t3) {
            c(this.promise, this.onRejected, t3);
          }, o.resolve = function(t3, e4) {
            var i3 = f(d, e4);
            if ("error" === i3.status) return o.reject(t3, i3.value);
            var n2 = i3.value;
            if (n2) p(t3, n2);
            else {
              t3.state = a, t3.outcome = e4;
              for (var r2 = -1, s2 = t3.queue.length; ++r2 < s2; ) t3.queue[r2].callFulfilled(e4);
            }
            return t3;
          }, o.reject = function(t3, e4) {
            t3.state = s, t3.outcome = e4;
            for (var i3 = -1, n2 = t3.queue.length; ++i3 < n2; ) t3.queue[i3].callRejected(e4);
            return t3;
          }, h.resolve = function(t3) {
            return t3 instanceof this ? t3 : o.resolve(new this(r), t3);
          }, h.reject = function(t3) {
            var e4 = new this(r);
            return o.reject(e4, t3);
          }, h.all = function(t3) {
            var e4 = this;
            if ("[object Array]" !== Object.prototype.toString.call(t3)) return this.reject(new TypeError("must be an array"));
            var i3 = t3.length, n2 = false;
            if (!i3) return this.resolve([]);
            for (var s2 = new Array(i3), a2 = 0, l2 = -1, h2 = new this(r); ++l2 < i3; ) u2(t3[l2], l2);
            return h2;
            function u2(t4, r2) {
              e4.resolve(t4).then(function(t5) {
                s2[r2] = t5, ++a2 !== i3 || n2 || (n2 = true, o.resolve(h2, s2));
              }, function(t5) {
                n2 || (n2 = true, o.reject(h2, t5));
              });
            }
          }, h.race = function(t3) {
            var e4 = this;
            if ("[object Array]" !== Object.prototype.toString.call(t3)) return this.reject(new TypeError("must be an array"));
            var i3 = t3.length, n2 = false;
            if (!i3) return this.resolve([]);
            for (var s2, a2 = -1, l2 = new this(r); ++a2 < i3; ) s2 = t3[a2], e4.resolve(s2).then(function(t4) {
              n2 || (n2 = true, o.resolve(l2, t4));
            }, function(t4) {
              n2 || (n2 = true, o.reject(l2, t4));
            });
            return l2;
          };
        }, { 1: 1 }], 3: [function(t2, i2, n) {
          (function(e3) {
            "use strict";
            "function" != typeof e3.Promise && (e3.Promise = t2(2));
          }).call(this, void 0 !== e2 ? e2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, { 2: 2 }], 4: [function(t2, e3, i2) {
          "use strict";
          var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
            return typeof t3;
          } : function(t3) {
            return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
          }, r = function() {
            try {
              if ("undefined" != typeof indexedDB) return indexedDB;
              if ("undefined" != typeof webkitIndexedDB) return webkitIndexedDB;
              if ("undefined" != typeof mozIndexedDB) return mozIndexedDB;
              if ("undefined" != typeof OIndexedDB) return OIndexedDB;
              if ("undefined" != typeof msIndexedDB) return msIndexedDB;
            } catch (t3) {
              return;
            }
          }();
          function o(t3, e4) {
            t3 = t3 || [], e4 = e4 || {};
            try {
              return new Blob(t3, e4);
            } catch (r2) {
              if ("TypeError" !== r2.name) throw r2;
              for (var i3 = new ("undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder)(), n2 = 0; n2 < t3.length; n2 += 1) i3.append(t3[n2]);
              return i3.getBlob(e4.type);
            }
          }
          "undefined" == typeof Promise && t2(3);
          var s = Promise;
          function a(t3, e4) {
            e4 && t3.then(function(t4) {
              e4(null, t4);
            }, function(t4) {
              e4(t4);
            });
          }
          function l(t3, e4, i3) {
            "function" == typeof e4 && t3.then(e4), "function" == typeof i3 && t3.catch(i3);
          }
          function h(t3) {
            return "string" != typeof t3 && (console.warn(t3 + " used as a key, but it is not a string."), t3 = String(t3)), t3;
          }
          function u() {
            if (arguments.length && "function" == typeof arguments[arguments.length - 1]) return arguments[arguments.length - 1];
          }
          var c = void 0, d = {}, p = Object.prototype.toString;
          function f(t3) {
            return "boolean" == typeof c ? s.resolve(c) : function(t4) {
              return new s(function(e4) {
                var i3 = t4.transaction("local-forage-detect-blob-support", "readwrite"), n2 = o([""]);
                i3.objectStore("local-forage-detect-blob-support").put(n2, "key"), i3.onabort = function(t5) {
                  t5.preventDefault(), t5.stopPropagation(), e4(false);
                }, i3.oncomplete = function() {
                  var t5 = navigator.userAgent.match(/Chrome\/(\d+)/), i4 = navigator.userAgent.match(/Edge\//);
                  e4(i4 || !t5 || parseInt(t5[1], 10) >= 43);
                };
              }).catch(function() {
                return false;
              });
            }(t3).then(function(t4) {
              return c = t4;
            });
          }
          function m(t3) {
            var e4 = d[t3.name], i3 = {};
            i3.promise = new s(function(t4, e5) {
              i3.resolve = t4, i3.reject = e5;
            }), e4.deferredOperations.push(i3), e4.dbReady ? e4.dbReady = e4.dbReady.then(function() {
              return i3.promise;
            }) : e4.dbReady = i3.promise;
          }
          function g(t3) {
            var e4 = d[t3.name].deferredOperations.pop();
            if (e4) return e4.resolve(), e4.promise;
          }
          function v(t3, e4) {
            var i3 = d[t3.name].deferredOperations.pop();
            if (i3) return i3.reject(e4), i3.promise;
          }
          function _(t3, e4) {
            return new s(function(i3, n2) {
              if (d[t3.name] = d[t3.name] || { forages: [], db: null, dbReady: null, deferredOperations: [] }, t3.db) {
                if (!e4) return i3(t3.db);
                m(t3), t3.db.close();
              }
              var o2 = [t3.name];
              e4 && o2.push(t3.version);
              var s2 = r.open.apply(r, o2);
              e4 && (s2.onupgradeneeded = function(e5) {
                var i4 = s2.result;
                try {
                  i4.createObjectStore(t3.storeName), e5.oldVersion <= 1 && i4.createObjectStore("local-forage-detect-blob-support");
                } catch (i5) {
                  if ("ConstraintError" !== i5.name) throw i5;
                  console.warn('The database "' + t3.name + '" has been upgraded from version ' + e5.oldVersion + " to version " + e5.newVersion + ', but the storage "' + t3.storeName + '" already exists.');
                }
              }), s2.onerror = function(t4) {
                t4.preventDefault(), n2(s2.error);
              }, s2.onsuccess = function() {
                var e5 = s2.result;
                e5.onversionchange = function(t4) {
                  t4.target.close();
                }, i3(e5), g(t3);
              };
            });
          }
          function y(t3) {
            return _(t3, false);
          }
          function x(t3) {
            return _(t3, true);
          }
          function b(t3, e4) {
            if (!t3.db) return true;
            var i3 = !t3.db.objectStoreNames.contains(t3.storeName), n2 = t3.version < t3.db.version, r2 = t3.version > t3.db.version;
            if (n2 && (t3.version !== e4 && console.warn('The database "' + t3.name + `" can't be downgraded from version ` + t3.db.version + " to version " + t3.version + "."), t3.version = t3.db.version), r2 || i3) {
              if (i3) {
                var o2 = t3.db.version + 1;
                o2 > t3.version && (t3.version = o2);
              }
              return true;
            }
            return false;
          }
          function T(t3) {
            return o([function(t4) {
              for (var e4 = t4.length, i3 = new ArrayBuffer(e4), n2 = new Uint8Array(i3), r2 = 0; r2 < e4; r2++) n2[r2] = t4.charCodeAt(r2);
              return i3;
            }(atob(t3.data))], { type: t3.type });
          }
          function E(t3) {
            return t3 && t3.__local_forage_encoded_blob;
          }
          function S(t3) {
            var e4 = this, i3 = e4._initReady().then(function() {
              var t4 = d[e4._dbInfo.name];
              if (t4 && t4.dbReady) return t4.dbReady;
            });
            return l(i3, t3, t3), i3;
          }
          function w(t3, e4, i3, n2) {
            void 0 === n2 && (n2 = 1);
            try {
              var r2 = t3.db.transaction(t3.storeName, e4);
              i3(null, r2);
            } catch (r3) {
              if (n2 > 0 && (!t3.db || "InvalidStateError" === r3.name || "NotFoundError" === r3.name)) return s.resolve().then(function() {
                if (!t3.db || "NotFoundError" === r3.name && !t3.db.objectStoreNames.contains(t3.storeName) && t3.version <= t3.db.version) return t3.db && (t3.version = t3.db.version + 1), x(t3);
              }).then(function() {
                return function(t4) {
                  m(t4);
                  for (var e5 = d[t4.name], i4 = e5.forages, n3 = 0; n3 < i4.length; n3++) {
                    var r4 = i4[n3];
                    r4._dbInfo.db && (r4._dbInfo.db.close(), r4._dbInfo.db = null);
                  }
                  return t4.db = null, y(t4).then(function(e6) {
                    return t4.db = e6, b(t4) ? x(t4) : e6;
                  }).then(function(n4) {
                    t4.db = e5.db = n4;
                    for (var r5 = 0; r5 < i4.length; r5++) i4[r5]._dbInfo.db = n4;
                  }).catch(function(e6) {
                    throw v(t4, e6), e6;
                  });
                }(t3).then(function() {
                  w(t3, e4, i3, n2 - 1);
                });
              }).catch(i3);
              i3(r3);
            }
          }
          var A = { _driver: "asyncStorage", _initStorage: function(t3) {
            var e4 = this, i3 = { db: null };
            if (t3) for (var n2 in t3) i3[n2] = t3[n2];
            var r2 = d[i3.name];
            r2 || (r2 = { forages: [], db: null, dbReady: null, deferredOperations: [] }, d[i3.name] = r2), r2.forages.push(e4), e4._initReady || (e4._initReady = e4.ready, e4.ready = S);
            var o2 = [];
            function a2() {
              return s.resolve();
            }
            for (var l2 = 0; l2 < r2.forages.length; l2++) {
              var h2 = r2.forages[l2];
              h2 !== e4 && o2.push(h2._initReady().catch(a2));
            }
            var u2 = r2.forages.slice(0);
            return s.all(o2).then(function() {
              return i3.db = r2.db, y(i3);
            }).then(function(t4) {
              return i3.db = t4, b(i3, e4._defaultConfig.version) ? x(i3) : t4;
            }).then(function(t4) {
              i3.db = r2.db = t4, e4._dbInfo = i3;
              for (var n3 = 0; n3 < u2.length; n3++) {
                var o3 = u2[n3];
                o3 !== e4 && (o3._dbInfo.db = i3.db, o3._dbInfo.version = i3.version);
              }
            });
          }, _support: function() {
            try {
              if (!r || !r.open) return false;
              var t3 = "undefined" != typeof openDatabase && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), e4 = "function" == typeof fetch && -1 !== fetch.toString().indexOf("[native code");
              return (!t3 || e4) && "undefined" != typeof indexedDB && "undefined" != typeof IDBKeyRange;
            } catch (t4) {
              return false;
            }
          }(), iterate: function(t3, e4) {
            var i3 = this, n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                w(i3._dbInfo, "readonly", function(r2, o2) {
                  if (r2) return n3(r2);
                  try {
                    var s2 = o2.objectStore(i3._dbInfo.storeName).openCursor(), a2 = 1;
                    s2.onsuccess = function() {
                      var i4 = s2.result;
                      if (i4) {
                        var n4 = i4.value;
                        E(n4) && (n4 = T(n4));
                        var r3 = t3(n4, i4.key, a2++);
                        void 0 !== r3 ? e5(r3) : i4.continue();
                      } else e5();
                    }, s2.onerror = function() {
                      n3(s2.error);
                    };
                  } catch (t4) {
                    n3(t4);
                  }
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, getItem: function(t3, e4) {
            var i3 = this;
            t3 = h(t3);
            var n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                w(i3._dbInfo, "readonly", function(r2, o2) {
                  if (r2) return n3(r2);
                  try {
                    var s2 = o2.objectStore(i3._dbInfo.storeName).get(t3);
                    s2.onsuccess = function() {
                      var t4 = s2.result;
                      void 0 === t4 && (t4 = null), E(t4) && (t4 = T(t4)), e5(t4);
                    }, s2.onerror = function() {
                      n3(s2.error);
                    };
                  } catch (t4) {
                    n3(t4);
                  }
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, setItem: function(t3, e4, i3) {
            var n2 = this;
            t3 = h(t3);
            var r2 = new s(function(i4, r3) {
              var o2;
              n2.ready().then(function() {
                return o2 = n2._dbInfo, "[object Blob]" === p.call(e4) ? f(o2.db).then(function(t4) {
                  return t4 ? e4 : (i5 = e4, new s(function(t5, e5) {
                    var n3 = new FileReader();
                    n3.onerror = e5, n3.onloadend = function(e6) {
                      var n4 = btoa(e6.target.result || "");
                      t5({ __local_forage_encoded_blob: true, data: n4, type: i5.type });
                    }, n3.readAsBinaryString(i5);
                  }));
                  var i5;
                }) : e4;
              }).then(function(e5) {
                w(n2._dbInfo, "readwrite", function(o3, s2) {
                  if (o3) return r3(o3);
                  try {
                    var a2 = s2.objectStore(n2._dbInfo.storeName);
                    null === e5 && (e5 = void 0);
                    var l2 = a2.put(e5, t3);
                    s2.oncomplete = function() {
                      void 0 === e5 && (e5 = null), i4(e5);
                    }, s2.onabort = s2.onerror = function() {
                      var t4 = l2.error ? l2.error : l2.transaction.error;
                      r3(t4);
                    };
                  } catch (t4) {
                    r3(t4);
                  }
                });
              }).catch(r3);
            });
            return a(r2, i3), r2;
          }, removeItem: function(t3, e4) {
            var i3 = this;
            t3 = h(t3);
            var n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                w(i3._dbInfo, "readwrite", function(r2, o2) {
                  if (r2) return n3(r2);
                  try {
                    var s2 = o2.objectStore(i3._dbInfo.storeName).delete(t3);
                    o2.oncomplete = function() {
                      e5();
                    }, o2.onerror = function() {
                      n3(s2.error);
                    }, o2.onabort = function() {
                      var t4 = s2.error ? s2.error : s2.transaction.error;
                      n3(t4);
                    };
                  } catch (t4) {
                    n3(t4);
                  }
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, clear: function(t3) {
            var e4 = this, i3 = new s(function(t4, i4) {
              e4.ready().then(function() {
                w(e4._dbInfo, "readwrite", function(n2, r2) {
                  if (n2) return i4(n2);
                  try {
                    var o2 = r2.objectStore(e4._dbInfo.storeName).clear();
                    r2.oncomplete = function() {
                      t4();
                    }, r2.onabort = r2.onerror = function() {
                      var t5 = o2.error ? o2.error : o2.transaction.error;
                      i4(t5);
                    };
                  } catch (t5) {
                    i4(t5);
                  }
                });
              }).catch(i4);
            });
            return a(i3, t3), i3;
          }, length: function(t3) {
            var e4 = this, i3 = new s(function(t4, i4) {
              e4.ready().then(function() {
                w(e4._dbInfo, "readonly", function(n2, r2) {
                  if (n2) return i4(n2);
                  try {
                    var o2 = r2.objectStore(e4._dbInfo.storeName).count();
                    o2.onsuccess = function() {
                      t4(o2.result);
                    }, o2.onerror = function() {
                      i4(o2.error);
                    };
                  } catch (t5) {
                    i4(t5);
                  }
                });
              }).catch(i4);
            });
            return a(i3, t3), i3;
          }, key: function(t3, e4) {
            var i3 = this, n2 = new s(function(e5, n3) {
              t3 < 0 ? e5(null) : i3.ready().then(function() {
                w(i3._dbInfo, "readonly", function(r2, o2) {
                  if (r2) return n3(r2);
                  try {
                    var s2 = o2.objectStore(i3._dbInfo.storeName), a2 = false, l2 = s2.openKeyCursor();
                    l2.onsuccess = function() {
                      var i4 = l2.result;
                      i4 ? 0 === t3 || a2 ? e5(i4.key) : (a2 = true, i4.advance(t3)) : e5(null);
                    }, l2.onerror = function() {
                      n3(l2.error);
                    };
                  } catch (t4) {
                    n3(t4);
                  }
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, keys: function(t3) {
            var e4 = this, i3 = new s(function(t4, i4) {
              e4.ready().then(function() {
                w(e4._dbInfo, "readonly", function(n2, r2) {
                  if (n2) return i4(n2);
                  try {
                    var o2 = r2.objectStore(e4._dbInfo.storeName).openKeyCursor(), s2 = [];
                    o2.onsuccess = function() {
                      var e5 = o2.result;
                      e5 ? (s2.push(e5.key), e5.continue()) : t4(s2);
                    }, o2.onerror = function() {
                      i4(o2.error);
                    };
                  } catch (t5) {
                    i4(t5);
                  }
                });
              }).catch(i4);
            });
            return a(i3, t3), i3;
          }, dropInstance: function(t3, e4) {
            e4 = u.apply(this, arguments);
            var i3 = this.config();
            (t3 = "function" != typeof t3 && t3 || {}).name || (t3.name = t3.name || i3.name, t3.storeName = t3.storeName || i3.storeName);
            var n2, o2 = this;
            if (t3.name) {
              var l2 = t3.name === i3.name && o2._dbInfo.db, h2 = l2 ? s.resolve(o2._dbInfo.db) : y(t3).then(function(e5) {
                var i4 = d[t3.name], n3 = i4.forages;
                i4.db = e5;
                for (var r2 = 0; r2 < n3.length; r2++) n3[r2]._dbInfo.db = e5;
                return e5;
              });
              n2 = t3.storeName ? h2.then(function(e5) {
                if (e5.objectStoreNames.contains(t3.storeName)) {
                  var i4 = e5.version + 1;
                  m(t3);
                  var n3 = d[t3.name], o3 = n3.forages;
                  e5.close();
                  for (var a2 = 0; a2 < o3.length; a2++) {
                    var l3 = o3[a2];
                    l3._dbInfo.db = null, l3._dbInfo.version = i4;
                  }
                  return new s(function(e6, n4) {
                    var o4 = r.open(t3.name, i4);
                    o4.onerror = function(t4) {
                      o4.result.close(), n4(t4);
                    }, o4.onupgradeneeded = function() {
                      o4.result.deleteObjectStore(t3.storeName);
                    }, o4.onsuccess = function() {
                      var t4 = o4.result;
                      t4.close(), e6(t4);
                    };
                  }).then(function(t4) {
                    n3.db = t4;
                    for (var e6 = 0; e6 < o3.length; e6++) {
                      var i5 = o3[e6];
                      i5._dbInfo.db = t4, g(i5._dbInfo);
                    }
                  }).catch(function(e6) {
                    throw (v(t3, e6) || s.resolve()).catch(function() {
                    }), e6;
                  });
                }
              }) : h2.then(function(e5) {
                m(t3);
                var i4 = d[t3.name], n3 = i4.forages;
                e5.close();
                for (var o3 = 0; o3 < n3.length; o3++) n3[o3]._dbInfo.db = null;
                return new s(function(e6, i5) {
                  var n4 = r.deleteDatabase(t3.name);
                  n4.onerror = function() {
                    var t4 = n4.result;
                    t4 && t4.close(), i5(n4.error);
                  }, n4.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + t3.name + '" until all open connections are closed');
                  }, n4.onsuccess = function() {
                    var t4 = n4.result;
                    t4 && t4.close(), e6(t4);
                  };
                }).then(function(t4) {
                  i4.db = t4;
                  for (var e6 = 0; e6 < n3.length; e6++) g(n3[e6]._dbInfo);
                }).catch(function(e6) {
                  throw (v(t3, e6) || s.resolve()).catch(function() {
                  }), e6;
                });
              });
            } else n2 = s.reject("Invalid arguments");
            return a(n2, e4), n2;
          } }, M = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", C = /^~~local_forage_type~([^~]+)~/, R = "__lfsc__:".length, I = R + "arbf".length, P = Object.prototype.toString;
          function O(t3) {
            var e4, i3, n2, r2, o2, s2 = 0.75 * t3.length, a2 = t3.length, l2 = 0;
            "=" === t3[t3.length - 1] && (s2--, "=" === t3[t3.length - 2] && s2--);
            var h2 = new ArrayBuffer(s2), u2 = new Uint8Array(h2);
            for (e4 = 0; e4 < a2; e4 += 4) i3 = M.indexOf(t3[e4]), n2 = M.indexOf(t3[e4 + 1]), r2 = M.indexOf(t3[e4 + 2]), o2 = M.indexOf(t3[e4 + 3]), u2[l2++] = i3 << 2 | n2 >> 4, u2[l2++] = (15 & n2) << 4 | r2 >> 2, u2[l2++] = (3 & r2) << 6 | 63 & o2;
            return h2;
          }
          function N(t3) {
            var e4, i3 = new Uint8Array(t3), n2 = "";
            for (e4 = 0; e4 < i3.length; e4 += 3) n2 += M[i3[e4] >> 2], n2 += M[(3 & i3[e4]) << 4 | i3[e4 + 1] >> 4], n2 += M[(15 & i3[e4 + 1]) << 2 | i3[e4 + 2] >> 6], n2 += M[63 & i3[e4 + 2]];
            return i3.length % 3 == 2 ? n2 = n2.substring(0, n2.length - 1) + "=" : i3.length % 3 == 1 && (n2 = n2.substring(0, n2.length - 2) + "=="), n2;
          }
          var L = { serialize: function(t3, e4) {
            var i3 = "";
            if (t3 && (i3 = P.call(t3)), t3 && ("[object ArrayBuffer]" === i3 || t3.buffer && "[object ArrayBuffer]" === P.call(t3.buffer))) {
              var n2, r2 = "__lfsc__:";
              t3 instanceof ArrayBuffer ? (n2 = t3, r2 += "arbf") : (n2 = t3.buffer, "[object Int8Array]" === i3 ? r2 += "si08" : "[object Uint8Array]" === i3 ? r2 += "ui08" : "[object Uint8ClampedArray]" === i3 ? r2 += "uic8" : "[object Int16Array]" === i3 ? r2 += "si16" : "[object Uint16Array]" === i3 ? r2 += "ur16" : "[object Int32Array]" === i3 ? r2 += "si32" : "[object Uint32Array]" === i3 ? r2 += "ui32" : "[object Float32Array]" === i3 ? r2 += "fl32" : "[object Float64Array]" === i3 ? r2 += "fl64" : e4(new Error("Failed to get type for BinaryArray"))), e4(r2 + N(n2));
            } else if ("[object Blob]" === i3) {
              var o2 = new FileReader();
              o2.onload = function() {
                var i4 = "~~local_forage_type~" + t3.type + "~" + N(this.result);
                e4("__lfsc__:blob" + i4);
              }, o2.readAsArrayBuffer(t3);
            } else try {
              e4(JSON.stringify(t3));
            } catch (i4) {
              console.error("Couldn't convert value into a JSON string: ", t3), e4(null, i4);
            }
          }, deserialize: function(t3) {
            if ("__lfsc__:" !== t3.substring(0, R)) return JSON.parse(t3);
            var e4, i3 = t3.substring(I), n2 = t3.substring(R, I);
            if ("blob" === n2 && C.test(i3)) {
              var r2 = i3.match(C);
              e4 = r2[1], i3 = i3.substring(r2[0].length);
            }
            var s2 = O(i3);
            switch (n2) {
              case "arbf":
                return s2;
              case "blob":
                return o([s2], { type: e4 });
              case "si08":
                return new Int8Array(s2);
              case "ui08":
                return new Uint8Array(s2);
              case "uic8":
                return new Uint8ClampedArray(s2);
              case "si16":
                return new Int16Array(s2);
              case "ur16":
                return new Uint16Array(s2);
              case "si32":
                return new Int32Array(s2);
              case "ui32":
                return new Uint32Array(s2);
              case "fl32":
                return new Float32Array(s2);
              case "fl64":
                return new Float64Array(s2);
              default:
                throw new Error("Unkown type: " + n2);
            }
          }, stringToBuffer: O, bufferToString: N };
          function D(t3, e4, i3, n2) {
            t3.executeSql("CREATE TABLE IF NOT EXISTS " + e4.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], i3, n2);
          }
          function F(t3, e4, i3, n2, r2, o2) {
            t3.executeSql(i3, n2, r2, function(t4, s2) {
              s2.code === s2.SYNTAX_ERR ? t4.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [e4.storeName], function(t5, a2) {
                a2.rows.length ? o2(t5, s2) : D(t5, e4, function() {
                  t5.executeSql(i3, n2, r2, o2);
                }, o2);
              }, o2) : o2(t4, s2);
            }, o2);
          }
          function B(t3, e4, i3, n2) {
            var r2 = this;
            t3 = h(t3);
            var o2 = new s(function(o3, s2) {
              r2.ready().then(function() {
                void 0 === e4 && (e4 = null);
                var a2 = e4, l2 = r2._dbInfo;
                l2.serializer.serialize(e4, function(e5, h2) {
                  h2 ? s2(h2) : l2.db.transaction(function(i4) {
                    F(i4, l2, "INSERT OR REPLACE INTO " + l2.storeName + " (key, value) VALUES (?, ?)", [t3, e5], function() {
                      o3(a2);
                    }, function(t4, e6) {
                      s2(e6);
                    });
                  }, function(e6) {
                    if (e6.code === e6.QUOTA_ERR) {
                      if (n2 > 0) return void o3(B.apply(r2, [t3, a2, i3, n2 - 1]));
                      s2(e6);
                    }
                  });
                });
              }).catch(s2);
            });
            return a(o2, i3), o2;
          }
          function U(t3) {
            return new s(function(e4, i3) {
              t3.transaction(function(n2) {
                n2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(i4, n3) {
                  for (var r2 = [], o2 = 0; o2 < n3.rows.length; o2++) r2.push(n3.rows.item(o2).name);
                  e4({ db: t3, storeNames: r2 });
                }, function(t4, e5) {
                  i3(e5);
                });
              }, function(t4) {
                i3(t4);
              });
            });
          }
          var k = { _driver: "webSQLStorage", _initStorage: function(t3) {
            var e4 = this, i3 = { db: null };
            if (t3) for (var n2 in t3) i3[n2] = "string" != typeof t3[n2] ? t3[n2].toString() : t3[n2];
            var r2 = new s(function(t4, n3) {
              try {
                i3.db = openDatabase(i3.name, String(i3.version), i3.description, i3.size);
              } catch (t5) {
                return n3(t5);
              }
              i3.db.transaction(function(r3) {
                D(r3, i3, function() {
                  e4._dbInfo = i3, t4();
                }, function(t5, e5) {
                  n3(e5);
                });
              }, n3);
            });
            return i3.serializer = L, r2;
          }, _support: "function" == typeof openDatabase, iterate: function(t3, e4) {
            var i3 = this, n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                var r2 = i3._dbInfo;
                r2.db.transaction(function(i4) {
                  F(i4, r2, "SELECT * FROM " + r2.storeName, [], function(i5, n4) {
                    for (var o2 = n4.rows, s2 = o2.length, a2 = 0; a2 < s2; a2++) {
                      var l2 = o2.item(a2), h2 = l2.value;
                      if (h2 && (h2 = r2.serializer.deserialize(h2)), void 0 !== (h2 = t3(h2, l2.key, a2 + 1))) return void e5(h2);
                    }
                    e5();
                  }, function(t4, e6) {
                    n3(e6);
                  });
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, getItem: function(t3, e4) {
            var i3 = this;
            t3 = h(t3);
            var n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                var r2 = i3._dbInfo;
                r2.db.transaction(function(i4) {
                  F(i4, r2, "SELECT * FROM " + r2.storeName + " WHERE key = ? LIMIT 1", [t3], function(t4, i5) {
                    var n4 = i5.rows.length ? i5.rows.item(0).value : null;
                    n4 && (n4 = r2.serializer.deserialize(n4)), e5(n4);
                  }, function(t4, e6) {
                    n3(e6);
                  });
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, setItem: function(t3, e4, i3) {
            return B.apply(this, [t3, e4, i3, 1]);
          }, removeItem: function(t3, e4) {
            var i3 = this;
            t3 = h(t3);
            var n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                var r2 = i3._dbInfo;
                r2.db.transaction(function(i4) {
                  F(i4, r2, "DELETE FROM " + r2.storeName + " WHERE key = ?", [t3], function() {
                    e5();
                  }, function(t4, e6) {
                    n3(e6);
                  });
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, clear: function(t3) {
            var e4 = this, i3 = new s(function(t4, i4) {
              e4.ready().then(function() {
                var n2 = e4._dbInfo;
                n2.db.transaction(function(e5) {
                  F(e5, n2, "DELETE FROM " + n2.storeName, [], function() {
                    t4();
                  }, function(t5, e6) {
                    i4(e6);
                  });
                });
              }).catch(i4);
            });
            return a(i3, t3), i3;
          }, length: function(t3) {
            var e4 = this, i3 = new s(function(t4, i4) {
              e4.ready().then(function() {
                var n2 = e4._dbInfo;
                n2.db.transaction(function(e5) {
                  F(e5, n2, "SELECT COUNT(key) as c FROM " + n2.storeName, [], function(e6, i5) {
                    var n3 = i5.rows.item(0).c;
                    t4(n3);
                  }, function(t5, e6) {
                    i4(e6);
                  });
                });
              }).catch(i4);
            });
            return a(i3, t3), i3;
          }, key: function(t3, e4) {
            var i3 = this, n2 = new s(function(e5, n3) {
              i3.ready().then(function() {
                var r2 = i3._dbInfo;
                r2.db.transaction(function(i4) {
                  F(i4, r2, "SELECT key FROM " + r2.storeName + " WHERE id = ? LIMIT 1", [t3 + 1], function(t4, i5) {
                    var n4 = i5.rows.length ? i5.rows.item(0).key : null;
                    e5(n4);
                  }, function(t4, e6) {
                    n3(e6);
                  });
                });
              }).catch(n3);
            });
            return a(n2, e4), n2;
          }, keys: function(t3) {
            var e4 = this, i3 = new s(function(t4, i4) {
              e4.ready().then(function() {
                var n2 = e4._dbInfo;
                n2.db.transaction(function(e5) {
                  F(e5, n2, "SELECT key FROM " + n2.storeName, [], function(e6, i5) {
                    for (var n3 = [], r2 = 0; r2 < i5.rows.length; r2++) n3.push(i5.rows.item(r2).key);
                    t4(n3);
                  }, function(t5, e6) {
                    i4(e6);
                  });
                });
              }).catch(i4);
            });
            return a(i3, t3), i3;
          }, dropInstance: function(t3, e4) {
            e4 = u.apply(this, arguments);
            var i3 = this.config();
            (t3 = "function" != typeof t3 && t3 || {}).name || (t3.name = t3.name || i3.name, t3.storeName = t3.storeName || i3.storeName);
            var n2, r2 = this;
            return a(n2 = t3.name ? new s(function(e5) {
              var n3;
              n3 = t3.name === i3.name ? r2._dbInfo.db : openDatabase(t3.name, "", "", 0), t3.storeName ? e5({ db: n3, storeNames: [t3.storeName] }) : e5(U(n3));
            }).then(function(t4) {
              return new s(function(e5, i4) {
                t4.db.transaction(function(n3) {
                  function r3(t5) {
                    return new s(function(e6, i5) {
                      n3.executeSql("DROP TABLE IF EXISTS " + t5, [], function() {
                        e6();
                      }, function(t6, e7) {
                        i5(e7);
                      });
                    });
                  }
                  for (var o2 = [], a2 = 0, l2 = t4.storeNames.length; a2 < l2; a2++) o2.push(r3(t4.storeNames[a2]));
                  s.all(o2).then(function() {
                    e5();
                  }).catch(function(t5) {
                    i4(t5);
                  });
                }, function(t5) {
                  i4(t5);
                });
              });
            }) : s.reject("Invalid arguments"), e4), n2;
          } };
          function G(t3, e4) {
            var i3 = t3.name + "/";
            return t3.storeName !== e4.storeName && (i3 += t3.storeName + "/"), i3;
          }
          function H() {
            return !function() {
              try {
                return localStorage.setItem("_localforage_support_test", true), localStorage.removeItem("_localforage_support_test"), false;
              } catch (t3) {
                return true;
              }
            }() || localStorage.length > 0;
          }
          var j = { _driver: "localStorageWrapper", _initStorage: function(t3) {
            var e4 = {};
            if (t3) for (var i3 in t3) e4[i3] = t3[i3];
            return e4.keyPrefix = G(t3, this._defaultConfig), H() ? (this._dbInfo = e4, e4.serializer = L, s.resolve()) : s.reject();
          }, _support: function() {
            try {
              return "undefined" != typeof localStorage && "setItem" in localStorage && !!localStorage.setItem;
            } catch (t3) {
              return false;
            }
          }(), iterate: function(t3, e4) {
            var i3 = this, n2 = i3.ready().then(function() {
              for (var e5 = i3._dbInfo, n3 = e5.keyPrefix, r2 = n3.length, o2 = localStorage.length, s2 = 1, a2 = 0; a2 < o2; a2++) {
                var l2 = localStorage.key(a2);
                if (0 === l2.indexOf(n3)) {
                  var h2 = localStorage.getItem(l2);
                  if (h2 && (h2 = e5.serializer.deserialize(h2)), void 0 !== (h2 = t3(h2, l2.substring(r2), s2++))) return h2;
                }
              }
            });
            return a(n2, e4), n2;
          }, getItem: function(t3, e4) {
            var i3 = this;
            t3 = h(t3);
            var n2 = i3.ready().then(function() {
              var e5 = i3._dbInfo, n3 = localStorage.getItem(e5.keyPrefix + t3);
              return n3 && (n3 = e5.serializer.deserialize(n3)), n3;
            });
            return a(n2, e4), n2;
          }, setItem: function(t3, e4, i3) {
            var n2 = this;
            t3 = h(t3);
            var r2 = n2.ready().then(function() {
              void 0 === e4 && (e4 = null);
              var i4 = e4;
              return new s(function(r3, o2) {
                var s2 = n2._dbInfo;
                s2.serializer.serialize(e4, function(e5, n3) {
                  if (n3) o2(n3);
                  else try {
                    localStorage.setItem(s2.keyPrefix + t3, e5), r3(i4);
                  } catch (t4) {
                    "QuotaExceededError" !== t4.name && "NS_ERROR_DOM_QUOTA_REACHED" !== t4.name || o2(t4), o2(t4);
                  }
                });
              });
            });
            return a(r2, i3), r2;
          }, removeItem: function(t3, e4) {
            var i3 = this;
            t3 = h(t3);
            var n2 = i3.ready().then(function() {
              var e5 = i3._dbInfo;
              localStorage.removeItem(e5.keyPrefix + t3);
            });
            return a(n2, e4), n2;
          }, clear: function(t3) {
            var e4 = this, i3 = e4.ready().then(function() {
              for (var t4 = e4._dbInfo.keyPrefix, i4 = localStorage.length - 1; i4 >= 0; i4--) {
                var n2 = localStorage.key(i4);
                0 === n2.indexOf(t4) && localStorage.removeItem(n2);
              }
            });
            return a(i3, t3), i3;
          }, length: function(t3) {
            var e4 = this.keys().then(function(t4) {
              return t4.length;
            });
            return a(e4, t3), e4;
          }, key: function(t3, e4) {
            var i3 = this, n2 = i3.ready().then(function() {
              var e5, n3 = i3._dbInfo;
              try {
                e5 = localStorage.key(t3);
              } catch (t4) {
                e5 = null;
              }
              return e5 && (e5 = e5.substring(n3.keyPrefix.length)), e5;
            });
            return a(n2, e4), n2;
          }, keys: function(t3) {
            var e4 = this, i3 = e4.ready().then(function() {
              for (var t4 = e4._dbInfo, i4 = localStorage.length, n2 = [], r2 = 0; r2 < i4; r2++) {
                var o2 = localStorage.key(r2);
                0 === o2.indexOf(t4.keyPrefix) && n2.push(o2.substring(t4.keyPrefix.length));
              }
              return n2;
            });
            return a(i3, t3), i3;
          }, dropInstance: function(t3, e4) {
            if (e4 = u.apply(this, arguments), !(t3 = "function" != typeof t3 && t3 || {}).name) {
              var i3 = this.config();
              t3.name = t3.name || i3.name, t3.storeName = t3.storeName || i3.storeName;
            }
            var n2, r2 = this;
            return a(n2 = t3.name ? new s(function(e5) {
              t3.storeName ? e5(G(t3, r2._defaultConfig)) : e5(t3.name + "/");
            }).then(function(t4) {
              for (var e5 = localStorage.length - 1; e5 >= 0; e5--) {
                var i4 = localStorage.key(e5);
                0 === i4.indexOf(t4) && localStorage.removeItem(i4);
              }
            }) : s.reject("Invalid arguments"), e4), n2;
          } }, z = function(t3, e4) {
            for (var i3, n2, r2 = t3.length, o2 = 0; o2 < r2; ) {
              if ((i3 = t3[o2]) === (n2 = e4) || "number" == typeof i3 && "number" == typeof n2 && isNaN(i3) && isNaN(n2)) return true;
              o2++;
            }
            return false;
          }, V = Array.isArray || function(t3) {
            return "[object Array]" === Object.prototype.toString.call(t3);
          }, X = {}, W = {}, Y = { INDEXEDDB: A, WEBSQL: k, LOCALSTORAGE: j }, q = [Y.INDEXEDDB._driver, Y.WEBSQL._driver, Y.LOCALSTORAGE._driver], Z = ["dropInstance"], J = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Z), K = { description: "", driver: q.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
          function Q(t3, e4) {
            t3[e4] = function() {
              var i3 = arguments;
              return t3.ready().then(function() {
                return t3[e4].apply(t3, i3);
              });
            };
          }
          function $() {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var e4 = arguments[t3];
              if (e4) for (var i3 in e4) e4.hasOwnProperty(i3) && (V(e4[i3]) ? arguments[0][i3] = e4[i3].slice() : arguments[0][i3] = e4[i3]);
            }
            return arguments[0];
          }
          var tt = new (function() {
            function t3(e4) {
              for (var i3 in function(t4, e5) {
                if (!(t4 instanceof e5)) throw new TypeError("Cannot call a class as a function");
              }(this, t3), Y) if (Y.hasOwnProperty(i3)) {
                var n2 = Y[i3], r2 = n2._driver;
                this[i3] = r2, X[r2] || this.defineDriver(n2);
              }
              this._defaultConfig = $({}, K), this._config = $({}, this._defaultConfig, e4), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
              });
            }
            return t3.prototype.config = function(t4) {
              if ("object" === (void 0 === t4 ? "undefined" : n(t4))) {
                if (this._ready) return new Error("Can't call config() after localforage has been used.");
                for (var e4 in t4) {
                  if ("storeName" === e4 && (t4[e4] = t4[e4].replace(/\W/g, "_")), "version" === e4 && "number" != typeof t4[e4]) return new Error("Database version must be a number.");
                  this._config[e4] = t4[e4];
                }
                return !("driver" in t4) || !t4.driver || this.setDriver(this._config.driver);
              }
              return "string" == typeof t4 ? this._config[t4] : this._config;
            }, t3.prototype.defineDriver = function(t4, e4, i3) {
              var n2 = new s(function(e5, i4) {
                try {
                  var n3 = t4._driver, r2 = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!t4._driver) return void i4(r2);
                  for (var o2 = J.concat("_initStorage"), l2 = 0, h2 = o2.length; l2 < h2; l2++) {
                    var u2 = o2[l2];
                    if ((!z(Z, u2) || t4[u2]) && "function" != typeof t4[u2]) return void i4(r2);
                  }
                  !function() {
                    for (var e6 = function(t5) {
                      return function() {
                        var e7 = new Error("Method " + t5 + " is not implemented by the current driver"), i6 = s.reject(e7);
                        return a(i6, arguments[arguments.length - 1]), i6;
                      };
                    }, i5 = 0, n4 = Z.length; i5 < n4; i5++) {
                      var r3 = Z[i5];
                      t4[r3] || (t4[r3] = e6(r3));
                    }
                  }();
                  var c2 = function(i5) {
                    X[n3] && console.info("Redefining LocalForage driver: " + n3), X[n3] = t4, W[n3] = i5, e5();
                  };
                  "_support" in t4 ? t4._support && "function" == typeof t4._support ? t4._support().then(c2, i4) : c2(!!t4._support) : c2(true);
                } catch (t5) {
                  i4(t5);
                }
              });
              return l(n2, e4, i3), n2;
            }, t3.prototype.driver = function() {
              return this._driver || null;
            }, t3.prototype.getDriver = function(t4, e4, i3) {
              var n2 = X[t4] ? s.resolve(X[t4]) : s.reject(new Error("Driver not found."));
              return l(n2, e4, i3), n2;
            }, t3.prototype.getSerializer = function(t4) {
              var e4 = s.resolve(L);
              return l(e4, t4), e4;
            }, t3.prototype.ready = function(t4) {
              var e4 = this, i3 = e4._driverSet.then(function() {
                return null === e4._ready && (e4._ready = e4._initDriver()), e4._ready;
              });
              return l(i3, t4, t4), i3;
            }, t3.prototype.setDriver = function(t4, e4, i3) {
              var n2 = this;
              V(t4) || (t4 = [t4]);
              var r2 = this._getSupportedDrivers(t4);
              function o2() {
                n2._config.driver = n2.driver();
              }
              function a2(t5) {
                return n2._extend(t5), o2(), n2._ready = n2._initStorage(n2._config), n2._ready;
              }
              var h2 = null !== this._driverSet ? this._driverSet.catch(function() {
                return s.resolve();
              }) : s.resolve();
              return this._driverSet = h2.then(function() {
                var t5 = r2[0];
                return n2._dbInfo = null, n2._ready = null, n2.getDriver(t5).then(function(t6) {
                  n2._driver = t6._driver, o2(), n2._wrapLibraryMethodsWithReady(), n2._initDriver = /* @__PURE__ */ function(t7) {
                    return function() {
                      var e5 = 0;
                      return function i4() {
                        for (; e5 < t7.length; ) {
                          var r3 = t7[e5];
                          return e5++, n2._dbInfo = null, n2._ready = null, n2.getDriver(r3).then(a2).catch(i4);
                        }
                        o2();
                        var l2 = new Error("No available storage method found.");
                        return n2._driverSet = s.reject(l2), n2._driverSet;
                      }();
                    };
                  }(r2);
                });
              }).catch(function() {
                o2();
                var t5 = new Error("No available storage method found.");
                return n2._driverSet = s.reject(t5), n2._driverSet;
              }), l(this._driverSet, e4, i3), this._driverSet;
            }, t3.prototype.supports = function(t4) {
              return !!W[t4];
            }, t3.prototype._extend = function(t4) {
              $(this, t4);
            }, t3.prototype._getSupportedDrivers = function(t4) {
              for (var e4 = [], i3 = 0, n2 = t4.length; i3 < n2; i3++) {
                var r2 = t4[i3];
                this.supports(r2) && e4.push(r2);
              }
              return e4;
            }, t3.prototype._wrapLibraryMethodsWithReady = function() {
              for (var t4 = 0, e4 = J.length; t4 < e4; t4++) Q(this, J[t4]);
            }, t3.prototype.createInstance = function(e4) {
              return new t3(e4);
            }, t3;
          }())();
          e3.exports = tt;
        }, { 3: 3 }] }, {}, [4])(4);
      }).call(this, i(17));
    }, function(t, e, i) {
      var n = i(14).Symbol;
      t.exports = n;
    }, function(t, e) {
      t.exports = function(t2) {
        return t2.webpackPolyfill || (t2.deprecate = function() {
        }, t2.paths = [], t2.children || (t2.children = []), Object.defineProperty(t2, "loaded", { enumerable: true, get: function() {
          return t2.l;
        } }), Object.defineProperty(t2, "id", { enumerable: true, get: function() {
          return t2.i;
        } }), t2.webpackPolyfill = 1), t2;
      };
    }, function(t, e, i) {
      var n = i(152), r = i(153), o = i(154), s = i(155), a = i(156);
      function l(t2) {
        var e2 = -1, i2 = null == t2 ? 0 : t2.length;
        for (this.clear(); ++e2 < i2; ) {
          var n2 = t2[e2];
          this.set(n2[0], n2[1]);
        }
      }
      l.prototype.clear = n, l.prototype.delete = r, l.prototype.get = o, l.prototype.has = s, l.prototype.set = a, t.exports = l;
    }, function(t, e, i) {
      var n = i(36);
      t.exports = function(t2, e2) {
        for (var i2 = t2.length; i2--; ) if (n(t2[i2][0], e2)) return i2;
        return -1;
      };
    }, function(t, e, i) {
      var n = i(22)(Object, "create");
      t.exports = n;
    }, function(t, e, i) {
      var n = i(174);
      t.exports = function(t2, e2) {
        var i2 = t2.__data__;
        return n(e2) ? i2["string" == typeof e2 ? "string" : "hash"] : i2.map;
      };
    }, function(t, e) {
      var i = Array.isArray;
      t.exports = i;
    }, function(t, e, i) {
      var n = i(196), r = i(37), o = i(197), s = i(198), a = i(199), l = i(20), h = i(55), u = h(n), c = h(r), d = h(o), p = h(s), f = h(a), m = l;
      (n && "[object DataView]" != m(new n(new ArrayBuffer(1))) || r && "[object Map]" != m(new r()) || o && "[object Promise]" != m(o.resolve()) || s && "[object Set]" != m(new s()) || a && "[object WeakMap]" != m(new a())) && (m = function(t2) {
        var e2 = l(t2), i2 = "[object Object]" == e2 ? t2.constructor : void 0, n2 = i2 ? h(i2) : "";
        if (n2) switch (n2) {
          case u:
            return "[object DataView]";
          case c:
            return "[object Map]";
          case d:
            return "[object Promise]";
          case p:
            return "[object Set]";
          case f:
            return "[object WeakMap]";
        }
        return e2;
      }), t.exports = m;
    }, function(t, e, i) {
      var n = i(68), r = i(69);
      t.exports = function(t2, e2, i2, o) {
        var s = !i2;
        i2 || (i2 = {});
        for (var a = -1, l = e2.length; ++a < l; ) {
          var h = e2[a], u = o ? o(i2[h], t2[h], h, i2, t2) : void 0;
          void 0 === u && (u = t2[h]), s ? r(i2, h, u) : n(i2, h, u);
        }
        return i2;
      };
    }, function(t, e, i) {
      var n = i(20), r = i(21);
      t.exports = function(t2) {
        if (!r(t2)) return false;
        var e2 = n(t2);
        return "[object Function]" == e2 || "[object GeneratorFunction]" == e2 || "[object AsyncFunction]" == e2 || "[object Proxy]" == e2;
      };
    }, function(t, e, i) {
      "use strict";
      (function(t2) {
        i.d(e, "a", function() {
          return Fi;
        });
        var n = i(4), r = i(0), o = i(10), s = i(8), a = i(16), l = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t2 ? t2 : "undefined" != typeof self ? self : {};
        function h(t3, e2, i2) {
          return t3(i2 = { path: e2, exports: {}, require: function(t4, e3) {
            return function() {
              throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == e3 && i2.path);
          } }, i2.exports), i2.exports;
        }
        var u = h(function(t3) {
          var e2 = Object.prototype.hasOwnProperty, i2 = "~";
          function n2() {
          }
          function r2(t4, e3, i3) {
            this.fn = t4, this.context = e3, this.once = i3 || false;
          }
          function o2(t4, e3, n3, o3, s3) {
            if ("function" != typeof n3) throw new TypeError("The listener must be a function");
            var a3 = new r2(n3, o3 || t4, s3), l2 = i2 ? i2 + e3 : e3;
            return t4._events[l2] ? t4._events[l2].fn ? t4._events[l2] = [t4._events[l2], a3] : t4._events[l2].push(a3) : (t4._events[l2] = a3, t4._eventsCount++), t4;
          }
          function s2(t4, e3) {
            0 == --t4._eventsCount ? t4._events = new n2() : delete t4._events[e3];
          }
          function a2() {
            this._events = new n2(), this._eventsCount = 0;
          }
          Object.create && (n2.prototype = /* @__PURE__ */ Object.create(null), new n2().__proto__ || (i2 = false)), a2.prototype.eventNames = function() {
            var t4, n3, r3 = [];
            if (0 === this._eventsCount) return r3;
            for (n3 in t4 = this._events) e2.call(t4, n3) && r3.push(i2 ? n3.slice(1) : n3);
            return Object.getOwnPropertySymbols ? r3.concat(Object.getOwnPropertySymbols(t4)) : r3;
          }, a2.prototype.listeners = function(t4) {
            var e3 = i2 ? i2 + t4 : t4, n3 = this._events[e3];
            if (!n3) return [];
            if (n3.fn) return [n3.fn];
            for (var r3 = 0, o3 = n3.length, s3 = new Array(o3); r3 < o3; r3++) s3[r3] = n3[r3].fn;
            return s3;
          }, a2.prototype.listenerCount = function(t4) {
            var e3 = i2 ? i2 + t4 : t4, n3 = this._events[e3];
            return n3 ? n3.fn ? 1 : n3.length : 0;
          }, a2.prototype.emit = function(t4, e3, n3, r3, o3, s3) {
            var a3 = arguments, l2 = i2 ? i2 + t4 : t4;
            if (!this._events[l2]) return false;
            var h2, u2, c2 = this._events[l2], d2 = arguments.length;
            if (c2.fn) {
              switch (c2.once && this.removeListener(t4, c2.fn, void 0, true), d2) {
                case 1:
                  return c2.fn.call(c2.context), true;
                case 2:
                  return c2.fn.call(c2.context, e3), true;
                case 3:
                  return c2.fn.call(c2.context, e3, n3), true;
                case 4:
                  return c2.fn.call(c2.context, e3, n3, r3), true;
                case 5:
                  return c2.fn.call(c2.context, e3, n3, r3, o3), true;
                case 6:
                  return c2.fn.call(c2.context, e3, n3, r3, o3, s3), true;
              }
              for (u2 = 1, h2 = new Array(d2 - 1); u2 < d2; u2++) h2[u2 - 1] = a3[u2];
              c2.fn.apply(c2.context, h2);
            } else {
              var p2, f2 = c2.length;
              for (u2 = 0; u2 < f2; u2++) switch (c2[u2].once && this.removeListener(t4, c2[u2].fn, void 0, true), d2) {
                case 1:
                  c2[u2].fn.call(c2[u2].context);
                  break;
                case 2:
                  c2[u2].fn.call(c2[u2].context, e3);
                  break;
                case 3:
                  c2[u2].fn.call(c2[u2].context, e3, n3);
                  break;
                case 4:
                  c2[u2].fn.call(c2[u2].context, e3, n3, r3);
                  break;
                default:
                  if (!h2) for (p2 = 1, h2 = new Array(d2 - 1); p2 < d2; p2++) h2[p2 - 1] = a3[p2];
                  c2[u2].fn.apply(c2[u2].context, h2);
              }
            }
            return true;
          }, a2.prototype.on = function(t4, e3, i3) {
            return o2(this, t4, e3, i3, false);
          }, a2.prototype.once = function(t4, e3, i3) {
            return o2(this, t4, e3, i3, true);
          }, a2.prototype.removeListener = function(t4, e3, n3, r3) {
            var o3 = i2 ? i2 + t4 : t4;
            if (!this._events[o3]) return this;
            if (!e3) return s2(this, o3), this;
            var a3 = this._events[o3];
            if (a3.fn) a3.fn !== e3 || r3 && !a3.once || n3 && a3.context !== n3 || s2(this, o3);
            else {
              for (var l2 = 0, h2 = [], u2 = a3.length; l2 < u2; l2++) (a3[l2].fn !== e3 || r3 && !a3[l2].once || n3 && a3[l2].context !== n3) && h2.push(a3[l2]);
              h2.length ? this._events[o3] = 1 === h2.length ? h2[0] : h2 : s2(this, o3);
            }
            return this;
          }, a2.prototype.removeAllListeners = function(t4) {
            var e3;
            return t4 ? (e3 = i2 ? i2 + t4 : t4, this._events[e3] && s2(this, e3)) : (this._events = new n2(), this._eventsCount = 0), this;
          }, a2.prototype.off = a2.prototype.removeListener, a2.prototype.addListener = a2.prototype.on, a2.prefixed = i2, a2.EventEmitter = a2, t3.exports = a2;
        }), c = h(function(t3, e2) {
          !function(i2) {
            var n2 = e2 && !e2.nodeType && e2, r2 = t3 && !t3.nodeType && t3, o2 = "object" == typeof l && l;
            o2.global !== o2 && o2.window !== o2 && o2.self !== o2 || (i2 = o2);
            var s2, a2, h2 = 2147483647, u2 = /^xn--/, c2 = /[^\x20-\x7E]/, d2 = /[\x2E\u3002\uFF0E\uFF61]/g, p2 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, f2 = Math.floor, m2 = String.fromCharCode;
            function g2(t4) {
              throw RangeError(p2[t4]);
            }
            function v2(t4, e3) {
              for (var i3 = t4.length, n3 = []; i3--; ) n3[i3] = e3(t4[i3]);
              return n3;
            }
            function _2(t4, e3) {
              var i3 = t4.split("@"), n3 = "";
              return i3.length > 1 && (n3 = i3[0] + "@", t4 = i3[1]), n3 + v2((t4 = t4.replace(d2, ".")).split("."), e3).join(".");
            }
            function y2(t4) {
              for (var e3, i3, n3 = [], r3 = 0, o3 = t4.length; r3 < o3; ) (e3 = t4.charCodeAt(r3++)) >= 55296 && e3 <= 56319 && r3 < o3 ? 56320 == (64512 & (i3 = t4.charCodeAt(r3++))) ? n3.push(((1023 & e3) << 10) + (1023 & i3) + 65536) : (n3.push(e3), r3--) : n3.push(e3);
              return n3;
            }
            function x2(t4) {
              return v2(t4, function(t5) {
                var e3 = "";
                return t5 > 65535 && (e3 += m2((t5 -= 65536) >>> 10 & 1023 | 55296), t5 = 56320 | 1023 & t5), e3 += m2(t5);
              }).join("");
            }
            function b2(t4, e3) {
              return t4 + 22 + 75 * (t4 < 26) - ((0 != e3) << 5);
            }
            function T2(t4, e3, i3) {
              var n3 = 0;
              for (t4 = i3 ? f2(t4 / 700) : t4 >> 1, t4 += f2(t4 / e3); t4 > 455; n3 += 36) t4 = f2(t4 / 35);
              return f2(n3 + 36 * t4 / (t4 + 38));
            }
            function E2(t4) {
              var e3, i3, n3, r3, o3, s3, a3, l2, u3, c3, d3, p3 = [], m3 = t4.length, v3 = 0, _3 = 128, y3 = 72;
              for ((i3 = t4.lastIndexOf("-")) < 0 && (i3 = 0), n3 = 0; n3 < i3; ++n3) t4.charCodeAt(n3) >= 128 && g2("not-basic"), p3.push(t4.charCodeAt(n3));
              for (r3 = i3 > 0 ? i3 + 1 : 0; r3 < m3; ) {
                for (o3 = v3, s3 = 1, a3 = 36; r3 >= m3 && g2("invalid-input"), ((l2 = (d3 = t4.charCodeAt(r3++)) - 48 < 10 ? d3 - 22 : d3 - 65 < 26 ? d3 - 65 : d3 - 97 < 26 ? d3 - 97 : 36) >= 36 || l2 > f2((h2 - v3) / s3)) && g2("overflow"), v3 += l2 * s3, !(l2 < (u3 = a3 <= y3 ? 1 : a3 >= y3 + 26 ? 26 : a3 - y3)); a3 += 36) s3 > f2(h2 / (c3 = 36 - u3)) && g2("overflow"), s3 *= c3;
                y3 = T2(v3 - o3, e3 = p3.length + 1, 0 == o3), f2(v3 / e3) > h2 - _3 && g2("overflow"), _3 += f2(v3 / e3), v3 %= e3, p3.splice(v3++, 0, _3);
              }
              return x2(p3);
            }
            function S2(t4) {
              var e3, i3, n3, r3, o3, s3, a3, l2, u3, c3, d3, p3, v3, _3, x3, E3 = [];
              for (p3 = (t4 = y2(t4)).length, e3 = 128, i3 = 0, o3 = 72, s3 = 0; s3 < p3; ++s3) (d3 = t4[s3]) < 128 && E3.push(m2(d3));
              for (n3 = r3 = E3.length, r3 && E3.push("-"); n3 < p3; ) {
                for (a3 = h2, s3 = 0; s3 < p3; ++s3) (d3 = t4[s3]) >= e3 && d3 < a3 && (a3 = d3);
                for (a3 - e3 > f2((h2 - i3) / (v3 = n3 + 1)) && g2("overflow"), i3 += (a3 - e3) * v3, e3 = a3, s3 = 0; s3 < p3; ++s3) if ((d3 = t4[s3]) < e3 && ++i3 > h2 && g2("overflow"), d3 == e3) {
                  for (l2 = i3, u3 = 36; !(l2 < (c3 = u3 <= o3 ? 1 : u3 >= o3 + 26 ? 26 : u3 - o3)); u3 += 36) x3 = l2 - c3, _3 = 36 - c3, E3.push(m2(b2(c3 + x3 % _3, 0))), l2 = f2(x3 / _3);
                  E3.push(m2(b2(l2, 0))), o3 = T2(i3, v3, n3 == r3), i3 = 0, ++n3;
                }
                ++i3, ++e3;
              }
              return E3.join("");
            }
            if (s2 = { version: "1.3.2", ucs2: { decode: y2, encode: x2 }, decode: E2, encode: S2, toASCII: function(t4) {
              return _2(t4, function(t5) {
                return c2.test(t5) ? "xn--" + S2(t5) : t5;
              });
            }, toUnicode: function(t4) {
              return _2(t4, function(t5) {
                return u2.test(t5) ? E2(t5.slice(4).toLowerCase()) : t5;
              });
            } }, n2 && r2) if (t3.exports == n2) r2.exports = s2;
            else for (a2 in s2) s2.hasOwnProperty(a2) && (n2[a2] = s2[a2]);
            else i2.punycode = s2;
          }(l);
        }), d = function(t3) {
          return "string" == typeof t3;
        }, p = function(t3) {
          return "object" == typeof t3 && null !== t3;
        }, f = function(t3) {
          return null === t3;
        }, m = function(t3) {
          return null == t3;
        };
        function g(t3, e2) {
          return Object.prototype.hasOwnProperty.call(t3, e2);
        }
        var v = function(t3, e2, i2, n2) {
          e2 = e2 || "&", i2 = i2 || "=";
          var r2 = {};
          if ("string" != typeof t3 || 0 === t3.length) return r2;
          var o2 = /\+/g;
          t3 = t3.split(e2);
          var s2 = 1e3;
          n2 && "number" == typeof n2.maxKeys && (s2 = n2.maxKeys);
          var a2 = t3.length;
          s2 > 0 && a2 > s2 && (a2 = s2);
          for (var l2 = 0; l2 < a2; ++l2) {
            var h2, u2, c2, d2, p2 = t3[l2].replace(o2, "%20"), f2 = p2.indexOf(i2);
            f2 >= 0 ? (h2 = p2.substr(0, f2), u2 = p2.substr(f2 + 1)) : (h2 = p2, u2 = ""), c2 = decodeURIComponent(h2), d2 = decodeURIComponent(u2), g(r2, c2) ? Array.isArray(r2[c2]) ? r2[c2].push(d2) : r2[c2] = [r2[c2], d2] : r2[c2] = d2;
          }
          return r2;
        }, _ = function(t3) {
          switch (typeof t3) {
            case "string":
              return t3;
            case "boolean":
              return t3 ? "true" : "false";
            case "number":
              return isFinite(t3) ? t3 : "";
            default:
              return "";
          }
        }, y = function(t3, e2, i2, n2) {
          return e2 = e2 || "&", i2 = i2 || "=", null === t3 && (t3 = void 0), "object" == typeof t3 ? Object.keys(t3).map(function(n3) {
            var r2 = encodeURIComponent(_(n3)) + i2;
            return Array.isArray(t3[n3]) ? t3[n3].map(function(t4) {
              return r2 + encodeURIComponent(_(t4));
            }).join(e2) : r2 + encodeURIComponent(_(t3[n3]));
          }).join(e2) : n2 ? encodeURIComponent(_(n2)) + i2 + encodeURIComponent(_(t3)) : "";
        }, x = h(function(t3, e2) {
          e2.decode = e2.parse = v, e2.encode = e2.stringify = y;
        }), b = B, T = function(t3, e2) {
          return B(t3, false, true).resolve(e2);
        }, E = function(t3) {
          d(t3) && (t3 = B(t3));
          if (!(t3 instanceof S)) return S.prototype.format.call(t3);
          return t3.format();
        };
        function S() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        var w = /^([a-z0-9.+-]+:)/i, A = /:[0-9]*$/, M = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, C = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), R = ["'"].concat(C), I = ["%", "/", "?", ";", "#"].concat(R), P = ["/", "?", "#"], O = /^[+a-z0-9A-Z_-]{0,63}$/, N = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, L = { javascript: true, "javascript:": true }, D = { javascript: true, "javascript:": true }, F = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
        function B(t3, e2, i2) {
          if (t3 && p(t3) && t3 instanceof S) return t3;
          var n2 = new S();
          return n2.parse(t3, e2, i2), n2;
        }
        S.prototype.parse = function(t3, e2, i2) {
          if (!d(t3)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t3);
          var n2 = t3.indexOf("?"), r2 = -1 !== n2 && n2 < t3.indexOf("#") ? "?" : "#", o2 = t3.split(r2);
          o2[0] = o2[0].replace(/\\/g, "/");
          var s2 = t3 = o2.join(r2);
          if (s2 = s2.trim(), !i2 && 1 === t3.split("#").length) {
            var a2 = M.exec(s2);
            if (a2) return this.path = s2, this.href = s2, this.pathname = a2[1], a2[2] ? (this.search = a2[2], this.query = e2 ? x.parse(this.search.substr(1)) : this.search.substr(1)) : e2 && (this.search = "", this.query = {}), this;
          }
          var l2 = w.exec(s2);
          if (l2) {
            var h2 = (l2 = l2[0]).toLowerCase();
            this.protocol = h2, s2 = s2.substr(l2.length);
          }
          if (i2 || l2 || s2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var u2 = "//" === s2.substr(0, 2);
            !u2 || l2 && D[l2] || (s2 = s2.substr(2), this.slashes = true);
          }
          if (!D[l2] && (u2 || l2 && !F[l2])) {
            for (var p2, f2, m2 = -1, g2 = 0; g2 < P.length; g2++) {
              -1 !== (v2 = s2.indexOf(P[g2])) && (-1 === m2 || v2 < m2) && (m2 = v2);
            }
            -1 !== (f2 = -1 === m2 ? s2.lastIndexOf("@") : s2.lastIndexOf("@", m2)) && (p2 = s2.slice(0, f2), s2 = s2.slice(f2 + 1), this.auth = decodeURIComponent(p2)), m2 = -1;
            for (g2 = 0; g2 < I.length; g2++) {
              var v2;
              -1 !== (v2 = s2.indexOf(I[g2])) && (-1 === m2 || v2 < m2) && (m2 = v2);
            }
            -1 === m2 && (m2 = s2.length), this.host = s2.slice(0, m2), s2 = s2.slice(m2), this.parseHost(), this.hostname = this.hostname || "";
            var _2 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!_2) for (var y2 = this.hostname.split(/\./), b2 = (g2 = 0, y2.length); g2 < b2; g2++) {
              var T2 = y2[g2];
              if (T2 && !T2.match(O)) {
                for (var E2 = "", S2 = 0, A2 = T2.length; S2 < A2; S2++) T2.charCodeAt(S2) > 127 ? E2 += "x" : E2 += T2[S2];
                if (!E2.match(O)) {
                  var C2 = y2.slice(0, g2), B2 = y2.slice(g2 + 1), U2 = T2.match(N);
                  U2 && (C2.push(U2[1]), B2.unshift(U2[2])), B2.length && (s2 = "/" + B2.join(".") + s2), this.hostname = C2.join(".");
                  break;
                }
              }
            }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), _2 || (this.hostname = c.toASCII(this.hostname));
            var k2 = this.port ? ":" + this.port : "", G2 = this.hostname || "";
            this.host = G2 + k2, this.href += this.host, _2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== s2[0] && (s2 = "/" + s2));
          }
          if (!L[h2]) for (g2 = 0, b2 = R.length; g2 < b2; g2++) {
            var H2 = R[g2];
            if (-1 !== s2.indexOf(H2)) {
              var j2 = encodeURIComponent(H2);
              j2 === H2 && (j2 = escape(H2)), s2 = s2.split(H2).join(j2);
            }
          }
          var z2 = s2.indexOf("#");
          -1 !== z2 && (this.hash = s2.substr(z2), s2 = s2.slice(0, z2));
          var V2 = s2.indexOf("?");
          if (-1 !== V2 ? (this.search = s2.substr(V2), this.query = s2.substr(V2 + 1), e2 && (this.query = x.parse(this.query)), s2 = s2.slice(0, V2)) : e2 && (this.search = "", this.query = {}), s2 && (this.pathname = s2), F[h2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            k2 = this.pathname || "";
            var X2 = this.search || "";
            this.path = k2 + X2;
          }
          return this.href = this.format(), this;
        }, S.prototype.format = function() {
          var t3 = this.auth || "";
          t3 && (t3 = (t3 = encodeURIComponent(t3)).replace(/%3A/i, ":"), t3 += "@");
          var e2 = this.protocol || "", i2 = this.pathname || "", n2 = this.hash || "", r2 = false, o2 = "";
          this.host ? r2 = t3 + this.host : this.hostname && (r2 = t3 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r2 += ":" + this.port)), this.query && p(this.query) && Object.keys(this.query).length && (o2 = x.stringify(this.query));
          var s2 = this.search || o2 && "?" + o2 || "";
          return e2 && ":" !== e2.substr(-1) && (e2 += ":"), this.slashes || (!e2 || F[e2]) && false !== r2 ? (r2 = "//" + (r2 || ""), i2 && "/" !== i2.charAt(0) && (i2 = "/" + i2)) : r2 || (r2 = ""), n2 && "#" !== n2.charAt(0) && (n2 = "#" + n2), s2 && "?" !== s2.charAt(0) && (s2 = "?" + s2), e2 + r2 + (i2 = i2.replace(/[?#]/g, function(t4) {
            return encodeURIComponent(t4);
          })) + (s2 = s2.replace("#", "%23")) + n2;
        }, S.prototype.resolve = function(t3) {
          return this.resolveObject(B(t3, false, true)).format();
        }, S.prototype.resolveObject = function(t3) {
          if (d(t3)) {
            var e2 = new S();
            e2.parse(t3, false, true), t3 = e2;
          }
          for (var i2 = new S(), n2 = Object.keys(this), r2 = 0; r2 < n2.length; r2++) {
            var o2 = n2[r2];
            i2[o2] = this[o2];
          }
          if (i2.hash = t3.hash, "" === t3.href) return i2.href = i2.format(), i2;
          if (t3.slashes && !t3.protocol) {
            for (var s2 = Object.keys(t3), a2 = 0; a2 < s2.length; a2++) {
              var l2 = s2[a2];
              "protocol" !== l2 && (i2[l2] = t3[l2]);
            }
            return F[i2.protocol] && i2.hostname && !i2.pathname && (i2.path = i2.pathname = "/"), i2.href = i2.format(), i2;
          }
          if (t3.protocol && t3.protocol !== i2.protocol) {
            if (!F[t3.protocol]) {
              for (var h2 = Object.keys(t3), u2 = 0; u2 < h2.length; u2++) {
                var c2 = h2[u2];
                i2[c2] = t3[c2];
              }
              return i2.href = i2.format(), i2;
            }
            if (i2.protocol = t3.protocol, t3.host || D[t3.protocol]) i2.pathname = t3.pathname;
            else {
              for (var p2 = (t3.pathname || "").split("/"); p2.length && !(t3.host = p2.shift()); ) ;
              t3.host || (t3.host = ""), t3.hostname || (t3.hostname = ""), "" !== p2[0] && p2.unshift(""), p2.length < 2 && p2.unshift(""), i2.pathname = p2.join("/");
            }
            if (i2.search = t3.search, i2.query = t3.query, i2.host = t3.host || "", i2.auth = t3.auth, i2.hostname = t3.hostname || t3.host, i2.port = t3.port, i2.pathname || i2.search) {
              var g2 = i2.pathname || "", v2 = i2.search || "";
              i2.path = g2 + v2;
            }
            return i2.slashes = i2.slashes || t3.slashes, i2.href = i2.format(), i2;
          }
          var _2 = i2.pathname && "/" === i2.pathname.charAt(0), y2 = t3.host || t3.pathname && "/" === t3.pathname.charAt(0), x2 = y2 || _2 || i2.host && t3.pathname, b2 = x2, T2 = i2.pathname && i2.pathname.split("/") || [], E2 = (p2 = t3.pathname && t3.pathname.split("/") || [], i2.protocol && !F[i2.protocol]);
          if (E2 && (i2.hostname = "", i2.port = null, i2.host && ("" === T2[0] ? T2[0] = i2.host : T2.unshift(i2.host)), i2.host = "", t3.protocol && (t3.hostname = null, t3.port = null, t3.host && ("" === p2[0] ? p2[0] = t3.host : p2.unshift(t3.host)), t3.host = null), x2 = x2 && ("" === p2[0] || "" === T2[0])), y2) i2.host = t3.host || "" === t3.host ? t3.host : i2.host, i2.hostname = t3.hostname || "" === t3.hostname ? t3.hostname : i2.hostname, i2.search = t3.search, i2.query = t3.query, T2 = p2;
          else if (p2.length) T2 || (T2 = []), T2.pop(), T2 = T2.concat(p2), i2.search = t3.search, i2.query = t3.query;
          else if (!m(t3.search)) {
            if (E2) i2.hostname = i2.host = T2.shift(), (R2 = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = R2.shift(), i2.host = i2.hostname = R2.shift());
            return i2.search = t3.search, i2.query = t3.query, f(i2.pathname) && f(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.href = i2.format(), i2;
          }
          if (!T2.length) return i2.pathname = null, i2.search ? i2.path = "/" + i2.search : i2.path = null, i2.href = i2.format(), i2;
          for (var w2 = T2.slice(-1)[0], A2 = (i2.host || t3.host || T2.length > 1) && ("." === w2 || ".." === w2) || "" === w2, M2 = 0, C2 = T2.length; C2 >= 0; C2--) "." === (w2 = T2[C2]) ? T2.splice(C2, 1) : ".." === w2 ? (T2.splice(C2, 1), M2++) : M2 && (T2.splice(C2, 1), M2--);
          if (!x2 && !b2) for (; M2--; M2) T2.unshift("..");
          !x2 || "" === T2[0] || T2[0] && "/" === T2[0].charAt(0) || T2.unshift(""), A2 && "/" !== T2.join("/").substr(-1) && T2.push("");
          var R2, I2 = "" === T2[0] || T2[0] && "/" === T2[0].charAt(0);
          E2 && (i2.hostname = i2.host = I2 ? "" : T2.length ? T2.shift() : "", (R2 = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = R2.shift(), i2.host = i2.hostname = R2.shift()));
          return (x2 = x2 || i2.host && T2.length) && !I2 && T2.unshift(""), T2.length ? i2.pathname = T2.join("/") : (i2.pathname = null, i2.path = null), f(i2.pathname) && f(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.auth = t3.auth || i2.auth, i2.slashes = i2.slashes || t3.slashes, i2.href = i2.format(), i2;
        }, S.prototype.parseHost = function() {
          var t3 = this.host, e2 = A.exec(t3);
          e2 && (":" !== (e2 = e2[0]) && (this.port = e2.substr(1)), t3 = t3.substr(0, t3.length - e2.length)), t3 && (this.hostname = t3);
        };
        var U = { parse: b, format: E, resolve: T };
        n.b.RETINA_PREFIX = /@([0-9\.]+)x/, n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
        var k, G = false;
        var H = function() {
          for (var t3 = [], e2 = [], i2 = 0; i2 < 32; i2++) t3[i2] = i2, e2[i2] = i2;
          t3[r.b.NORMAL_NPM] = r.b.NORMAL, t3[r.b.ADD_NPM] = r.b.ADD, t3[r.b.SCREEN_NPM] = r.b.SCREEN, e2[r.b.NORMAL] = r.b.NORMAL_NPM, e2[r.b.ADD] = r.b.ADD_NPM, e2[r.b.SCREEN] = r.b.SCREEN_NPM;
          var n2 = [];
          return n2.push(e2), n2.push(t3), n2;
        }();
        function j(t3) {
          if (4 === t3.BYTES_PER_ELEMENT) return t3 instanceof Float32Array ? "Float32Array" : t3 instanceof Uint32Array ? "Uint32Array" : "Int32Array";
          if (2 === t3.BYTES_PER_ELEMENT) {
            if (t3 instanceof Uint16Array) return "Uint16Array";
          } else if (1 === t3.BYTES_PER_ELEMENT && t3 instanceof Uint8Array) return "Uint8Array";
          return null;
        }
        function z(t3) {
          return t3 += 0 === t3 ? 1 : 0, --t3, t3 |= t3 >>> 1, t3 |= t3 >>> 2, t3 |= t3 >>> 4, t3 |= t3 >>> 8, (t3 |= t3 >>> 16) + 1;
        }
        function V(t3) {
          return !(t3 & t3 - 1 || !t3);
        }
        function X(t3) {
          var e2 = (t3 > 65535 ? 1 : 0) << 4, i2 = ((t3 >>>= e2) > 255 ? 1 : 0) << 3;
          return e2 |= i2, e2 |= i2 = ((t3 >>>= i2) > 15 ? 1 : 0) << 2, (e2 |= i2 = ((t3 >>>= i2) > 3 ? 1 : 0) << 1) | (t3 >>>= i2) >> 1;
        }
        var W = 0;
        function Y() {
          return ++W;
        }
        var q = {};
        function Z(t3, e2, i2) {
          if (void 0 === i2 && (i2 = 3), !q[e2]) {
            var n2 = new Error().stack;
            void 0 === n2 ? console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t3) : (n2 = n2.split("\n").splice(i2).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e2 + "\nDeprecated since v" + t3), console.warn(n2), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e2 + "\nDeprecated since v" + t3), console.warn(n2))), q[e2] = true;
          }
        }
        var J, K = {}, Q = /* @__PURE__ */ Object.create(null), $ = /* @__PURE__ */ Object.create(null);
        function tt(t3, e2) {
          if (void 0 === e2 && (e2 = globalThis.location), 0 === t3.indexOf("data:")) return "";
          e2 = e2 || globalThis.location, J || (J = document.createElement("a")), J.href = t3;
          var i2 = U.parse(J.href), n2 = !i2.port && "" === e2.port || i2.port === e2.port;
          return i2.hostname === e2.hostname && n2 && i2.protocol === e2.protocol ? "" : "anonymous";
        }
        function et(t3, e2) {
          var i2 = n.b.RETINA_PREFIX.exec(t3);
          return i2 ? parseFloat(i2[1]) : void 0 !== e2 ? e2 : 1;
        }
        !function() {
          function t3(t4, e2, i2) {
            this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = i2 || n.b.RESOLUTION, this.resize(t4, e2);
          }
          t3.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          }, t3.prototype.resize = function(t4, e2) {
            this.canvas.width = Math.round(t4 * this.resolution), this.canvas.height = Math.round(e2 * this.resolution);
          }, t3.prototype.destroy = function() {
            this.context = null, this.canvas = null;
          }, Object.defineProperty(t3.prototype, "width", { get: function() {
            return this.canvas.width;
          }, set: function(t4) {
            this.canvas.width = Math.round(t4);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
            return this.canvas.height;
          }, set: function(t4) {
            this.canvas.height = Math.round(t4);
          }, enumerable: false, configurable: true });
        }();
        var it, nt = function() {
          function t3(t4) {
            this.items = [], this._name = t4, this._aliasCount = 0;
          }
          return t3.prototype.emit = function(t4, e2, i2, n2, r2, o2, s2, a2) {
            if (arguments.length > 8) throw new Error("max arguments reached");
            var l2 = this, h2 = l2.name, u2 = l2.items;
            this._aliasCount++;
            for (var c2 = 0, d2 = u2.length; c2 < d2; c2++) u2[c2][h2](t4, e2, i2, n2, r2, o2, s2, a2);
            return u2 === this.items && this._aliasCount--, this;
          }, t3.prototype.ensureNonAliasedItems = function() {
            this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
          }, t3.prototype.add = function(t4) {
            return t4[this._name] && (this.ensureNonAliasedItems(), this.remove(t4), this.items.push(t4)), this;
          }, t3.prototype.remove = function(t4) {
            var e2 = this.items.indexOf(t4);
            return -1 !== e2 && (this.ensureNonAliasedItems(), this.items.splice(e2, 1)), this;
          }, t3.prototype.contains = function(t4) {
            return -1 !== this.items.indexOf(t4);
          }, t3.prototype.removeAll = function() {
            return this.ensureNonAliasedItems(), this.items.length = 0, this;
          }, t3.prototype.destroy = function() {
            this.removeAll(), this.items = null, this._name = null;
          }, Object.defineProperty(t3.prototype, "empty", { get: function() {
            return 0 === this.items.length;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "name", { get: function() {
            return this._name;
          }, enumerable: false, configurable: true }), t3;
        }();
        Object.defineProperties(nt.prototype, { dispatch: { value: nt.prototype.emit }, run: { value: nt.prototype.emit } }), /*!
         * @pixi/ticker - v6.4.2
         * Compiled Thu, 02 Jun 2022 15:39:26 UTC
         *
         * @pixi/ticker is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        n.b.TARGET_FPMS = 0.06, function(t3) {
          t3[t3.INTERACTION = 50] = "INTERACTION", t3[t3.HIGH = 25] = "HIGH", t3[t3.NORMAL = 0] = "NORMAL", t3[t3.LOW = -25] = "LOW", t3[t3.UTILITY = -50] = "UTILITY";
        }(it || (it = {}));
        var rt, ot = function() {
          function t3(t4, e2, i2, n2) {
            void 0 === e2 && (e2 = null), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = false), this.next = null, this.previous = null, this._destroyed = false, this.fn = t4, this.context = e2, this.priority = i2, this.once = n2;
          }
          return t3.prototype.match = function(t4, e2) {
            return void 0 === e2 && (e2 = null), this.fn === t4 && this.context === e2;
          }, t3.prototype.emit = function(t4) {
            this.fn && (this.context ? this.fn.call(this.context, t4) : this.fn(t4));
            var e2 = this.next;
            return this.once && this.destroy(true), this._destroyed && (this.next = null), e2;
          }, t3.prototype.connect = function(t4) {
            this.previous = t4, t4.next && (t4.next.previous = this), this.next = t4.next, t4.next = this;
          }, t3.prototype.destroy = function(t4) {
            void 0 === t4 && (t4 = false), this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
            var e2 = this.next;
            return this.next = t4 ? null : e2, this.previous = null, e2;
          }, t3;
        }(), st = function() {
          function t3() {
            var t4 = this;
            this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new ot(null, null, 1 / 0), this.deltaMS = 1 / n.b.TARGET_FPMS, this.elapsedMS = 1 / n.b.TARGET_FPMS, this._tick = function(e2) {
              t4._requestId = null, t4.started && (t4.update(e2), t4.started && null === t4._requestId && t4._head.next && (t4._requestId = requestAnimationFrame(t4._tick)));
            };
          }
          return t3.prototype._requestIfNeeded = function() {
            null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
          }, t3.prototype._cancelIfNeeded = function() {
            null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null);
          }, t3.prototype._startIfPossible = function() {
            this.started ? this._requestIfNeeded() : this.autoStart && this.start();
          }, t3.prototype.add = function(t4, e2, i2) {
            return void 0 === i2 && (i2 = it.NORMAL), this._addListener(new ot(t4, e2, i2));
          }, t3.prototype.addOnce = function(t4, e2, i2) {
            return void 0 === i2 && (i2 = it.NORMAL), this._addListener(new ot(t4, e2, i2, true));
          }, t3.prototype._addListener = function(t4) {
            var e2 = this._head.next, i2 = this._head;
            if (e2) {
              for (; e2; ) {
                if (t4.priority > e2.priority) {
                  t4.connect(i2);
                  break;
                }
                i2 = e2, e2 = e2.next;
              }
              t4.previous || t4.connect(i2);
            } else t4.connect(i2);
            return this._startIfPossible(), this;
          }, t3.prototype.remove = function(t4, e2) {
            for (var i2 = this._head.next; i2; ) i2 = i2.match(t4, e2) ? i2.destroy() : i2.next;
            return this._head.next || this._cancelIfNeeded(), this;
          }, Object.defineProperty(t3.prototype, "count", { get: function() {
            if (!this._head) return 0;
            for (var t4 = 0, e2 = this._head; e2 = e2.next; ) t4++;
            return t4;
          }, enumerable: false, configurable: true }), t3.prototype.start = function() {
            this.started || (this.started = true, this._requestIfNeeded());
          }, t3.prototype.stop = function() {
            this.started && (this.started = false, this._cancelIfNeeded());
          }, t3.prototype.destroy = function() {
            if (!this._protected) {
              this.stop();
              for (var t4 = this._head.next; t4; ) t4 = t4.destroy(true);
              this._head.destroy(), this._head = null;
            }
          }, t3.prototype.update = function(t4) {
            var e2;
            if (void 0 === t4 && (t4 = performance.now()), t4 > this.lastTime) {
              if ((e2 = this.elapsedMS = t4 - this.lastTime) > this._maxElapsedMS && (e2 = this._maxElapsedMS), e2 *= this.speed, this._minElapsedMS) {
                var i2 = t4 - this._lastFrame | 0;
                if (i2 < this._minElapsedMS) return;
                this._lastFrame = t4 - i2 % this._minElapsedMS;
              }
              this.deltaMS = e2, this.deltaTime = this.deltaMS * n.b.TARGET_FPMS;
              for (var r2 = this._head, o2 = r2.next; o2; ) o2 = o2.emit(this.deltaTime);
              r2.next || this._cancelIfNeeded();
            } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = t4;
          }, Object.defineProperty(t3.prototype, "FPS", { get: function() {
            return 1e3 / this.elapsedMS;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "minFPS", { get: function() {
            return 1e3 / this._maxElapsedMS;
          }, set: function(t4) {
            var e2 = Math.min(this.maxFPS, t4), i2 = Math.min(Math.max(0, e2) / 1e3, n.b.TARGET_FPMS);
            this._maxElapsedMS = 1 / i2;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "maxFPS", { get: function() {
            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
          }, set: function(t4) {
            if (0 === t4) this._minElapsedMS = 0;
            else {
              var e2 = Math.max(this.minFPS, t4);
              this._minElapsedMS = 1 / (e2 / 1e3);
            }
          }, enumerable: false, configurable: true }), Object.defineProperty(t3, "shared", { get: function() {
            if (!t3._shared) {
              var e2 = t3._shared = new t3();
              e2.autoStart = true, e2._protected = true;
            }
            return t3._shared;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3, "system", { get: function() {
            if (!t3._system) {
              var e2 = t3._system = new t3();
              e2.autoStart = true, e2._protected = true;
            }
            return t3._system;
          }, enumerable: false, configurable: true }), t3;
        }(), at = 2 * Math.PI;
        !function(t3) {
          t3[t3.POLY = 0] = "POLY", t3[t3.RECT = 1] = "RECT", t3[t3.CIRC = 2] = "CIRC", t3[t3.ELIP = 3] = "ELIP", t3[t3.RREC = 4] = "RREC";
        }(rt || (rt = {}));
        var lt = function() {
          function t3(t4, e2) {
            void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = 0), this.x = 0, this.y = 0, this.x = t4, this.y = e2;
          }
          return t3.prototype.clone = function() {
            return new t3(this.x, this.y);
          }, t3.prototype.copyFrom = function(t4) {
            return this.set(t4.x, t4.y), this;
          }, t3.prototype.copyTo = function(t4) {
            return t4.set(this.x, this.y), t4;
          }, t3.prototype.equals = function(t4) {
            return t4.x === this.x && t4.y === this.y;
          }, t3.prototype.set = function(t4, e2) {
            return void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = t4), this.x = t4, this.y = e2, this;
          }, t3.prototype.toString = function() {
            return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
          }, t3;
        }(), ht = [new lt(), new lt(), new lt(), new lt()], ut = function() {
          function t3(t4, e2, i2, n2) {
            void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 0), this.x = Number(t4), this.y = Number(e2), this.width = Number(i2), this.height = Number(n2), this.type = rt.RECT;
          }
          return Object.defineProperty(t3.prototype, "left", { get: function() {
            return this.x;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "right", { get: function() {
            return this.x + this.width;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "top", { get: function() {
            return this.y;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "bottom", { get: function() {
            return this.y + this.height;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3, "EMPTY", { get: function() {
            return new t3(0, 0, 0, 0);
          }, enumerable: false, configurable: true }), t3.prototype.clone = function() {
            return new t3(this.x, this.y, this.width, this.height);
          }, t3.prototype.copyFrom = function(t4) {
            return this.x = t4.x, this.y = t4.y, this.width = t4.width, this.height = t4.height, this;
          }, t3.prototype.copyTo = function(t4) {
            return t4.x = this.x, t4.y = this.y, t4.width = this.width, t4.height = this.height, t4;
          }, t3.prototype.contains = function(t4, e2) {
            return !(this.width <= 0 || this.height <= 0) && (t4 >= this.x && t4 < this.x + this.width && e2 >= this.y && e2 < this.y + this.height);
          }, t3.prototype.intersects = function(t4, e2) {
            if (!e2) {
              var i2 = this.x < t4.x ? t4.x : this.x;
              if ((this.right > t4.right ? t4.right : this.right) <= i2) return false;
              var n2 = this.y < t4.y ? t4.y : this.y;
              return (this.bottom > t4.bottom ? t4.bottom : this.bottom) > n2;
            }
            var r2 = this.left, o2 = this.right, s2 = this.top, a2 = this.bottom;
            if (o2 <= r2 || a2 <= s2) return false;
            var l2 = ht[0].set(t4.left, t4.top), h2 = ht[1].set(t4.left, t4.bottom), u2 = ht[2].set(t4.right, t4.top), c2 = ht[3].set(t4.right, t4.bottom);
            if (u2.x <= l2.x || h2.y <= l2.y) return false;
            var d2 = Math.sign(e2.a * e2.d - e2.b * e2.c);
            if (0 === d2) return false;
            if (e2.apply(l2, l2), e2.apply(h2, h2), e2.apply(u2, u2), e2.apply(c2, c2), Math.max(l2.x, h2.x, u2.x, c2.x) <= r2 || Math.min(l2.x, h2.x, u2.x, c2.x) >= o2 || Math.max(l2.y, h2.y, u2.y, c2.y) <= s2 || Math.min(l2.y, h2.y, u2.y, c2.y) >= a2) return false;
            var p2 = d2 * (h2.y - l2.y), f2 = d2 * (l2.x - h2.x), m2 = p2 * r2 + f2 * s2, g2 = p2 * o2 + f2 * s2, v2 = p2 * r2 + f2 * a2, _2 = p2 * o2 + f2 * a2;
            if (Math.max(m2, g2, v2, _2) <= p2 * l2.x + f2 * l2.y || Math.min(m2, g2, v2, _2) >= p2 * c2.x + f2 * c2.y) return false;
            var y2 = d2 * (l2.y - u2.y), x2 = d2 * (u2.x - l2.x), b2 = y2 * r2 + x2 * s2, T2 = y2 * o2 + x2 * s2, E2 = y2 * r2 + x2 * a2, S2 = y2 * o2 + x2 * a2;
            return !(Math.max(b2, T2, E2, S2) <= y2 * l2.x + x2 * l2.y || Math.min(b2, T2, E2, S2) >= y2 * c2.x + x2 * c2.y);
          }, t3.prototype.pad = function(t4, e2) {
            return void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = t4), this.x -= t4, this.y -= e2, this.width += 2 * t4, this.height += 2 * e2, this;
          }, t3.prototype.fit = function(t4) {
            var e2 = Math.max(this.x, t4.x), i2 = Math.min(this.x + this.width, t4.x + t4.width), n2 = Math.max(this.y, t4.y), r2 = Math.min(this.y + this.height, t4.y + t4.height);
            return this.x = e2, this.width = Math.max(i2 - e2, 0), this.y = n2, this.height = Math.max(r2 - n2, 0), this;
          }, t3.prototype.ceil = function(t4, e2) {
            void 0 === t4 && (t4 = 1), void 0 === e2 && (e2 = 1e-3);
            var i2 = Math.ceil((this.x + this.width - e2) * t4) / t4, n2 = Math.ceil((this.y + this.height - e2) * t4) / t4;
            return this.x = Math.floor((this.x + e2) * t4) / t4, this.y = Math.floor((this.y + e2) * t4) / t4, this.width = i2 - this.x, this.height = n2 - this.y, this;
          }, t3.prototype.enlarge = function(t4) {
            var e2 = Math.min(this.x, t4.x), i2 = Math.max(this.x + this.width, t4.x + t4.width), n2 = Math.min(this.y, t4.y), r2 = Math.max(this.y + this.height, t4.y + t4.height);
            return this.x = e2, this.width = i2 - e2, this.y = n2, this.height = r2 - n2, this;
          }, t3.prototype.toString = function() {
            return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
          }, t3;
        }(), ct = function() {
          function t3(t4, e2, i2, n2) {
            void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 0), this._x = i2, this._y = n2, this.cb = t4, this.scope = e2;
          }
          return t3.prototype.clone = function(e2, i2) {
            return void 0 === e2 && (e2 = this.cb), void 0 === i2 && (i2 = this.scope), new t3(e2, i2, this._x, this._y);
          }, t3.prototype.set = function(t4, e2) {
            return void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = t4), this._x === t4 && this._y === e2 || (this._x = t4, this._y = e2, this.cb.call(this.scope)), this;
          }, t3.prototype.copyFrom = function(t4) {
            return this._x === t4.x && this._y === t4.y || (this._x = t4.x, this._y = t4.y, this.cb.call(this.scope)), this;
          }, t3.prototype.copyTo = function(t4) {
            return t4.set(this._x, this._y), t4;
          }, t3.prototype.equals = function(t4) {
            return t4.x === this._x && t4.y === this._y;
          }, t3.prototype.toString = function() {
            return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
          }, Object.defineProperty(t3.prototype, "x", { get: function() {
            return this._x;
          }, set: function(t4) {
            this._x !== t4 && (this._x = t4, this.cb.call(this.scope));
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "y", { get: function() {
            return this._y;
          }, set: function(t4) {
            this._y !== t4 && (this._y = t4, this.cb.call(this.scope));
          }, enumerable: false, configurable: true }), t3;
        }(), dt = function() {
          function t3(t4, e2, i2, n2, r2, o2) {
            void 0 === t4 && (t4 = 1), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), this.array = null, this.a = t4, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2;
          }
          return t3.prototype.fromArray = function(t4) {
            this.a = t4[0], this.b = t4[1], this.c = t4[3], this.d = t4[4], this.tx = t4[2], this.ty = t4[5];
          }, t3.prototype.set = function(t4, e2, i2, n2, r2, o2) {
            return this.a = t4, this.b = e2, this.c = i2, this.d = n2, this.tx = r2, this.ty = o2, this;
          }, t3.prototype.toArray = function(t4, e2) {
            this.array || (this.array = new Float32Array(9));
            var i2 = e2 || this.array;
            return t4 ? (i2[0] = this.a, i2[1] = this.b, i2[2] = 0, i2[3] = this.c, i2[4] = this.d, i2[5] = 0, i2[6] = this.tx, i2[7] = this.ty, i2[8] = 1) : (i2[0] = this.a, i2[1] = this.c, i2[2] = this.tx, i2[3] = this.b, i2[4] = this.d, i2[5] = this.ty, i2[6] = 0, i2[7] = 0, i2[8] = 1), i2;
          }, t3.prototype.apply = function(t4, e2) {
            e2 = e2 || new lt();
            var i2 = t4.x, n2 = t4.y;
            return e2.x = this.a * i2 + this.c * n2 + this.tx, e2.y = this.b * i2 + this.d * n2 + this.ty, e2;
          }, t3.prototype.applyInverse = function(t4, e2) {
            e2 = e2 || new lt();
            var i2 = 1 / (this.a * this.d + this.c * -this.b), n2 = t4.x, r2 = t4.y;
            return e2.x = this.d * i2 * n2 + -this.c * i2 * r2 + (this.ty * this.c - this.tx * this.d) * i2, e2.y = this.a * i2 * r2 + -this.b * i2 * n2 + (-this.ty * this.a + this.tx * this.b) * i2, e2;
          }, t3.prototype.translate = function(t4, e2) {
            return this.tx += t4, this.ty += e2, this;
          }, t3.prototype.scale = function(t4, e2) {
            return this.a *= t4, this.d *= e2, this.c *= t4, this.b *= e2, this.tx *= t4, this.ty *= e2, this;
          }, t3.prototype.rotate = function(t4) {
            var e2 = Math.cos(t4), i2 = Math.sin(t4), n2 = this.a, r2 = this.c, o2 = this.tx;
            return this.a = n2 * e2 - this.b * i2, this.b = n2 * i2 + this.b * e2, this.c = r2 * e2 - this.d * i2, this.d = r2 * i2 + this.d * e2, this.tx = o2 * e2 - this.ty * i2, this.ty = o2 * i2 + this.ty * e2, this;
          }, t3.prototype.append = function(t4) {
            var e2 = this.a, i2 = this.b, n2 = this.c, r2 = this.d;
            return this.a = t4.a * e2 + t4.b * n2, this.b = t4.a * i2 + t4.b * r2, this.c = t4.c * e2 + t4.d * n2, this.d = t4.c * i2 + t4.d * r2, this.tx = t4.tx * e2 + t4.ty * n2 + this.tx, this.ty = t4.tx * i2 + t4.ty * r2 + this.ty, this;
          }, t3.prototype.setTransform = function(t4, e2, i2, n2, r2, o2, s2, a2, l2) {
            return this.a = Math.cos(s2 + l2) * r2, this.b = Math.sin(s2 + l2) * r2, this.c = -Math.sin(s2 - a2) * o2, this.d = Math.cos(s2 - a2) * o2, this.tx = t4 - (i2 * this.a + n2 * this.c), this.ty = e2 - (i2 * this.b + n2 * this.d), this;
          }, t3.prototype.prepend = function(t4) {
            var e2 = this.tx;
            if (1 !== t4.a || 0 !== t4.b || 0 !== t4.c || 1 !== t4.d) {
              var i2 = this.a, n2 = this.c;
              this.a = i2 * t4.a + this.b * t4.c, this.b = i2 * t4.b + this.b * t4.d, this.c = n2 * t4.a + this.d * t4.c, this.d = n2 * t4.b + this.d * t4.d;
            }
            return this.tx = e2 * t4.a + this.ty * t4.c + t4.tx, this.ty = e2 * t4.b + this.ty * t4.d + t4.ty, this;
          }, t3.prototype.decompose = function(t4) {
            var e2 = this.a, i2 = this.b, n2 = this.c, r2 = this.d, o2 = t4.pivot, s2 = -Math.atan2(-n2, r2), a2 = Math.atan2(i2, e2), l2 = Math.abs(s2 + a2);
            return l2 < 1e-5 || Math.abs(at - l2) < 1e-5 ? (t4.rotation = a2, t4.skew.x = t4.skew.y = 0) : (t4.rotation = 0, t4.skew.x = s2, t4.skew.y = a2), t4.scale.x = Math.sqrt(e2 * e2 + i2 * i2), t4.scale.y = Math.sqrt(n2 * n2 + r2 * r2), t4.position.x = this.tx + (o2.x * e2 + o2.y * n2), t4.position.y = this.ty + (o2.x * i2 + o2.y * r2), t4;
          }, t3.prototype.invert = function() {
            var t4 = this.a, e2 = this.b, i2 = this.c, n2 = this.d, r2 = this.tx, o2 = t4 * n2 - e2 * i2;
            return this.a = n2 / o2, this.b = -e2 / o2, this.c = -i2 / o2, this.d = t4 / o2, this.tx = (i2 * this.ty - n2 * r2) / o2, this.ty = -(t4 * this.ty - e2 * r2) / o2, this;
          }, t3.prototype.identity = function() {
            return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
          }, t3.prototype.clone = function() {
            var e2 = new t3();
            return e2.a = this.a, e2.b = this.b, e2.c = this.c, e2.d = this.d, e2.tx = this.tx, e2.ty = this.ty, e2;
          }, t3.prototype.copyTo = function(t4) {
            return t4.a = this.a, t4.b = this.b, t4.c = this.c, t4.d = this.d, t4.tx = this.tx, t4.ty = this.ty, t4;
          }, t3.prototype.copyFrom = function(t4) {
            return this.a = t4.a, this.b = t4.b, this.c = t4.c, this.d = t4.d, this.tx = t4.tx, this.ty = t4.ty, this;
          }, t3.prototype.toString = function() {
            return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
          }, Object.defineProperty(t3, "IDENTITY", { get: function() {
            return new t3();
          }, enumerable: false, configurable: true }), Object.defineProperty(t3, "TEMP_MATRIX", { get: function() {
            return new t3();
          }, enumerable: false, configurable: true }), t3;
        }(), pt = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], ft = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], mt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], gt = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], vt = [], _t = [], yt = Math.sign;
        !function() {
          for (var t3 = 0; t3 < 16; t3++) {
            var e2 = [];
            vt.push(e2);
            for (var i2 = 0; i2 < 16; i2++) for (var n2 = yt(pt[t3] * pt[i2] + mt[t3] * ft[i2]), r2 = yt(ft[t3] * pt[i2] + gt[t3] * ft[i2]), o2 = yt(pt[t3] * mt[i2] + mt[t3] * gt[i2]), s2 = yt(ft[t3] * mt[i2] + gt[t3] * gt[i2]), a2 = 0; a2 < 16; a2++) if (pt[a2] === n2 && ft[a2] === r2 && mt[a2] === o2 && gt[a2] === s2) {
              e2.push(a2);
              break;
            }
          }
          for (t3 = 0; t3 < 16; t3++) {
            var l2 = new dt();
            l2.set(pt[t3], ft[t3], mt[t3], gt[t3], 0, 0), _t.push(l2);
          }
        }();
        var xt = { E: 0, SE: 1, S: 2, SW: 3, W: 4, NW: 5, N: 6, NE: 7, MIRROR_VERTICAL: 8, MAIN_DIAGONAL: 10, MIRROR_HORIZONTAL: 12, REVERSE_DIAGONAL: 14, uX: function(t3) {
          return pt[t3];
        }, uY: function(t3) {
          return ft[t3];
        }, vX: function(t3) {
          return mt[t3];
        }, vY: function(t3) {
          return gt[t3];
        }, inv: function(t3) {
          return 8 & t3 ? 15 & t3 : 7 & -t3;
        }, add: function(t3, e2) {
          return vt[t3][e2];
        }, sub: function(t3, e2) {
          return vt[t3][xt.inv(e2)];
        }, rotate180: function(t3) {
          return 4 ^ t3;
        }, isVertical: function(t3) {
          return 2 == (3 & t3);
        }, byDirection: function(t3, e2) {
          return 2 * Math.abs(t3) <= Math.abs(e2) ? e2 >= 0 ? xt.S : xt.N : 2 * Math.abs(e2) <= Math.abs(t3) ? t3 > 0 ? xt.E : xt.W : e2 > 0 ? t3 > 0 ? xt.SE : xt.SW : t3 > 0 ? xt.NE : xt.NW;
        }, matrixAppendRotationInv: function(t3, e2, i2, n2) {
          void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = 0);
          var r2 = _t[xt.inv(e2)];
          r2.tx = i2, r2.ty = n2, t3.append(r2);
        } };
        !function() {
          function t3() {
            this.worldTransform = new dt(), this.localTransform = new dt(), this.position = new ct(this.onChange, this, 0, 0), this.scale = new ct(this.onChange, this, 1, 1), this.pivot = new ct(this.onChange, this, 0, 0), this.skew = new ct(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
          }
          t3.prototype.onChange = function() {
            this._localID++;
          }, t3.prototype.updateSkew = function() {
            this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
          }, t3.prototype.toString = function() {
            return "[@pixi/math:Transform position=(" + this.position.x + ", " + this.position.y + ") rotation=" + this.rotation + " scale=(" + this.scale.x + ", " + this.scale.y + ") skew=(" + this.skew.x + ", " + this.skew.y + ") ]";
          }, t3.prototype.updateLocalTransform = function() {
            var t4 = this.localTransform;
            this._localID !== this._currentLocalID && (t4.a = this._cx * this.scale.x, t4.b = this._sx * this.scale.x, t4.c = this._cy * this.scale.y, t4.d = this._sy * this.scale.y, t4.tx = this.position.x - (this.pivot.x * t4.a + this.pivot.y * t4.c), t4.ty = this.position.y - (this.pivot.x * t4.b + this.pivot.y * t4.d), this._currentLocalID = this._localID, this._parentID = -1);
          }, t3.prototype.updateTransform = function(t4) {
            var e2 = this.localTransform;
            if (this._localID !== this._currentLocalID && (e2.a = this._cx * this.scale.x, e2.b = this._sx * this.scale.x, e2.c = this._cy * this.scale.y, e2.d = this._sy * this.scale.y, e2.tx = this.position.x - (this.pivot.x * e2.a + this.pivot.y * e2.c), e2.ty = this.position.y - (this.pivot.x * e2.b + this.pivot.y * e2.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t4._worldID) {
              var i2 = t4.worldTransform, n2 = this.worldTransform;
              n2.a = e2.a * i2.a + e2.b * i2.c, n2.b = e2.a * i2.b + e2.b * i2.d, n2.c = e2.c * i2.a + e2.d * i2.c, n2.d = e2.c * i2.b + e2.d * i2.d, n2.tx = e2.tx * i2.a + e2.ty * i2.c + i2.tx, n2.ty = e2.tx * i2.b + e2.ty * i2.d + i2.ty, this._parentID = t4._worldID, this._worldID++;
            }
          }, t3.prototype.setFromMatrix = function(t4) {
            t4.decompose(this), this._localID++;
          }, Object.defineProperty(t3.prototype, "rotation", { get: function() {
            return this._rotation;
          }, set: function(t4) {
            this._rotation !== t4 && (this._rotation = t4, this.updateSkew());
          }, enumerable: false, configurable: true }), t3.IDENTITY = new t3();
        }(), /*!
         * @pixi/core - v6.4.2
         * Compiled Thu, 02 Jun 2022 15:39:26 UTC
         *
         * @pixi/core is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        n.b.PREFER_ENV = n.a.any ? r.g.WEBGL : r.g.WEBGL2, n.b.STRICT_TEXTURE_CACHE = false;
        var bt = [];
        function Tt(t3, e2) {
          if (!t3) return null;
          var i2 = "";
          if ("string" == typeof t3) {
            var n2 = /\.(\w{3,4})(?:$|\?|#)/i.exec(t3);
            n2 && (i2 = n2[1].toLowerCase());
          }
          for (var r2 = bt.length - 1; r2 >= 0; --r2) {
            var o2 = bt[r2];
            if (o2.test && o2.test(t3, i2)) return new o2(t3, e2);
          }
          throw new Error("Unrecognized source type to auto-detect Resource");
        }
        var Et = function(t3, e2) {
          return (Et = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
            t4.__proto__ = e3;
          } || function(t4, e3) {
            for (var i2 in e3) e3.hasOwnProperty(i2) && (t4[i2] = e3[i2]);
          })(t3, e2);
        };
        function St(t3, e2) {
          function i2() {
            this.constructor = t3;
          }
          Et(t3, e2), t3.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
        }
        var wt = function() {
          return (wt = Object.assign || function(t3) {
            for (var e2, i2 = arguments, n2 = 1, r2 = arguments.length; n2 < r2; n2++) for (var o2 in e2 = i2[n2]) Object.prototype.hasOwnProperty.call(e2, o2) && (t3[o2] = e2[o2]);
            return t3;
          }).apply(this, arguments);
        };
        var At = function() {
          function t3(t4, e2) {
            void 0 === t4 && (t4 = 0), void 0 === e2 && (e2 = 0), this._width = t4, this._height = e2, this.destroyed = false, this.internal = false, this.onResize = new nt("setRealSize"), this.onUpdate = new nt("update"), this.onError = new nt("onError");
          }
          return t3.prototype.bind = function(t4) {
            this.onResize.add(t4), this.onUpdate.add(t4), this.onError.add(t4), (this._width || this._height) && this.onResize.emit(this._width, this._height);
          }, t3.prototype.unbind = function(t4) {
            this.onResize.remove(t4), this.onUpdate.remove(t4), this.onError.remove(t4);
          }, t3.prototype.resize = function(t4, e2) {
            t4 === this._width && e2 === this._height || (this._width = t4, this._height = e2, this.onResize.emit(t4, e2));
          }, Object.defineProperty(t3.prototype, "valid", { get: function() {
            return !!this._width && !!this._height;
          }, enumerable: false, configurable: true }), t3.prototype.update = function() {
            this.destroyed || this.onUpdate.emit();
          }, t3.prototype.load = function() {
            return Promise.resolve(this);
          }, Object.defineProperty(t3.prototype, "width", { get: function() {
            return this._width;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
            return this._height;
          }, enumerable: false, configurable: true }), t3.prototype.style = function(t4, e2, i2) {
            return false;
          }, t3.prototype.dispose = function() {
          }, t3.prototype.destroy = function() {
            this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
          }, t3.test = function(t4, e2) {
            return false;
          }, t3;
        }(), Mt = function(t3) {
          function e2(e3, i2) {
            var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
            if (!o2 || !s2) throw new Error("BufferResource width or height invalid");
            return (n2 = t3.call(this, o2, s2) || this).data = e3, n2;
          }
          return St(e2, t3), e2.prototype.upload = function(t4, e3, i2) {
            var n2 = t4.gl;
            n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
            var o2 = e3.realWidth, s2 = e3.realHeight;
            return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
          }, e2.prototype.dispose = function() {
            this.data = null;
          }, e2.test = function(t4) {
            return t4 instanceof Float32Array || t4 instanceof Uint8Array || t4 instanceof Uint32Array;
          }, e2;
        }(At), Ct = { scaleMode: r.p.NEAREST, format: r.h.RGBA, alphaMode: r.a.NPM }, Rt = function(t3) {
          function e2(e3, i2) {
            void 0 === e3 && (e3 = null), void 0 === i2 && (i2 = null);
            var o2 = t3.call(this) || this, s2 = (i2 = i2 || {}).alphaMode, a2 = i2.mipmap, l2 = i2.anisotropicLevel, h2 = i2.scaleMode, u2 = i2.width, c2 = i2.height, d2 = i2.wrapMode, p2 = i2.format, f2 = i2.type, m2 = i2.target, g2 = i2.resolution, v2 = i2.resourceOptions;
            return !e3 || e3 instanceof At || ((e3 = Tt(e3, v2)).internal = true), o2.resolution = g2 || n.b.RESOLUTION, o2.width = Math.round((u2 || 0) * o2.resolution) / o2.resolution, o2.height = Math.round((c2 || 0) * o2.resolution) / o2.resolution, o2._mipmap = void 0 !== a2 ? a2 : n.b.MIPMAP_TEXTURES, o2.anisotropicLevel = void 0 !== l2 ? l2 : n.b.ANISOTROPIC_LEVEL, o2._wrapMode = d2 || n.b.WRAP_MODE, o2._scaleMode = void 0 !== h2 ? h2 : n.b.SCALE_MODE, o2.format = p2 || r.h.RGBA, o2.type = f2 || r.r.UNSIGNED_BYTE, o2.target = m2 || r.q.TEXTURE_2D, o2.alphaMode = void 0 !== s2 ? s2 : r.a.UNPACK, o2.uid = Y(), o2.touched = 0, o2.isPowerOfTwo = false, o2._refreshPOT(), o2._glTextures = {}, o2.dirtyId = 0, o2.dirtyStyleId = 0, o2.cacheId = null, o2.valid = u2 > 0 && c2 > 0, o2.textureCacheIds = [], o2.destroyed = false, o2.resource = null, o2._batchEnabled = 0, o2._batchLocation = 0, o2.parentTextureArray = null, o2.setResource(e3), o2;
          }
          return St(e2, t3), Object.defineProperty(e2.prototype, "realWidth", { get: function() {
            return Math.round(this.width * this.resolution);
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "realHeight", { get: function() {
            return Math.round(this.height * this.resolution);
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mipmap", { get: function() {
            return this._mipmap;
          }, set: function(t4) {
            this._mipmap !== t4 && (this._mipmap = t4, this.dirtyStyleId++);
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scaleMode", { get: function() {
            return this._scaleMode;
          }, set: function(t4) {
            this._scaleMode !== t4 && (this._scaleMode = t4, this.dirtyStyleId++);
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "wrapMode", { get: function() {
            return this._wrapMode;
          }, set: function(t4) {
            this._wrapMode !== t4 && (this._wrapMode = t4, this.dirtyStyleId++);
          }, enumerable: false, configurable: true }), e2.prototype.setStyle = function(t4, e3) {
            var i2;
            return void 0 !== t4 && t4 !== this.scaleMode && (this.scaleMode = t4, i2 = true), void 0 !== e3 && e3 !== this.mipmap && (this.mipmap = e3, i2 = true), i2 && this.dirtyStyleId++, this;
          }, e2.prototype.setSize = function(t4, e3, i2) {
            return i2 = i2 || this.resolution, this.setRealSize(t4 * i2, e3 * i2, i2);
          }, e2.prototype.setRealSize = function(t4, e3, i2) {
            return this.resolution = i2 || this.resolution, this.width = Math.round(t4) / this.resolution, this.height = Math.round(e3) / this.resolution, this._refreshPOT(), this.update(), this;
          }, e2.prototype._refreshPOT = function() {
            this.isPowerOfTwo = V(this.realWidth) && V(this.realHeight);
          }, e2.prototype.setResolution = function(t4) {
            var e3 = this.resolution;
            return e3 === t4 || (this.resolution = t4, this.valid && (this.width = Math.round(this.width * e3) / t4, this.height = Math.round(this.height * e3) / t4, this.emit("update", this)), this._refreshPOT()), this;
          }, e2.prototype.setResource = function(t4) {
            if (this.resource === t4) return this;
            if (this.resource) throw new Error("Resource can be set only once");
            return t4.bind(this), this.resource = t4, this;
          }, e2.prototype.update = function() {
            this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
          }, e2.prototype.onError = function(t4) {
            this.emit("error", this, t4);
          }, e2.prototype.destroy = function() {
            this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete $[this.cacheId], delete Q[this.cacheId], this.cacheId = null), this.dispose(), e2.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true;
          }, e2.prototype.dispose = function() {
            this.emit("dispose", this);
          }, e2.prototype.castToBaseTexture = function() {
            return this;
          }, e2.from = function(t4, i2, r2) {
            void 0 === r2 && (r2 = n.b.STRICT_TEXTURE_CACHE);
            var o2 = "string" == typeof t4, s2 = null;
            if (o2) s2 = t4;
            else {
              if (!t4._pixiId) {
                var a2 = i2 && i2.pixiIdPrefix || "pixiid";
                t4._pixiId = a2 + "_" + Y();
              }
              s2 = t4._pixiId;
            }
            var l2 = $[s2];
            if (o2 && r2 && !l2) throw new Error('The cacheId "' + s2 + '" does not exist in BaseTextureCache.');
            return l2 || ((l2 = new e2(t4, i2)).cacheId = s2, e2.addToCache(l2, s2)), l2;
          }, e2.fromBuffer = function(t4, i2, n2, o2) {
            t4 = t4 || new Float32Array(i2 * n2 * 4);
            var s2 = new Mt(t4, { width: i2, height: n2 }), a2 = t4 instanceof Float32Array ? r.r.FLOAT : r.r.UNSIGNED_BYTE;
            return new e2(s2, Object.assign(Ct, o2 || { width: i2, height: n2, type: a2 }));
          }, e2.addToCache = function(t4, e3) {
            e3 && (-1 === t4.textureCacheIds.indexOf(e3) && t4.textureCacheIds.push(e3), $[e3] && console.warn("BaseTexture added to the cache with an id [" + e3 + "] that already had an entry"), $[e3] = t4);
          }, e2.removeFromCache = function(t4) {
            if ("string" == typeof t4) {
              var e3 = $[t4];
              if (e3) {
                var i2 = e3.textureCacheIds.indexOf(t4);
                return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete $[t4], e3;
              }
            } else if (t4 && t4.textureCacheIds) {
              for (var n2 = 0; n2 < t4.textureCacheIds.length; ++n2) delete $[t4.textureCacheIds[n2]];
              return t4.textureCacheIds.length = 0, t4;
            }
            return null;
          }, e2._globalBatch = 0, e2;
        }(u), It = function(t3) {
          function e2(e3, i2) {
            var n2 = this, r2 = i2 || {}, o2 = r2.width, s2 = r2.height;
            (n2 = t3.call(this, o2, s2) || this).items = [], n2.itemDirtyIds = [];
            for (var a2 = 0; a2 < e3; a2++) {
              var l2 = new Rt();
              n2.items.push(l2), n2.itemDirtyIds.push(-2);
            }
            return n2.length = e3, n2._load = null, n2.baseTexture = null, n2;
          }
          return St(e2, t3), e2.prototype.initFromArray = function(t4, e3) {
            for (var i2 = 0; i2 < this.length; i2++) t4[i2] && (t4[i2].castToBaseTexture ? this.addBaseTextureAt(t4[i2].castToBaseTexture(), i2) : t4[i2] instanceof At ? this.addResourceAt(t4[i2], i2) : this.addResourceAt(Tt(t4[i2], e3), i2));
          }, e2.prototype.dispose = function() {
            for (var t4 = 0, e3 = this.length; t4 < e3; t4++) this.items[t4].destroy();
            this.items = null, this.itemDirtyIds = null, this._load = null;
          }, e2.prototype.addResourceAt = function(t4, e3) {
            if (!this.items[e3]) throw new Error("Index " + e3 + " is out of bounds");
            return t4.valid && !this.valid && this.resize(t4.width, t4.height), this.items[e3].setResource(t4), this;
          }, e2.prototype.bind = function(e3) {
            if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
            t3.prototype.bind.call(this, e3);
            for (var i2 = 0; i2 < this.length; i2++) this.items[i2].parentTextureArray = e3, this.items[i2].on("update", e3.update, e3);
          }, e2.prototype.unbind = function(e3) {
            t3.prototype.unbind.call(this, e3);
            for (var i2 = 0; i2 < this.length; i2++) this.items[i2].parentTextureArray = null, this.items[i2].off("update", e3.update, e3);
          }, e2.prototype.load = function() {
            var t4 = this;
            if (this._load) return this._load;
            var e3 = this.items.map(function(t5) {
              return t5.resource;
            }).filter(function(t5) {
              return t5;
            }).map(function(t5) {
              return t5.load();
            });
            return this._load = Promise.all(e3).then(function() {
              var e4 = t4.items[0], i2 = e4.realWidth, n2 = e4.realHeight;
              return t4.resize(i2, n2), Promise.resolve(t4);
            }), this._load;
          }, e2;
        }(At), Pt = function(t3) {
          function e2(e3, i2) {
            var n2, r2, o2 = this, s2 = i2 || {}, a2 = s2.width, l2 = s2.height;
            return Array.isArray(e3) ? (n2 = e3, r2 = e3.length) : r2 = e3, o2 = t3.call(this, r2, { width: a2, height: l2 }) || this, n2 && o2.initFromArray(n2, i2), o2;
          }
          return St(e2, t3), e2.prototype.addBaseTextureAt = function(t4, e3) {
            if (!t4.resource) throw new Error("ArrayResource does not support RenderTexture");
            return this.addResourceAt(t4.resource, e3), this;
          }, e2.prototype.bind = function(e3) {
            t3.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_2D_ARRAY;
          }, e2.prototype.upload = function(t4, e3, i2) {
            var n2 = this.length, r2 = this.itemDirtyIds, o2 = this.items, s2 = t4.gl;
            i2.dirtyId < 0 && s2.texImage3D(s2.TEXTURE_2D_ARRAY, 0, i2.internalFormat, this._width, this._height, n2, 0, e3.format, i2.type, null);
            for (var a2 = 0; a2 < n2; a2++) {
              var l2 = o2[a2];
              r2[a2] < l2.dirtyId && (r2[a2] = l2.dirtyId, l2.valid && s2.texSubImage3D(s2.TEXTURE_2D_ARRAY, 0, 0, 0, a2, l2.resource.width, l2.resource.height, 1, e3.format, i2.type, l2.resource.source));
            }
            return true;
          }, e2;
        }(It), Ot = function(t3) {
          function e2(e3) {
            var i2 = this, n2 = e3, r2 = n2.naturalWidth || n2.videoWidth || n2.width, o2 = n2.naturalHeight || n2.videoHeight || n2.height;
            return (i2 = t3.call(this, r2, o2) || this).source = e3, i2.noSubImage = false, i2;
          }
          return St(e2, t3), e2.crossOrigin = function(t4, e3, i2) {
            void 0 === i2 && 0 !== e3.indexOf("data:") ? t4.crossOrigin = tt(e3) : false !== i2 && (t4.crossOrigin = "string" == typeof i2 ? i2 : "anonymous");
          }, e2.prototype.upload = function(t4, e3, i2, n2) {
            var o2 = t4.gl, s2 = e3.realWidth, a2 = e3.realHeight;
            if ((n2 = n2 || this.source) instanceof HTMLImageElement) {
              if (!n2.complete || 0 === n2.naturalWidth) return false;
            } else if (n2 instanceof HTMLVideoElement && n2.readyState <= 1) return false;
            return o2.pixelStorei(o2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK), this.noSubImage || e3.target !== o2.TEXTURE_2D || i2.width !== s2 || i2.height !== a2 ? (i2.width = s2, i2.height = a2, o2.texImage2D(e3.target, 0, i2.internalFormat, e3.format, i2.type, n2)) : o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e3.format, i2.type, n2), true;
          }, e2.prototype.update = function() {
            if (!this.destroyed) {
              var e3 = this.source, i2 = e3.naturalWidth || e3.videoWidth || e3.width, n2 = e3.naturalHeight || e3.videoHeight || e3.height;
              this.resize(i2, n2), t3.prototype.update.call(this);
            }
          }, e2.prototype.dispose = function() {
            this.source = null;
          }, e2;
        }(At), Nt = function(t3) {
          function e2(e3) {
            return t3.call(this, e3) || this;
          }
          return St(e2, t3), e2.test = function(t4) {
            var e3 = globalThis.OffscreenCanvas;
            return !!(e3 && t4 instanceof e3) || globalThis.HTMLCanvasElement && t4 instanceof HTMLCanvasElement;
          }, e2;
        }(Ot), Lt = function(t3) {
          function e2(i2, n2) {
            var o2 = this, s2 = n2 || {}, a2 = s2.width, l2 = s2.height, h2 = s2.autoLoad, u2 = s2.linkBaseTexture;
            if (i2 && i2.length !== e2.SIDES) throw new Error("Invalid length. Got " + i2.length + ", expected 6");
            o2 = t3.call(this, 6, { width: a2, height: l2 }) || this;
            for (var c2 = 0; c2 < e2.SIDES; c2++) o2.items[c2].target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + c2;
            return o2.linkBaseTexture = false !== u2, i2 && o2.initFromArray(i2, n2), false !== h2 && o2.load(), o2;
          }
          return St(e2, t3), e2.prototype.bind = function(e3) {
            t3.prototype.bind.call(this, e3), e3.target = r.q.TEXTURE_CUBE_MAP;
          }, e2.prototype.addBaseTextureAt = function(t4, e3, i2) {
            if (!this.items[e3]) throw new Error("Index " + e3 + " is out of bounds");
            if (!this.linkBaseTexture || t4.parentTextureArray || Object.keys(t4._glTextures).length > 0) {
              if (!t4.resource) throw new Error("CubeResource does not support copying of renderTexture.");
              this.addResourceAt(t4.resource, e3);
            } else t4.target = r.q.TEXTURE_CUBE_MAP_POSITIVE_X + e3, t4.parentTextureArray = this.baseTexture, this.items[e3] = t4;
            return t4.valid && !this.valid && this.resize(t4.realWidth, t4.realHeight), this.items[e3] = t4, this;
          }, e2.prototype.upload = function(t4, i2, n2) {
            for (var r2 = this.itemDirtyIds, o2 = 0; o2 < e2.SIDES; o2++) {
              var s2 = this.items[o2];
              r2[o2] < s2.dirtyId && (s2.valid && s2.resource ? (s2.resource.upload(t4, s2, n2), r2[o2] = s2.dirtyId) : r2[o2] < -1 && (t4.gl.texImage2D(s2.target, 0, n2.internalFormat, i2.realWidth, i2.realHeight, 0, i2.format, n2.type, null), r2[o2] = -1));
            }
            return true;
          }, e2.test = function(t4) {
            return Array.isArray(t4) && t4.length === e2.SIDES;
          }, e2.SIDES = 6, e2;
        }(It), Dt = function(t3) {
          function e2(e3, i2) {
            var r2 = this;
            if (i2 = i2 || {}, !(e3 instanceof HTMLImageElement)) {
              var o2 = new Image();
              Ot.crossOrigin(o2, e3, i2.crossorigin), o2.src = e3, e3 = o2;
            }
            return r2 = t3.call(this, e3) || this, !e3.complete && r2._width && r2._height && (r2._width = 0, r2._height = 0), r2.url = e3.src, r2._process = null, r2.preserveBitmap = false, r2.createBitmap = (void 0 !== i2.createBitmap ? i2.createBitmap : n.b.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, r2.alphaMode = "number" == typeof i2.alphaMode ? i2.alphaMode : null, r2.bitmap = null, r2._load = null, false !== i2.autoLoad && r2.load(), r2;
          }
          return St(e2, t3), e2.prototype.load = function(t4) {
            var e3 = this;
            return this._load || (void 0 !== t4 && (this.createBitmap = t4), this._load = new Promise(function(t5, i2) {
              var n2 = e3.source;
              e3.url = n2.src;
              var r2 = function() {
                e3.destroyed || (n2.onload = null, n2.onerror = null, e3.resize(n2.width, n2.height), e3._load = null, e3.createBitmap ? t5(e3.process()) : t5(e3));
              };
              n2.complete && n2.src ? r2() : (n2.onload = r2, n2.onerror = function(t6) {
                i2(t6), e3.onError.emit(t6);
              });
            })), this._load;
          }, e2.prototype.process = function() {
            var t4 = this, e3 = this.source;
            if (null !== this._process) return this._process;
            if (null !== this.bitmap || !globalThis.createImageBitmap) return Promise.resolve(this);
            var i2 = globalThis.createImageBitmap, n2 = !e3.crossOrigin || "anonymous" === e3.crossOrigin;
            return this._process = fetch(e3.src, { mode: n2 ? "cors" : "no-cors" }).then(function(t5) {
              return t5.blob();
            }).then(function(n3) {
              return i2(n3, 0, 0, e3.width, e3.height, { premultiplyAlpha: t4.alphaMode === r.a.UNPACK ? "premultiply" : "none" });
            }).then(function(e4) {
              return t4.destroyed ? Promise.reject() : (t4.bitmap = e4, t4.update(), t4._process = null, Promise.resolve(t4));
            }), this._process;
          }, e2.prototype.upload = function(e3, i2, n2) {
            if ("number" == typeof this.alphaMode && (i2.alphaMode = this.alphaMode), !this.createBitmap) return t3.prototype.upload.call(this, e3, i2, n2);
            if (!this.bitmap && (this.process(), !this.bitmap)) return false;
            if (t3.prototype.upload.call(this, e3, i2, n2, this.bitmap), !this.preserveBitmap) {
              var r2 = true, o2 = i2._glTextures;
              for (var s2 in o2) {
                var a2 = o2[s2];
                if (a2 !== n2 && a2.dirtyId !== i2.dirtyId) {
                  r2 = false;
                  break;
                }
              }
              r2 && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
            }
            return true;
          }, e2.prototype.dispose = function() {
            this.source.onload = null, this.source.onerror = null, t3.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
          }, e2.test = function(t4) {
            return "string" == typeof t4 || t4 instanceof HTMLImageElement;
          }, e2;
        }(Ot), Ft = function(t3) {
          function e2(e3, i2) {
            var n2 = this;
            return i2 = i2 || {}, (n2 = t3.call(this, document.createElement("canvas")) || this)._width = 0, n2._height = 0, n2.svg = e3, n2.scale = i2.scale || 1, n2._overrideWidth = i2.width, n2._overrideHeight = i2.height, n2._resolve = null, n2._crossorigin = i2.crossorigin, n2._load = null, false !== i2.autoLoad && n2.load(), n2;
          }
          return St(e2, t3), e2.prototype.load = function() {
            var t4 = this;
            return this._load || (this._load = new Promise(function(i2) {
              if (t4._resolve = function() {
                t4.resize(t4.source.width, t4.source.height), i2(t4);
              }, e2.SVG_XML.test(t4.svg.trim())) {
                if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                t4.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t4.svg)));
              }
              t4._loadSvg();
            })), this._load;
          }, e2.prototype._loadSvg = function() {
            var t4 = this, e3 = new Image();
            Ot.crossOrigin(e3, this.svg, this._crossorigin), e3.src = this.svg, e3.onerror = function(i2) {
              t4._resolve && (e3.onerror = null, t4.onError.emit(i2));
            }, e3.onload = function() {
              if (t4._resolve) {
                var i2 = e3.width, n2 = e3.height;
                if (!i2 || !n2) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                var r2 = i2 * t4.scale, o2 = n2 * t4.scale;
                (t4._overrideWidth || t4._overrideHeight) && (r2 = t4._overrideWidth || t4._overrideHeight / n2 * i2, o2 = t4._overrideHeight || t4._overrideWidth / i2 * n2), r2 = Math.round(r2), o2 = Math.round(o2);
                var s2 = t4.source;
                s2.width = r2, s2.height = o2, s2._pixiId = "canvas_" + Y(), s2.getContext("2d").drawImage(e3, 0, 0, i2, n2, 0, 0, r2, o2), t4._resolve(), t4._resolve = null;
              }
            };
          }, e2.getSize = function(t4) {
            var i2 = e2.SVG_SIZE.exec(t4), n2 = {};
            return i2 && (n2[i2[1]] = Math.round(parseFloat(i2[3])), n2[i2[5]] = Math.round(parseFloat(i2[7]))), n2;
          }, e2.prototype.dispose = function() {
            t3.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
          }, e2.test = function(t4, i2) {
            return "svg" === i2 || "string" == typeof t4 && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t4) || "string" == typeof t4 && e2.SVG_XML.test(t4);
          }, e2.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e2.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e2;
        }(Ot), Bt = function(t3) {
          function e2(i2, n2) {
            var r2 = this;
            if (n2 = n2 || {}, !(i2 instanceof HTMLVideoElement)) {
              var o2 = document.createElement("video");
              o2.setAttribute("preload", "auto"), o2.setAttribute("webkit-playsinline", ""), o2.setAttribute("playsinline", ""), "string" == typeof i2 && (i2 = [i2]);
              var s2 = i2[0].src || i2[0];
              Ot.crossOrigin(o2, s2, n2.crossorigin);
              for (var a2 = 0; a2 < i2.length; ++a2) {
                var l2 = document.createElement("source"), h2 = i2[a2], u2 = h2.src, c2 = h2.mime, d2 = (u2 = u2 || i2[a2]).split("?").shift().toLowerCase(), p2 = d2.slice(d2.lastIndexOf(".") + 1);
                c2 = c2 || e2.MIME_TYPES[p2] || "video/" + p2, l2.src = u2, l2.type = c2, o2.appendChild(l2);
              }
              i2 = o2;
            }
            return (r2 = t3.call(this, i2) || this).noSubImage = true, r2._autoUpdate = true, r2._isConnectedToTicker = false, r2._updateFPS = n2.updateFPS || 0, r2._msToNextUpdate = 0, r2.autoPlay = false !== n2.autoPlay, r2._load = null, r2._resolve = null, r2._onCanPlay = r2._onCanPlay.bind(r2), r2._onError = r2._onError.bind(r2), false !== n2.autoLoad && r2.load(), r2;
          }
          return St(e2, t3), e2.prototype.update = function(e3) {
            if (!this.destroyed) {
              var i2 = st.shared.elapsedMS * this.source.playbackRate;
              this._msToNextUpdate = Math.floor(this._msToNextUpdate - i2), (!this._updateFPS || this._msToNextUpdate <= 0) && (t3.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
            }
          }, e2.prototype.load = function() {
            var t4 = this;
            if (this._load) return this._load;
            var e3 = this.source;
            return (e3.readyState === e3.HAVE_ENOUGH_DATA || e3.readyState === e3.HAVE_FUTURE_DATA) && e3.width && e3.height && (e3.complete = true), e3.addEventListener("play", this._onPlayStart.bind(this)), e3.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e3.addEventListener("canplay", this._onCanPlay), e3.addEventListener("canplaythrough", this._onCanPlay), e3.addEventListener("error", this._onError, true)), this._load = new Promise(function(i2) {
              t4.valid ? i2(t4) : (t4._resolve = i2, e3.load());
            }), this._load;
          }, e2.prototype._onError = function(t4) {
            this.source.removeEventListener("error", this._onError, true), this.onError.emit(t4);
          }, e2.prototype._isSourcePlaying = function() {
            var t4 = this.source;
            return t4.currentTime > 0 && false === t4.paused && false === t4.ended && t4.readyState > 2;
          }, e2.prototype._isSourceReady = function() {
            var t4 = this.source;
            return 3 === t4.readyState || 4 === t4.readyState;
          }, e2.prototype._onPlayStart = function() {
            this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (st.shared.add(this.update, this), this._isConnectedToTicker = true);
          }, e2.prototype._onPlayStop = function() {
            this._isConnectedToTicker && (st.shared.remove(this.update, this), this._isConnectedToTicker = false);
          }, e2.prototype._onCanPlay = function() {
            var t4 = this.source;
            t4.removeEventListener("canplay", this._onCanPlay), t4.removeEventListener("canplaythrough", this._onCanPlay);
            var e3 = this.valid;
            this.resize(t4.videoWidth, t4.videoHeight), !e3 && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t4.play();
          }, e2.prototype.dispose = function() {
            this._isConnectedToTicker && (st.shared.remove(this.update, this), this._isConnectedToTicker = false);
            var e3 = this.source;
            e3 && (e3.removeEventListener("error", this._onError, true), e3.pause(), e3.src = "", e3.load()), t3.prototype.dispose.call(this);
          }, Object.defineProperty(e2.prototype, "autoUpdate", { get: function() {
            return this._autoUpdate;
          }, set: function(t4) {
            t4 !== this._autoUpdate && (this._autoUpdate = t4, !this._autoUpdate && this._isConnectedToTicker ? (st.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (st.shared.add(this.update, this), this._isConnectedToTicker = true));
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "updateFPS", { get: function() {
            return this._updateFPS;
          }, set: function(t4) {
            t4 !== this._updateFPS && (this._updateFPS = t4);
          }, enumerable: false, configurable: true }), e2.test = function(t4, i2) {
            return globalThis.HTMLVideoElement && t4 instanceof HTMLVideoElement || e2.TYPES.indexOf(i2) > -1;
          }, e2.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e2.MIME_TYPES = { ogv: "video/ogg", mov: "video/quicktime", m4v: "video/mp4" }, e2;
        }(Ot), Ut = function(t3) {
          function e2(e3) {
            return t3.call(this, e3) || this;
          }
          return St(e2, t3), e2.test = function(t4) {
            return !!globalThis.createImageBitmap && t4 instanceof ImageBitmap;
          }, e2;
        }(Ot);
        bt.push(Dt, Ut, Nt, Bt, Ft, Mt, Lt, Pt);
        var kt = { __proto__: null, Resource: At, BaseImageResource: Ot, INSTALLED: bt, autoDetectResource: Tt, AbstractMultiResource: It, ArrayResource: Pt, BufferResource: Mt, CanvasResource: Nt, CubeResource: Lt, ImageResource: Dt, SVGResource: Ft, VideoResource: Bt, ImageBitmapResource: Ut }, Gt = function(t3) {
          function e2() {
            return null !== t3 && t3.apply(this, arguments) || this;
          }
          return St(e2, t3), e2.prototype.upload = function(t4, e3, i2) {
            var n2 = t4.gl;
            n2.pixelStorei(n2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e3.alphaMode === r.a.UNPACK);
            var o2 = e3.realWidth, s2 = e3.realHeight;
            return i2.width === o2 && i2.height === s2 ? n2.texSubImage2D(e3.target, 0, 0, 0, o2, s2, e3.format, i2.type, this.data) : (i2.width = o2, i2.height = s2, n2.texImage2D(e3.target, 0, i2.internalFormat, o2, s2, 0, e3.format, i2.type, this.data)), true;
          }, e2;
        }(Mt), Ht = function() {
          function t3(t4, e2) {
            this.width = Math.round(t4 || 100), this.height = Math.round(e2 || 100), this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new nt("disposeFramebuffer"), this.multisample = r.l.NONE;
          }
          return Object.defineProperty(t3.prototype, "colorTexture", { get: function() {
            return this.colorTextures[0];
          }, enumerable: false, configurable: true }), t3.prototype.addColorTexture = function(t4, e2) {
            return void 0 === t4 && (t4 = 0), this.colorTextures[t4] = e2 || new Rt(null, { scaleMode: r.p.NEAREST, resolution: 1, mipmap: r.k.OFF, width: this.width, height: this.height }), this.dirtyId++, this.dirtyFormat++, this;
          }, t3.prototype.addDepthTexture = function(t4) {
            return this.depthTexture = t4 || new Rt(new Gt(null, { width: this.width, height: this.height }), { scaleMode: r.p.NEAREST, resolution: 1, width: this.width, height: this.height, mipmap: r.k.OFF, format: r.h.DEPTH_COMPONENT, type: r.r.UNSIGNED_SHORT }), this.dirtyId++, this.dirtyFormat++, this;
          }, t3.prototype.enableDepth = function() {
            return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
          }, t3.prototype.enableStencil = function() {
            return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
          }, t3.prototype.resize = function(t4, e2) {
            if (t4 = Math.round(t4), e2 = Math.round(e2), t4 !== this.width || e2 !== this.height) {
              this.width = t4, this.height = e2, this.dirtyId++, this.dirtySize++;
              for (var i2 = 0; i2 < this.colorTextures.length; i2++) {
                var n2 = this.colorTextures[i2], r2 = n2.resolution;
                n2.setSize(t4 / r2, e2 / r2);
              }
              if (this.depthTexture) {
                r2 = this.depthTexture.resolution;
                this.depthTexture.setSize(t4 / r2, e2 / r2);
              }
            }
          }, t3.prototype.dispose = function() {
            this.disposeRunner.emit(this, false);
          }, t3.prototype.destroyDepthTexture = function() {
            this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
          }, t3;
        }(), jt = function(t3) {
          function e2(e3) {
            void 0 === e3 && (e3 = {});
            var i2 = this;
            if ("number" == typeof e3) {
              var n2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
              e3 = { width: n2, height: o2, scaleMode: s2, resolution: a2 };
            }
            return e3.width = e3.width || 100, e3.height = e3.height || 100, e3.multisample = void 0 !== e3.multisample ? e3.multisample : r.l.NONE, (i2 = t3.call(this, null, e3) || this).mipmap = r.k.OFF, i2.valid = true, i2.clearColor = [0, 0, 0, 0], i2.framebuffer = new Ht(i2.realWidth, i2.realHeight).addColorTexture(0, i2), i2.framebuffer.multisample = e3.multisample, i2.maskStack = [], i2.filterStack = [{}], i2;
          }
          return St(e2, t3), e2.prototype.resize = function(t4, e3) {
            this.framebuffer.resize(t4 * this.resolution, e3 * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
          }, e2.prototype.dispose = function() {
            this.framebuffer.dispose(), t3.prototype.dispose.call(this);
          }, e2.prototype.destroy = function() {
            t3.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
          }, e2;
        }(Rt), zt = function() {
          function t3() {
            this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
          }
          return t3.prototype.set = function(t4, e2, i2) {
            var n2 = e2.width, r2 = e2.height;
            if (i2) {
              var o2 = t4.width / 2 / n2, s2 = t4.height / 2 / r2, a2 = t4.x / n2 + o2, l2 = t4.y / r2 + s2;
              i2 = xt.add(i2, xt.NW), this.x0 = a2 + o2 * xt.uX(i2), this.y0 = l2 + s2 * xt.uY(i2), i2 = xt.add(i2, 2), this.x1 = a2 + o2 * xt.uX(i2), this.y1 = l2 + s2 * xt.uY(i2), i2 = xt.add(i2, 2), this.x2 = a2 + o2 * xt.uX(i2), this.y2 = l2 + s2 * xt.uY(i2), i2 = xt.add(i2, 2), this.x3 = a2 + o2 * xt.uX(i2), this.y3 = l2 + s2 * xt.uY(i2);
            } else this.x0 = t4.x / n2, this.y0 = t4.y / r2, this.x1 = (t4.x + t4.width) / n2, this.y1 = t4.y / r2, this.x2 = (t4.x + t4.width) / n2, this.y2 = (t4.y + t4.height) / r2, this.x3 = t4.x / n2, this.y3 = (t4.y + t4.height) / r2;
            this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
          }, t3.prototype.toString = function() {
            return "[@pixi/core:TextureUvs x0=" + this.x0 + " y0=" + this.y0 + " x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3 + "]";
          }, t3;
        }(), Vt = new zt();
        function Xt(t3) {
          t3.destroy = function() {
          }, t3.on = function() {
          }, t3.once = function() {
          }, t3.emit = function() {
          };
        }
        var Wt = function(t3) {
          function e2(i2, n2, r2, o2, s2, a2) {
            var l2 = t3.call(this) || this;
            if (l2.noFrame = false, n2 || (l2.noFrame = true, n2 = new ut(0, 0, 1, 1)), i2 instanceof e2 && (i2 = i2.baseTexture), l2.baseTexture = i2, l2._frame = n2, l2.trim = o2, l2.valid = false, l2._uvs = Vt, l2.uvMatrix = null, l2.orig = r2 || n2, l2._rotate = Number(s2 || 0), true === s2) l2._rotate = 2;
            else if (l2._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
            return l2.defaultAnchor = a2 ? new lt(a2.x, a2.y) : new lt(0, 0), l2._updateID = 0, l2.textureCacheIds = [], i2.valid ? l2.noFrame ? i2.valid && l2.onBaseTextureUpdated(i2) : l2.frame = n2 : i2.once("loaded", l2.onBaseTextureUpdated, l2), l2.noFrame && i2.on("update", l2.onBaseTextureUpdated, l2), l2;
          }
          return St(e2, t3), e2.prototype.update = function() {
            this.baseTexture.resource && this.baseTexture.resource.update();
          }, e2.prototype.onBaseTextureUpdated = function(t4) {
            if (this.noFrame) {
              if (!this.baseTexture.valid) return;
              this._frame.width = t4.width, this._frame.height = t4.height, this.valid = true, this.updateUvs();
            } else this.frame = this._frame;
            this.emit("update", this);
          }, e2.prototype.destroy = function(t4) {
            if (this.baseTexture) {
              if (t4) {
                var i2 = this.baseTexture.resource;
                i2 && i2.url && Q[i2.url] && e2.removeFromCache(i2.url), this.baseTexture.destroy();
              }
              this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
            }
            this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, e2.removeFromCache(this), this.textureCacheIds = null;
          }, e2.prototype.clone = function() {
            var t4 = this._frame.clone(), i2 = this._frame === this.orig ? t4 : this.orig.clone(), n2 = new e2(this.baseTexture, !this.noFrame && t4, i2, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
            return this.noFrame && (n2._frame = t4), n2;
          }, e2.prototype.updateUvs = function() {
            this._uvs === Vt && (this._uvs = new zt()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
          }, e2.from = function(t4, i2, r2) {
            void 0 === i2 && (i2 = {}), void 0 === r2 && (r2 = n.b.STRICT_TEXTURE_CACHE);
            var o2 = "string" == typeof t4, s2 = null;
            if (o2) s2 = t4;
            else if (t4 instanceof Rt) {
              if (!t4.cacheId) {
                var a2 = i2 && i2.pixiIdPrefix || "pixiid";
                t4.cacheId = a2 + "-" + Y(), Rt.addToCache(t4, t4.cacheId);
              }
              s2 = t4.cacheId;
            } else {
              if (!t4._pixiId) {
                a2 = i2 && i2.pixiIdPrefix || "pixiid";
                t4._pixiId = a2 + "_" + Y();
              }
              s2 = t4._pixiId;
            }
            var l2 = Q[s2];
            if (o2 && r2 && !l2) throw new Error('The cacheId "' + s2 + '" does not exist in TextureCache.');
            return l2 || t4 instanceof Rt ? !l2 && t4 instanceof Rt && (l2 = new e2(t4), e2.addToCache(l2, s2)) : (i2.resolution || (i2.resolution = et(t4)), (l2 = new e2(new Rt(t4, i2))).baseTexture.cacheId = s2, Rt.addToCache(l2.baseTexture, s2), e2.addToCache(l2, s2)), l2;
          }, e2.fromURL = function(t4, i2) {
            var n2 = Object.assign({ autoLoad: false }, null == i2 ? void 0 : i2.resourceOptions), r2 = e2.from(t4, Object.assign({ resourceOptions: n2 }, i2), false), o2 = r2.baseTexture.resource;
            return r2.baseTexture.valid ? Promise.resolve(r2) : o2.load().then(function() {
              return Promise.resolve(r2);
            });
          }, e2.fromBuffer = function(t4, i2, n2, r2) {
            return new e2(Rt.fromBuffer(t4, i2, n2, r2));
          }, e2.fromLoader = function(t4, i2, r2, o2) {
            var s2 = new Rt(t4, Object.assign({ scaleMode: n.b.SCALE_MODE, resolution: et(i2) }, o2)), a2 = s2.resource;
            a2 instanceof Dt && (a2.url = i2);
            var l2 = new e2(s2);
            return r2 || (r2 = i2), Rt.addToCache(l2.baseTexture, r2), e2.addToCache(l2, r2), r2 !== i2 && (Rt.addToCache(l2.baseTexture, i2), e2.addToCache(l2, i2)), l2.baseTexture.valid ? Promise.resolve(l2) : new Promise(function(t5) {
              l2.baseTexture.once("loaded", function() {
                return t5(l2);
              });
            });
          }, e2.addToCache = function(t4, e3) {
            e3 && (-1 === t4.textureCacheIds.indexOf(e3) && t4.textureCacheIds.push(e3), Q[e3] && console.warn("Texture added to the cache with an id [" + e3 + "] that already had an entry"), Q[e3] = t4);
          }, e2.removeFromCache = function(t4) {
            if ("string" == typeof t4) {
              var e3 = Q[t4];
              if (e3) {
                var i2 = e3.textureCacheIds.indexOf(t4);
                return i2 > -1 && e3.textureCacheIds.splice(i2, 1), delete Q[t4], e3;
              }
            } else if (t4 && t4.textureCacheIds) {
              for (var n2 = 0; n2 < t4.textureCacheIds.length; ++n2) Q[t4.textureCacheIds[n2]] === t4 && delete Q[t4.textureCacheIds[n2]];
              return t4.textureCacheIds.length = 0, t4;
            }
            return null;
          }, Object.defineProperty(e2.prototype, "resolution", { get: function() {
            return this.baseTexture.resolution;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "frame", { get: function() {
            return this._frame;
          }, set: function(t4) {
            this._frame = t4, this.noFrame = false;
            var e3 = t4.x, i2 = t4.y, n2 = t4.width, r2 = t4.height, o2 = e3 + n2 > this.baseTexture.width, s2 = i2 + r2 > this.baseTexture.height;
            if (o2 || s2) {
              var a2 = o2 && s2 ? "and" : "or", l2 = "X: " + e3 + " + " + n2 + " = " + (e3 + n2) + " > " + this.baseTexture.width, h2 = "Y: " + i2 + " + " + r2 + " = " + (i2 + r2) + " > " + this.baseTexture.height;
              throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l2 + " " + a2 + " " + h2);
            }
            this.valid = n2 && r2 && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t4), this.valid && this.updateUvs();
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotate", { get: function() {
            return this._rotate;
          }, set: function(t4) {
            this._rotate = t4, this.valid && this.updateUvs();
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
            return this.orig.width;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
            return this.orig.height;
          }, enumerable: false, configurable: true }), e2.prototype.castToBaseTexture = function() {
            return this.baseTexture;
          }, Object.defineProperty(e2, "EMPTY", { get: function() {
            return e2._EMPTY || (e2._EMPTY = new e2(new Rt()), Xt(e2._EMPTY), Xt(e2._EMPTY.baseTexture)), e2._EMPTY;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2, "WHITE", { get: function() {
            if (!e2._WHITE) {
              var t4 = document.createElement("canvas"), i2 = t4.getContext("2d");
              t4.width = 16, t4.height = 16, i2.fillStyle = "white", i2.fillRect(0, 0, 16, 16), e2._WHITE = new e2(new Rt(new Nt(t4))), Xt(e2._WHITE), Xt(e2._WHITE.baseTexture);
            }
            return e2._WHITE;
          }, enumerable: false, configurable: true }), e2;
        }(u), Yt = function(t3) {
          function e2(e3, i2) {
            var n2 = t3.call(this, e3, i2) || this;
            return n2.valid = true, n2.filterFrame = null, n2.filterPoolKey = null, n2.updateUvs(), n2;
          }
          return St(e2, t3), Object.defineProperty(e2.prototype, "framebuffer", { get: function() {
            return this.baseTexture.framebuffer;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "multisample", { get: function() {
            return this.framebuffer.multisample;
          }, set: function(t4) {
            this.framebuffer.multisample = t4;
          }, enumerable: false, configurable: true }), e2.prototype.resize = function(t4, e3, i2) {
            void 0 === i2 && (i2 = true);
            var n2 = this.baseTexture.resolution, r2 = Math.round(t4 * n2) / n2, o2 = Math.round(e3 * n2) / n2;
            this.valid = r2 > 0 && o2 > 0, this._frame.width = this.orig.width = r2, this._frame.height = this.orig.height = o2, i2 && this.baseTexture.resize(r2, o2), this.updateUvs();
          }, e2.prototype.setResolution = function(t4) {
            var e3 = this.baseTexture;
            e3.resolution !== t4 && (e3.setResolution(t4), this.resize(e3.width, e3.height, false));
          }, e2.create = function(t4) {
            for (var i2 = arguments, n2 = [], r2 = 1; r2 < arguments.length; r2++) n2[r2 - 1] = i2[r2];
            return "number" == typeof t4 && (Z("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t4 = { width: t4, height: n2[0], scaleMode: n2[1], resolution: n2[2] }), new e2(new jt(t4));
          }, e2;
        }(Wt), qt = function() {
          function t3(t4) {
            this.texturePool = {}, this.textureOptions = t4 || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
          }
          return t3.prototype.createTexture = function(t4, e2, i2) {
            void 0 === i2 && (i2 = r.l.NONE);
            var n2 = new jt(Object.assign({ width: t4, height: e2, resolution: 1, multisample: i2 }, this.textureOptions));
            return new Yt(n2);
          }, t3.prototype.getOptimalTexture = function(t4, e2, i2, n2) {
            var o2;
            void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = r.l.NONE), t4 = Math.ceil(t4 * i2 - 1e-6), e2 = Math.ceil(e2 * i2 - 1e-6), this.enableFullScreen && t4 === this._pixelsWidth && e2 === this._pixelsHeight ? o2 = n2 > 1 ? -n2 : -1 : (o2 = ((65535 & (t4 = z(t4))) << 16 | 65535 & (e2 = z(e2))) >>> 0, n2 > 1 && (o2 += 4294967296 * n2)), this.texturePool[o2] || (this.texturePool[o2] = []);
            var s2 = this.texturePool[o2].pop();
            return s2 || (s2 = this.createTexture(t4, e2, n2)), s2.filterPoolKey = o2, s2.setResolution(i2), s2;
          }, t3.prototype.getFilterTexture = function(t4, e2, i2) {
            var n2 = this.getOptimalTexture(t4.width, t4.height, e2 || t4.resolution, i2 || r.l.NONE);
            return n2.filterFrame = t4.filterFrame, n2;
          }, t3.prototype.returnTexture = function(t4) {
            var e2 = t4.filterPoolKey;
            t4.filterFrame = null, this.texturePool[e2].push(t4);
          }, t3.prototype.returnFilterTexture = function(t4) {
            this.returnTexture(t4);
          }, t3.prototype.clear = function(t4) {
            if (t4 = false !== t4) for (var e2 in this.texturePool) {
              var i2 = this.texturePool[e2];
              if (i2) for (var n2 = 0; n2 < i2.length; n2++) i2[n2].destroy(true);
            }
            this.texturePool = {};
          }, t3.prototype.setScreenSize = function(t4) {
            if (t4.width !== this._pixelsWidth || t4.height !== this._pixelsHeight) {
              for (var e2 in this.enableFullScreen = t4.width > 0 && t4.height > 0, this.texturePool) if (Number(e2) < 0) {
                var i2 = this.texturePool[e2];
                if (i2) for (var n2 = 0; n2 < i2.length; n2++) i2[n2].destroy(true);
                this.texturePool[e2] = [];
              }
              this._pixelsWidth = t4.width, this._pixelsHeight = t4.height;
            }
          }, t3.SCREEN_KEY = -1, t3;
        }(), Zt = function() {
          function t3(t4, e2, i2, n2, o2, s2, a2) {
            void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = false), void 0 === n2 && (n2 = r.r.FLOAT), this.buffer = t4, this.size = e2, this.normalized = i2, this.type = n2, this.stride = o2, this.start = s2, this.instance = a2;
          }
          return t3.prototype.destroy = function() {
            this.buffer = null;
          }, t3.from = function(e2, i2, n2, r2, o2) {
            return new t3(e2, i2, n2, r2, o2);
          }, t3;
        }(), Jt = 0, Kt = function() {
          function t3(t4, e2, i2) {
            void 0 === e2 && (e2 = true), void 0 === i2 && (i2 = false), this.data = t4 || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i2, this.static = e2, this.id = Jt++, this.disposeRunner = new nt("disposeBuffer");
          }
          return t3.prototype.update = function(t4) {
            t4 instanceof Array && (t4 = new Float32Array(t4)), this.data = t4 || this.data, this._updateID++;
          }, t3.prototype.dispose = function() {
            this.disposeRunner.emit(this, false);
          }, t3.prototype.destroy = function() {
            this.dispose(), this.data = null;
          }, Object.defineProperty(t3.prototype, "index", { get: function() {
            return this.type === r.d.ELEMENT_ARRAY_BUFFER;
          }, set: function(t4) {
            this.type = t4 ? r.d.ELEMENT_ARRAY_BUFFER : r.d.ARRAY_BUFFER;
          }, enumerable: false, configurable: true }), t3.from = function(e2) {
            return e2 instanceof Array && (e2 = new Float32Array(e2)), new t3(e2);
          }, t3;
        }(), Qt = { Float32Array, Uint32Array, Int32Array, Uint8Array };
        var $t = { 5126: 4, 5123: 2, 5121: 1 }, te = 0, ee = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array }, ie = function() {
          function t3(t4, e2) {
            void 0 === t4 && (t4 = []), void 0 === e2 && (e2 = {}), this.buffers = t4, this.indexBuffer = null, this.attributes = e2, this.glVertexArrayObjects = {}, this.id = te++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new nt("disposeGeometry"), this.refCount = 0;
          }
          return t3.prototype.addAttribute = function(t4, e2, i2, n2, r2, o2, s2, a2) {
            if (void 0 === i2 && (i2 = 0), void 0 === n2 && (n2 = false), void 0 === a2 && (a2 = false), !e2) throw new Error("You must pass a buffer when creating an attribute");
            e2 instanceof Kt || (e2 instanceof Array && (e2 = new Float32Array(e2)), e2 = new Kt(e2));
            var l2 = t4.split("|");
            if (l2.length > 1) {
              for (var h2 = 0; h2 < l2.length; h2++) this.addAttribute(l2[h2], e2, i2, n2, r2);
              return this;
            }
            var u2 = this.buffers.indexOf(e2);
            return -1 === u2 && (this.buffers.push(e2), u2 = this.buffers.length - 1), this.attributes[t4] = new Zt(u2, i2, n2, r2, o2, s2, a2), this.instanced = this.instanced || a2, this;
          }, t3.prototype.getAttribute = function(t4) {
            return this.attributes[t4];
          }, t3.prototype.getBuffer = function(t4) {
            return this.buffers[this.getAttribute(t4).buffer];
          }, t3.prototype.addIndex = function(t4) {
            return t4 instanceof Kt || (t4 instanceof Array && (t4 = new Uint16Array(t4)), t4 = new Kt(t4)), t4.type = r.d.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t4, -1 === this.buffers.indexOf(t4) && this.buffers.push(t4), this;
          }, t3.prototype.getIndex = function() {
            return this.indexBuffer;
          }, t3.prototype.interleave = function() {
            if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
            var t4, e2 = [], i2 = [], n2 = new Kt();
            for (t4 in this.attributes) {
              var r2 = this.attributes[t4], o2 = this.buffers[r2.buffer];
              e2.push(o2.data), i2.push(r2.size * $t[r2.type] / 4), r2.buffer = 0;
            }
            for (n2.data = function(t5, e3) {
              for (var i3 = 0, n3 = 0, r3 = {}, o3 = 0; o3 < t5.length; o3++) n3 += e3[o3], i3 += t5[o3].length;
              var s2 = new ArrayBuffer(4 * i3), a2 = null, l2 = 0;
              for (o3 = 0; o3 < t5.length; o3++) {
                var h2 = e3[o3], u2 = t5[o3], c2 = j(u2);
                r3[c2] || (r3[c2] = new Qt[c2](s2)), a2 = r3[c2];
                for (var d2 = 0; d2 < u2.length; d2++) {
                  a2[(d2 / h2 | 0) * n3 + l2 + d2 % h2] = u2[d2];
                }
                l2 += h2;
              }
              return new Float32Array(s2);
            }(e2, i2), t4 = 0; t4 < this.buffers.length; t4++) this.buffers[t4] !== this.indexBuffer && this.buffers[t4].destroy();
            return this.buffers = [n2], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
          }, t3.prototype.getSize = function() {
            for (var t4 in this.attributes) {
              var e2 = this.attributes[t4];
              return this.buffers[e2.buffer].data.length / (e2.stride / 4 || e2.size);
            }
            return 0;
          }, t3.prototype.dispose = function() {
            this.disposeRunner.emit(this, false);
          }, t3.prototype.destroy = function() {
            this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
          }, t3.prototype.clone = function() {
            for (var e2 = new t3(), i2 = 0; i2 < this.buffers.length; i2++) e2.buffers[i2] = new Kt(this.buffers[i2].data.slice(0));
            for (var i2 in this.attributes) {
              var n2 = this.attributes[i2];
              e2.attributes[i2] = new Zt(n2.buffer, n2.size, n2.normalized, n2.type, n2.stride, n2.start, n2.instance);
            }
            return this.indexBuffer && (e2.indexBuffer = e2.buffers[this.buffers.indexOf(this.indexBuffer)], e2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER), e2;
          }, t3.merge = function(e2) {
            for (var i2, n2 = new t3(), o2 = [], s2 = [], a2 = [], l2 = 0; l2 < e2.length; l2++) {
              i2 = e2[l2];
              for (var h2 = 0; h2 < i2.buffers.length; h2++) s2[h2] = s2[h2] || 0, s2[h2] += i2.buffers[h2].data.length, a2[h2] = 0;
            }
            for (l2 = 0; l2 < i2.buffers.length; l2++) o2[l2] = new ee[j(i2.buffers[l2].data)](s2[l2]), n2.buffers[l2] = new Kt(o2[l2]);
            for (l2 = 0; l2 < e2.length; l2++) {
              i2 = e2[l2];
              for (h2 = 0; h2 < i2.buffers.length; h2++) o2[h2].set(i2.buffers[h2].data, a2[h2]), a2[h2] += i2.buffers[h2].data.length;
            }
            if (n2.attributes = i2.attributes, i2.indexBuffer) {
              n2.indexBuffer = n2.buffers[i2.buffers.indexOf(i2.indexBuffer)], n2.indexBuffer.type = r.d.ELEMENT_ARRAY_BUFFER;
              var u2 = 0, c2 = 0, d2 = 0, p2 = 0;
              for (l2 = 0; l2 < i2.buffers.length; l2++) if (i2.buffers[l2] !== i2.indexBuffer) {
                p2 = l2;
                break;
              }
              for (var l2 in i2.attributes) {
                var f2 = i2.attributes[l2];
                (0 | f2.buffer) === p2 && (c2 += f2.size * $t[f2.type] / 4);
              }
              for (l2 = 0; l2 < e2.length; l2++) {
                var m2 = e2[l2].indexBuffer.data;
                for (h2 = 0; h2 < m2.length; h2++) n2.indexBuffer.data[h2 + d2] += u2;
                u2 += e2[l2].buffers[p2].data.length / c2, d2 += m2.length;
              }
            }
            return n2;
          }, t3;
        }(), ne = function(t3) {
          function e2() {
            var e3 = t3.call(this) || this;
            return e3.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e3;
          }
          return St(e2, t3), e2;
        }(ie), re = function(t3) {
          function e2() {
            var e3 = t3.call(this) || this;
            return e3.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e3.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e3.vertexBuffer = new Kt(e3.vertices), e3.uvBuffer = new Kt(e3.uvs), e3.addAttribute("aVertexPosition", e3.vertexBuffer).addAttribute("aTextureCoord", e3.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e3;
          }
          return St(e2, t3), e2.prototype.map = function(t4, e3) {
            var i2 = 0, n2 = 0;
            return this.uvs[0] = i2, this.uvs[1] = n2, this.uvs[2] = i2 + e3.width / t4.width, this.uvs[3] = n2, this.uvs[4] = i2 + e3.width / t4.width, this.uvs[5] = n2 + e3.height / t4.height, this.uvs[6] = i2, this.uvs[7] = n2 + e3.height / t4.height, i2 = e3.x, n2 = e3.y, this.vertices[0] = i2, this.vertices[1] = n2, this.vertices[2] = i2 + e3.width, this.vertices[3] = n2, this.vertices[4] = i2 + e3.width, this.vertices[5] = n2 + e3.height, this.vertices[6] = i2, this.vertices[7] = n2 + e3.height, this.invalidate(), this;
          }, e2.prototype.invalidate = function() {
            return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
          }, e2;
        }(ie), oe = 0, se = function() {
          function t3(t4, e2, i2) {
            this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = oe++, this.static = !!e2, this.ubo = !!i2, t4 instanceof Kt ? (this.buffer = t4, this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = t4, this.ubo && (this.buffer = new Kt(new Float32Array(1)), this.buffer.type = r.d.UNIFORM_BUFFER, this.autoManage = true));
          }
          return t3.prototype.update = function() {
            this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
          }, t3.prototype.add = function(e2, i2, n2) {
            if (this.ubo) throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
            this.uniforms[e2] = new t3(i2, n2);
          }, t3.from = function(e2, i2, n2) {
            return new t3(e2, i2, n2);
          }, t3.uboFrom = function(e2, i2) {
            return new t3(e2, null == i2 || i2, true);
          }, t3;
        }(), ae = function() {
          function t3() {
            this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = r.l.NONE, this.sourceFrame = new ut(), this.destinationFrame = new ut(), this.bindingSourceFrame = new ut(), this.bindingDestinationFrame = new ut(), this.filters = [], this.transform = null;
          }
          return t3.prototype.clear = function() {
            this.target = null, this.filters = null, this.renderTexture = null;
          }, t3;
        }(), le = [new lt(), new lt(), new lt(), new lt()], he = new dt(), ue = function() {
          function t3(t4) {
            this.renderer = t4, this.defaultFilterStack = [{}], this.texturePool = new qt(), this.texturePool.setScreenSize(t4.view), this.statePool = [], this.quad = new ne(), this.quadUv = new re(), this.tempRect = new ut(), this.activeState = {}, this.globalUniforms = new se({ outputFrame: new ut(), inputSize: new Float32Array(4), inputPixel: new Float32Array(4), inputClamp: new Float32Array(4), resolution: 1, filterArea: new Float32Array(4), filterClamp: new Float32Array(4) }, true), this.forceClear = false, this.useMaxPadding = false;
          }
          return t3.prototype.push = function(t4, e2) {
            for (var i2, n2, r2 = this.renderer, o2 = this.defaultFilterStack, s2 = this.statePool.pop() || new ae(), a2 = this.renderer.renderTexture, l2 = e2[0].resolution, h2 = e2[0].multisample, u2 = e2[0].padding, c2 = e2[0].autoFit, d2 = null === (i2 = e2[0].legacy) || void 0 === i2 || i2, p2 = 1; p2 < e2.length; p2++) {
              var f2 = e2[p2];
              l2 = Math.min(l2, f2.resolution), h2 = Math.min(h2, f2.multisample), u2 = this.useMaxPadding ? Math.max(u2, f2.padding) : u2 + f2.padding, c2 = c2 && f2.autoFit, d2 = d2 || null === (n2 = f2.legacy) || void 0 === n2 || n2;
            }
            1 === o2.length && (this.defaultFilterStack[0].renderTexture = a2.current), o2.push(s2), s2.resolution = l2, s2.multisample = h2, s2.legacy = d2, s2.target = t4, s2.sourceFrame.copyFrom(t4.filterArea || t4.getBounds(true)), s2.sourceFrame.pad(u2);
            var m2 = this.tempRect.copyFrom(a2.sourceFrame);
            r2.projection.transform && this.transformAABB(he.copyFrom(r2.projection.transform).invert(), m2), c2 ? (s2.sourceFrame.fit(m2), (s2.sourceFrame.width <= 0 || s2.sourceFrame.height <= 0) && (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0)) : s2.sourceFrame.intersects(m2) || (s2.sourceFrame.width = 0, s2.sourceFrame.height = 0), this.roundFrame(s2.sourceFrame, a2.current ? a2.current.resolution : r2.resolution, a2.sourceFrame, a2.destinationFrame, r2.projection.transform), s2.renderTexture = this.getOptimalFilterTexture(s2.sourceFrame.width, s2.sourceFrame.height, l2, h2), s2.filters = e2, s2.destinationFrame.width = s2.renderTexture.width, s2.destinationFrame.height = s2.renderTexture.height;
            var g2 = this.tempRect;
            g2.x = 0, g2.y = 0, g2.width = s2.sourceFrame.width, g2.height = s2.sourceFrame.height, s2.renderTexture.filterFrame = s2.sourceFrame, s2.bindingSourceFrame.copyFrom(a2.sourceFrame), s2.bindingDestinationFrame.copyFrom(a2.destinationFrame), s2.transform = r2.projection.transform, r2.projection.transform = null, a2.bind(s2.renderTexture, s2.sourceFrame, g2), r2.framebuffer.clear(0, 0, 0, 0);
          }, t3.prototype.pop = function() {
            var t4 = this.defaultFilterStack, e2 = t4.pop(), i2 = e2.filters;
            this.activeState = e2;
            var n2 = this.globalUniforms.uniforms;
            n2.outputFrame = e2.sourceFrame, n2.resolution = e2.resolution;
            var o2 = n2.inputSize, s2 = n2.inputPixel, a2 = n2.inputClamp;
            if (o2[0] = e2.destinationFrame.width, o2[1] = e2.destinationFrame.height, o2[2] = 1 / o2[0], o2[3] = 1 / o2[1], s2[0] = Math.round(o2[0] * e2.resolution), s2[1] = Math.round(o2[1] * e2.resolution), s2[2] = 1 / s2[0], s2[3] = 1 / s2[1], a2[0] = 0.5 * s2[2], a2[1] = 0.5 * s2[3], a2[2] = e2.sourceFrame.width * o2[2] - 0.5 * s2[2], a2[3] = e2.sourceFrame.height * o2[3] - 0.5 * s2[3], e2.legacy) {
              var l2 = n2.filterArea;
              l2[0] = e2.destinationFrame.width, l2[1] = e2.destinationFrame.height, l2[2] = e2.sourceFrame.x, l2[3] = e2.sourceFrame.y, n2.filterClamp = n2.inputClamp;
            }
            this.globalUniforms.update();
            var h2 = t4[t4.length - 1];
            if (this.renderer.framebuffer.blit(), 1 === i2.length) i2[0].apply(this, e2.renderTexture, h2.renderTexture, r.e.BLEND, e2), this.returnFilterTexture(e2.renderTexture);
            else {
              var u2 = e2.renderTexture, c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution);
              c2.filterFrame = u2.filterFrame;
              var d2 = 0;
              for (d2 = 0; d2 < i2.length - 1; ++d2) {
                1 === d2 && e2.multisample > 1 && ((c2 = this.getOptimalFilterTexture(u2.width, u2.height, e2.resolution)).filterFrame = u2.filterFrame), i2[d2].apply(this, u2, c2, r.e.CLEAR, e2);
                var p2 = u2;
                u2 = c2, c2 = p2;
              }
              i2[d2].apply(this, u2, h2.renderTexture, r.e.BLEND, e2), d2 > 1 && e2.multisample > 1 && this.returnFilterTexture(e2.renderTexture), this.returnFilterTexture(u2), this.returnFilterTexture(c2);
            }
            e2.clear(), this.statePool.push(e2);
          }, t3.prototype.bindAndClear = function(t4, e2) {
            void 0 === e2 && (e2 = r.e.CLEAR);
            var i2 = this.renderer, n2 = i2.renderTexture, o2 = i2.state;
            if (t4 === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t4 && t4.filterFrame) {
              var s2 = this.tempRect;
              s2.x = 0, s2.y = 0, s2.width = t4.filterFrame.width, s2.height = t4.filterFrame.height, n2.bind(t4, t4.filterFrame, s2);
            } else t4 !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n2.bind(t4) : this.renderer.renderTexture.bind(t4, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
            var a2 = 1 & o2.stateId || this.forceClear;
            (e2 === r.e.CLEAR || e2 === r.e.BLIT && a2) && this.renderer.framebuffer.clear(0, 0, 0, 0);
          }, t3.prototype.applyFilter = function(t4, e2, i2, n2) {
            var o2 = this.renderer;
            o2.state.set(t4.state), this.bindAndClear(i2, n2), t4.uniforms.uSampler = e2, t4.uniforms.filterGlobals = this.globalUniforms, o2.shader.bind(t4), t4.legacy = !!t4.program.attributeData.aTextureCoord, t4.legacy ? (this.quadUv.map(e2._frame, e2.filterFrame), o2.geometry.bind(this.quadUv), o2.geometry.draw(r.f.TRIANGLES)) : (o2.geometry.bind(this.quad), o2.geometry.draw(r.f.TRIANGLE_STRIP));
          }, t3.prototype.calculateSpriteMatrix = function(t4, e2) {
            var i2 = this.activeState, n2 = i2.sourceFrame, r2 = i2.destinationFrame, o2 = e2._texture.orig, s2 = t4.set(r2.width, 0, 0, r2.height, n2.x, n2.y), a2 = e2.worldTransform.copyTo(dt.TEMP_MATRIX);
            return a2.invert(), s2.prepend(a2), s2.scale(1 / o2.width, 1 / o2.height), s2.translate(e2.anchor.x, e2.anchor.y), s2;
          }, t3.prototype.destroy = function() {
            this.renderer = null, this.texturePool.clear(false);
          }, t3.prototype.getOptimalFilterTexture = function(t4, e2, i2, n2) {
            return void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = r.l.NONE), this.texturePool.getOptimalTexture(t4, e2, i2, n2);
          }, t3.prototype.getFilterTexture = function(t4, e2, i2) {
            if ("number" == typeof t4) {
              var n2 = t4;
              t4 = e2, e2 = n2;
            }
            t4 = t4 || this.activeState.renderTexture;
            var o2 = this.texturePool.getOptimalTexture(t4.width, t4.height, e2 || t4.resolution, i2 || r.l.NONE);
            return o2.filterFrame = t4.filterFrame, o2;
          }, t3.prototype.returnFilterTexture = function(t4) {
            this.texturePool.returnTexture(t4);
          }, t3.prototype.emptyPool = function() {
            this.texturePool.clear(true);
          }, t3.prototype.resize = function() {
            this.texturePool.setScreenSize(this.renderer.view);
          }, t3.prototype.transformAABB = function(t4, e2) {
            var i2 = le[0], n2 = le[1], r2 = le[2], o2 = le[3];
            i2.set(e2.left, e2.top), n2.set(e2.left, e2.bottom), r2.set(e2.right, e2.top), o2.set(e2.right, e2.bottom), t4.apply(i2, i2), t4.apply(n2, n2), t4.apply(r2, r2), t4.apply(o2, o2);
            var s2 = Math.min(i2.x, n2.x, r2.x, o2.x), a2 = Math.min(i2.y, n2.y, r2.y, o2.y), l2 = Math.max(i2.x, n2.x, r2.x, o2.x), h2 = Math.max(i2.y, n2.y, r2.y, o2.y);
            e2.x = s2, e2.y = a2, e2.width = l2 - s2, e2.height = h2 - a2;
          }, t3.prototype.roundFrame = function(t4, e2, i2, n2, r2) {
            if (!(t4.width <= 0 || t4.height <= 0 || i2.width <= 0 || i2.height <= 0)) {
              if (r2) {
                var o2 = r2.a, s2 = r2.b, a2 = r2.c, l2 = r2.d;
                if ((Math.abs(s2) > 1e-4 || Math.abs(a2) > 1e-4) && (Math.abs(o2) > 1e-4 || Math.abs(l2) > 1e-4)) return;
              }
              (r2 = r2 ? he.copyFrom(r2) : he.identity()).translate(-i2.x, -i2.y).scale(n2.width / i2.width, n2.height / i2.height).translate(n2.x, n2.y), this.transformAABB(r2, t4), t4.ceil(e2), this.transformAABB(r2.invert(), t4);
            }
          }, t3;
        }(), ce = function() {
          function t3(t4) {
            this.renderer = t4;
          }
          return t3.prototype.flush = function() {
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3.prototype.start = function() {
          }, t3.prototype.stop = function() {
            this.flush();
          }, t3.prototype.render = function(t4) {
          }, t3;
        }(), de = function() {
          function t3(t4) {
            this.renderer = t4, this.emptyRenderer = new ce(t4), this.currentRenderer = this.emptyRenderer;
          }
          return t3.prototype.setObjectRenderer = function(t4) {
            this.currentRenderer !== t4 && (this.currentRenderer.stop(), this.currentRenderer = t4, this.currentRenderer.start());
          }, t3.prototype.flush = function() {
            this.setObjectRenderer(this.emptyRenderer);
          }, t3.prototype.reset = function() {
            this.setObjectRenderer(this.emptyRenderer);
          }, t3.prototype.copyBoundTextures = function(t4, e2) {
            for (var i2 = this.renderer.texture.boundTextures, n2 = e2 - 1; n2 >= 0; --n2) t4[n2] = i2[n2] || null, t4[n2] && (t4[n2]._batchLocation = n2);
          }, t3.prototype.boundArray = function(t4, e2, i2, n2) {
            for (var r2 = t4.elements, o2 = t4.ids, s2 = t4.count, a2 = 0, l2 = 0; l2 < s2; l2++) {
              var h2 = r2[l2], u2 = h2._batchLocation;
              if (u2 >= 0 && u2 < n2 && e2[u2] === h2) o2[l2] = u2;
              else for (; a2 < n2; ) {
                var c2 = e2[a2];
                if (!c2 || c2._batchEnabled !== i2 || c2._batchLocation !== a2) {
                  o2[l2] = a2, h2._batchLocation = a2, e2[a2] = h2;
                  break;
                }
                a2++;
              }
            }
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }(), pe = 0, fe = function() {
          function t3(t4) {
            this.renderer = t4, this.webGLVersion = 1, this.extensions = {}, this.supports = { uint32Indices: false }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), t4.view.addEventListener("webglcontextlost", this.handleContextLost, false), t4.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
          }
          return Object.defineProperty(t3.prototype, "isLost", { get: function() {
            return !this.gl || this.gl.isContextLost();
          }, enumerable: false, configurable: true }), t3.prototype.contextChange = function(t4) {
            this.gl = t4, this.renderer.gl = t4, this.renderer.CONTEXT_UID = pe++, t4.isContextLost() && t4.getExtension("WEBGL_lose_context") && t4.getExtension("WEBGL_lose_context").restoreContext();
          }, t3.prototype.initFromContext = function(t4) {
            this.gl = t4, this.validateContext(t4), this.renderer.gl = t4, this.renderer.CONTEXT_UID = pe++, this.renderer.runners.contextChange.emit(t4);
          }, t3.prototype.initFromOptions = function(t4) {
            var e2 = this.createContext(this.renderer.view, t4);
            this.initFromContext(e2);
          }, t3.prototype.createContext = function(t4, e2) {
            var i2;
            if (n.b.PREFER_ENV >= r.g.WEBGL2 && (i2 = t4.getContext("webgl2", e2)), i2) this.webGLVersion = 2;
            else if (this.webGLVersion = 1, !(i2 = t4.getContext("webgl", e2) || t4.getContext("experimental-webgl", e2))) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
            return this.gl = i2, this.getExtensions(), this.gl;
          }, t3.prototype.getExtensions = function() {
            var t4 = this.gl, e2 = { anisotropicFiltering: t4.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear: t4.getExtension("OES_texture_float_linear"), s3tc: t4.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: t4.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: t4.getExtension("WEBGL_compressed_texture_etc"), etc1: t4.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: t4.getExtension("WEBGL_compressed_texture_pvrtc") || t4.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: t4.getExtension("WEBGL_compressed_texture_atc"), astc: t4.getExtension("WEBGL_compressed_texture_astc") };
            1 === this.webGLVersion ? Object.assign(this.extensions, e2, { drawBuffers: t4.getExtension("WEBGL_draw_buffers"), depthTexture: t4.getExtension("WEBGL_depth_texture"), loseContext: t4.getExtension("WEBGL_lose_context"), vertexArrayObject: t4.getExtension("OES_vertex_array_object") || t4.getExtension("MOZ_OES_vertex_array_object") || t4.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex: t4.getExtension("OES_element_index_uint"), floatTexture: t4.getExtension("OES_texture_float"), floatTextureLinear: t4.getExtension("OES_texture_float_linear"), textureHalfFloat: t4.getExtension("OES_texture_half_float"), textureHalfFloatLinear: t4.getExtension("OES_texture_half_float_linear") }) : 2 === this.webGLVersion && Object.assign(this.extensions, e2, { colorBufferFloat: t4.getExtension("EXT_color_buffer_float") });
          }, t3.prototype.handleContextLost = function(t4) {
            t4.preventDefault();
          }, t3.prototype.handleContextRestored = function() {
            this.renderer.runners.contextChange.emit(this.gl);
          }, t3.prototype.destroy = function() {
            var t4 = this.renderer.view;
            this.renderer = null, t4.removeEventListener("webglcontextlost", this.handleContextLost), t4.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
          }, t3.prototype.postrender = function() {
            this.renderer.renderingToScreen && this.gl.flush();
          }, t3.prototype.validateContext = function(t4) {
            var e2 = t4.getContextAttributes(), i2 = "WebGL2RenderingContext" in globalThis && t4 instanceof globalThis.WebGL2RenderingContext;
            i2 && (this.webGLVersion = 2), e2 && !e2.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
            var n2 = i2 || !!t4.getExtension("OES_element_index_uint");
            this.supports.uint32Indices = n2, n2 || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
          }, t3;
        }(), me = function(t3) {
          this.framebuffer = t3, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = r.l.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
        }, ge = new ut(), ve = function() {
          function t3(t4) {
            this.renderer = t4, this.managedFramebuffers = [], this.unknownFramebuffer = new Ht(10, 10), this.msaaSamples = null;
          }
          return t3.prototype.contextChange = function() {
            var t4 = this.gl = this.renderer.gl;
            if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new ut(), this.hasMRT = true, this.writeDepthTexture = true, this.disposeAll(true), 1 === this.renderer.context.webGLVersion) {
              var e2 = this.renderer.context.extensions.drawBuffers, i2 = this.renderer.context.extensions.depthTexture;
              n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (e2 = null, i2 = null), e2 ? t4.drawBuffers = function(t5) {
                return e2.drawBuffersWEBGL(t5);
              } : (this.hasMRT = false, t4.drawBuffers = function() {
              }), i2 || (this.writeDepthTexture = false);
            } else this.msaaSamples = t4.getInternalformatParameter(t4.RENDERBUFFER, t4.RGBA8, t4.SAMPLES);
          }, t3.prototype.bind = function(t4, e2, i2) {
            void 0 === i2 && (i2 = 0);
            var n2 = this.gl;
            if (t4) {
              var r2 = t4.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t4);
              this.current !== t4 && (this.current = t4, n2.bindFramebuffer(n2.FRAMEBUFFER, r2.framebuffer)), r2.mipLevel !== i2 && (t4.dirtyId++, t4.dirtyFormat++, r2.mipLevel = i2), r2.dirtyId !== t4.dirtyId && (r2.dirtyId = t4.dirtyId, r2.dirtyFormat !== t4.dirtyFormat ? (r2.dirtyFormat = t4.dirtyFormat, r2.dirtySize = t4.dirtySize, this.updateFramebuffer(t4, i2)) : r2.dirtySize !== t4.dirtySize && (r2.dirtySize = t4.dirtySize, this.resizeFramebuffer(t4)));
              for (var o2 = 0; o2 < t4.colorTextures.length; o2++) {
                var s2 = t4.colorTextures[o2];
                this.renderer.texture.unbind(s2.parentTextureArray || s2);
              }
              if (t4.depthTexture && this.renderer.texture.unbind(t4.depthTexture), e2) {
                var a2 = e2.width >> i2, l2 = e2.height >> i2, h2 = a2 / e2.width;
                this.setViewport(e2.x * h2, e2.y * h2, a2, l2);
              } else {
                a2 = t4.width >> i2, l2 = t4.height >> i2;
                this.setViewport(0, 0, a2, l2);
              }
            } else this.current && (this.current = null, n2.bindFramebuffer(n2.FRAMEBUFFER, null)), e2 ? this.setViewport(e2.x, e2.y, e2.width, e2.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
          }, t3.prototype.setViewport = function(t4, e2, i2, n2) {
            var r2 = this.viewport;
            t4 = Math.round(t4), e2 = Math.round(e2), i2 = Math.round(i2), n2 = Math.round(n2), r2.width === i2 && r2.height === n2 && r2.x === t4 && r2.y === e2 || (r2.x = t4, r2.y = e2, r2.width = i2, r2.height = n2, this.gl.viewport(t4, e2, i2, n2));
          }, Object.defineProperty(t3.prototype, "size", { get: function() {
            return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
          }, enumerable: false, configurable: true }), t3.prototype.clear = function(t4, e2, i2, n2, o2) {
            void 0 === o2 && (o2 = r.c.COLOR | r.c.DEPTH);
            var s2 = this.gl;
            s2.clearColor(t4, e2, i2, n2), s2.clear(o2);
          }, t3.prototype.initFramebuffer = function(t4) {
            var e2 = this.gl, i2 = new me(e2.createFramebuffer());
            return i2.multisample = this.detectSamples(t4.multisample), t4.glFramebuffers[this.CONTEXT_UID] = i2, this.managedFramebuffers.push(t4), t4.disposeRunner.add(this), i2;
          }, t3.prototype.resizeFramebuffer = function(t4) {
            var e2 = this.gl, i2 = t4.glFramebuffers[this.CONTEXT_UID];
            i2.msaaBuffer && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.msaaBuffer), e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.RGBA8, t4.width, t4.height)), i2.stencil && (e2.bindRenderbuffer(e2.RENDERBUFFER, i2.stencil), i2.msaaBuffer ? e2.renderbufferStorageMultisample(e2.RENDERBUFFER, i2.multisample, e2.DEPTH24_STENCIL8, t4.width, t4.height) : e2.renderbufferStorage(e2.RENDERBUFFER, e2.DEPTH_STENCIL, t4.width, t4.height));
            var n2 = t4.colorTextures, r2 = n2.length;
            e2.drawBuffers || (r2 = Math.min(r2, 1));
            for (var o2 = 0; o2 < r2; o2++) {
              var s2 = n2[o2], a2 = s2.parentTextureArray || s2;
              this.renderer.texture.bind(a2, 0);
            }
            t4.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t4.depthTexture, 0);
          }, t3.prototype.updateFramebuffer = function(t4, e2) {
            var i2 = this.gl, n2 = t4.glFramebuffers[this.CONTEXT_UID], r2 = t4.colorTextures, o2 = r2.length;
            i2.drawBuffers || (o2 = Math.min(o2, 1)), n2.multisample > 1 && this.canMultisampleFramebuffer(t4) ? (n2.msaaBuffer = n2.msaaBuffer || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.msaaBuffer), i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.RGBA8, t4.width, t4.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.RENDERBUFFER, n2.msaaBuffer)) : n2.msaaBuffer && (i2.deleteRenderbuffer(n2.msaaBuffer), n2.msaaBuffer = null, n2.blitFramebuffer && (n2.blitFramebuffer.dispose(), n2.blitFramebuffer = null));
            for (var s2 = [], a2 = 0; a2 < o2; a2++) {
              var l2 = r2[a2], h2 = l2.parentTextureArray || l2;
              this.renderer.texture.bind(h2, 0), 0 === a2 && n2.msaaBuffer || (i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0 + a2, l2.target, h2._glTextures[this.CONTEXT_UID].texture, e2), s2.push(i2.COLOR_ATTACHMENT0 + a2));
            }
            if ((s2.length > 1 && i2.drawBuffers(s2), t4.depthTexture) && this.writeDepthTexture) {
              var u2 = t4.depthTexture;
              this.renderer.texture.bind(u2, 0), i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.DEPTH_ATTACHMENT, i2.TEXTURE_2D, u2._glTextures[this.CONTEXT_UID].texture, e2);
            }
            !t4.stencil && !t4.depth || t4.depthTexture && this.writeDepthTexture ? n2.stencil && (i2.deleteRenderbuffer(n2.stencil), n2.stencil = null) : (n2.stencil = n2.stencil || i2.createRenderbuffer(), i2.bindRenderbuffer(i2.RENDERBUFFER, n2.stencil), n2.msaaBuffer ? i2.renderbufferStorageMultisample(i2.RENDERBUFFER, n2.multisample, i2.DEPTH24_STENCIL8, t4.width, t4.height) : i2.renderbufferStorage(i2.RENDERBUFFER, i2.DEPTH_STENCIL, t4.width, t4.height), i2.framebufferRenderbuffer(i2.FRAMEBUFFER, i2.DEPTH_STENCIL_ATTACHMENT, i2.RENDERBUFFER, n2.stencil));
          }, t3.prototype.canMultisampleFramebuffer = function(t4) {
            return 1 !== this.renderer.context.webGLVersion && t4.colorTextures.length <= 1 && !t4.depthTexture;
          }, t3.prototype.detectSamples = function(t4) {
            var e2 = this.msaaSamples, i2 = r.l.NONE;
            if (t4 <= 1 || null === e2) return i2;
            for (var n2 = 0; n2 < e2.length; n2++) if (e2[n2] <= t4) {
              i2 = e2[n2];
              break;
            }
            return 1 === i2 && (i2 = r.l.NONE), i2;
          }, t3.prototype.blit = function(t4, e2, i2) {
            var n2 = this.current, r2 = this.renderer, o2 = this.gl, s2 = this.CONTEXT_UID;
            if (2 === r2.context.webGLVersion && n2) {
              var a2 = n2.glFramebuffers[s2];
              if (a2) {
                if (!t4) {
                  if (!a2.msaaBuffer) return;
                  var l2 = n2.colorTextures[0];
                  if (!l2) return;
                  a2.blitFramebuffer || (a2.blitFramebuffer = new Ht(n2.width, n2.height), a2.blitFramebuffer.addColorTexture(0, l2)), (t4 = a2.blitFramebuffer).colorTextures[0] !== l2 && (t4.colorTextures[0] = l2, t4.dirtyId++, t4.dirtyFormat++), t4.width === n2.width && t4.height === n2.height || (t4.width = n2.width, t4.height = n2.height, t4.dirtyId++, t4.dirtySize++);
                }
                e2 || ((e2 = ge).width = n2.width, e2.height = n2.height), i2 || (i2 = e2);
                var h2 = e2.width === i2.width && e2.height === i2.height;
                this.bind(t4), o2.bindFramebuffer(o2.READ_FRAMEBUFFER, a2.framebuffer), o2.blitFramebuffer(e2.left, e2.top, e2.right, e2.bottom, i2.left, i2.top, i2.right, i2.bottom, o2.COLOR_BUFFER_BIT, h2 ? o2.NEAREST : o2.LINEAR);
              }
            }
          }, t3.prototype.disposeFramebuffer = function(t4, e2) {
            var i2 = t4.glFramebuffers[this.CONTEXT_UID], n2 = this.gl;
            if (i2) {
              delete t4.glFramebuffers[this.CONTEXT_UID];
              var r2 = this.managedFramebuffers.indexOf(t4);
              r2 >= 0 && this.managedFramebuffers.splice(r2, 1), t4.disposeRunner.remove(this), e2 || (n2.deleteFramebuffer(i2.framebuffer), i2.msaaBuffer && n2.deleteRenderbuffer(i2.msaaBuffer), i2.stencil && n2.deleteRenderbuffer(i2.stencil)), i2.blitFramebuffer && i2.blitFramebuffer.dispose();
            }
          }, t3.prototype.disposeAll = function(t4) {
            var e2 = this.managedFramebuffers;
            this.managedFramebuffers = [];
            for (var i2 = 0; i2 < e2.length; i2++) this.disposeFramebuffer(e2[i2], t4);
          }, t3.prototype.forceStencil = function() {
            var t4 = this.current;
            if (t4) {
              var e2 = t4.glFramebuffers[this.CONTEXT_UID];
              if (e2 && !e2.stencil) {
                t4.stencil = true;
                var i2 = t4.width, n2 = t4.height, r2 = this.gl, o2 = r2.createRenderbuffer();
                r2.bindRenderbuffer(r2.RENDERBUFFER, o2), e2.msaaBuffer ? r2.renderbufferStorageMultisample(r2.RENDERBUFFER, e2.multisample, r2.DEPTH24_STENCIL8, i2, n2) : r2.renderbufferStorage(r2.RENDERBUFFER, r2.DEPTH_STENCIL, i2, n2), e2.stencil = o2, r2.framebufferRenderbuffer(r2.FRAMEBUFFER, r2.DEPTH_STENCIL_ATTACHMENT, r2.RENDERBUFFER, o2);
              }
            }
          }, t3.prototype.reset = function() {
            this.current = this.unknownFramebuffer, this.viewport = new ut();
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }(), _e = { 5126: 4, 5123: 2, 5121: 1 }, ye = function() {
          function t3(t4) {
            this.renderer = t4, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
          }
          return t3.prototype.contextChange = function() {
            this.disposeAll(true);
            var t4 = this.gl = this.renderer.gl, e2 = this.renderer.context;
            if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== e2.webGLVersion) {
              var i2 = this.renderer.context.extensions.vertexArrayObject;
              n.b.PREFER_ENV === r.g.WEBGL_LEGACY && (i2 = null), i2 ? (t4.createVertexArray = function() {
                return i2.createVertexArrayOES();
              }, t4.bindVertexArray = function(t5) {
                return i2.bindVertexArrayOES(t5);
              }, t4.deleteVertexArray = function(t5) {
                return i2.deleteVertexArrayOES(t5);
              }) : (this.hasVao = false, t4.createVertexArray = function() {
                return null;
              }, t4.bindVertexArray = function() {
                return null;
              }, t4.deleteVertexArray = function() {
                return null;
              });
            }
            if (2 !== e2.webGLVersion) {
              var o2 = t4.getExtension("ANGLE_instanced_arrays");
              o2 ? (t4.vertexAttribDivisor = function(t5, e3) {
                return o2.vertexAttribDivisorANGLE(t5, e3);
              }, t4.drawElementsInstanced = function(t5, e3, i3, n2, r2) {
                return o2.drawElementsInstancedANGLE(t5, e3, i3, n2, r2);
              }, t4.drawArraysInstanced = function(t5, e3, i3, n2) {
                return o2.drawArraysInstancedANGLE(t5, e3, i3, n2);
              }) : this.hasInstance = false;
            }
            this.canUseUInt32ElementIndex = 2 === e2.webGLVersion || !!e2.extensions.uint32ElementIndex;
          }, t3.prototype.bind = function(t4, e2) {
            e2 = e2 || this.renderer.shader.shader;
            var i2 = this.gl, n2 = t4.glVertexArrayObjects[this.CONTEXT_UID], r2 = false;
            n2 || (this.managedGeometries[t4.id] = t4, t4.disposeRunner.add(this), t4.glVertexArrayObjects[this.CONTEXT_UID] = n2 = {}, r2 = true);
            var o2 = n2[e2.program.id] || this.initGeometryVao(t4, e2, r2);
            this._activeGeometry = t4, this._activeVao !== o2 && (this._activeVao = o2, this.hasVao ? i2.bindVertexArray(o2) : this.activateVao(t4, e2.program)), this.updateBuffers();
          }, t3.prototype.reset = function() {
            this.unbind();
          }, t3.prototype.updateBuffers = function() {
            for (var t4 = this._activeGeometry, e2 = this.renderer.buffer, i2 = 0; i2 < t4.buffers.length; i2++) {
              var n2 = t4.buffers[i2];
              e2.update(n2);
            }
          }, t3.prototype.checkCompatibility = function(t4, e2) {
            var i2 = t4.attributes, n2 = e2.attributeData;
            for (var r2 in n2) if (!i2[r2]) throw new Error('shader and geometry incompatible, geometry missing the "' + r2 + '" attribute');
          }, t3.prototype.getSignature = function(t4, e2) {
            var i2 = t4.attributes, n2 = e2.attributeData, r2 = ["g", t4.id];
            for (var o2 in i2) n2[o2] && r2.push(o2, n2[o2].location);
            return r2.join("-");
          }, t3.prototype.initGeometryVao = function(t4, e2, i2) {
            void 0 === i2 && (i2 = true);
            var n2 = this.gl, r2 = this.CONTEXT_UID, o2 = this.renderer.buffer, s2 = e2.program;
            s2.glPrograms[r2] || this.renderer.shader.generateProgram(e2), this.checkCompatibility(t4, s2);
            var a2 = this.getSignature(t4, s2), l2 = t4.glVertexArrayObjects[this.CONTEXT_UID], h2 = l2[a2];
            if (h2) return l2[s2.id] = h2, h2;
            var u2 = t4.buffers, c2 = t4.attributes, d2 = {}, p2 = {};
            for (var f2 in u2) d2[f2] = 0, p2[f2] = 0;
            for (var f2 in c2) !c2[f2].size && s2.attributeData[f2] ? c2[f2].size = s2.attributeData[f2].size : c2[f2].size || console.warn("PIXI Geometry attribute '" + f2 + "' size cannot be determined (likely the bound shader does not have the attribute)"), d2[c2[f2].buffer] += c2[f2].size * _e[c2[f2].type];
            for (var f2 in c2) {
              var m2 = c2[f2], g2 = m2.size;
              void 0 === m2.stride && (d2[m2.buffer] === g2 * _e[m2.type] ? m2.stride = 0 : m2.stride = d2[m2.buffer]), void 0 === m2.start && (m2.start = p2[m2.buffer], p2[m2.buffer] += g2 * _e[m2.type]);
            }
            h2 = n2.createVertexArray(), n2.bindVertexArray(h2);
            for (var v2 = 0; v2 < u2.length; v2++) {
              var _2 = u2[v2];
              o2.bind(_2), i2 && _2._glBuffers[r2].refCount++;
            }
            return this.activateVao(t4, s2), this._activeVao = h2, l2[s2.id] = h2, l2[a2] = h2, h2;
          }, t3.prototype.disposeGeometry = function(t4, e2) {
            var i2;
            if (this.managedGeometries[t4.id]) {
              delete this.managedGeometries[t4.id];
              var n2 = t4.glVertexArrayObjects[this.CONTEXT_UID], r2 = this.gl, o2 = t4.buffers, s2 = null === (i2 = this.renderer) || void 0 === i2 ? void 0 : i2.buffer;
              if (t4.disposeRunner.remove(this), n2) {
                if (s2) for (var a2 = 0; a2 < o2.length; a2++) {
                  var l2 = o2[a2]._glBuffers[this.CONTEXT_UID];
                  l2 && (l2.refCount--, 0 !== l2.refCount || e2 || s2.dispose(o2[a2], e2));
                }
                if (!e2) {
                  for (var h2 in n2) if ("g" === h2[0]) {
                    var u2 = n2[h2];
                    this._activeVao === u2 && this.unbind(), r2.deleteVertexArray(u2);
                  }
                }
                delete t4.glVertexArrayObjects[this.CONTEXT_UID];
              }
            }
          }, t3.prototype.disposeAll = function(t4) {
            for (var e2 = Object.keys(this.managedGeometries), i2 = 0; i2 < e2.length; i2++) this.disposeGeometry(this.managedGeometries[e2[i2]], t4);
          }, t3.prototype.activateVao = function(t4, e2) {
            var i2 = this.gl, n2 = this.CONTEXT_UID, r2 = this.renderer.buffer, o2 = t4.buffers, s2 = t4.attributes;
            t4.indexBuffer && r2.bind(t4.indexBuffer);
            var a2 = null;
            for (var l2 in s2) {
              var h2 = s2[l2], u2 = o2[h2.buffer], c2 = u2._glBuffers[n2];
              if (e2.attributeData[l2]) {
                a2 !== c2 && (r2.bind(u2), a2 = c2);
                var d2 = e2.attributeData[l2].location;
                if (i2.enableVertexAttribArray(d2), i2.vertexAttribPointer(d2, h2.size, h2.type || i2.FLOAT, h2.normalized, h2.stride, h2.start), h2.instance) {
                  if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
                  i2.vertexAttribDivisor(d2, 1);
                }
              }
            }
          }, t3.prototype.draw = function(t4, e2, i2, n2) {
            var r2 = this.gl, o2 = this._activeGeometry;
            if (o2.indexBuffer) {
              var s2 = o2.indexBuffer.data.BYTES_PER_ELEMENT, a2 = 2 === s2 ? r2.UNSIGNED_SHORT : r2.UNSIGNED_INT;
              2 === s2 || 4 === s2 && this.canUseUInt32ElementIndex ? o2.instanced ? r2.drawElementsInstanced(t4, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2, n2 || 1) : r2.drawElements(t4, e2 || o2.indexBuffer.data.length, a2, (i2 || 0) * s2) : console.warn("unsupported index buffer type: uint32");
            } else o2.instanced ? r2.drawArraysInstanced(t4, i2, e2 || o2.getSize(), n2 || 1) : r2.drawArrays(t4, i2, e2 || o2.getSize());
            return this;
          }, t3.prototype.unbind = function() {
            this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }(), xe = function() {
          function t3(t4) {
            void 0 === t4 && (t4 = null), this.type = r.j.NONE, this.autoDetect = true, this.maskObject = t4 || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = n.b.FILTER_MULTISAMPLE, this.enabled = true, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._target = null;
          }
          return Object.defineProperty(t3.prototype, "filter", { get: function() {
            return this._filters ? this._filters[0] : null;
          }, set: function(t4) {
            t4 ? this._filters ? this._filters[0] = t4 : this._filters = [t4] : this._filters = null;
          }, enumerable: false, configurable: true }), t3.prototype.reset = function() {
            this.pooled && (this.maskObject = null, this.type = r.j.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
          }, t3.prototype.copyCountersOrReset = function(t4) {
            t4 ? (this._stencilCounter = t4._stencilCounter, this._scissorCounter = t4._scissorCounter, this._scissorRect = t4._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
          }, t3;
        }();
        function be(t3, e2, i2) {
          var n2 = t3.createShader(e2);
          return t3.shaderSource(n2, i2), t3.compileShader(n2), n2;
        }
        function Te(t3, e2) {
          var i2 = t3.getShaderSource(e2).split("\n").map(function(t4, e3) {
            return e3 + ": " + t4;
          }), n2 = t3.getShaderInfoLog(e2), r2 = n2.split("\n"), o2 = {}, s2 = r2.map(function(t4) {
            return parseFloat(t4.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
          }).filter(function(t4) {
            return !(!t4 || o2[t4]) && (o2[t4] = true, true);
          }), a2 = [""];
          s2.forEach(function(t4) {
            i2[t4 - 1] = "%c" + i2[t4 - 1] + "%c", a2.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
          });
          var l2 = i2.join("\n");
          a2[0] = l2, console.error(n2), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a2), console.groupEnd();
        }
        function Ee(t3) {
          for (var e2 = new Array(t3), i2 = 0; i2 < e2.length; i2++) e2[i2] = false;
          return e2;
        }
        function Se(t3, e2) {
          switch (t3) {
            case "float":
              return 0;
            case "vec2":
              return new Float32Array(2 * e2);
            case "vec3":
              return new Float32Array(3 * e2);
            case "vec4":
              return new Float32Array(4 * e2);
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
              return 0;
            case "ivec2":
              return new Int32Array(2 * e2);
            case "ivec3":
              return new Int32Array(3 * e2);
            case "ivec4":
              return new Int32Array(4 * e2);
            case "uvec2":
              return new Uint32Array(2 * e2);
            case "uvec3":
              return new Uint32Array(3 * e2);
            case "uvec4":
              return new Uint32Array(4 * e2);
            case "bool":
              return false;
            case "bvec2":
              return Ee(2 * e2);
            case "bvec3":
              return Ee(3 * e2);
            case "bvec4":
              return Ee(4 * e2);
            case "mat2":
              return new Float32Array([1, 0, 0, 1]);
            case "mat3":
              return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            case "mat4":
              return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
          }
          return null;
        }
        var we, Ae = {}, Me = Ae;
        function Ce() {
          if (!we) {
            we = r.m.MEDIUM;
            var t3 = function() {
              if (Me === Ae || Me && Me.isContextLost()) {
                var t4 = document.createElement("canvas"), e3 = void 0;
                n.b.PREFER_ENV >= r.g.WEBGL2 && (e3 = t4.getContext("webgl2", {})), e3 || ((e3 = t4.getContext("webgl", {}) || t4.getContext("experimental-webgl", {})) ? e3.getExtension("WEBGL_draw_buffers") : e3 = null), Me = e3;
              }
              return Me;
            }();
            if (t3 && t3.getShaderPrecisionFormat) {
              var e2 = t3.getShaderPrecisionFormat(t3.FRAGMENT_SHADER, t3.HIGH_FLOAT);
              we = e2.precision ? r.m.HIGH : r.m.MEDIUM;
            }
          }
          return we;
        }
        function Re(t3, e2, i2) {
          if ("precision" !== t3.substring(0, 9)) {
            var n2 = e2;
            return e2 === r.m.HIGH && i2 !== r.m.HIGH && (n2 = r.m.MEDIUM), "precision " + n2 + " float;\n" + t3;
          }
          return i2 !== r.m.HIGH && "precision highp" === t3.substring(0, 15) ? t3.replace("precision highp", "precision mediump") : t3;
        }
        var Ie = { float: 1, vec2: 2, vec3: 3, vec4: 4, int: 1, ivec2: 2, ivec3: 3, ivec4: 4, uint: 1, uvec2: 2, uvec3: 3, uvec4: 4, bool: 1, bvec2: 2, bvec3: 3, bvec4: 4, mat2: 4, mat3: 9, mat4: 16, sampler2D: 1 };
        function Pe(t3) {
          return Ie[t3];
        }
        var Oe = null, Ne = { FLOAT: "float", FLOAT_VEC2: "vec2", FLOAT_VEC3: "vec3", FLOAT_VEC4: "vec4", INT: "int", INT_VEC2: "ivec2", INT_VEC3: "ivec3", INT_VEC4: "ivec4", UNSIGNED_INT: "uint", UNSIGNED_INT_VEC2: "uvec2", UNSIGNED_INT_VEC3: "uvec3", UNSIGNED_INT_VEC4: "uvec4", BOOL: "bool", BOOL_VEC2: "bvec2", BOOL_VEC3: "bvec3", BOOL_VEC4: "bvec4", FLOAT_MAT2: "mat2", FLOAT_MAT3: "mat3", FLOAT_MAT4: "mat4", SAMPLER_2D: "sampler2D", INT_SAMPLER_2D: "sampler2D", UNSIGNED_INT_SAMPLER_2D: "sampler2D", SAMPLER_CUBE: "samplerCube", INT_SAMPLER_CUBE: "samplerCube", UNSIGNED_INT_SAMPLER_CUBE: "samplerCube", SAMPLER_2D_ARRAY: "sampler2DArray", INT_SAMPLER_2D_ARRAY: "sampler2DArray", UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray" };
        function Le(t3, e2) {
          if (!Oe) {
            var i2 = Object.keys(Ne);
            Oe = {};
            for (var n2 = 0; n2 < i2.length; ++n2) {
              var r2 = i2[n2];
              Oe[t3[r2]] = Ne[r2];
            }
          }
          return Oe[e2];
        }
        var De = [{ test: function(t3) {
          return "float" === t3.type && 1 === t3.size;
        }, code: function(t3) {
          return '\n            if(uv["' + t3 + '"] !== ud["' + t3 + '"].value)\n            {\n                ud["' + t3 + '"].value = uv["' + t3 + '"]\n                gl.uniform1f(ud["' + t3 + '"].location, uv["' + t3 + '"])\n            }\n            ';
        } }, { test: function(t3) {
          return ("sampler2D" === t3.type || "samplerCube" === t3.type || "sampler2DArray" === t3.type) && 1 === t3.size && !t3.isArray;
        }, code: function(t3) {
          return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t3 + '"], t);\n\n            if(ud["' + t3 + '"].value !== t)\n            {\n                ud["' + t3 + '"].value = t;\n                gl.uniform1i(ud["' + t3 + '"].location, t);\n; // eslint-disable-line max-len\n            }';
        } }, { test: function(t3, e2) {
          return "mat3" === t3.type && 1 === t3.size && void 0 !== e2.a;
        }, code: function(t3) {
          return '\n            gl.uniformMatrix3fv(ud["' + t3 + '"].location, false, uv["' + t3 + '"].toArray(true));\n            ';
        }, codeUbo: function(t3) {
          return "\n                var " + t3 + "_matrix = uv." + t3 + ".toArray(true);\n\n                data[offset] = " + t3 + "_matrix[0];\n                data[offset+1] = " + t3 + "_matrix[1];\n                data[offset+2] = " + t3 + "_matrix[2];\n        \n                data[offset + 4] = " + t3 + "_matrix[3];\n                data[offset + 5] = " + t3 + "_matrix[4];\n                data[offset + 6] = " + t3 + "_matrix[5];\n        \n                data[offset + 8] = " + t3 + "_matrix[6];\n                data[offset + 9] = " + t3 + "_matrix[7];\n                data[offset + 10] = " + t3 + "_matrix[8];\n            ";
        } }, { test: function(t3, e2) {
          return "vec2" === t3.type && 1 === t3.size && void 0 !== e2.x;
        }, code: function(t3) {
          return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t3 + '"].location, v.x, v.y);\n                }';
        }, codeUbo: function(t3) {
          return "\n                v = uv." + t3 + ";\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            ";
        } }, { test: function(t3) {
          return "vec2" === t3.type && 1 === t3.size;
        }, code: function(t3) {
          return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t3 + '"].location, v[0], v[1]);\n                }\n            ';
        } }, { test: function(t3, e2) {
          return "vec4" === t3.type && 1 === t3.size && void 0 !== e2.width;
        }, code: function(t3) {
          return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t3 + '"].location, v.x, v.y, v.width, v.height)\n                }';
        }, codeUbo: function(t3) {
          return "\n                    v = uv." + t3 + ";\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                ";
        } }, { test: function(t3) {
          return "vec4" === t3.type && 1 === t3.size;
        }, code: function(t3) {
          return '\n                cv = ud["' + t3 + '"].value;\n                v = uv["' + t3 + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t3 + '"].location, v[0], v[1], v[2], v[3])\n                }';
        } }], Fe = { float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }", vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }", ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }", bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", mat2: "gl.uniformMatrix2fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", sampler2D: "gl.uniform1i(location, v)", samplerCube: "gl.uniform1i(location, v)", sampler2DArray: "gl.uniform1i(location, v)" }, Be = { float: "gl.uniform1fv(location, v)", vec2: "gl.uniform2fv(location, v)", vec3: "gl.uniform3fv(location, v)", vec4: "gl.uniform4fv(location, v)", mat4: "gl.uniformMatrix4fv(location, false, v)", mat3: "gl.uniformMatrix3fv(location, false, v)", mat2: "gl.uniformMatrix2fv(location, false, v)", int: "gl.uniform1iv(location, v)", ivec2: "gl.uniform2iv(location, v)", ivec3: "gl.uniform3iv(location, v)", ivec4: "gl.uniform4iv(location, v)", uint: "gl.uniform1uiv(location, v)", uvec2: "gl.uniform2uiv(location, v)", uvec3: "gl.uniform3uiv(location, v)", uvec4: "gl.uniform4uiv(location, v)", bool: "gl.uniform1iv(location, v)", bvec2: "gl.uniform2iv(location, v)", bvec3: "gl.uniform3iv(location, v)", bvec4: "gl.uniform4iv(location, v)", sampler2D: "gl.uniform1iv(location, v)", samplerCube: "gl.uniform1iv(location, v)", sampler2DArray: "gl.uniform1iv(location, v)" };
        var Ue, ke = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");
        function Ge(t3) {
          for (var e2 = "", i2 = 0; i2 < t3; ++i2) i2 > 0 && (e2 += "\nelse "), i2 < t3 - 1 && (e2 += "if(test == " + i2 + ".0){}");
          return e2;
        }
        var He = 0, je = {}, ze = function() {
          function t3(e2, i2, o2) {
            void 0 === o2 && (o2 = "pixi-shader"), this.id = He++, this.vertexSrc = e2 || t3.defaultVertexSrc, this.fragmentSrc = i2 || t3.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (o2 = o2.replace(/\s+/g, "-"), je[o2] ? (je[o2]++, o2 += "-" + je[o2]) : je[o2] = 1, this.vertexSrc = "#define SHADER_NAME " + o2 + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + o2 + "\n" + this.fragmentSrc, this.vertexSrc = Re(this.vertexSrc, n.b.PRECISION_VERTEX, r.m.HIGH), this.fragmentSrc = Re(this.fragmentSrc, n.b.PRECISION_FRAGMENT, Ce())), this.glPrograms = {}, this.syncUniforms = null;
          }
          return Object.defineProperty(t3, "defaultVertexSrc", { get: function() {
            return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n";
          }, enumerable: false, configurable: true }), Object.defineProperty(t3, "defaultFragmentSrc", { get: function() {
            return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}";
          }, enumerable: false, configurable: true }), t3.from = function(e2, i2, n2) {
            var r2 = e2 + i2, o2 = K[r2];
            return o2 || (K[r2] = o2 = new t3(e2, i2, n2)), o2;
          }, t3;
        }(), Ve = function() {
          function t3(t4, e2) {
            this.uniformBindCount = 0, this.program = t4, this.uniformGroup = e2 ? e2 instanceof se ? e2 : new se(e2) : new se({});
          }
          return t3.prototype.checkUniformExists = function(t4, e2) {
            if (e2.uniforms[t4]) return true;
            for (var i2 in e2.uniforms) {
              var n2 = e2.uniforms[i2];
              if (n2.group && this.checkUniformExists(t4, n2)) return true;
            }
            return false;
          }, t3.prototype.destroy = function() {
            this.uniformGroup = null;
          }, Object.defineProperty(t3.prototype, "uniforms", { get: function() {
            return this.uniformGroup.uniforms;
          }, enumerable: false, configurable: true }), t3.from = function(e2, i2, n2) {
            return new t3(ze.from(e2, i2), n2);
          }, t3;
        }(), Xe = function() {
          function t3() {
            this.data = 0, this.blendMode = r.b.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
          }
          return Object.defineProperty(t3.prototype, "blend", { get: function() {
            return !!(1 & this.data);
          }, set: function(t4) {
            !!(1 & this.data) !== t4 && (this.data ^= 1);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "offsets", { get: function() {
            return !!(2 & this.data);
          }, set: function(t4) {
            !!(2 & this.data) !== t4 && (this.data ^= 2);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "culling", { get: function() {
            return !!(4 & this.data);
          }, set: function(t4) {
            !!(4 & this.data) !== t4 && (this.data ^= 4);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "depthTest", { get: function() {
            return !!(8 & this.data);
          }, set: function(t4) {
            !!(8 & this.data) !== t4 && (this.data ^= 8);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "depthMask", { get: function() {
            return !!(32 & this.data);
          }, set: function(t4) {
            !!(32 & this.data) !== t4 && (this.data ^= 32);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "clockwiseFrontFace", { get: function() {
            return !!(16 & this.data);
          }, set: function(t4) {
            !!(16 & this.data) !== t4 && (this.data ^= 16);
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "blendMode", { get: function() {
            return this._blendMode;
          }, set: function(t4) {
            this.blend = t4 !== r.b.NONE, this._blendMode = t4;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "polygonOffset", { get: function() {
            return this._polygonOffset;
          }, set: function(t4) {
            this.offsets = !!t4, this._polygonOffset = t4;
          }, enumerable: false, configurable: true }), t3.prototype.toString = function() {
            return "[@pixi/core:State blendMode=" + this.blendMode + " clockwiseFrontFace=" + this.clockwiseFrontFace + " culling=" + this.culling + " depthMask=" + this.depthMask + " polygonOffset=" + this.polygonOffset + "]";
          }, t3.for2d = function() {
            var e2 = new t3();
            return e2.depthTest = false, e2.blend = true, e2;
          }, t3;
        }(), We = function(t3) {
          function e2(i2, r2, o2) {
            var s2 = this, a2 = ze.from(i2 || e2.defaultVertexSrc, r2 || e2.defaultFragmentSrc);
            return (s2 = t3.call(this, a2, o2) || this).padding = 0, s2.resolution = n.b.FILTER_RESOLUTION, s2.multisample = n.b.FILTER_MULTISAMPLE, s2.enabled = true, s2.autoFit = true, s2.state = new Xe(), s2;
          }
          return St(e2, t3), e2.prototype.apply = function(t4, e3, i2, n2, r2) {
            t4.applyFilter(this, e3, i2, n2);
          }, Object.defineProperty(e2.prototype, "blendMode", { get: function() {
            return this.state.blendMode;
          }, set: function(t4) {
            this.state.blendMode = t4;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
            return this._resolution;
          }, set: function(t4) {
            this._resolution = t4;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultVertexSrc", { get: function() {
            return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n";
          }, enumerable: false, configurable: true }), Object.defineProperty(e2, "defaultFragmentSrc", { get: function() {
            return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n";
          }, enumerable: false, configurable: true }), e2;
        }(Ve), Ye = new dt(), qe = function() {
          function t3(t4, e2) {
            this._texture = t4, this.mapCoord = new dt(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e2 ? 0.5 : e2, this.isSimple = false;
          }
          return Object.defineProperty(t3.prototype, "texture", { get: function() {
            return this._texture;
          }, set: function(t4) {
            this._texture = t4, this._textureID = -1;
          }, enumerable: false, configurable: true }), t3.prototype.multiplyUvs = function(t4, e2) {
            void 0 === e2 && (e2 = t4);
            for (var i2 = this.mapCoord, n2 = 0; n2 < t4.length; n2 += 2) {
              var r2 = t4[n2], o2 = t4[n2 + 1];
              e2[n2] = r2 * i2.a + o2 * i2.c + i2.tx, e2[n2 + 1] = r2 * i2.b + o2 * i2.d + i2.ty;
            }
            return e2;
          }, t3.prototype.update = function(t4) {
            var e2 = this._texture;
            if (!e2 || !e2.valid) return false;
            if (!t4 && this._textureID === e2._updateID) return false;
            this._textureID = e2._updateID, this._updateID++;
            var i2 = e2._uvs;
            this.mapCoord.set(i2.x1 - i2.x0, i2.y1 - i2.y0, i2.x3 - i2.x0, i2.y3 - i2.y0, i2.x0, i2.y0);
            var n2 = e2.orig, r2 = e2.trim;
            r2 && (Ye.set(n2.width / r2.width, 0, 0, n2.height / r2.height, -r2.x / r2.width, -r2.y / r2.height), this.mapCoord.append(Ye));
            var o2 = e2.baseTexture, s2 = this.uClampFrame, a2 = this.clampMargin / o2.resolution, l2 = this.clampOffset;
            return s2[0] = (e2._frame.x + a2 + l2) / o2.width, s2[1] = (e2._frame.y + a2 + l2) / o2.height, s2[2] = (e2._frame.x + e2._frame.width - a2 + l2) / o2.width, s2[3] = (e2._frame.y + e2._frame.height - a2 + l2) / o2.height, this.uClampOffset[0] = l2 / o2.realWidth, this.uClampOffset[1] = l2 / o2.realHeight, this.isSimple = e2._frame.width === o2.width && e2._frame.height === o2.height && 0 === e2.rotate, true;
          }, t3;
        }(), Ze = function(t3) {
          function e2(e3, i2, n2) {
            var r2 = this, o2 = null;
            return "string" != typeof e3 && void 0 === i2 && void 0 === n2 && (o2 = e3, e3 = void 0, i2 = void 0, n2 = void 0), (r2 = t3.call(this, e3 || "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", i2 || "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n", n2) || this).maskSprite = o2, r2.maskMatrix = new dt(), r2;
          }
          return St(e2, t3), Object.defineProperty(e2.prototype, "maskSprite", { get: function() {
            return this._maskSprite;
          }, set: function(t4) {
            this._maskSprite = t4, this._maskSprite && (this._maskSprite.renderable = false);
          }, enumerable: false, configurable: true }), e2.prototype.apply = function(t4, e3, i2, n2) {
            var r2 = this._maskSprite, o2 = r2._texture;
            o2.valid && (o2.uvMatrix || (o2.uvMatrix = new qe(o2, 0)), o2.uvMatrix.update(), this.uniforms.npmAlpha = o2.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o2, this.uniforms.otherMatrix = t4.calculateSpriteMatrix(this.maskMatrix, r2).prepend(o2.uvMatrix.mapCoord), this.uniforms.alpha = r2.worldAlpha, this.uniforms.maskClamp = o2.uvMatrix.uClampFrame, t4.applyFilter(this, e3, i2, n2));
          }, e2;
        }(We), Je = function() {
          function t3(t4) {
            this.renderer = t4, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
          }
          return t3.prototype.setMaskStack = function(t4) {
            this.maskStack = t4, this.renderer.scissor.setMaskStack(t4), this.renderer.stencil.setMaskStack(t4);
          }, t3.prototype.push = function(t4, e2) {
            var i2 = e2;
            if (!i2.isMaskData) {
              var n2 = this.maskDataPool.pop() || new xe();
              n2.pooled = true, n2.maskObject = e2, i2 = n2;
            }
            var o2 = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
            if (i2.copyCountersOrReset(o2), i2.autoDetect && this.detect(i2), i2._target = t4, i2.type !== r.j.SPRITE && this.maskStack.push(i2), i2.enabled) switch (i2.type) {
              case r.j.SCISSOR:
                this.renderer.scissor.push(i2);
                break;
              case r.j.STENCIL:
                this.renderer.stencil.push(i2);
                break;
              case r.j.SPRITE:
                i2.copyCountersOrReset(null), this.pushSpriteMask(i2);
            }
            i2.type === r.j.SPRITE && this.maskStack.push(i2);
          }, t3.prototype.pop = function(t4) {
            var e2 = this.maskStack.pop();
            if (e2 && e2._target === t4) {
              if (e2.enabled) switch (e2.type) {
                case r.j.SCISSOR:
                  this.renderer.scissor.pop();
                  break;
                case r.j.STENCIL:
                  this.renderer.stencil.pop(e2.maskObject);
                  break;
                case r.j.SPRITE:
                  this.popSpriteMask(e2);
              }
              if (e2.reset(), e2.pooled && this.maskDataPool.push(e2), 0 !== this.maskStack.length) {
                var i2 = this.maskStack[this.maskStack.length - 1];
                i2.type === r.j.SPRITE && i2._filters && (i2._filters[0].maskSprite = i2.maskObject);
              }
            }
          }, t3.prototype.detect = function(t4) {
            t4.maskObject.isSprite ? t4.type = r.j.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t4) ? t4.type = r.j.SCISSOR : t4.type = r.j.STENCIL;
          }, t3.prototype.pushSpriteMask = function(t4) {
            var e2, i2, n2 = t4.maskObject, r2 = t4._target, o2 = t4._filters;
            o2 || (o2 = this.alphaMaskPool[this.alphaMaskIndex]) || (o2 = this.alphaMaskPool[this.alphaMaskIndex] = [new Ze()]);
            var s2, a2, l2 = this.renderer, h2 = l2.renderTexture;
            if (h2.current) {
              var u2 = h2.current;
              s2 = t4.resolution || u2.resolution, a2 = null !== (e2 = t4.multisample) && void 0 !== e2 ? e2 : u2.multisample;
            } else s2 = t4.resolution || l2.resolution, a2 = null !== (i2 = t4.multisample) && void 0 !== i2 ? i2 : l2.multisample;
            o2[0].resolution = s2, o2[0].multisample = a2, o2[0].maskSprite = n2;
            var c2 = r2.filterArea;
            r2.filterArea = n2.getBounds(true), l2.filter.push(r2, o2), r2.filterArea = c2, t4._filters || this.alphaMaskIndex++;
          }, t3.prototype.popSpriteMask = function(t4) {
            this.renderer.filter.pop(), t4._filters ? t4._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }(), Ke = function() {
          function t3(t4) {
            this.renderer = t4, this.maskStack = [], this.glConst = 0;
          }
          return t3.prototype.getStackLength = function() {
            return this.maskStack.length;
          }, t3.prototype.setMaskStack = function(t4) {
            var e2 = this.renderer.gl, i2 = this.getStackLength();
            this.maskStack = t4;
            var n2 = this.getStackLength();
            n2 !== i2 && (0 === n2 ? e2.disable(this.glConst) : (e2.enable(this.glConst), this._useCurrent()));
          }, t3.prototype._useCurrent = function() {
          }, t3.prototype.destroy = function() {
            this.renderer = null, this.maskStack = null;
          }, t3;
        }(), Qe = new dt(), $e = function(t3) {
          function e2(e3) {
            var i2 = t3.call(this, e3) || this;
            return i2.glConst = WebGLRenderingContext.SCISSOR_TEST, i2;
          }
          return St(e2, t3), e2.prototype.getStackLength = function() {
            var t4 = this.maskStack[this.maskStack.length - 1];
            return t4 ? t4._scissorCounter : 0;
          }, e2.prototype.calcScissorRect = function(t4) {
            if (!t4._scissorRectLocal) {
              var e3 = t4._scissorRect, i2 = t4.maskObject, n2 = this.renderer, r2 = n2.renderTexture;
              i2.renderable = true;
              var o2 = i2.getBounds();
              this.roundFrameToPixels(o2, r2.current ? r2.current.resolution : n2.resolution, r2.sourceFrame, r2.destinationFrame, n2.projection.transform), i2.renderable = false, e3 && o2.fit(e3), t4._scissorRectLocal = o2;
            }
          }, e2.isMatrixRotated = function(t4) {
            if (!t4) return false;
            var e3 = t4.a, i2 = t4.b, n2 = t4.c, r2 = t4.d;
            return (Math.abs(i2) > 1e-4 || Math.abs(n2) > 1e-4) && (Math.abs(e3) > 1e-4 || Math.abs(r2) > 1e-4);
          }, e2.prototype.testScissor = function(t4) {
            var i2 = t4.maskObject;
            if (!i2.isFastRect || !i2.isFastRect()) return false;
            if (e2.isMatrixRotated(i2.worldTransform)) return false;
            if (e2.isMatrixRotated(this.renderer.projection.transform)) return false;
            this.calcScissorRect(t4);
            var n2 = t4._scissorRectLocal;
            return n2.width > 0 && n2.height > 0;
          }, e2.prototype.roundFrameToPixels = function(t4, i2, n2, r2, o2) {
            e2.isMatrixRotated(o2) || ((o2 = o2 ? Qe.copyFrom(o2) : Qe.identity()).translate(-n2.x, -n2.y).scale(r2.width / n2.width, r2.height / n2.height).translate(r2.x, r2.y), this.renderer.filter.transformAABB(o2, t4), t4.fit(r2), t4.x = Math.round(t4.x * i2), t4.y = Math.round(t4.y * i2), t4.width = Math.round(t4.width * i2), t4.height = Math.round(t4.height * i2));
          }, e2.prototype.push = function(t4) {
            t4._scissorRectLocal || this.calcScissorRect(t4);
            var e3 = this.renderer.gl;
            t4._scissorRect || e3.enable(e3.SCISSOR_TEST), t4._scissorCounter++, t4._scissorRect = t4._scissorRectLocal, this._useCurrent();
          }, e2.prototype.pop = function() {
            var t4 = this.renderer.gl;
            this.getStackLength() > 0 ? this._useCurrent() : t4.disable(t4.SCISSOR_TEST);
          }, e2.prototype._useCurrent = function() {
            var t4, e3 = this.maskStack[this.maskStack.length - 1]._scissorRect;
            t4 = this.renderer.renderTexture.current ? e3.y : this.renderer.height - e3.height - e3.y, this.renderer.gl.scissor(e3.x, t4, e3.width, e3.height);
          }, e2;
        }(Ke), ti = function(t3) {
          function e2(e3) {
            var i2 = t3.call(this, e3) || this;
            return i2.glConst = WebGLRenderingContext.STENCIL_TEST, i2;
          }
          return St(e2, t3), e2.prototype.getStackLength = function() {
            var t4 = this.maskStack[this.maskStack.length - 1];
            return t4 ? t4._stencilCounter : 0;
          }, e2.prototype.push = function(t4) {
            var e3 = t4.maskObject, i2 = this.renderer.gl, n2 = t4._stencilCounter;
            0 === n2 && (this.renderer.framebuffer.forceStencil(), i2.clearStencil(0), i2.clear(i2.STENCIL_BUFFER_BIT), i2.enable(i2.STENCIL_TEST)), t4._stencilCounter++, i2.colorMask(false, false, false, false), i2.stencilFunc(i2.EQUAL, n2, 4294967295), i2.stencilOp(i2.KEEP, i2.KEEP, i2.INCR), e3.renderable = true, e3.render(this.renderer), this.renderer.batch.flush(), e3.renderable = false, this._useCurrent();
          }, e2.prototype.pop = function(t4) {
            var e3 = this.renderer.gl;
            0 === this.getStackLength() ? e3.disable(e3.STENCIL_TEST) : (e3.colorMask(false, false, false, false), e3.stencilOp(e3.KEEP, e3.KEEP, e3.DECR), t4.renderable = true, t4.render(this.renderer), this.renderer.batch.flush(), t4.renderable = false, this._useCurrent());
          }, e2.prototype._useCurrent = function() {
            var t4 = this.renderer.gl;
            t4.colorMask(true, true, true, true), t4.stencilFunc(t4.EQUAL, this.getStackLength(), 4294967295), t4.stencilOp(t4.KEEP, t4.KEEP, t4.KEEP);
          }, e2;
        }(Ke), ei = function() {
          function t3(t4) {
            this.renderer = t4, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new dt(), this.transform = null;
          }
          return t3.prototype.update = function(t4, e2, i2, n2) {
            this.destinationFrame = t4 || this.destinationFrame || this.defaultFrame, this.sourceFrame = e2 || this.sourceFrame || t4, this.calculateProjection(this.destinationFrame, this.sourceFrame, i2, n2), this.transform && this.projectionMatrix.append(this.transform);
            var r2 = this.renderer;
            r2.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r2.globalUniforms.update(), r2.shader.shader && r2.shader.syncUniformGroup(r2.shader.shader.uniforms.globals);
          }, t3.prototype.calculateProjection = function(t4, e2, i2, n2) {
            var r2 = this.projectionMatrix, o2 = n2 ? -1 : 1;
            r2.identity(), r2.a = 1 / e2.width * 2, r2.d = o2 * (1 / e2.height * 2), r2.tx = -1 - e2.x * r2.a, r2.ty = -o2 - e2.y * r2.d;
          }, t3.prototype.setTransform = function(t4) {
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }(), ii = new ut(), ni = new ut(), ri = function() {
          function t3(t4) {
            this.renderer = t4, this.clearColor = t4._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new ut(), this.destinationFrame = new ut(), this.viewportFrame = new ut();
          }
          return t3.prototype.bind = function(t4, e2, i2) {
            void 0 === t4 && (t4 = null);
            var n2, r2, o2, s2 = this.renderer;
            this.current = t4, t4 ? (o2 = (n2 = t4.baseTexture).resolution, e2 || (ii.width = t4.frame.width, ii.height = t4.frame.height, e2 = ii), i2 || (ni.x = t4.frame.x, ni.y = t4.frame.y, ni.width = e2.width, ni.height = e2.height, i2 = ni), r2 = n2.framebuffer) : (o2 = s2.resolution, e2 || (ii.width = s2.screen.width, ii.height = s2.screen.height, e2 = ii), i2 || ((i2 = ii).width = e2.width, i2.height = e2.height));
            var a2 = this.viewportFrame;
            a2.x = i2.x * o2, a2.y = i2.y * o2, a2.width = i2.width * o2, a2.height = i2.height * o2, t4 || (a2.y = s2.view.height - (a2.y + a2.height)), a2.ceil(), this.renderer.framebuffer.bind(r2, a2), this.renderer.projection.update(i2, e2, o2, !r2), t4 ? this.renderer.mask.setMaskStack(n2.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e2), this.destinationFrame.copyFrom(i2);
          }, t3.prototype.clear = function(t4, e2) {
            t4 = this.current ? t4 || this.current.baseTexture.clearColor : t4 || this.clearColor;
            var i2 = this.destinationFrame, n2 = this.current ? this.current.baseTexture : this.renderer.screen, r2 = i2.width !== n2.width || i2.height !== n2.height;
            if (r2) {
              var o2 = this.viewportFrame, s2 = o2.x, a2 = o2.y, l2 = o2.width, h2 = o2.height;
              s2 = Math.round(s2), a2 = Math.round(a2), l2 = Math.round(l2), h2 = Math.round(h2), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(s2, a2, l2, h2);
            }
            this.renderer.framebuffer.clear(t4[0], t4[1], t4[2], t4[3], e2), r2 && this.renderer.scissor.pop();
          }, t3.prototype.resize = function() {
            this.bind(null);
          }, t3.prototype.reset = function() {
            this.bind(null);
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }();
        function oi(t3, e2, i2, n2, r2) {
          i2.buffer.update(r2);
        }
        var si = { float: "\n        data[offset] = v;\n    ", vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ", vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ", vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ", mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ", mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ", mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    " }, ai = { float: 4, vec2: 8, vec3: 12, vec4: 16, int: 4, ivec2: 8, ivec3: 12, ivec4: 16, uint: 4, uvec2: 8, uvec3: 12, uvec4: 16, bool: 4, bvec2: 8, bvec3: 12, bvec4: 16, mat2: 32, mat3: 48, mat4: 64 };
        function li(t3, e2) {
          if (!t3.autoManage) return { size: 0, syncFunc: oi };
          for (var i2 = function(t4) {
            for (var e3 = t4.map(function(t5) {
              return { data: t5, offset: 0, dataLen: 0, dirty: 0 };
            }), i3 = 0, n3 = 0, r3 = 0, o3 = 0; o3 < e3.length; o3++) {
              var s3 = e3[o3];
              if (i3 = ai[s3.data.type], s3.data.size > 1 && (i3 = Math.max(i3, 16) * s3.data.size), s3.dataLen = i3, n3 % i3 != 0 && n3 < 16) {
                var a3 = n3 % i3 % 16;
                n3 += a3, r3 += a3;
              }
              n3 + i3 > 16 ? (r3 = 16 * Math.ceil(r3 / 16), s3.offset = r3, r3 += i3, n3 = i3) : (s3.offset = r3, n3 += i3, r3 += i3);
            }
            return { uboElements: e3, size: r3 = 16 * Math.ceil(r3 / 16) };
          }(function(t4, e3) {
            var i3 = [];
            for (var n3 in t4) e3[n3] && i3.push(e3[n3]);
            return i3.sort(function(t5, e4) {
              return t5.index - e4.index;
            }), i3;
          }(t3.uniforms, e2)), n2 = i2.uboElements, r2 = i2.size, o2 = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "], s2 = 0; s2 < n2.length; s2++) {
            for (var a2 = n2[s2], l2 = t3.uniforms[a2.data.name], h2 = a2.data.name, u2 = false, c2 = 0; c2 < De.length; c2++) {
              var d2 = De[c2];
              if (d2.codeUbo && d2.test(a2.data, l2)) {
                o2.push("offset = " + a2.offset / 4 + ";", De[c2].codeUbo(a2.data.name, l2)), u2 = true;
                break;
              }
            }
            if (!u2) if (a2.data.size > 1) {
              var p2 = Pe(a2.data.type), f2 = Math.max(ai[a2.data.type] / 16, 1), m2 = p2 / f2, g2 = (4 - m2 % 4) % 4;
              o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n\n                t = 0;\n\n                for(var i=0; i < " + a2.data.size * f2 + "; i++)\n                {\n                    for(var j = 0; j < " + m2 + "; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += " + g2 + ";\n                }\n\n                ");
            } else {
              var v2 = si[a2.data.type];
              o2.push("\n                cv = ud." + h2 + ".value;\n                v = uv." + h2 + ";\n                offset = " + a2.offset / 4 + ";\n                " + v2 + ";\n                ");
            }
          }
          return o2.push("\n       renderer.buffer.update(buffer);\n    "), { size: r2, syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", o2.join("\n")) };
        }
        var hi = function() {
          function t3(t4, e2) {
            this.program = t4, this.uniformData = e2, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
          }
          return t3.prototype.destroy = function() {
            this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
          }, t3;
        }();
        function ui(t3, e2) {
          var i2 = be(t3, t3.VERTEX_SHADER, e2.vertexSrc), n2 = be(t3, t3.FRAGMENT_SHADER, e2.fragmentSrc), r2 = t3.createProgram();
          if (t3.attachShader(r2, i2), t3.attachShader(r2, n2), t3.linkProgram(r2), t3.getProgramParameter(r2, t3.LINK_STATUS) || function(t4, e3, i3, n3) {
            t4.getProgramParameter(e3, t4.LINK_STATUS) || (t4.getShaderParameter(i3, t4.COMPILE_STATUS) || Te(t4, i3), t4.getShaderParameter(n3, t4.COMPILE_STATUS) || Te(t4, n3), console.error("PixiJS Error: Could not initialize shader."), "" !== t4.getProgramInfoLog(e3) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t4.getProgramInfoLog(e3)));
          }(t3, r2, i2, n2), e2.attributeData = function(t4, e3) {
            for (var i3 = {}, n3 = e3.getProgramParameter(t4, e3.ACTIVE_ATTRIBUTES), r3 = 0; r3 < n3; r3++) {
              var o3 = e3.getActiveAttrib(t4, r3);
              if (0 !== o3.name.indexOf("gl_")) {
                var s3 = Le(e3, o3.type), a3 = { type: s3, name: o3.name, size: Pe(s3), location: e3.getAttribLocation(t4, o3.name) };
                i3[o3.name] = a3;
              }
            }
            return i3;
          }(r2, t3), e2.uniformData = function(t4, e3) {
            for (var i3 = {}, n3 = e3.getProgramParameter(t4, e3.ACTIVE_UNIFORMS), r3 = 0; r3 < n3; r3++) {
              var o3 = e3.getActiveUniform(t4, r3), s3 = o3.name.replace(/\[.*?\]$/, ""), a3 = !!o3.name.match(/\[.*?\]$/), l3 = Le(e3, o3.type);
              i3[s3] = { name: s3, index: r3, type: l3, size: o3.size, isArray: a3, value: Se(l3, o3.size) };
            }
            return i3;
          }(r2, t3), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e2.vertexSrc)) {
            var o2 = Object.keys(e2.attributeData);
            o2.sort(function(t4, e3) {
              return t4 > e3 ? 1 : -1;
            });
            for (var s2 = 0; s2 < o2.length; s2++) e2.attributeData[o2[s2]].location = s2, t3.bindAttribLocation(r2, s2, o2[s2]);
            t3.linkProgram(r2);
          }
          t3.deleteShader(i2), t3.deleteShader(n2);
          var a2 = {};
          for (var s2 in e2.uniformData) {
            var l2 = e2.uniformData[s2];
            a2[s2] = { location: t3.getUniformLocation(r2, s2), value: Se(l2.type, l2.size) };
          }
          return new hi(r2, a2);
        }
        var ci = 0, di = { textureCount: 0, uboCount: 0 }, pi = function() {
          function t3(t4) {
            this.destroyed = false, this.renderer = t4, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = ci++;
          }
          return t3.prototype.systemCheck = function() {
            if (!function() {
              if ("boolean" == typeof Ue) return Ue;
              try {
                var t4 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
                Ue = true === t4({ a: "b" }, "a", "b");
              } catch (t5) {
                Ue = false;
              }
              return Ue;
            }()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
          }, t3.prototype.contextChange = function(t4) {
            this.gl = t4, this.reset();
          }, t3.prototype.bind = function(t4, e2) {
            t4.uniforms.globals = this.renderer.globalUniforms;
            var i2 = t4.program, n2 = i2.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t4);
            return this.shader = t4, this.program !== i2 && (this.program = i2, this.gl.useProgram(n2.program)), e2 || (di.textureCount = 0, di.uboCount = 0, this.syncUniformGroup(t4.uniformGroup, di)), n2;
          }, t3.prototype.setUniforms = function(t4) {
            var e2 = this.shader.program, i2 = e2.glPrograms[this.renderer.CONTEXT_UID];
            e2.syncUniforms(i2.uniformData, t4, this.renderer);
          }, t3.prototype.syncUniformGroup = function(t4, e2) {
            var i2 = this.getGlProgram();
            t4.static && t4.dirtyId === i2.uniformDirtyGroups[t4.id] || (i2.uniformDirtyGroups[t4.id] = t4.dirtyId, this.syncUniforms(t4, i2, e2));
          }, t3.prototype.syncUniforms = function(t4, e2, i2) {
            (t4.syncUniforms[this.shader.program.id] || this.createSyncGroups(t4))(e2.uniformData, t4.uniforms, this.renderer, i2);
          }, t3.prototype.createSyncGroups = function(t4) {
            var e2 = this.getSignature(t4, this.shader.program.uniformData, "u");
            return this.cache[e2] || (this.cache[e2] = function(t5, e3) {
              var i2, n2 = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
              for (var r2 in t5.uniforms) {
                var o2 = e3[r2];
                if (o2) {
                  for (var s2 = t5.uniforms[r2], a2 = false, l2 = 0; l2 < De.length; l2++) if (De[l2].test(o2, s2)) {
                    n2.push(De[l2].code(r2, s2)), a2 = true;
                    break;
                  }
                  if (!a2) {
                    var h2 = (1 === o2.size ? Fe : Be)[o2.type].replace("location", 'ud["' + r2 + '"].location');
                    n2.push('\n            cu = ud["' + r2 + '"];\n            cv = cu.value;\n            v = uv["' + r2 + '"];\n            ' + h2 + ";");
                  }
                } else (null === (i2 = t5.uniforms[r2]) || void 0 === i2 ? void 0 : i2.group) && (t5.uniforms[r2].ubo ? n2.push("\n                        renderer.shader.syncUniformBufferGroup(uv." + r2 + ", '" + r2 + "');\n                    ") : n2.push("\n                        renderer.shader.syncUniformGroup(uv." + r2 + ", syncData);\n                    "));
              }
              return new Function("ud", "uv", "renderer", "syncData", n2.join("\n"));
            }(t4, this.shader.program.uniformData)), t4.syncUniforms[this.shader.program.id] = this.cache[e2], t4.syncUniforms[this.shader.program.id];
          }, t3.prototype.syncUniformBufferGroup = function(t4, e2) {
            var i2 = this.getGlProgram();
            if (!t4.static || 0 !== t4.dirtyId || !i2.uniformGroups[t4.id]) {
              t4.dirtyId = 0;
              var n2 = i2.uniformGroups[t4.id] || this.createSyncBufferGroup(t4, i2, e2);
              t4.buffer.update(), n2(i2.uniformData, t4.uniforms, this.renderer, di, t4.buffer);
            }
            this.renderer.buffer.bindBufferBase(t4.buffer, i2.uniformBufferBindings[e2]);
          }, t3.prototype.createSyncBufferGroup = function(t4, e2, i2) {
            var n2 = this.renderer.gl;
            this.renderer.buffer.bind(t4.buffer);
            var r2 = this.gl.getUniformBlockIndex(e2.program, i2);
            e2.uniformBufferBindings[i2] = this.shader.uniformBindCount, n2.uniformBlockBinding(e2.program, r2, this.shader.uniformBindCount), this.shader.uniformBindCount++;
            var o2 = this.getSignature(t4, this.shader.program.uniformData, "ubo"), s2 = this._uboCache[o2];
            if (s2 || (s2 = this._uboCache[o2] = li(t4, this.shader.program.uniformData)), t4.autoManage) {
              var a2 = new Float32Array(s2.size / 4);
              t4.buffer.update(a2);
            }
            return e2.uniformGroups[t4.id] = s2.syncFunc, e2.uniformGroups[t4.id];
          }, t3.prototype.getSignature = function(t4, e2, i2) {
            var n2 = t4.uniforms, r2 = [i2 + "-"];
            for (var o2 in n2) r2.push(o2), e2[o2] && r2.push(e2[o2].type);
            return r2.join("-");
          }, t3.prototype.getGlProgram = function() {
            return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
          }, t3.prototype.generateProgram = function(t4) {
            var e2 = this.gl, i2 = t4.program, n2 = ui(e2, i2);
            return i2.glPrograms[this.renderer.CONTEXT_UID] = n2, n2;
          }, t3.prototype.reset = function() {
            this.program = null, this.shader = null;
          }, t3.prototype.destroy = function() {
            this.renderer = null, this.destroyed = true;
          }, t3;
        }();
        var fi = function() {
          function t3() {
            this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = r.b.NONE, this._blendEq = false, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new Xe(), this.defaultState.blend = true;
          }
          return t3.prototype.contextChange = function(t4) {
            this.gl = t4, this.blendModes = function(t5, e2) {
              return void 0 === e2 && (e2 = []), e2[r.b.NORMAL] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD] = [t5.ONE, t5.ONE], e2[r.b.MULTIPLY] = [t5.DST_COLOR, t5.ONE_MINUS_SRC_ALPHA, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SCREEN] = [t5.ONE, t5.ONE_MINUS_SRC_COLOR, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.OVERLAY] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DARKEN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.LIGHTEN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_DODGE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR_BURN] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.HARD_LIGHT] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SOFT_LIGHT] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DIFFERENCE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.EXCLUSION] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.HUE] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SATURATION] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.COLOR] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.LUMINOSITY] = [t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.NONE] = [0, 0], e2[r.b.NORMAL_NPM] = [t5.SRC_ALPHA, t5.ONE_MINUS_SRC_ALPHA, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.ADD_NPM] = [t5.SRC_ALPHA, t5.ONE, t5.ONE, t5.ONE], e2[r.b.SCREEN_NPM] = [t5.SRC_ALPHA, t5.ONE_MINUS_SRC_COLOR, t5.ONE, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SRC_IN] = [t5.DST_ALPHA, t5.ZERO], e2[r.b.SRC_OUT] = [t5.ONE_MINUS_DST_ALPHA, t5.ZERO], e2[r.b.SRC_ATOP] = [t5.DST_ALPHA, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_OVER] = [t5.ONE_MINUS_DST_ALPHA, t5.ONE], e2[r.b.DST_IN] = [t5.ZERO, t5.SRC_ALPHA], e2[r.b.DST_OUT] = [t5.ZERO, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.DST_ATOP] = [t5.ONE_MINUS_DST_ALPHA, t5.SRC_ALPHA], e2[r.b.XOR] = [t5.ONE_MINUS_DST_ALPHA, t5.ONE_MINUS_SRC_ALPHA], e2[r.b.SUBTRACT] = [t5.ONE, t5.ONE, t5.ONE, t5.ONE, t5.FUNC_REVERSE_SUBTRACT, t5.FUNC_ADD], e2;
            }(t4), this.set(this.defaultState), this.reset();
          }, t3.prototype.set = function(t4) {
            if (t4 = t4 || this.defaultState, this.stateId !== t4.data) {
              for (var e2 = this.stateId ^ t4.data, i2 = 0; e2; ) 1 & e2 && this.map[i2].call(this, !!(t4.data & 1 << i2)), e2 >>= 1, i2++;
              this.stateId = t4.data;
            }
            for (i2 = 0; i2 < this.checks.length; i2++) this.checks[i2](this, t4);
          }, t3.prototype.forceState = function(t4) {
            t4 = t4 || this.defaultState;
            for (var e2 = 0; e2 < this.map.length; e2++) this.map[e2].call(this, !!(t4.data & 1 << e2));
            for (e2 = 0; e2 < this.checks.length; e2++) this.checks[e2](this, t4);
            this.stateId = t4.data;
          }, t3.prototype.setBlend = function(e2) {
            this.updateCheck(t3.checkBlendMode, e2), this.gl[e2 ? "enable" : "disable"](this.gl.BLEND);
          }, t3.prototype.setOffset = function(e2) {
            this.updateCheck(t3.checkPolygonOffset, e2), this.gl[e2 ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
          }, t3.prototype.setDepthTest = function(t4) {
            this.gl[t4 ? "enable" : "disable"](this.gl.DEPTH_TEST);
          }, t3.prototype.setDepthMask = function(t4) {
            this.gl.depthMask(t4);
          }, t3.prototype.setCullFace = function(t4) {
            this.gl[t4 ? "enable" : "disable"](this.gl.CULL_FACE);
          }, t3.prototype.setFrontFace = function(t4) {
            this.gl.frontFace(this.gl[t4 ? "CW" : "CCW"]);
          }, t3.prototype.setBlendMode = function(t4) {
            if (t4 !== this.blendMode) {
              this.blendMode = t4;
              var e2 = this.blendModes[t4], i2 = this.gl;
              2 === e2.length ? i2.blendFunc(e2[0], e2[1]) : i2.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), 6 === e2.length ? (this._blendEq = true, i2.blendEquationSeparate(e2[4], e2[5])) : this._blendEq && (this._blendEq = false, i2.blendEquationSeparate(i2.FUNC_ADD, i2.FUNC_ADD));
            }
          }, t3.prototype.setPolygonOffset = function(t4, e2) {
            this.gl.polygonOffset(t4, e2);
          }, t3.prototype.reset = function() {
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
          }, t3.prototype.updateCheck = function(t4, e2) {
            var i2 = this.checks.indexOf(t4);
            e2 && -1 === i2 ? this.checks.push(t4) : e2 || -1 === i2 || this.checks.splice(i2, 1);
          }, t3.checkBlendMode = function(t4, e2) {
            t4.setBlendMode(e2.blendMode);
          }, t3.checkPolygonOffset = function(t4, e2) {
            t4.setPolygonOffset(1, e2.polygonOffset);
          }, t3.prototype.destroy = function() {
            this.gl = null;
          }, t3;
        }(), mi = function() {
          function t3(t4) {
            this.renderer = t4, this.count = 0, this.checkCount = 0, this.maxIdle = n.b.GC_MAX_IDLE, this.checkCountMax = n.b.GC_MAX_CHECK_COUNT, this.mode = n.b.GC_MODE;
          }
          return t3.prototype.postrender = function() {
            this.renderer.renderingToScreen && (this.count++, this.mode !== r.i.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
          }, t3.prototype.run = function() {
            for (var t4 = this.renderer.texture, e2 = t4.managedTextures, i2 = false, n2 = 0; n2 < e2.length; n2++) {
              var r2 = e2[n2];
              !r2.framebuffer && this.count - r2.touched > this.maxIdle && (t4.destroyTexture(r2, true), e2[n2] = null, i2 = true);
            }
            if (i2) {
              var o2 = 0;
              for (n2 = 0; n2 < e2.length; n2++) null !== e2[n2] && (e2[o2++] = e2[n2]);
              e2.length = o2;
            }
          }, t3.prototype.unload = function(t4) {
            var e2 = this.renderer.texture, i2 = t4._texture;
            i2 && !i2.framebuffer && e2.destroyTexture(i2);
            for (var n2 = t4.children.length - 1; n2 >= 0; n2--) this.unload(t4.children[n2]);
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }();
        var gi = function(t3) {
          this.texture = t3, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = r.r.UNSIGNED_BYTE, this.internalFormat = r.h.RGBA, this.samplerType = 0;
        }, vi = function() {
          function t3(t4) {
            this.renderer = t4, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new Rt(), this.hasIntegerTextures = false;
          }
          return t3.prototype.contextChange = function() {
            var t4 = this.gl = this.renderer.gl;
            this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = function(t5) {
              var e3, i3, n3, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, E2, S2;
              return "WebGL2RenderingContext" in globalThis && t5 instanceof globalThis.WebGL2RenderingContext ? ((e3 = {})[r.r.UNSIGNED_BYTE] = ((i3 = {})[r.h.RGBA] = t5.RGBA8, i3[r.h.RGB] = t5.RGB8, i3[r.h.RG] = t5.RG8, i3[r.h.RED] = t5.R8, i3[r.h.RGBA_INTEGER] = t5.RGBA8UI, i3[r.h.RGB_INTEGER] = t5.RGB8UI, i3[r.h.RG_INTEGER] = t5.RG8UI, i3[r.h.RED_INTEGER] = t5.R8UI, i3[r.h.ALPHA] = t5.ALPHA, i3[r.h.LUMINANCE] = t5.LUMINANCE, i3[r.h.LUMINANCE_ALPHA] = t5.LUMINANCE_ALPHA, i3), e3[r.r.BYTE] = ((n3 = {})[r.h.RGBA] = t5.RGBA8_SNORM, n3[r.h.RGB] = t5.RGB8_SNORM, n3[r.h.RG] = t5.RG8_SNORM, n3[r.h.RED] = t5.R8_SNORM, n3[r.h.RGBA_INTEGER] = t5.RGBA8I, n3[r.h.RGB_INTEGER] = t5.RGB8I, n3[r.h.RG_INTEGER] = t5.RG8I, n3[r.h.RED_INTEGER] = t5.R8I, n3), e3[r.r.UNSIGNED_SHORT] = ((o2 = {})[r.h.RGBA_INTEGER] = t5.RGBA16UI, o2[r.h.RGB_INTEGER] = t5.RGB16UI, o2[r.h.RG_INTEGER] = t5.RG16UI, o2[r.h.RED_INTEGER] = t5.R16UI, o2[r.h.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT16, o2), e3[r.r.SHORT] = ((s2 = {})[r.h.RGBA_INTEGER] = t5.RGBA16I, s2[r.h.RGB_INTEGER] = t5.RGB16I, s2[r.h.RG_INTEGER] = t5.RG16I, s2[r.h.RED_INTEGER] = t5.R16I, s2), e3[r.r.UNSIGNED_INT] = ((a2 = {})[r.h.RGBA_INTEGER] = t5.RGBA32UI, a2[r.h.RGB_INTEGER] = t5.RGB32UI, a2[r.h.RG_INTEGER] = t5.RG32UI, a2[r.h.RED_INTEGER] = t5.R32UI, a2[r.h.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT24, a2), e3[r.r.INT] = ((l2 = {})[r.h.RGBA_INTEGER] = t5.RGBA32I, l2[r.h.RGB_INTEGER] = t5.RGB32I, l2[r.h.RG_INTEGER] = t5.RG32I, l2[r.h.RED_INTEGER] = t5.R32I, l2), e3[r.r.FLOAT] = ((h2 = {})[r.h.RGBA] = t5.RGBA32F, h2[r.h.RGB] = t5.RGB32F, h2[r.h.RG] = t5.RG32F, h2[r.h.RED] = t5.R32F, h2[r.h.DEPTH_COMPONENT] = t5.DEPTH_COMPONENT32F, h2), e3[r.r.HALF_FLOAT] = ((u2 = {})[r.h.RGBA] = t5.RGBA16F, u2[r.h.RGB] = t5.RGB16F, u2[r.h.RG] = t5.RG16F, u2[r.h.RED] = t5.R16F, u2), e3[r.r.UNSIGNED_SHORT_5_6_5] = ((c2 = {})[r.h.RGB] = t5.RGB565, c2), e3[r.r.UNSIGNED_SHORT_4_4_4_4] = ((d2 = {})[r.h.RGBA] = t5.RGBA4, d2), e3[r.r.UNSIGNED_SHORT_5_5_5_1] = ((p2 = {})[r.h.RGBA] = t5.RGB5_A1, p2), e3[r.r.UNSIGNED_INT_2_10_10_10_REV] = ((f2 = {})[r.h.RGBA] = t5.RGB10_A2, f2[r.h.RGBA_INTEGER] = t5.RGB10_A2UI, f2), e3[r.r.UNSIGNED_INT_10F_11F_11F_REV] = ((m2 = {})[r.h.RGB] = t5.R11F_G11F_B10F, m2), e3[r.r.UNSIGNED_INT_5_9_9_9_REV] = ((g2 = {})[r.h.RGB] = t5.RGB9_E5, g2), e3[r.r.UNSIGNED_INT_24_8] = ((v2 = {})[r.h.DEPTH_STENCIL] = t5.DEPTH24_STENCIL8, v2), e3[r.r.FLOAT_32_UNSIGNED_INT_24_8_REV] = ((_2 = {})[r.h.DEPTH_STENCIL] = t5.DEPTH32F_STENCIL8, _2), S2 = e3) : ((y2 = {})[r.r.UNSIGNED_BYTE] = ((x2 = {})[r.h.RGBA] = t5.RGBA, x2[r.h.RGB] = t5.RGB, x2[r.h.ALPHA] = t5.ALPHA, x2[r.h.LUMINANCE] = t5.LUMINANCE, x2[r.h.LUMINANCE_ALPHA] = t5.LUMINANCE_ALPHA, x2), y2[r.r.UNSIGNED_SHORT_5_6_5] = ((b2 = {})[r.h.RGB] = t5.RGB, b2), y2[r.r.UNSIGNED_SHORT_4_4_4_4] = ((T2 = {})[r.h.RGBA] = t5.RGBA, T2), y2[r.r.UNSIGNED_SHORT_5_5_5_1] = ((E2 = {})[r.h.RGBA] = t5.RGBA, E2), S2 = y2), S2;
            }(t4);
            var e2 = t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS);
            this.boundTextures.length = e2;
            for (var i2 = 0; i2 < e2; i2++) this.boundTextures[i2] = null;
            this.emptyTextures = {};
            var n2 = new gi(t4.createTexture());
            t4.bindTexture(t4.TEXTURE_2D, n2.texture), t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, 1, 1, 0, t4.RGBA, t4.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t4.TEXTURE_2D] = n2, this.emptyTextures[t4.TEXTURE_CUBE_MAP] = new gi(t4.createTexture()), t4.bindTexture(t4.TEXTURE_CUBE_MAP, this.emptyTextures[t4.TEXTURE_CUBE_MAP].texture);
            for (i2 = 0; i2 < 6; i2++) t4.texImage2D(t4.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, t4.RGBA, 1, 1, 0, t4.RGBA, t4.UNSIGNED_BYTE, null);
            t4.texParameteri(t4.TEXTURE_CUBE_MAP, t4.TEXTURE_MAG_FILTER, t4.LINEAR), t4.texParameteri(t4.TEXTURE_CUBE_MAP, t4.TEXTURE_MIN_FILTER, t4.LINEAR);
            for (i2 = 0; i2 < this.boundTextures.length; i2++) this.bind(null, i2);
          }, t3.prototype.bind = function(t4, e2) {
            void 0 === e2 && (e2 = 0);
            var i2 = this.gl;
            if ((t4 = null == t4 ? void 0 : t4.castToBaseTexture()) && t4.valid && !t4.parentTextureArray) {
              t4.touched = this.renderer.textureGC.count;
              var n2 = t4._glTextures[this.CONTEXT_UID] || this.initTexture(t4);
              this.boundTextures[e2] !== t4 && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(t4.target, n2.texture)), n2.dirtyId !== t4.dirtyId && (this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), this.updateTexture(t4)), this.boundTextures[e2] = t4;
            } else this.currentLocation !== e2 && (this.currentLocation = e2, i2.activeTexture(i2.TEXTURE0 + e2)), i2.bindTexture(i2.TEXTURE_2D, this.emptyTextures[i2.TEXTURE_2D].texture), this.boundTextures[e2] = null;
          }, t3.prototype.reset = function() {
            this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
            for (var t4 = 0; t4 < this.boundTextures.length; t4++) this.boundTextures[t4] = this.unknownTexture;
          }, t3.prototype.unbind = function(t4) {
            var e2 = this.gl, i2 = this.boundTextures;
            if (this._unknownBoundTextures) {
              this._unknownBoundTextures = false;
              for (var n2 = 0; n2 < i2.length; n2++) i2[n2] === this.unknownTexture && this.bind(null, n2);
            }
            for (n2 = 0; n2 < i2.length; n2++) i2[n2] === t4 && (this.currentLocation !== n2 && (e2.activeTexture(e2.TEXTURE0 + n2), this.currentLocation = n2), e2.bindTexture(t4.target, this.emptyTextures[t4.target].texture), i2[n2] = null);
          }, t3.prototype.ensureSamplerType = function(t4) {
            var e2 = this.boundTextures, i2 = this.hasIntegerTextures, n2 = this.CONTEXT_UID;
            if (i2) for (var o2 = t4 - 1; o2 >= 0; --o2) {
              var s2 = e2[o2];
              if (s2) s2._glTextures[n2].samplerType !== r.o.FLOAT && this.renderer.texture.unbind(s2);
            }
          }, t3.prototype.initTexture = function(t4) {
            var e2 = new gi(this.gl.createTexture());
            return e2.dirtyId = -1, t4._glTextures[this.CONTEXT_UID] = e2, this.managedTextures.push(t4), t4.on("dispose", this.destroyTexture, this), e2;
          }, t3.prototype.initTextureType = function(t4, e2) {
            var i2, n2;
            e2.internalFormat = null !== (n2 = null === (i2 = this.internalFormats[t4.type]) || void 0 === i2 ? void 0 : i2[t4.format]) && void 0 !== n2 ? n2 : t4.format, 2 === this.webGLVersion && t4.type === r.r.HALF_FLOAT ? e2.type = this.gl.HALF_FLOAT : e2.type = t4.type;
          }, t3.prototype.updateTexture = function(t4) {
            var e2 = t4._glTextures[this.CONTEXT_UID];
            if (e2) {
              var i2 = this.renderer;
              if (this.initTextureType(t4, e2), t4.resource && t4.resource.upload(i2, t4, e2)) e2.samplerType !== r.o.FLOAT && (this.hasIntegerTextures = true);
              else {
                var n2 = t4.realWidth, o2 = t4.realHeight, s2 = i2.gl;
                (e2.width !== n2 || e2.height !== o2 || e2.dirtyId < 0) && (e2.width = n2, e2.height = o2, s2.texImage2D(t4.target, 0, e2.internalFormat, n2, o2, 0, t4.format, e2.type, null));
              }
              t4.dirtyStyleId !== e2.dirtyStyleId && this.updateTextureStyle(t4), e2.dirtyId = t4.dirtyId;
            }
          }, t3.prototype.destroyTexture = function(t4, e2) {
            var i2 = this.gl;
            if ((t4 = t4.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t4), i2.deleteTexture(t4._glTextures[this.CONTEXT_UID].texture), t4.off("dispose", this.destroyTexture, this), delete t4._glTextures[this.CONTEXT_UID], !e2)) {
              var n2 = this.managedTextures.indexOf(t4);
              -1 !== n2 && function(t5, e3, i3) {
                var n3, r2 = t5.length;
                if (!(e3 >= r2 || 0 === i3)) {
                  var o2 = r2 - (i3 = e3 + i3 > r2 ? r2 - e3 : i3);
                  for (n3 = e3; n3 < o2; ++n3) t5[n3] = t5[n3 + i3];
                  t5.length = o2;
                }
              }(this.managedTextures, n2, 1);
            }
          }, t3.prototype.updateTextureStyle = function(t4) {
            var e2 = t4._glTextures[this.CONTEXT_UID];
            e2 && (t4.mipmap !== r.k.POW2 && 2 === this.webGLVersion || t4.isPowerOfTwo ? e2.mipmap = t4.mipmap >= 1 : e2.mipmap = false, 2 === this.webGLVersion || t4.isPowerOfTwo ? e2.wrapMode = t4.wrapMode : e2.wrapMode = r.s.CLAMP, t4.resource && t4.resource.style(this.renderer, t4, e2) || this.setStyle(t4, e2), e2.dirtyStyleId = t4.dirtyStyleId);
          }, t3.prototype.setStyle = function(t4, e2) {
            var i2 = this.gl;
            if (e2.mipmap && t4.mipmap !== r.k.ON_MANUAL && i2.generateMipmap(t4.target), i2.texParameteri(t4.target, i2.TEXTURE_WRAP_S, e2.wrapMode), i2.texParameteri(t4.target, i2.TEXTURE_WRAP_T, e2.wrapMode), e2.mipmap) {
              i2.texParameteri(t4.target, i2.TEXTURE_MIN_FILTER, t4.scaleMode === r.p.LINEAR ? i2.LINEAR_MIPMAP_LINEAR : i2.NEAREST_MIPMAP_NEAREST);
              var n2 = this.renderer.context.extensions.anisotropicFiltering;
              if (n2 && t4.anisotropicLevel > 0 && t4.scaleMode === r.p.LINEAR) {
                var o2 = Math.min(t4.anisotropicLevel, i2.getParameter(n2.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                i2.texParameterf(t4.target, n2.TEXTURE_MAX_ANISOTROPY_EXT, o2);
              }
            } else i2.texParameteri(t4.target, i2.TEXTURE_MIN_FILTER, t4.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
            i2.texParameteri(t4.target, i2.TEXTURE_MAG_FILTER, t4.scaleMode === r.p.LINEAR ? i2.LINEAR : i2.NEAREST);
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }(), _i = { __proto__: null, FilterSystem: ue, BatchSystem: de, ContextSystem: fe, FramebufferSystem: ve, GeometrySystem: ye, MaskSystem: Je, ScissorSystem: $e, StencilSystem: ti, ProjectionSystem: ei, RenderTextureSystem: ri, ShaderSystem: pi, StateSystem: fi, TextureGCSystem: mi, TextureSystem: vi }, yi = new dt(), xi = function(t3) {
          function e2(e3, i2) {
            void 0 === e3 && (e3 = r.n.UNKNOWN);
            var o2 = t3.call(this) || this;
            return i2 = Object.assign({}, n.b.RENDER_OPTIONS, i2), o2.options = i2, o2.type = e3, o2.screen = new ut(0, 0, i2.width, i2.height), o2.view = i2.view || document.createElement("canvas"), o2.resolution = i2.resolution || n.b.RESOLUTION, o2.useContextAlpha = i2.useContextAlpha, o2.autoDensity = !!i2.autoDensity, o2.preserveDrawingBuffer = i2.preserveDrawingBuffer, o2.clearBeforeRender = i2.clearBeforeRender, o2._backgroundColor = 0, o2._backgroundColorRgba = [0, 0, 0, 1], o2._backgroundColorString = "#000000", o2.backgroundColor = i2.backgroundColor || o2._backgroundColor, o2.backgroundAlpha = i2.backgroundAlpha, void 0 !== i2.transparent && (Z("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), o2.useContextAlpha = i2.transparent, o2.backgroundAlpha = i2.transparent ? 0 : 1), o2._lastObjectRendered = null, o2.plugins = {}, o2;
          }
          return St(e2, t3), e2.prototype.initPlugins = function(t4) {
            for (var e3 in t4) this.plugins[e3] = new t4[e3](this);
          }, Object.defineProperty(e2.prototype, "width", { get: function() {
            return this.view.width;
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
            return this.view.height;
          }, enumerable: false, configurable: true }), e2.prototype.resize = function(t4, e3) {
            this.view.width = Math.round(t4 * this.resolution), this.view.height = Math.round(e3 * this.resolution);
            var i2 = this.view.width / this.resolution, n2 = this.view.height / this.resolution;
            this.screen.width = i2, this.screen.height = n2, this.autoDensity && (this.view.style.width = i2 + "px", this.view.style.height = n2 + "px"), this.emit("resize", i2, n2);
          }, e2.prototype.generateTexture = function(t4, e3, i2, n2) {
            void 0 === e3 && (e3 = {}), "number" == typeof e3 && (Z("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), e3 = { scaleMode: e3, resolution: i2, region: n2 });
            var r2 = e3.region, o2 = function(t5, e4) {
              var i3 = {};
              for (var n3 in t5) Object.prototype.hasOwnProperty.call(t5, n3) && e4.indexOf(n3) < 0 && (i3[n3] = t5[n3]);
              if (null != t5 && "function" == typeof Object.getOwnPropertySymbols) {
                var r3 = 0;
                for (n3 = Object.getOwnPropertySymbols(t5); r3 < n3.length; r3++) e4.indexOf(n3[r3]) < 0 && (i3[n3[r3]] = t5[n3[r3]]);
              }
              return i3;
            }(e3, ["region"]);
            0 === (n2 = r2 || t4.getLocalBounds(null, true)).width && (n2.width = 1), 0 === n2.height && (n2.height = 1);
            var s2 = Yt.create(wt({ width: n2.width, height: n2.height }, o2));
            return yi.tx = -n2.x, yi.ty = -n2.y, this.render(t4, { renderTexture: s2, clear: false, transform: yi, skipUpdateTransform: !!t4.parent }), s2;
          }, e2.prototype.destroy = function(t4) {
            for (var e3 in this.plugins) this.plugins[e3].destroy(), this.plugins[e3] = null;
            t4 && this.view.parentNode && this.view.parentNode.removeChild(this.view);
            this.plugins = null, this.type = r.n.UNKNOWN, this.view = null, this.screen = null, this._tempDisplayObjectParent = null, this.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
          }, Object.defineProperty(e2.prototype, "backgroundColor", { get: function() {
            return this._backgroundColor;
          }, set: function(t4) {
            var e3;
            this._backgroundColor = t4, this._backgroundColorString = (e3 = t4.toString(16), "#" + (e3 = "000000".substring(0, 6 - e3.length) + e3)), function(t5, e4) {
              void 0 === e4 && (e4 = []), e4[0] = (t5 >> 16 & 255) / 255, e4[1] = (t5 >> 8 & 255) / 255, e4[2] = (255 & t5) / 255;
            }(t4, this._backgroundColorRgba);
          }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "backgroundAlpha", { get: function() {
            return this._backgroundColorRgba[3];
          }, set: function(t4) {
            this._backgroundColorRgba[3] = t4;
          }, enumerable: false, configurable: true }), e2;
        }(u), bi = function(t3) {
          this.buffer = t3 || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
        }, Ti = function() {
          function t3(t4) {
            this.renderer = t4, this.managedBuffers = {}, this.boundBufferBases = {};
          }
          return t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3.prototype.contextChange = function() {
            this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
          }, t3.prototype.bind = function(t4) {
            var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t4._glBuffers[i2] || this.createGLBuffer(t4);
            e2.bindBuffer(t4.type, n2.buffer);
          }, t3.prototype.bindBufferBase = function(t4, e2) {
            var i2 = this.gl, n2 = this.CONTEXT_UID;
            if (this.boundBufferBases[e2] !== t4) {
              var r2 = t4._glBuffers[n2] || this.createGLBuffer(t4);
              this.boundBufferBases[e2] = t4, i2.bindBufferBase(i2.UNIFORM_BUFFER, e2, r2.buffer);
            }
          }, t3.prototype.bindBufferRange = function(t4, e2, i2) {
            var n2 = this.gl, r2 = this.CONTEXT_UID;
            i2 = i2 || 0;
            var o2 = t4._glBuffers[r2] || this.createGLBuffer(t4);
            n2.bindBufferRange(n2.UNIFORM_BUFFER, e2 || 0, o2.buffer, 256 * i2, 256);
          }, t3.prototype.update = function(t4) {
            var e2 = this.gl, i2 = this.CONTEXT_UID, n2 = t4._glBuffers[i2];
            if (t4._updateID !== n2.updateID) if (n2.updateID = t4._updateID, e2.bindBuffer(t4.type, n2.buffer), n2.byteLength >= t4.data.byteLength) e2.bufferSubData(t4.type, 0, t4.data);
            else {
              var r2 = t4.static ? e2.STATIC_DRAW : e2.DYNAMIC_DRAW;
              n2.byteLength = t4.data.byteLength, e2.bufferData(t4.type, t4.data, r2);
            }
          }, t3.prototype.dispose = function(t4, e2) {
            if (this.managedBuffers[t4.id]) {
              delete this.managedBuffers[t4.id];
              var i2 = t4._glBuffers[this.CONTEXT_UID], n2 = this.gl;
              t4.disposeRunner.remove(this), i2 && (e2 || n2.deleteBuffer(i2.buffer), delete t4._glBuffers[this.CONTEXT_UID]);
            }
          }, t3.prototype.disposeAll = function(t4) {
            for (var e2 = Object.keys(this.managedBuffers), i2 = 0; i2 < e2.length; i2++) this.dispose(this.managedBuffers[e2[i2]], t4);
          }, t3.prototype.createGLBuffer = function(t4) {
            var e2 = this.CONTEXT_UID, i2 = this.gl;
            return t4._glBuffers[e2] = new bi(i2.createBuffer()), this.managedBuffers[t4.id] = t4, t4.disposeRunner.add(this), t4._glBuffers[e2];
          }, t3;
        }();
        !function(t3) {
          function e2(i2) {
            var n2 = t3.call(this, r.n.WEBGL, i2) || this;
            return i2 = n2.options, n2.gl = null, n2.CONTEXT_UID = 0, n2.runners = { destroy: new nt("destroy"), contextChange: new nt("contextChange"), reset: new nt("reset"), update: new nt("update"), postrender: new nt("postrender"), prerender: new nt("prerender"), resize: new nt("resize") }, n2.runners.contextChange.add(n2), n2.globalUniforms = new se({ projectionMatrix: new dt() }, true), n2.addSystem(Je, "mask").addSystem(fe, "context").addSystem(fi, "state").addSystem(pi, "shader").addSystem(vi, "texture").addSystem(Ti, "buffer").addSystem(ye, "geometry").addSystem(ve, "framebuffer").addSystem($e, "scissor").addSystem(ti, "stencil").addSystem(ei, "projection").addSystem(mi, "textureGC").addSystem(ue, "filter").addSystem(ri, "renderTexture").addSystem(de, "batch"), n2.initPlugins(e2.__plugins), n2.multisample = void 0, i2.context ? n2.context.initFromContext(i2.context) : n2.context.initFromOptions({ alpha: !!n2.useContextAlpha, antialias: i2.antialias, premultipliedAlpha: n2.useContextAlpha && "notMultiplied" !== n2.useContextAlpha, stencil: true, preserveDrawingBuffer: i2.preserveDrawingBuffer, powerPreference: n2.options.powerPreference }), n2.renderingToScreen = true, function(t4) {
              var e3;
              if (!G) {
                if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                  var i3 = ["\n %c %c %c PixiJS 6.4.2 - \u2730 " + t4 + " \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
                  (e3 = globalThis.console).log.apply(e3, i3);
                } else globalThis.console && globalThis.console.log("PixiJS 6.4.2 - " + t4 + " - http://www.pixijs.com/");
                G = true;
              }
            }(2 === n2.context.webGLVersion ? "WebGL 2" : "WebGL 1"), n2.resize(n2.options.width, n2.options.height), n2;
          }
          St(e2, t3), e2.create = function(t4) {
            if (void 0 === k && (k = function() {
              var t5 = { stencil: true, failIfMajorPerformanceCaveat: n.b.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT };
              try {
                if (!globalThis.WebGLRenderingContext) return false;
                var e3 = document.createElement("canvas"), i2 = e3.getContext("webgl", t5) || e3.getContext("experimental-webgl", t5), r2 = !(!i2 || !i2.getContextAttributes().stencil);
                if (i2) {
                  var o2 = i2.getExtension("WEBGL_lose_context");
                  o2 && o2.loseContext();
                }
                return i2 = null, r2;
              } catch (t6) {
                return false;
              }
            }()), k) return new e2(t4);
            throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
          }, e2.prototype.contextChange = function() {
            var t4, e3 = this.gl;
            if (1 === this.context.webGLVersion) {
              var i2 = e3.getParameter(e3.FRAMEBUFFER_BINDING);
              e3.bindFramebuffer(e3.FRAMEBUFFER, null), t4 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.FRAMEBUFFER, i2);
            } else {
              i2 = e3.getParameter(e3.DRAW_FRAMEBUFFER_BINDING);
              e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, null), t4 = e3.getParameter(e3.SAMPLES), e3.bindFramebuffer(e3.DRAW_FRAMEBUFFER, i2);
            }
            t4 >= r.l.HIGH ? this.multisample = r.l.HIGH : t4 >= r.l.MEDIUM ? this.multisample = r.l.MEDIUM : t4 >= r.l.LOW ? this.multisample = r.l.LOW : this.multisample = r.l.NONE;
          }, e2.prototype.addSystem = function(t4, e3) {
            var i2 = new t4(this);
            if (this[e3]) throw new Error('Whoops! The name "' + e3 + '" is already in use');
            for (var n2 in this[e3] = i2, this.runners) this.runners[n2].add(i2);
            return this;
          }, e2.prototype.render = function(t4, e3) {
            var i2, n2, r2, o2;
            if (e3 && (e3 instanceof Yt ? (Z("6.0.0", "Renderer#render arguments changed, use options instead."), i2 = e3, n2 = arguments[2], r2 = arguments[3], o2 = arguments[4]) : (i2 = e3.renderTexture, n2 = e3.clear, r2 = e3.transform, o2 = e3.skipUpdateTransform)), this.renderingToScreen = !i2, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = r2, !this.context.isLost) {
              if (i2 || (this._lastObjectRendered = t4), !o2) {
                var s2 = t4.enableTempParent();
                t4.updateTransform(), t4.disableTempParent(s2);
              }
              this.renderTexture.bind(i2), this.batch.currentRenderer.start(), (void 0 !== n2 ? n2 : this.clearBeforeRender) && this.renderTexture.clear(), t4.render(this), this.batch.currentRenderer.flush(), i2 && i2.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
            }
          }, e2.prototype.generateTexture = function(e3, i2, n2, r2) {
            void 0 === i2 && (i2 = {});
            var o2 = t3.prototype.generateTexture.call(this, e3, i2, n2, r2);
            return this.framebuffer.blit(), o2;
          }, e2.prototype.resize = function(e3, i2) {
            t3.prototype.resize.call(this, e3, i2), this.runners.resize.emit(this.screen.height, this.screen.width);
          }, e2.prototype.reset = function() {
            return this.runners.reset.emit(), this;
          }, e2.prototype.clear = function() {
            this.renderTexture.bind(), this.renderTexture.clear();
          }, e2.prototype.destroy = function(e3) {
            for (var i2 in this.runners.destroy.emit(), this.runners) this.runners[i2].destroy();
            t3.prototype.destroy.call(this, e3), this.gl = null;
          }, Object.defineProperty(e2.prototype, "extract", { get: function() {
            return Z("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
          }, enumerable: false, configurable: true }), e2.registerPlugin = function(t4, i2) {
            e2.__plugins = e2.__plugins || {}, e2.__plugins[t4] = i2;
          };
        }(xi);
        var Ei = function() {
          this.texArray = null, this.blend = 0, this.type = r.f.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
        }, Si = function() {
          function t3() {
            this.elements = [], this.ids = [], this.count = 0;
          }
          return t3.prototype.clear = function() {
            for (var t4 = 0; t4 < this.count; t4++) this.elements[t4] = null;
            this.count = 0;
          }, t3;
        }(), wi = function() {
          function t3(t4) {
            "number" == typeof t4 ? this.rawBinaryData = new ArrayBuffer(t4) : t4 instanceof Uint8Array ? this.rawBinaryData = t4.buffer : this.rawBinaryData = t4, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
          }
          return Object.defineProperty(t3.prototype, "int8View", { get: function() {
            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "uint8View", { get: function() {
            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "int16View", { get: function() {
            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "uint16View", { get: function() {
            return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "int32View", { get: function() {
            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
          }, enumerable: false, configurable: true }), t3.prototype.view = function(t4) {
            return this[t4 + "View"];
          }, t3.prototype.destroy = function() {
            this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
          }, t3.sizeOf = function(t4) {
            switch (t4) {
              case "int8":
              case "uint8":
                return 1;
              case "int16":
              case "uint16":
                return 2;
              case "int32":
              case "uint32":
              case "float32":
                return 4;
              default:
                throw new Error(t4 + " isn't a valid view type");
            }
          }, t3;
        }(), Ai = function(t3) {
          function e2(e3) {
            var i2 = t3.call(this, e3) || this;
            return i2.shaderGenerator = null, i2.geometryClass = null, i2.vertexSize = null, i2.state = Xe.for2d(), i2.size = 4 * n.b.SPRITE_BATCH_SIZE, i2._vertexCount = 0, i2._indexCount = 0, i2._bufferedElements = [], i2._bufferedTextures = [], i2._bufferSize = 0, i2._shader = null, i2._packedGeometries = [], i2._packedGeometryPoolSize = 2, i2._flushId = 0, i2._aBuffers = {}, i2._iBuffers = {}, i2.MAX_TEXTURES = 1, i2.renderer.on("prerender", i2.onPrerender, i2), e3.runners.contextChange.add(i2), i2._dcIndex = 0, i2._aIndex = 0, i2._iIndex = 0, i2._attributeBuffer = null, i2._indexBuffer = null, i2._tempBoundTextures = [], i2;
          }
          return St(e2, t3), e2.prototype.contextChange = function() {
            var t4 = this.renderer.gl;
            n.b.PREFER_ENV === r.g.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t4.getParameter(t4.MAX_TEXTURE_IMAGE_UNITS), n.b.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = function(t5, e4) {
              if (0 === t5) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
              for (var i2 = e4.createShader(e4.FRAGMENT_SHADER); ; ) {
                var n2 = ke.replace(/%forloop%/gi, Ge(t5));
                if (e4.shaderSource(i2, n2), e4.compileShader(i2), e4.getShaderParameter(i2, e4.COMPILE_STATUS)) break;
                t5 = t5 / 2 | 0;
              }
              return t5;
            }(this.MAX_TEXTURES, t4)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
            for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++) this._packedGeometries[e3] = new this.geometryClass();
            this.initFlushBuffers();
          }, e2.prototype.initFlushBuffers = function() {
            for (var t4 = e2._drawCallPool, i2 = e2._textureArrayPool, n2 = this.size / 4, r2 = Math.floor(n2 / this.MAX_TEXTURES) + 1; t4.length < n2; ) t4.push(new Ei());
            for (; i2.length < r2; ) i2.push(new Si());
            for (var o2 = 0; o2 < this.MAX_TEXTURES; o2++) this._tempBoundTextures[o2] = null;
          }, e2.prototype.onPrerender = function() {
            this._flushId = 0;
          }, e2.prototype.render = function(t4) {
            t4._texture.valid && (this._vertexCount + t4.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t4.vertexData.length / 2, this._indexCount += t4.indices.length, this._bufferedTextures[this._bufferSize] = t4._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t4);
          }, e2.prototype.buildTexturesAndDrawCalls = function() {
            var t4 = this._bufferedTextures, i2 = this.MAX_TEXTURES, n2 = e2._textureArrayPool, r2 = this.renderer.batch, o2 = this._tempBoundTextures, s2 = this.renderer.textureGC.count, a2 = ++Rt._globalBatch, l2 = 0, h2 = n2[0], u2 = 0;
            r2.copyBoundTextures(o2, i2);
            for (var c2 = 0; c2 < this._bufferSize; ++c2) {
              var d2 = t4[c2];
              t4[c2] = null, d2._batchEnabled !== a2 && (h2.count >= i2 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, c2), u2 = c2, h2 = n2[++l2], ++a2), d2._batchEnabled = a2, d2.touched = s2, h2.elements[h2.count++] = d2);
            }
            h2.count > 0 && (r2.boundArray(h2, o2, a2, i2), this.buildDrawCalls(h2, u2, this._bufferSize), ++l2, ++a2);
            for (c2 = 0; c2 < o2.length; c2++) o2[c2] = null;
            Rt._globalBatch = a2;
          }, e2.prototype.buildDrawCalls = function(t4, i2, n2) {
            var r2 = this._bufferedElements, o2 = this._attributeBuffer, s2 = this._indexBuffer, a2 = this.vertexSize, l2 = e2._drawCallPool, h2 = this._dcIndex, u2 = this._aIndex, c2 = this._iIndex, d2 = l2[h2];
            d2.start = this._iIndex, d2.texArray = t4;
            for (var p2 = i2; p2 < n2; ++p2) {
              var f2 = r2[p2], m2 = f2._texture.baseTexture, g2 = H[m2.alphaMode ? 1 : 0][f2.blendMode];
              r2[p2] = null, i2 < p2 && d2.blend !== g2 && (d2.size = c2 - d2.start, i2 = p2, (d2 = l2[++h2]).texArray = t4, d2.start = c2), this.packInterleavedGeometry(f2, o2, s2, u2, c2), u2 += f2.vertexData.length / 2 * a2, c2 += f2.indices.length, d2.blend = g2;
            }
            i2 < n2 && (d2.size = c2 - d2.start, ++h2), this._dcIndex = h2, this._aIndex = u2, this._iIndex = c2;
          }, e2.prototype.bindAndClearTexArray = function(t4) {
            for (var e3 = this.renderer.texture, i2 = 0; i2 < t4.count; i2++) e3.bind(t4.elements[i2], t4.ids[i2]), t4.elements[i2] = null;
            t4.count = 0;
          }, e2.prototype.updateGeometry = function() {
            var t4 = this._packedGeometries, e3 = this._attributeBuffer, i2 = this._indexBuffer;
            n.b.CAN_UPLOAD_SAME_BUFFER ? (t4[this._flushId]._buffer.update(e3.rawBinaryData), t4[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, t4[this._flushId] = new this.geometryClass()), t4[this._flushId]._buffer.update(e3.rawBinaryData), t4[this._flushId]._indexBuffer.update(i2), this.renderer.geometry.bind(t4[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
          }, e2.prototype.drawBatches = function() {
            for (var t4 = this._dcIndex, i2 = this.renderer, n2 = i2.gl, r2 = i2.state, o2 = e2._drawCallPool, s2 = null, a2 = 0; a2 < t4; a2++) {
              var l2 = o2[a2], h2 = l2.texArray, u2 = l2.type, c2 = l2.size, d2 = l2.start, p2 = l2.blend;
              s2 !== h2 && (s2 = h2, this.bindAndClearTexArray(h2)), this.state.blendMode = p2, r2.set(this.state), n2.drawElements(u2, c2, n2.UNSIGNED_SHORT, 2 * d2);
            }
          }, e2.prototype.flush = function() {
            0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
          }, e2.prototype.start = function() {
            this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), n.b.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
          }, e2.prototype.stop = function() {
            this.flush();
          }, e2.prototype.destroy = function() {
            for (var e3 = 0; e3 < this._packedGeometryPoolSize; e3++) this._packedGeometries[e3] && this._packedGeometries[e3].destroy();
            this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t3.prototype.destroy.call(this);
          }, e2.prototype.getAttributeBuffer = function(t4) {
            var e3 = z(Math.ceil(t4 / 8)), i2 = X(e3), n2 = 8 * e3;
            this._aBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
            var r2 = this._aBuffers[n2];
            return r2 || (this._aBuffers[n2] = r2 = new wi(n2 * this.vertexSize * 4)), r2;
          }, e2.prototype.getIndexBuffer = function(t4) {
            var e3 = z(Math.ceil(t4 / 12)), i2 = X(e3), n2 = 12 * e3;
            this._iBuffers.length <= i2 && (this._iBuffers.length = i2 + 1);
            var r2 = this._iBuffers[i2];
            return r2 || (this._iBuffers[i2] = r2 = new Uint16Array(n2)), r2;
          }, e2.prototype.packInterleavedGeometry = function(t4, e3, i2, n2, r2) {
            for (var o2 = e3.uint32View, s2 = e3.float32View, a2 = n2 / this.vertexSize, l2 = t4.uvs, h2 = t4.indices, u2 = t4.vertexData, c2 = t4._texture.baseTexture._batchLocation, d2 = Math.min(t4.worldAlpha, 1), p2 = d2 < 1 && t4._texture.baseTexture.alphaMode ? function(t5, e4) {
              if (1 === e4) return (255 * e4 << 24) + t5;
              if (0 === e4) return 0;
              var i3 = t5 >> 16 & 255, n3 = t5 >> 8 & 255, r3 = 255 & t5;
              return (255 * e4 << 24) + ((i3 = i3 * e4 + 0.5 | 0) << 16) + ((n3 = n3 * e4 + 0.5 | 0) << 8) + (r3 = r3 * e4 + 0.5 | 0);
            }(t4._tintRGB, d2) : t4._tintRGB + (255 * d2 << 24), f2 = 0; f2 < u2.length; f2 += 2) s2[n2++] = u2[f2], s2[n2++] = u2[f2 + 1], s2[n2++] = l2[f2], s2[n2++] = l2[f2 + 1], o2[n2++] = p2, s2[n2++] = c2;
            for (f2 = 0; f2 < h2.length; f2++) i2[r2++] = a2 + h2[f2];
          }, e2._drawCallPool = [], e2._textureArrayPool = [], e2;
        }(ce), Mi = function() {
          function t3(t4, e2) {
            if (this.vertexSrc = t4, this.fragTemplate = e2, this.programCache = {}, this.defaultGroupCache = {}, e2.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".');
            if (e2.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".');
          }
          return t3.prototype.generateShader = function(t4) {
            if (!this.programCache[t4]) {
              for (var e2 = new Int32Array(t4), i2 = 0; i2 < t4; i2++) e2[i2] = i2;
              this.defaultGroupCache[t4] = se.from({ uSamplers: e2 }, true);
              var n2 = this.fragTemplate;
              n2 = (n2 = n2.replace(/%count%/gi, "" + t4)).replace(/%forloop%/gi, this.generateSampleSrc(t4)), this.programCache[t4] = new ze(this.vertexSrc, n2);
            }
            var r2 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new dt(), default: this.defaultGroupCache[t4] };
            return new Ve(this.programCache[t4], r2);
          }, t3.prototype.generateSampleSrc = function(t4) {
            var e2 = "";
            e2 += "\n", e2 += "\n";
            for (var i2 = 0; i2 < t4; i2++) i2 > 0 && (e2 += "\nelse "), i2 < t4 - 1 && (e2 += "if(vTextureId < " + i2 + ".5)"), e2 += "\n{", e2 += "\n	color = texture2D(uSamplers[" + i2 + "], vTextureCoord);", e2 += "\n}";
            return e2 += "\n", e2 += "\n";
          }, t3;
        }(), Ci = function(t3) {
          function e2(e3) {
            void 0 === e3 && (e3 = false);
            var i2 = t3.call(this) || this;
            return i2._buffer = new Kt(null, e3, false), i2._indexBuffer = new Kt(null, e3, true), i2.addAttribute("aVertexPosition", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aTextureCoord", i2._buffer, 2, false, r.r.FLOAT).addAttribute("aColor", i2._buffer, 4, true, r.r.UNSIGNED_BYTE).addAttribute("aTextureId", i2._buffer, 1, true, r.r.FLOAT).addIndex(i2._indexBuffer), i2;
          }
          return St(e2, t3), e2;
        }(ie), Ri = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n", Ii = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n";
        (function() {
          function t3() {
          }
          return t3.create = function(t4) {
            var e2 = Object.assign({ vertex: Ri, fragment: Ii, geometryClass: Ci, vertexSize: 6 }, t4), i2 = e2.vertex, n2 = e2.fragment, r2 = e2.vertexSize, o2 = e2.geometryClass;
            return function(t5) {
              function e3(e4) {
                var s2 = t5.call(this, e4) || this;
                return s2.shaderGenerator = new Mi(i2, n2), s2.geometryClass = o2, s2.vertexSize = r2, s2;
              }
              return St(e3, t5), e3;
            }(Ai);
          }, Object.defineProperty(t3, "defaultVertexSrc", { get: function() {
            return Ri;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3, "defaultFragmentTemplate", { get: function() {
            return Ii;
          }, enumerable: false, configurable: true }), t3;
        })().create();
        var Pi = {}, Oi = function(t3) {
          Object.defineProperty(Pi, t3, { get: function() {
            return Z("6.0.0", "PIXI.systems." + t3 + " has moved to PIXI." + t3), kt[t3];
          } });
        };
        for (var Ni in kt) Oi(Ni);
        var Li = {}, Di = function(t3) {
          Object.defineProperty(Li, t3, { get: function() {
            return Z("6.0.0", "PIXI.resources." + t3 + " has moved to PIXI." + t3), _i[t3];
          } });
        };
        for (var Ni in _i) Di(Ni);
        var Fi = function() {
          function t3(t4) {
            this.renderer = t4;
          }
          return t3.prototype.render = function(t4) {
            var e2 = this.renderer, i2 = t4.worldTransform;
            e2.context.globalAlpha = t4.worldAlpha, e2.setBlendMode(t4.blendMode), e2.setContextTransform(i2, t4.roundPixels), t4.drawMode !== r.f.TRIANGLES ? this._renderTriangleMesh(t4) : this._renderTriangles(t4);
          }, t3.prototype._renderTriangleMesh = function(t4) {
            for (var e2 = t4.geometry.buffers[0].data.length, i2 = 0; i2 < e2 - 2; i2++) {
              var n2 = 2 * i2;
              this._renderDrawTriangle(t4, n2, n2 + 2, n2 + 4);
            }
          }, t3.prototype._renderTriangles = function(t4) {
            for (var e2 = t4.geometry.getIndex().data, i2 = e2.length, n2 = 0; n2 < i2; n2 += 3) {
              var r2 = 2 * e2[n2], o2 = 2 * e2[n2 + 1], s2 = 2 * e2[n2 + 2];
              this._renderDrawTriangle(t4, r2, o2, s2);
            }
          }, t3.prototype._renderDrawTriangle = function(t4, e2, i2, n2) {
            var r2 = this.renderer.context, s2 = t4.geometry.buffers[0].data, a2 = t4.uvs, l2 = t4.texture;
            if (l2.valid) {
              var h2 = 16777215 !== t4.tint, u2 = l2.baseTexture, c2 = u2.width, d2 = u2.height;
              h2 && t4._cachedTint !== t4.tint && (t4._cachedTint = t4.tint, t4._cachedTexture = t4._cachedTexture || new Wt(u2), t4._tintedCanvas = o.b.getTintedCanvas({ texture: t4._cachedTexture }, t4.tint));
              var p2 = h2 ? t4._tintedCanvas : u2.getDrawableSource(), f2 = a2[e2] * u2.width, m2 = a2[i2] * u2.width, g2 = a2[n2] * u2.width, v2 = a2[e2 + 1] * u2.height, _2 = a2[i2 + 1] * u2.height, y2 = a2[n2 + 1] * u2.height, x2 = s2[e2], b2 = s2[i2], T2 = s2[n2], E2 = s2[e2 + 1], S2 = s2[i2 + 1], w2 = s2[n2 + 1], A2 = t4.canvasPadding / this.renderer.resolution;
              if (A2 > 0) {
                var M2 = t4.worldTransform, C2 = M2.a, R2 = M2.b, I2 = M2.c, P2 = M2.d, O2 = (x2 + b2 + T2) / 3, N2 = (E2 + S2 + w2) / 3, L2 = x2 - O2, D2 = E2 - N2, F2 = C2 * L2 + I2 * D2, B2 = R2 * L2 + P2 * D2, U2 = Math.sqrt(F2 * F2 + B2 * B2), k2 = 1 + A2 / U2;
                x2 = O2 + L2 * k2, E2 = N2 + D2 * k2, F2 = C2 * (L2 = b2 - O2) + I2 * (D2 = S2 - N2), B2 = R2 * L2 + P2 * D2, b2 = O2 + L2 * (k2 = 1 + A2 / (U2 = Math.sqrt(F2 * F2 + B2 * B2))), S2 = N2 + D2 * k2, F2 = C2 * (L2 = T2 - O2) + I2 * (D2 = w2 - N2), B2 = R2 * L2 + P2 * D2, T2 = O2 + L2 * (k2 = 1 + A2 / (U2 = Math.sqrt(F2 * F2 + B2 * B2))), w2 = N2 + D2 * k2;
              }
              r2.save(), r2.beginPath(), r2.moveTo(x2, E2), r2.lineTo(b2, S2), r2.lineTo(T2, w2), r2.closePath(), r2.clip();
              var G2 = f2 * _2 + v2 * g2 + m2 * y2 - _2 * g2 - v2 * m2 - f2 * y2, H2 = x2 * _2 + v2 * T2 + b2 * y2 - _2 * T2 - v2 * b2 - x2 * y2, j2 = f2 * b2 + x2 * g2 + m2 * T2 - b2 * g2 - x2 * m2 - f2 * T2, z2 = f2 * _2 * T2 + v2 * b2 * g2 + x2 * m2 * y2 - x2 * _2 * g2 - v2 * m2 * T2 - f2 * b2 * y2, V2 = E2 * _2 + v2 * w2 + S2 * y2 - _2 * w2 - v2 * S2 - E2 * y2, X2 = f2 * S2 + E2 * g2 + m2 * w2 - S2 * g2 - E2 * m2 - f2 * w2, W2 = f2 * _2 * w2 + v2 * S2 * g2 + E2 * m2 * y2 - E2 * _2 * g2 - v2 * m2 * w2 - f2 * S2 * y2;
              r2.transform(H2 / G2, V2 / G2, j2 / G2, X2 / G2, z2 / G2, W2 / G2), r2.drawImage(p2, 0, 0, c2 * u2.resolution, d2 * u2.resolution, 0, 0, c2, d2), r2.restore(), this.renderer.invalidateBlendMode();
            }
          }, t3.prototype.renderMeshFlat = function(t4) {
            var e2 = this.renderer.context, i2 = t4.geometry.getBuffer("aVertexPosition").data, n2 = i2.length / 2;
            e2.beginPath();
            for (var r2 = 1; r2 < n2 - 2; ++r2) {
              var o2 = 2 * r2, s2 = i2[o2], a2 = i2[o2 + 1], l2 = i2[o2 + 2], h2 = i2[o2 + 3], u2 = i2[o2 + 4], c2 = i2[o2 + 5];
              e2.moveTo(s2, a2), e2.lineTo(l2, h2), e2.lineTo(u2, c2);
            }
            e2.fillStyle = "#FF0000", e2.fill(), e2.closePath();
          }, t3.prototype.destroy = function() {
            this.renderer = null;
          }, t3;
        }();
        n.b.MESH_CANVAS_PADDING = 0, s.c.prototype._renderCanvas = function(t3, e2) {
          t3.plugins.mesh.render(e2);
        }, a.a.prototype._cachedTint = 16777215, a.a.prototype._tintedCanvas = null, a.a.prototype._canvasUvs = null, a.a.prototype._renderCanvas = function(t3) {
          var e2 = t3.context, i2 = this.worldTransform, n2 = 16777215 !== this.tint, r2 = this.texture;
          if (r2.valid) {
            n2 && this._cachedTint !== this.tint && (this._cachedTint = this.tint, this._tintedCanvas = o.b.getTintedCanvas(this, this.tint));
            var s2 = n2 ? this._tintedCanvas : r2.baseTexture.getDrawableSource();
            this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]);
            var a2 = this.vertices, l2 = this._canvasUvs, h2 = n2 ? 0 : r2.frame.x, u2 = n2 ? 0 : r2.frame.y, c2 = h2 + r2.frame.width, d2 = u2 + r2.frame.height;
            l2[0] = h2, l2[1] = h2 + this._leftWidth, l2[2] = c2 - this._rightWidth, l2[3] = c2, l2[4] = u2, l2[5] = u2 + this._topHeight, l2[6] = d2 - this._bottomHeight, l2[7] = d2;
            for (var p2 = 0; p2 < 8; p2++) l2[p2] *= r2.baseTexture.resolution;
            e2.globalAlpha = this.worldAlpha, t3.setBlendMode(this.blendMode), t3.setContextTransform(i2, this.roundPixels);
            for (var f2 = 0; f2 < 3; f2++) for (var m2 = 0; m2 < 3; m2++) {
              var g2 = 2 * m2 + 8 * f2, v2 = Math.max(1, l2[m2 + 1] - l2[m2]), _2 = Math.max(1, l2[f2 + 5] - l2[f2 + 4]), y2 = Math.max(1, a2[g2 + 10] - a2[g2]), x2 = Math.max(1, a2[g2 + 11] - a2[g2 + 1]);
              e2.drawImage(s2, l2[m2], l2[f2 + 4], v2, _2, a2[g2], a2[g2 + 1], y2, x2);
            }
          }
        };
        var Bi = false;
        s.a.prototype._cachedTint = 16777215, s.a.prototype._tintedCanvas = null, s.a.prototype._cachedTexture = null, s.a.prototype._renderCanvas = function(t3) {
          this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.material._renderCanvas ? this.material._renderCanvas(t3, this) : Bi || (Bi = true, globalThis.console && console.warn("Mesh with custom shaders are not supported in CanvasRenderer."));
        }, s.a.prototype._canvasPadding = null, Object.defineProperty(s.a.prototype, "canvasPadding", { get: function() {
          return null !== this._canvasPadding ? this._canvasPadding : n.b.MESH_CANVAS_PADDING;
        }, set: function(t3) {
          this._canvasPadding = t3;
        } }), a.b.prototype._renderCanvas = function(t3) {
          this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t3, this);
        }, a.c.prototype._renderCanvas = function(t3) {
          (this.autoUpdate || this.geometry._width !== this.shader.texture.height) && (this.geometry._width = this.shader.texture.height, this.geometry.update()), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t3, this);
        };
      }).call(this, i(17));
    }, function(t, e, i) {
      "use strict";
      var n = i(143), r = i(144);
      function o() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      e.parse = y, e.resolve = function(t2, e2) {
        return y(t2, false, true).resolve(e2);
      }, e.resolveObject = function(t2, e2) {
        return t2 ? y(t2, false, true).resolveObject(e2) : e2;
      }, e.format = function(t2) {
        r.isString(t2) && (t2 = y(t2));
        return t2 instanceof o ? t2.format() : o.prototype.format.call(t2);
      }, e.Url = o;
      var s = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, h = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), u = ["'"].concat(h), c = ["%", "/", "?", ";", "#"].concat(u), d = ["/", "?", "#"], p = /^[+a-z0-9A-Z_-]{0,63}$/, f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = { javascript: true, "javascript:": true }, g = { javascript: true, "javascript:": true }, v = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, _ = i(145);
      function y(t2, e2, i2) {
        if (t2 && r.isObject(t2) && t2 instanceof o) return t2;
        var n2 = new o();
        return n2.parse(t2, e2, i2), n2;
      }
      o.prototype.parse = function(t2, e2, i2) {
        if (!r.isString(t2)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t2);
        var o2 = t2.indexOf("?"), a2 = -1 !== o2 && o2 < t2.indexOf("#") ? "?" : "#", h2 = t2.split(a2);
        h2[0] = h2[0].replace(/\\/g, "/");
        var y2 = t2 = h2.join(a2);
        if (y2 = y2.trim(), !i2 && 1 === t2.split("#").length) {
          var x = l.exec(y2);
          if (x) return this.path = y2, this.href = y2, this.pathname = x[1], x[2] ? (this.search = x[2], this.query = e2 ? _.parse(this.search.substr(1)) : this.search.substr(1)) : e2 && (this.search = "", this.query = {}), this;
        }
        var b = s.exec(y2);
        if (b) {
          var T = (b = b[0]).toLowerCase();
          this.protocol = T, y2 = y2.substr(b.length);
        }
        if (i2 || b || y2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var E = "//" === y2.substr(0, 2);
          !E || b && g[b] || (y2 = y2.substr(2), this.slashes = true);
        }
        if (!g[b] && (E || b && !v[b])) {
          for (var S, w, A = -1, M = 0; M < d.length; M++) {
            -1 !== (C = y2.indexOf(d[M])) && (-1 === A || C < A) && (A = C);
          }
          -1 !== (w = -1 === A ? y2.lastIndexOf("@") : y2.lastIndexOf("@", A)) && (S = y2.slice(0, w), y2 = y2.slice(w + 1), this.auth = decodeURIComponent(S)), A = -1;
          for (M = 0; M < c.length; M++) {
            var C;
            -1 !== (C = y2.indexOf(c[M])) && (-1 === A || C < A) && (A = C);
          }
          -1 === A && (A = y2.length), this.host = y2.slice(0, A), y2 = y2.slice(A), this.parseHost(), this.hostname = this.hostname || "";
          var R = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!R) for (var I = this.hostname.split(/\./), P = (M = 0, I.length); M < P; M++) {
            var O = I[M];
            if (O && !O.match(p)) {
              for (var N = "", L = 0, D = O.length; L < D; L++) O.charCodeAt(L) > 127 ? N += "x" : N += O[L];
              if (!N.match(p)) {
                var F = I.slice(0, M), B = I.slice(M + 1), U = O.match(f);
                U && (F.push(U[1]), B.unshift(U[2])), B.length && (y2 = "/" + B.join(".") + y2), this.hostname = F.join(".");
                break;
              }
            }
          }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), R || (this.hostname = n.toASCII(this.hostname));
          var k = this.port ? ":" + this.port : "", G = this.hostname || "";
          this.host = G + k, this.href += this.host, R && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== y2[0] && (y2 = "/" + y2));
        }
        if (!m[T]) for (M = 0, P = u.length; M < P; M++) {
          var H = u[M];
          if (-1 !== y2.indexOf(H)) {
            var j = encodeURIComponent(H);
            j === H && (j = escape(H)), y2 = y2.split(H).join(j);
          }
        }
        var z = y2.indexOf("#");
        -1 !== z && (this.hash = y2.substr(z), y2 = y2.slice(0, z));
        var V = y2.indexOf("?");
        if (-1 !== V ? (this.search = y2.substr(V), this.query = y2.substr(V + 1), e2 && (this.query = _.parse(this.query)), y2 = y2.slice(0, V)) : e2 && (this.search = "", this.query = {}), y2 && (this.pathname = y2), v[T] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          k = this.pathname || "";
          var X = this.search || "";
          this.path = k + X;
        }
        return this.href = this.format(), this;
      }, o.prototype.format = function() {
        var t2 = this.auth || "";
        t2 && (t2 = (t2 = encodeURIComponent(t2)).replace(/%3A/i, ":"), t2 += "@");
        var e2 = this.protocol || "", i2 = this.pathname || "", n2 = this.hash || "", o2 = false, s2 = "";
        this.host ? o2 = t2 + this.host : this.hostname && (o2 = t2 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && r.isObject(this.query) && Object.keys(this.query).length && (s2 = _.stringify(this.query));
        var a2 = this.search || s2 && "?" + s2 || "";
        return e2 && ":" !== e2.substr(-1) && (e2 += ":"), this.slashes || (!e2 || v[e2]) && false !== o2 ? (o2 = "//" + (o2 || ""), i2 && "/" !== i2.charAt(0) && (i2 = "/" + i2)) : o2 || (o2 = ""), n2 && "#" !== n2.charAt(0) && (n2 = "#" + n2), a2 && "?" !== a2.charAt(0) && (a2 = "?" + a2), e2 + o2 + (i2 = i2.replace(/[?#]/g, function(t3) {
          return encodeURIComponent(t3);
        })) + (a2 = a2.replace("#", "%23")) + n2;
      }, o.prototype.resolve = function(t2) {
        return this.resolveObject(y(t2, false, true)).format();
      }, o.prototype.resolveObject = function(t2) {
        if (r.isString(t2)) {
          var e2 = new o();
          e2.parse(t2, false, true), t2 = e2;
        }
        for (var i2 = new o(), n2 = Object.keys(this), s2 = 0; s2 < n2.length; s2++) {
          var a2 = n2[s2];
          i2[a2] = this[a2];
        }
        if (i2.hash = t2.hash, "" === t2.href) return i2.href = i2.format(), i2;
        if (t2.slashes && !t2.protocol) {
          for (var l2 = Object.keys(t2), h2 = 0; h2 < l2.length; h2++) {
            var u2 = l2[h2];
            "protocol" !== u2 && (i2[u2] = t2[u2]);
          }
          return v[i2.protocol] && i2.hostname && !i2.pathname && (i2.path = i2.pathname = "/"), i2.href = i2.format(), i2;
        }
        if (t2.protocol && t2.protocol !== i2.protocol) {
          if (!v[t2.protocol]) {
            for (var c2 = Object.keys(t2), d2 = 0; d2 < c2.length; d2++) {
              var p2 = c2[d2];
              i2[p2] = t2[p2];
            }
            return i2.href = i2.format(), i2;
          }
          if (i2.protocol = t2.protocol, t2.host || g[t2.protocol]) i2.pathname = t2.pathname;
          else {
            for (var f2 = (t2.pathname || "").split("/"); f2.length && !(t2.host = f2.shift()); ) ;
            t2.host || (t2.host = ""), t2.hostname || (t2.hostname = ""), "" !== f2[0] && f2.unshift(""), f2.length < 2 && f2.unshift(""), i2.pathname = f2.join("/");
          }
          if (i2.search = t2.search, i2.query = t2.query, i2.host = t2.host || "", i2.auth = t2.auth, i2.hostname = t2.hostname || t2.host, i2.port = t2.port, i2.pathname || i2.search) {
            var m2 = i2.pathname || "", _2 = i2.search || "";
            i2.path = m2 + _2;
          }
          return i2.slashes = i2.slashes || t2.slashes, i2.href = i2.format(), i2;
        }
        var y2 = i2.pathname && "/" === i2.pathname.charAt(0), x = t2.host || t2.pathname && "/" === t2.pathname.charAt(0), b = x || y2 || i2.host && t2.pathname, T = b, E = i2.pathname && i2.pathname.split("/") || [], S = (f2 = t2.pathname && t2.pathname.split("/") || [], i2.protocol && !v[i2.protocol]);
        if (S && (i2.hostname = "", i2.port = null, i2.host && ("" === E[0] ? E[0] = i2.host : E.unshift(i2.host)), i2.host = "", t2.protocol && (t2.hostname = null, t2.port = null, t2.host && ("" === f2[0] ? f2[0] = t2.host : f2.unshift(t2.host)), t2.host = null), b = b && ("" === f2[0] || "" === E[0])), x) i2.host = t2.host || "" === t2.host ? t2.host : i2.host, i2.hostname = t2.hostname || "" === t2.hostname ? t2.hostname : i2.hostname, i2.search = t2.search, i2.query = t2.query, E = f2;
        else if (f2.length) E || (E = []), E.pop(), E = E.concat(f2), i2.search = t2.search, i2.query = t2.query;
        else if (!r.isNullOrUndefined(t2.search)) {
          if (S) i2.hostname = i2.host = E.shift(), (R = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = R.shift(), i2.host = i2.hostname = R.shift());
          return i2.search = t2.search, i2.query = t2.query, r.isNull(i2.pathname) && r.isNull(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.href = i2.format(), i2;
        }
        if (!E.length) return i2.pathname = null, i2.search ? i2.path = "/" + i2.search : i2.path = null, i2.href = i2.format(), i2;
        for (var w = E.slice(-1)[0], A = (i2.host || t2.host || E.length > 1) && ("." === w || ".." === w) || "" === w, M = 0, C = E.length; C >= 0; C--) "." === (w = E[C]) ? E.splice(C, 1) : ".." === w ? (E.splice(C, 1), M++) : M && (E.splice(C, 1), M--);
        if (!b && !T) for (; M--; M) E.unshift("..");
        !b || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), A && "/" !== E.join("/").substr(-1) && E.push("");
        var R, I = "" === E[0] || E[0] && "/" === E[0].charAt(0);
        S && (i2.hostname = i2.host = I ? "" : E.length ? E.shift() : "", (R = !!(i2.host && i2.host.indexOf("@") > 0) && i2.host.split("@")) && (i2.auth = R.shift(), i2.host = i2.hostname = R.shift()));
        return (b = b || i2.host && E.length) && !I && E.unshift(""), E.length ? i2.pathname = E.join("/") : (i2.pathname = null, i2.path = null), r.isNull(i2.pathname) && r.isNull(i2.search) || (i2.path = (i2.pathname ? i2.pathname : "") + (i2.search ? i2.search : "")), i2.auth = t2.auth || i2.auth, i2.slashes = i2.slashes || t2.slashes, i2.href = i2.format(), i2;
      }, o.prototype.parseHost = function() {
        var t2 = this.host, e2 = a.exec(t2);
        e2 && (":" !== (e2 = e2[0]) && (this.port = e2.substr(1)), t2 = t2.substr(0, t2.length - e2.length)), t2 && (this.hostname = t2);
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        return t2 === e2 || t2 != t2 && e2 != e2;
      };
    }, function(t, e, i) {
      var n = i(22)(i(14), "Map");
      t.exports = n;
    }, function(t, e, i) {
      var n = i(187), r = i(62), o = Object.prototype.propertyIsEnumerable, s = Object.getOwnPropertySymbols, a = s ? function(t2) {
        return null == t2 ? [] : (t2 = Object(t2), n(s(t2), function(e2) {
          return o.call(t2, e2);
        }));
      } : r;
      t.exports = a;
    }, function(t, e, i) {
      var n = i(63), r = i(194), o = i(67);
      t.exports = function(t2) {
        return o(t2) ? n(t2) : r(t2);
      };
    }, function(t, e, i) {
      (function(t2) {
        var n = i(14), r = i(191), o = e && !e.nodeType && e, s = o && "object" == typeof t2 && t2 && !t2.nodeType && t2, a = s && s.exports === o ? n.Buffer : void 0, l = (a ? a.isBuffer : void 0) || r;
        t2.exports = l;
      }).call(this, i(25)(t));
    }, function(t, e) {
      t.exports = function(t2) {
        return function(e2) {
          return t2(e2);
        };
      };
    }, function(t, e, i) {
      (function(t2) {
        var n = i(51), r = e && !e.nodeType && e, o = r && "object" == typeof t2 && t2 && !t2.nodeType && t2, s = o && o.exports === r && n.process, a = function() {
          try {
            var t3 = o && o.require && o.require("util").types;
            return t3 || s && s.binding && s.binding("util");
          } catch (t4) {
          }
        }();
        t2.exports = a;
      }).call(this, i(25)(t));
    }, function(t, e) {
      var i = Object.prototype;
      t.exports = function(t2) {
        var e2 = t2 && t2.constructor;
        return t2 === ("function" == typeof e2 && e2.prototype || i);
      };
    }, function(t, e, i) {
      var n = i(63), r = i(210), o = i(67);
      t.exports = function(t2) {
        return o(t2) ? n(t2, true) : r(t2);
      };
    }, function(t, e, i) {
      var n = i(58);
      t.exports = function(t2) {
        var e2 = new t2.constructor(t2.byteLength);
        return new n(e2).set(new n(t2)), e2;
      };
    }, function(t, e) {
      t.exports = "#define PI 3.14159265\nuniform float galleryHeight;\nvarying vec2 vUv;\nvarying float vPixelY;\nvoid main() {\n	vUv = uv;\n	float pixelHeight = (galleryHeight * 1.2) + 8.0;\n	float pixelY = (pixelHeight * 0.5) - position.y;\n	vPixelY = pixelY;\n	vec4 newPosition = vec4(position, 1.0);\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D galleryTexture;\nuniform float galleryHeight;\nvarying vec2 vUv;\nvarying float vPixelY;\nvoid main() {\n	vec4 color;\n	if ((vPixelY >= 0.0) && (vPixelY <= galleryHeight)) {\n		color = texture2D(galleryTexture, vec2(vUv.x, 1.0 - (vPixelY / galleryHeight)));\n	}\n	else if ((vPixelY > galleryHeight) && (vPixelY < (galleryHeight + 8.0))) {\n		color = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n	else {\n		float alpha = 1.0 - ((vPixelY - (galleryHeight + 8.0)) / (galleryHeight * 0.2));\n		color = texture2D(galleryTexture, vec2(vUv.x, ((vPixelY - galleryHeight) + 8.0) / galleryHeight));\n		color.a = alpha;\n		vec4 shadow = vec4(0.0, 0.0, 0.0, 1.0);\n		color = blendSrcOver(color, shadow);\n	}\n	gl_FragColor = color;\n}\n";
    }, function(t, e, i) {
      "use strict";
      var n = i(148);
      t.exports = function(t2, e2) {
        e2 = e2 || {};
        var i2 = new n(), r = e2.inPlace || false, o = t2.map(function(t3) {
          return r ? t3 : { width: t3.width, height: t3.height, item: t3 };
        });
        o = o.sort(function(t3, e3) {
          return e3.width * e3.height - t3.width * t3.height;
        }), i2.fit(o);
        var s = { width: o.reduce(function(t3, e3) {
          return Math.max(t3, e3.x + e3.width);
        }, 0), height: o.reduce(function(t3, e3) {
          return Math.max(t3, e3.y + e3.height);
        }, 0) };
        return r || (s.items = o), s;
      };
    }, function(t, e, i) {
      var n = i(21), r = i(200), o = i(201), s = Math.max, a = Math.min;
      t.exports = function(t2, e2, i2) {
        var l, h, u, c, d, p, f = 0, m = false, g = false, v = true;
        if ("function" != typeof t2) throw new TypeError("Expected a function");
        function _(e3) {
          var i3 = l, n2 = h;
          return l = h = void 0, f = e3, c = t2.apply(n2, i3);
        }
        function y(t3) {
          return f = t3, d = setTimeout(b, e2), m ? _(t3) : c;
        }
        function x(t3) {
          var i3 = t3 - p;
          return void 0 === p || i3 >= e2 || i3 < 0 || g && t3 - f >= u;
        }
        function b() {
          var t3 = r();
          if (x(t3)) return T(t3);
          d = setTimeout(b, function(t4) {
            var i3 = e2 - (t4 - p);
            return g ? a(i3, u - (t4 - f)) : i3;
          }(t3));
        }
        function T(t3) {
          return d = void 0, v && l ? _(t3) : (l = h = void 0, c);
        }
        function E() {
          var t3 = r(), i3 = x(t3);
          if (l = arguments, h = this, p = t3, i3) {
            if (void 0 === d) return y(p);
            if (g) return clearTimeout(d), d = setTimeout(b, e2), _(p);
          }
          return void 0 === d && (d = setTimeout(b, e2)), c;
        }
        return e2 = o(e2) || 0, n(i2) && (m = !!i2.leading, u = (g = "maxWait" in i2) ? s(o(i2.maxWait) || 0, e2) : u, v = "trailing" in i2 ? !!i2.trailing : v), E.cancel = function() {
          void 0 !== d && clearTimeout(d), f = 0, l = p = h = d = void 0;
        }, E.flush = function() {
          return void 0 === d ? c : T(r());
        }, E;
      };
    }, function(t, e, i) {
      var n = i(205);
      t.exports = function(t2) {
        return n(t2, 5);
      };
    }, function(t, e, i) {
      (function(e2) {
        var i2 = "object" == typeof e2 && e2 && e2.Object === Object && e2;
        t.exports = i2;
      }).call(this, i(17));
    }, function(t, e, i) {
      "use strict";
      var n = Object.prototype.hasOwnProperty, r = "~";
      function o() {
      }
      function s(t2, e2, i2) {
        this.fn = t2, this.context = e2, this.once = i2 || false;
      }
      function a(t2, e2, i2, n2, o2) {
        if ("function" != typeof i2) throw new TypeError("The listener must be a function");
        var a2 = new s(i2, n2 || t2, o2), l2 = r ? r + e2 : e2;
        return t2._events[l2] ? t2._events[l2].fn ? t2._events[l2] = [t2._events[l2], a2] : t2._events[l2].push(a2) : (t2._events[l2] = a2, t2._eventsCount++), t2;
      }
      function l(t2, e2) {
        0 == --t2._eventsCount ? t2._events = new o() : delete t2._events[e2];
      }
      function h() {
        this._events = new o(), this._eventsCount = 0;
      }
      Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (r = false)), h.prototype.eventNames = function() {
        var t2, e2, i2 = [];
        if (0 === this._eventsCount) return i2;
        for (e2 in t2 = this._events) n.call(t2, e2) && i2.push(r ? e2.slice(1) : e2);
        return Object.getOwnPropertySymbols ? i2.concat(Object.getOwnPropertySymbols(t2)) : i2;
      }, h.prototype.listeners = function(t2) {
        var e2 = r ? r + t2 : t2, i2 = this._events[e2];
        if (!i2) return [];
        if (i2.fn) return [i2.fn];
        for (var n2 = 0, o2 = i2.length, s2 = new Array(o2); n2 < o2; n2++) s2[n2] = i2[n2].fn;
        return s2;
      }, h.prototype.listenerCount = function(t2) {
        var e2 = r ? r + t2 : t2, i2 = this._events[e2];
        return i2 ? i2.fn ? 1 : i2.length : 0;
      }, h.prototype.emit = function(t2, e2, i2, n2, o2, s2) {
        var a2 = r ? r + t2 : t2;
        if (!this._events[a2]) return false;
        var l2, h2, u = this._events[a2], c = arguments.length;
        if (u.fn) {
          switch (u.once && this.removeListener(t2, u.fn, void 0, true), c) {
            case 1:
              return u.fn.call(u.context), true;
            case 2:
              return u.fn.call(u.context, e2), true;
            case 3:
              return u.fn.call(u.context, e2, i2), true;
            case 4:
              return u.fn.call(u.context, e2, i2, n2), true;
            case 5:
              return u.fn.call(u.context, e2, i2, n2, o2), true;
            case 6:
              return u.fn.call(u.context, e2, i2, n2, o2, s2), true;
          }
          for (h2 = 1, l2 = new Array(c - 1); h2 < c; h2++) l2[h2 - 1] = arguments[h2];
          u.fn.apply(u.context, l2);
        } else {
          var d, p = u.length;
          for (h2 = 0; h2 < p; h2++) switch (u[h2].once && this.removeListener(t2, u[h2].fn, void 0, true), c) {
            case 1:
              u[h2].fn.call(u[h2].context);
              break;
            case 2:
              u[h2].fn.call(u[h2].context, e2);
              break;
            case 3:
              u[h2].fn.call(u[h2].context, e2, i2);
              break;
            case 4:
              u[h2].fn.call(u[h2].context, e2, i2, n2);
              break;
            default:
              if (!l2) for (d = 1, l2 = new Array(c - 1); d < c; d++) l2[d - 1] = arguments[d];
              u[h2].fn.apply(u[h2].context, l2);
          }
        }
        return true;
      }, h.prototype.on = function(t2, e2, i2) {
        return a(this, t2, e2, i2, false);
      }, h.prototype.once = function(t2, e2, i2) {
        return a(this, t2, e2, i2, true);
      }, h.prototype.removeListener = function(t2, e2, i2, n2) {
        var o2 = r ? r + t2 : t2;
        if (!this._events[o2]) return this;
        if (!e2) return l(this, o2), this;
        var s2 = this._events[o2];
        if (s2.fn) s2.fn !== e2 || n2 && !s2.once || i2 && s2.context !== i2 || l(this, o2);
        else {
          for (var a2 = 0, h2 = [], u = s2.length; a2 < u; a2++) (s2[a2].fn !== e2 || n2 && !s2[a2].once || i2 && s2[a2].context !== i2) && h2.push(s2[a2]);
          h2.length ? this._events[o2] = 1 === h2.length ? h2[0] : h2 : l(this, o2);
        }
        return this;
      }, h.prototype.removeAllListeners = function(t2) {
        var e2;
        return t2 ? (e2 = r ? r + t2 : t2, this._events[e2] && l(this, e2)) : (this._events = new o(), this._eventsCount = 0), this;
      }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = r, h.EventEmitter = h, t.exports = h;
    }, function(t, e, i) {
      "use strict";
      function n(t2, e2, i2) {
        i2 = i2 || 2;
        var n2, o2, a2, l2, h2, u2, p2, f2 = e2 && e2.length, g2 = f2 ? e2[0] * i2 : t2.length, v2 = r(t2, 0, g2, i2, true), _2 = [];
        if (!v2 || v2.next === v2.prev) return _2;
        if (f2 && (v2 = function(t3, e3, i3, n3) {
          var o3, s2, a3, l3, h3, u3 = [];
          for (o3 = 0, s2 = e3.length; o3 < s2; o3++) a3 = e3[o3] * n3, l3 = o3 < s2 - 1 ? e3[o3 + 1] * n3 : t3.length, (h3 = r(t3, a3, l3, n3, false)) === h3.next && (h3.steiner = true), u3.push(m(h3));
          for (u3.sort(c), o3 = 0; o3 < u3.length; o3++) i3 = d(u3[o3], i3);
          return i3;
        }(t2, e2, v2, i2)), t2.length > 80 * i2) {
          n2 = a2 = t2[0], o2 = l2 = t2[1];
          for (var y2 = i2; y2 < g2; y2 += i2) (h2 = t2[y2]) < n2 && (n2 = h2), (u2 = t2[y2 + 1]) < o2 && (o2 = u2), h2 > a2 && (a2 = h2), u2 > l2 && (l2 = u2);
          p2 = 0 !== (p2 = Math.max(a2 - n2, l2 - o2)) ? 32767 / p2 : 0;
        }
        return s(v2, _2, i2, n2, o2, p2, 0), _2;
      }
      function r(t2, e2, i2, n2, r2) {
        var o2, s2;
        if (r2 === C(t2, e2, i2, n2) > 0) for (o2 = e2; o2 < i2; o2 += n2) s2 = w(o2, t2[o2], t2[o2 + 1], s2);
        else for (o2 = i2 - n2; o2 >= e2; o2 -= n2) s2 = w(o2, t2[o2], t2[o2 + 1], s2);
        return s2 && y(s2, s2.next) && (A(s2), s2 = s2.next), s2;
      }
      function o(t2, e2) {
        if (!t2) return t2;
        e2 || (e2 = t2);
        var i2, n2 = t2;
        do {
          if (i2 = false, n2.steiner || !y(n2, n2.next) && 0 !== _(n2.prev, n2, n2.next)) n2 = n2.next;
          else {
            if (A(n2), (n2 = e2 = n2.prev) === n2.next) break;
            i2 = true;
          }
        } while (i2 || n2 !== e2);
        return e2;
      }
      function s(t2, e2, i2, n2, r2, c2, d2) {
        if (t2) {
          !d2 && c2 && function(t3, e3, i3, n3) {
            var r3 = t3;
            do {
              0 === r3.z && (r3.z = f(r3.x, r3.y, e3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
            } while (r3 !== t3);
            r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
              var e4, i4, n4, r4, o2, s2, a2, l2, h2 = 1;
              do {
                for (i4 = t4, t4 = null, o2 = null, s2 = 0; i4; ) {
                  for (s2++, n4 = i4, a2 = 0, e4 = 0; e4 < h2 && (a2++, n4 = n4.nextZ); e4++) ;
                  for (l2 = h2; a2 > 0 || l2 > 0 && n4; ) 0 !== a2 && (0 === l2 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, a2--) : (r4 = n4, n4 = n4.nextZ, l2--), o2 ? o2.nextZ = r4 : t4 = r4, r4.prevZ = o2, o2 = r4;
                  i4 = n4;
                }
                o2.nextZ = null, h2 *= 2;
              } while (s2 > 1);
            }(r3);
          }(t2, n2, r2, c2);
          for (var p2, m2, g2 = t2; t2.prev !== t2.next; ) if (p2 = t2.prev, m2 = t2.next, c2 ? l(t2, n2, r2, c2) : a(t2)) e2.push(p2.i / i2 | 0), e2.push(t2.i / i2 | 0), e2.push(m2.i / i2 | 0), A(t2), t2 = m2.next, g2 = m2.next;
          else if ((t2 = m2) === g2) {
            d2 ? 1 === d2 ? s(t2 = h(o(t2), e2, i2), e2, i2, n2, r2, c2, 2) : 2 === d2 && u(t2, e2, i2, n2, r2, c2) : s(o(t2), e2, i2, n2, r2, c2, 1);
            break;
          }
        }
      }
      function a(t2) {
        var e2 = t2.prev, i2 = t2, n2 = t2.next;
        if (_(e2, i2, n2) >= 0) return false;
        for (var r2 = e2.x, o2 = i2.x, s2 = n2.x, a2 = e2.y, l2 = i2.y, h2 = n2.y, u2 = r2 < o2 ? r2 < s2 ? r2 : s2 : o2 < s2 ? o2 : s2, c2 = a2 < l2 ? a2 < h2 ? a2 : h2 : l2 < h2 ? l2 : h2, d2 = r2 > o2 ? r2 > s2 ? r2 : s2 : o2 > s2 ? o2 : s2, p2 = a2 > l2 ? a2 > h2 ? a2 : h2 : l2 > h2 ? l2 : h2, f2 = n2.next; f2 !== e2; ) {
          if (f2.x >= u2 && f2.x <= d2 && f2.y >= c2 && f2.y <= p2 && g(r2, a2, o2, l2, s2, h2, f2.x, f2.y) && _(f2.prev, f2, f2.next) >= 0) return false;
          f2 = f2.next;
        }
        return true;
      }
      function l(t2, e2, i2, n2) {
        var r2 = t2.prev, o2 = t2, s2 = t2.next;
        if (_(r2, o2, s2) >= 0) return false;
        for (var a2 = r2.x, l2 = o2.x, h2 = s2.x, u2 = r2.y, c2 = o2.y, d2 = s2.y, p2 = a2 < l2 ? a2 < h2 ? a2 : h2 : l2 < h2 ? l2 : h2, m2 = u2 < c2 ? u2 < d2 ? u2 : d2 : c2 < d2 ? c2 : d2, v2 = a2 > l2 ? a2 > h2 ? a2 : h2 : l2 > h2 ? l2 : h2, y2 = u2 > c2 ? u2 > d2 ? u2 : d2 : c2 > d2 ? c2 : d2, x2 = f(p2, m2, e2, i2, n2), b2 = f(v2, y2, e2, i2, n2), T2 = t2.prevZ, E2 = t2.nextZ; T2 && T2.z >= x2 && E2 && E2.z <= b2; ) {
          if (T2.x >= p2 && T2.x <= v2 && T2.y >= m2 && T2.y <= y2 && T2 !== r2 && T2 !== s2 && g(a2, u2, l2, c2, h2, d2, T2.x, T2.y) && _(T2.prev, T2, T2.next) >= 0) return false;
          if (T2 = T2.prevZ, E2.x >= p2 && E2.x <= v2 && E2.y >= m2 && E2.y <= y2 && E2 !== r2 && E2 !== s2 && g(a2, u2, l2, c2, h2, d2, E2.x, E2.y) && _(E2.prev, E2, E2.next) >= 0) return false;
          E2 = E2.nextZ;
        }
        for (; T2 && T2.z >= x2; ) {
          if (T2.x >= p2 && T2.x <= v2 && T2.y >= m2 && T2.y <= y2 && T2 !== r2 && T2 !== s2 && g(a2, u2, l2, c2, h2, d2, T2.x, T2.y) && _(T2.prev, T2, T2.next) >= 0) return false;
          T2 = T2.prevZ;
        }
        for (; E2 && E2.z <= b2; ) {
          if (E2.x >= p2 && E2.x <= v2 && E2.y >= m2 && E2.y <= y2 && E2 !== r2 && E2 !== s2 && g(a2, u2, l2, c2, h2, d2, E2.x, E2.y) && _(E2.prev, E2, E2.next) >= 0) return false;
          E2 = E2.nextZ;
        }
        return true;
      }
      function h(t2, e2, i2) {
        var n2 = t2;
        do {
          var r2 = n2.prev, s2 = n2.next.next;
          !y(r2, s2) && x(r2, n2, n2.next, s2) && E(r2, s2) && E(s2, r2) && (e2.push(r2.i / i2 | 0), e2.push(n2.i / i2 | 0), e2.push(s2.i / i2 | 0), A(n2), A(n2.next), n2 = t2 = s2), n2 = n2.next;
        } while (n2 !== t2);
        return o(n2);
      }
      function u(t2, e2, i2, n2, r2, a2) {
        var l2 = t2;
        do {
          for (var h2 = l2.next.next; h2 !== l2.prev; ) {
            if (l2.i !== h2.i && v(l2, h2)) {
              var u2 = S(l2, h2);
              return l2 = o(l2, l2.next), u2 = o(u2, u2.next), s(l2, e2, i2, n2, r2, a2, 0), void s(u2, e2, i2, n2, r2, a2, 0);
            }
            h2 = h2.next;
          }
          l2 = l2.next;
        } while (l2 !== t2);
      }
      function c(t2, e2) {
        return t2.x - e2.x;
      }
      function d(t2, e2) {
        var i2 = function(t3, e3) {
          var i3, n3 = e3, r2 = t3.x, o2 = t3.y, s2 = -1 / 0;
          do {
            if (o2 <= n3.y && o2 >= n3.next.y && n3.next.y !== n3.y) {
              var a2 = n3.x + (o2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
              if (a2 <= r2 && a2 > s2 && (s2 = a2, i3 = n3.x < n3.next.x ? n3 : n3.next, a2 === r2)) return i3;
            }
            n3 = n3.next;
          } while (n3 !== e3);
          if (!i3) return null;
          var l2, h2 = i3, u2 = i3.x, c2 = i3.y, d2 = 1 / 0;
          n3 = i3;
          do {
            r2 >= n3.x && n3.x >= u2 && r2 !== n3.x && g(o2 < c2 ? r2 : s2, o2, u2, c2, o2 < c2 ? s2 : r2, o2, n3.x, n3.y) && (l2 = Math.abs(o2 - n3.y) / (r2 - n3.x), E(n3, t3) && (l2 < d2 || l2 === d2 && (n3.x > i3.x || n3.x === i3.x && p(i3, n3))) && (i3 = n3, d2 = l2)), n3 = n3.next;
          } while (n3 !== h2);
          return i3;
        }(t2, e2);
        if (!i2) return e2;
        var n2 = S(i2, t2);
        return o(n2, n2.next), o(i2, i2.next);
      }
      function p(t2, e2) {
        return _(t2.prev, t2, e2.prev) < 0 && _(e2.next, t2, t2.next) < 0;
      }
      function f(t2, e2, i2, n2, r2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - i2) * r2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * r2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function m(t2) {
        var e2 = t2, i2 = t2;
        do {
          (e2.x < i2.x || e2.x === i2.x && e2.y < i2.y) && (i2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return i2;
      }
      function g(t2, e2, i2, n2, r2, o2, s2, a2) {
        return (r2 - s2) * (e2 - a2) >= (t2 - s2) * (o2 - a2) && (t2 - s2) * (n2 - a2) >= (i2 - s2) * (e2 - a2) && (i2 - s2) * (o2 - a2) >= (r2 - s2) * (n2 - a2);
      }
      function v(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          var i2 = t3;
          do {
            if (i2.i !== t3.i && i2.next.i !== t3.i && i2.i !== e3.i && i2.next.i !== e3.i && x(i2, i2.next, t3, e3)) return true;
            i2 = i2.next;
          } while (i2 !== t3);
          return false;
        }(t2, e2) && (E(t2, e2) && E(e2, t2) && function(t3, e3) {
          var i2 = t3, n2 = false, r2 = (t3.x + e3.x) / 2, o2 = (t3.y + e3.y) / 2;
          do {
            i2.y > o2 != i2.next.y > o2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (o2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
          } while (i2 !== t3);
          return n2;
        }(t2, e2) && (_(t2.prev, t2, e2.prev) || _(t2, e2.prev, e2)) || y(t2, e2) && _(t2.prev, t2, t2.next) > 0 && _(e2.prev, e2, e2.next) > 0);
      }
      function _(t2, e2, i2) {
        return (e2.y - t2.y) * (i2.x - e2.x) - (e2.x - t2.x) * (i2.y - e2.y);
      }
      function y(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function x(t2, e2, i2, n2) {
        var r2 = T(_(t2, e2, i2)), o2 = T(_(t2, e2, n2)), s2 = T(_(i2, n2, t2)), a2 = T(_(i2, n2, e2));
        return r2 !== o2 && s2 !== a2 || (!(0 !== r2 || !b(t2, i2, e2)) || (!(0 !== o2 || !b(t2, n2, e2)) || (!(0 !== s2 || !b(i2, t2, n2)) || !(0 !== a2 || !b(i2, e2, n2)))));
      }
      function b(t2, e2, i2) {
        return e2.x <= Math.max(t2.x, i2.x) && e2.x >= Math.min(t2.x, i2.x) && e2.y <= Math.max(t2.y, i2.y) && e2.y >= Math.min(t2.y, i2.y);
      }
      function T(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function E(t2, e2) {
        return _(t2.prev, t2, t2.next) < 0 ? _(t2, e2, t2.next) >= 0 && _(t2, t2.prev, e2) >= 0 : _(t2, e2, t2.prev) < 0 || _(t2, t2.next, e2) < 0;
      }
      function S(t2, e2) {
        var i2 = new M(t2.i, t2.x, t2.y), n2 = new M(e2.i, e2.x, e2.y), r2 = t2.next, o2 = e2.prev;
        return t2.next = e2, e2.prev = t2, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, o2.next = n2, n2.prev = o2, n2;
      }
      function w(t2, e2, i2, n2) {
        var r2 = new M(t2, e2, i2);
        return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
      }
      function A(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function M(t2, e2, i2) {
        this.i = t2, this.x = e2, this.y = i2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function C(t2, e2, i2, n2) {
        for (var r2 = 0, o2 = e2, s2 = i2 - n2; o2 < i2; o2 += n2) r2 += (t2[s2] - t2[o2]) * (t2[o2 + 1] + t2[s2 + 1]), s2 = o2;
        return r2;
      }
      t.exports = n, t.exports.default = n, n.deviation = function(t2, e2, i2, n2) {
        var r2 = e2 && e2.length, o2 = r2 ? e2[0] * i2 : t2.length, s2 = Math.abs(C(t2, 0, o2, i2));
        if (r2) for (var a2 = 0, l2 = e2.length; a2 < l2; a2++) {
          var h2 = e2[a2] * i2, u2 = a2 < l2 - 1 ? e2[a2 + 1] * i2 : t2.length;
          s2 -= Math.abs(C(t2, h2, u2, i2));
        }
        var c2 = 0;
        for (a2 = 0; a2 < n2.length; a2 += 3) {
          var d2 = n2[a2] * i2, p2 = n2[a2 + 1] * i2, f2 = n2[a2 + 2] * i2;
          c2 += Math.abs((t2[d2] - t2[f2]) * (t2[p2 + 1] - t2[d2 + 1]) - (t2[d2] - t2[p2]) * (t2[f2 + 1] - t2[d2 + 1]));
        }
        return 0 === s2 && 0 === c2 ? 0 : Math.abs((c2 - s2) / s2);
      }, n.flatten = function(t2) {
        for (var e2 = t2[0][0].length, i2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, r2 = 0; r2 < t2.length; r2++) {
          for (var o2 = 0; o2 < t2[r2].length; o2++) for (var s2 = 0; s2 < e2; s2++) i2.vertices.push(t2[r2][o2][s2]);
          r2 > 0 && (n2 += t2[r2 - 1].length, i2.holes.push(n2));
        }
        return i2;
      };
    }, function(t, e, i) {
      var n = i(26), r = i(157), o = i(158), s = i(159), a = i(160), l = i(161);
      function h(t2) {
        var e2 = this.__data__ = new n(t2);
        this.size = e2.size;
      }
      h.prototype.clear = r, h.prototype.delete = o, h.prototype.get = s, h.prototype.has = a, h.prototype.set = l, t.exports = h;
    }, function(t, e) {
      var i = Function.prototype.toString;
      t.exports = function(t2) {
        if (null != t2) {
          try {
            return i.call(t2);
          } catch (t3) {
          }
          try {
            return t2 + "";
          } catch (t3) {
          }
        }
        return "";
      };
    }, function(t, e, i) {
      var n = i(166), r = i(173), o = i(175), s = i(176), a = i(177);
      function l(t2) {
        var e2 = -1, i2 = null == t2 ? 0 : t2.length;
        for (this.clear(); ++e2 < i2; ) {
          var n2 = t2[e2];
          this.set(n2[0], n2[1]);
        }
      }
      l.prototype.clear = n, l.prototype.delete = r, l.prototype.get = o, l.prototype.has = s, l.prototype.set = a, t.exports = l;
    }, function(t, e, i) {
      var n = i(178), r = i(181), o = i(182);
      t.exports = function(t2, e2, i2, s, a, l) {
        var h = 1 & i2, u = t2.length, c = e2.length;
        if (u != c && !(h && c > u)) return false;
        var d = l.get(t2), p = l.get(e2);
        if (d && p) return d == e2 && p == t2;
        var f = -1, m = true, g = 2 & i2 ? new n() : void 0;
        for (l.set(t2, e2), l.set(e2, t2); ++f < u; ) {
          var v = t2[f], _ = e2[f];
          if (s) var y = h ? s(_, v, f, e2, t2, l) : s(v, _, f, t2, e2, l);
          if (void 0 !== y) {
            if (y) continue;
            m = false;
            break;
          }
          if (g) {
            if (!r(e2, function(t3, e3) {
              if (!o(g, e3) && (v === t3 || a(v, t3, i2, s, l))) return g.push(e3);
            })) {
              m = false;
              break;
            }
          } else if (v !== _ && !a(v, _, i2, s, l)) {
            m = false;
            break;
          }
        }
        return l.delete(t2), l.delete(e2), m;
      };
    }, function(t, e, i) {
      var n = i(14).Uint8Array;
      t.exports = n;
    }, function(t, e, i) {
      var n = i(60), r = i(38), o = i(39);
      t.exports = function(t2) {
        return n(t2, o, r);
      };
    }, function(t, e, i) {
      var n = i(61), r = i(30);
      t.exports = function(t2, e2, i2) {
        var o = e2(t2);
        return r(t2) ? o : n(o, i2(t2));
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        for (var i = -1, n = e2.length, r = t2.length; ++i < n; ) t2[r + i] = e2[i];
        return t2;
      };
    }, function(t, e) {
      t.exports = function() {
        return [];
      };
    }, function(t, e, i) {
      var n = i(188), r = i(189), o = i(30), s = i(40), a = i(192), l = i(64), h = Object.prototype.hasOwnProperty;
      t.exports = function(t2, e2) {
        var i2 = o(t2), u = !i2 && r(t2), c = !i2 && !u && s(t2), d = !i2 && !u && !c && l(t2), p = i2 || u || c || d, f = p ? n(t2.length, String) : [], m = f.length;
        for (var g in t2) !e2 && !h.call(t2, g) || p && ("length" == g || c && ("offset" == g || "parent" == g) || d && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || a(g, m)) || f.push(g);
        return f;
      };
    }, function(t, e, i) {
      var n = i(193), r = i(41), o = i(42), s = o && o.isTypedArray, a = s ? r(s) : n;
      t.exports = a;
    }, function(t, e) {
      t.exports = function(t2) {
        return "number" == typeof t2 && t2 > -1 && t2 % 1 == 0 && t2 <= 9007199254740991;
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        return function(i) {
          return t2(e2(i));
        };
      };
    }, function(t, e, i) {
      var n = i(33), r = i(65);
      t.exports = function(t2) {
        return null != t2 && r(t2.length) && !n(t2);
      };
    }, function(t, e, i) {
      var n = i(69), r = i(36), o = Object.prototype.hasOwnProperty;
      t.exports = function(t2, e2, i2) {
        var s = t2[e2];
        o.call(t2, e2) && r(s, i2) && (void 0 !== i2 || e2 in t2) || n(t2, e2, i2);
      };
    }, function(t, e, i) {
      var n = i(207);
      t.exports = function(t2, e2, i2) {
        "__proto__" == e2 && n ? n(t2, e2, { configurable: true, enumerable: true, value: i2, writable: true }) : t2[e2] = i2;
      };
    }, function(t, e, i) {
      var n = i(61), r = i(71), o = i(38), s = i(62), a = Object.getOwnPropertySymbols ? function(t2) {
        for (var e2 = []; t2; ) n(e2, o(t2)), t2 = r(t2);
        return e2;
      } : s;
      t.exports = a;
    }, function(t, e, i) {
      var n = i(66)(Object.getPrototypeOf, Object);
      t.exports = n;
    }, function(t, e) {
      t.exports = "varying vec2 vUv;\nvoid main() {\n	vUv = uv;\n	gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform float lines[26];\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float direction;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float middleAlpha = 0.0;\n	float endAlpha = 0.0;\n	float headLength = 0.0;\n	if (timePercent < 0.5) {\n		middleAlpha = 1.0;\n		endAlpha = 1.0 - (timePercent / 0.5);\n	}\n	else {\n		middleAlpha = 1.0 - ((timePercent - 0.5) / 0.5);\n		endAlpha = 0.0;\n	}\n	for (int i = 0; i < 26; i++) {\n		float halfDis = lines[i] / 2.0;\n		float middle = headLength + halfDis;\n		headLength += lines[i];\n		if ((direction > 0.9) && (direction < 1.1)) {\n			if (abs(vUv.y - middle) <= halfDis) {\n				srcColor.a = endAlpha + (((halfDis - abs(vUv.y - middle)) / halfDis) * (middleAlpha - endAlpha));\n				gl_FragColor = blendSrcOver(srcColor, distColor);\n				return ;\n			}\n		}\n		else {\n			if (abs(vUv.x - middle) <= halfDis) {\n				srcColor.a = endAlpha + (((halfDis - abs(vUv.x - middle)) / halfDis) * (middleAlpha - endAlpha));\n				gl_FragColor = blendSrcOver(srcColor, distColor);\n				return ;\n			}\n		}\n	}\n	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvoid main() {\n	float maxR;\n	float ringR;\n	float radiusMin;\n	float radiusMax;\n	float dist;\n	vec2 uv = vec2(vUv.x, vUv.y);\n	maxR = length(transform(vec2(1.0, 1.0)));\n	ringR = 1.0 / 6.0;\n	radiusMin = timePercent * maxR;\n	radiusMax = radiusMin + ringR;\n	dist = length(transform(uv));\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	if (dist < radiusMin) {\n		srcColor.a = 0.0;\n	}\n	else if ((dist >= radiusMin) && (dist <= radiusMax)) {\n		srcColor.a = (dist - radiusMin) / ringR;\n	}\n	else {\n		srcColor.a = 1.0;\n	}\n	if (timePercent >= 1.0) {\n		srcColor.a = 0.0;\n	}\n	else if (timePercent == 0.0) {\n		srcColor.a = 1.0;\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nuniform int option;\nvarying vec2 vUv;\nvec2 transformTo(vec2 uv, vec2 origin) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(origin.x, (origin.y * height) / width);\n}\nvec2 offset(float progress[4], float band, float amp, float radius, vec2 centerPosition) {\n	vec2 tc = vUv.xy;\n	vec2 uv = vec2(0.0, 0.0);\n	vec2 p;\n	float len;\n	vec2 uv_offset;\n	float wave_width = band * radius;\n	for (int i = 0; i < 4; i += 1) {\n		if (progress[i] == -1.0) {\n			continue;\n		}\n		p = tc - centerPosition;\n		p.x = (p.x * width) / height;\n		len = length(p);\n		float current_progress = progress[i];\n		float current_radius = radius * current_progress;\n		float damp_factor = 1.0;\n		if (current_progress > .5) {\n			damp_factor = (1.0 - current_progress) * 2.0;\n		}\n		float cut_factor = clamp((wave_width * damp_factor) - abs(current_radius - len), 0.0, 1.0);\n		float waves_factor = (4.0 * len) / radius;\n		uv_offset = (((p / len) * cos((waves_factor - (current_progress * 10.0)) * 3.14)) * amp) * cut_factor;\n		uv += uv_offset;\n	}\n	return uv;\n}\nvoid main() {\n	float maxR;\n	float ringR;\n	float radiusMin;\n	float radiusMax;\n	float dist;\n	float progress[4];\n	vec2 uv = vUv.xy;\n	vec2 uvOffset = vec2(0.0, 0.0);\n	vec2 startPosition = vec2(0.5, 0.5);\n	float redius = 2.0;\n	if (option == 1) {\n		startPosition = vec2(0.0, 0.0);\n	}\n	else if (option == 2) {\n		startPosition = vec2(1.0, 0.0);\n	}\n	else if (option == 3) {\n		startPosition = vec2(1.0, 1.0);\n	}\n	else if (option == 4) {\n		startPosition = vec2(0.0, 1.0);\n	}\n	maxR = length(transformTo(vec2(1.0, 1.0), vec2(0.0, 0.0)));\n	if (option == 0) {\n		maxR = maxR / 2.0;\n		redius = redius / 2.0;\n	}\n	dist = length(transformTo(uv, startPosition));\n	ringR = 1.0 / 6.0;\n	radiusMin = timePercent * maxR;\n	radiusMax = radiusMin + ringR;\n	for (int i = 0; i < 4; i++) {\n		progress[i] = timePercent + (0.1 * float(i));\n		if (progress[i] < 0.0) {\n			progress[i] = 0.0;\n		}\n	}\n	uvOffset = offset(progress, 0.2, 0.3, redius, startPosition);\n	vec4 srcColor = texture2D(texturePrev, fract(vUv + uvOffset));\n	vec4 distColor = texture2D(textureNext, fract(vUv + uvOffset));\n	if (dist < radiusMin) {\n		srcColor.a = 0.0;\n	}\n	else if ((dist >= radiusMin) && (dist <= radiusMax)) {\n		srcColor.a = (dist - radiusMin) / ringR;\n	}\n	else {\n		srcColor.a = 1.0;\n	}\n	if (timePercent >= 1.0) {\n		srcColor.a = 0.0;\n	}\n	else if (timePercent == 0.0) {\n		srcColor.a = 1.0;\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alphaStart;\n	float alphaEnd;\n	float rectStart;\n	float rectEnd;\n	bool isRevert = option > 1 ? true : false;\n	if (timePercent <= 0.33) {\n		alphaStart = isRevert ? 1.0 - (timePercent / 0.33) : 1.0;\n		alphaEnd = isRevert ? 1.0 : 1.0 - (timePercent / 0.33);\n		rectStart = isRevert ? 0.0 : 0.5;\n		rectEnd = isRevert ? 0.5 : 1.0;\n	}\n	else if ((timePercent > 0.33) && (timePercent <= 0.66)) {\n		alphaStart = isRevert ? 0.0 : 1.0;\n		alphaEnd = isRevert ? 1.0 : 0.0;\n		rectEnd = isRevert ? (((timePercent - 0.33) / 0.33) * 0.5) + 0.5 : 1.0 - (((timePercent - 0.33) / 0.33) * 0.5);\n		rectStart = rectEnd - 0.5;\n	}\n	else {\n		alphaStart = isRevert ? 0.0 : (1.0 - timePercent) / (1.0 - 0.66);\n		alphaEnd = isRevert ? (1.0 - timePercent) / (1.0 - 0.66) : 0.0;\n		rectStart = isRevert ? 0.5 : 0.0;\n		rectEnd = isRevert ? 1.0 : 0.5;\n	}\n	float changAxis = (option % 2) == 0 ? vUv.x : vUv.y;\n	if (changAxis >= rectEnd) {\n		srcColor.a = isRevert ? 1.0 : 0.0;\n	}\n	else if (changAxis <= rectStart) {\n		srcColor.a = isRevert ? 0.0 : 1.0;\n	}\n	else {\n		srcColor.a = alphaStart + (((changAxis - rectStart) / 0.5) * (alphaEnd - alphaStart));\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform sampler2D dissolveTexture;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 dissolveColor = texture2D(dissolveTexture, vUv);\n	if (dissolveColor.r == 0.0) {\n		result = srcColor;\n	}\n	else {\n		result = distColor;\n	}\n	gl_FragColor = result;\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	if (timePercent < 0.5) {\n		float stagePercent = timePercent / 0.5;\n		result = srcColor + (stagePercent * (1.0 - srcColor));\n	}\n	else {\n		float stagePercent = (timePercent - 0.5) / 0.5;\n		result = 1.0 - (stagePercent * (1.0 - distColor));\n	}\n	gl_FragColor = result;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	if (option == 1) {\n		if (timePercent < 0.5) {\n			srcColor.rgb *= (1.0 - (timePercent * 2.0));\n			gl_FragColor = srcColor;\n		}\n		else {\n			distColor.rgb *= ((timePercent - 0.5) * 2.0);\n			gl_FragColor = distColor;\n		}\n	}\n	else {\n		srcColor.a = 1.0 - timePercent;\n		gl_FragColor = blendSrcOver(srcColor, distColor);\n	}\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float changeAxis = (option % 2) == 1 ? vUv.x : vUv.y;\n	bool changeAxisX = (option % 2) == 1;\n	bool isRevert = option > 1;\n	float line;\n	if (isRevert) {\n		line = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 3);\n	}\n	else {\n		line = interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 3);\n	}\n	vec2 uv = vUv.xy;\n	if (changeAxis > line) {\n		if (changeAxisX) {\n			uv.x -= line;\n		}\n		else {\n			uv.y -= line;\n		}\n	}\n	else {\n		if (changeAxisX) {\n			uv.x += (1.0 - line);\n		}\n		else {\n			uv.y += (1.0 - line);\n		}\n	}\n	if (isRevert) {\n		result = changeAxis > line ? texture2D(textureNext, uv) : texture2D(texturePrev, uv);\n	}\n	else {\n		result = changeAxis > line ? texture2D(texturePrev, uv) : texture2D(textureNext, uv);\n	}\n	gl_FragColor = result;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform bool direction;\nuniform bool orient;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec2 rectLeft = direction ? vec2(0.25, 0.0) : vec2(0.25, 0.5);\n	vec2 rectRight = direction ? vec2(1, 0.75) : vec2(0.5, 0.75);\n	vec2 alphaLeft = vec2(1.0, 1.0);\n	vec2 alphaRight = vec2(1.0, 1.0);\n	if (timePercent <= 0.333) {\n		alphaLeft.y = 1.0 - (timePercent / 0.333);\n		alphaRight.x = 1.0 - (timePercent / 0.333);\n	}\n	else if ((timePercent <= 0.666) && (timePercent > 0.333)) {\n		rectLeft.x = direction ? (((timePercent - 0.333) / 0.333) * 0.25) + rectLeft.x : rectLeft.x - (((timePercent - 0.333) / 0.333) * 0.25);\n		rectLeft.y = direction ? rectLeft.x - 0.25 : rectLeft.x + 0.25;\n		rectRight.y = direction ? rectRight.y - (((timePercent - 0.333) / 0.333) * 0.25) : rectRight.y + (((timePercent - 0.333) / 0.333) * 0.25);\n		rectRight.x = direction ? rectRight.y + 0.25 : rectRight.y - 0.25;\n		alphaLeft.y = 0.0;\n		alphaRight.x = 0.0;\n	}\n	else {\n		rectLeft = direction ? vec2(0.5, 0.25) : vec2(0.0, 0.25);\n		rectRight = direction ? vec2(0.75, 0.5) : vec2(0.75, 1.0);\n		alphaLeft.y = 0.0;\n		alphaRight.x = 0.0;\n		alphaLeft.x = 1.0 - ((timePercent - 0.666) / (1.0 - 0.666));\n		alphaRight.y = 1.0 - ((timePercent - 0.666) / (1.0 - 0.666));\n	}\n	float axis = orient ? vUv.x : vUv.y;\n	if (direction) {\n		if ((axis < rectLeft.y) || (axis > rectRight.x)) {\n			srcColor.a = 0.0;\n		}\n		else if ((axis > rectLeft.x) && (axis < rectRight.y)) {\n			srcColor.a = 1.0;\n		}\n		else {\n			if ((axis < rectLeft.x) && (axis > rectLeft.y)) {\n				srcColor.a = alphaLeft.y - (((axis - rectLeft.y) / (rectLeft.x - rectLeft.y)) * (alphaLeft.y - alphaLeft.x));\n			}\n			else {\n				srcColor.a = alphaRight.x - (((rectRight.x - axis) / (rectLeft.x - rectLeft.y)) * (alphaRight.x - alphaRight.y));\n			}\n		}\n	}\n	else {\n		if ((axis < rectLeft.x) || (axis > rectRight.y)) {\n			srcColor.a = 1.0;\n		}\n		else if ((axis > rectLeft.y) && (axis < rectRight.x)) {\n			srcColor.a = 0.0;\n		}\n		else {\n			if ((axis >= rectLeft.x) && (axis <= rectLeft.y)) {\n				srcColor.a = alphaLeft.x - (((axis - rectLeft.x) / (rectLeft.y - rectLeft.x)) * (alphaLeft.x - alphaLeft.y));\n			}\n			else {\n				srcColor.a = alphaRight.y - (((rectRight.y - axis) / (rectLeft.y - rectLeft.x)) * (alphaRight.y - alphaRight.x));\n			}\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform bool direction;\nuniform bool thruBlk;\nvarying vec2 vUv;\nvoid main() {\n	vec4 uv4 = vec4(vUv.xy, 1.0, 1.0);\n	float scale;\n	float transform;\n	if (timePercent < 0.5) {\n		scale = 1.0 - ((timePercent / 0.5) * 0.05);\n		transform = (1.0 - scale) * 0.5;\n	}\n	else {\n		scale = 0.95 + (((timePercent - 0.5) / 0.5) * 0.05);\n		transform = (1.0 - scale) * 0.5;\n	}\n	mat4 matrix = mat4(scale, 0.0, 0.0, 0.0, 0.0, scale, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, transform, transform, 0.0, 1.0);\n	vec4 uv = matrix * uv4;\n	vec4 srcColor = texture2D(texturePrev, uv.xy);\n	vec4 distColor = texture2D(textureNext, uv.xy);\n	vec4 result = timePercent < 0.5 ? srcColor : distColor;\n	vec3 start;\n	vec3 end;\n	vec3 middleColor = thruBlk ? vec3(0.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0);\n	if ((timePercent < 0.25) || (timePercent > 0.75)) {\n		result *= 1.0;\n	}\n	else if ((timePercent >= 0.25) && (timePercent <= 0.5)) {\n		if (timePercent <= 0.375) {\n			start = result.rgb;\n			end = start + (((timePercent - 0.25) / 0.125) * (middleColor - result.rgb));\n		}\n		else {\n			start = result.rgb + (((timePercent - 0.375) / 0.125) * (middleColor - result.rgb));\n			end = middleColor;\n		}\n		result = direction ? vec4(end - (vUv.x * (end - start)), result.a) : vec4(start - (vUv.x * (start - end)), result.a);\n	}\n	else if ((timePercent > 0.5) && (timePercent <= 0.75)) {\n		if (timePercent < 0.625) {\n			start = middleColor - (((timePercent - 0.5) / 0.125) * (middleColor - result.rgb));\n			end = middleColor;\n		}\n		else {\n			start = result.rgb;\n			end = middleColor - (((timePercent - 0.625) / 0.125) * (middleColor - result.rgb));\n		}\n		result = direction ? vec4(end - (vUv.x * (end - start)), result.a) : vec4(start - (vUv.x * (start - end)), result.a);\n	}\n	gl_FragColor = result;\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int optionX;\nuniform int optionY;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float lineX = optionX > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	float lineY = optionY > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	vec2 uv = vUv.xy;\n	if ((optionX < 0) && (vUv.x <= lineX)) {\n		uv.x += (1.0 - lineX);\n	}\n	if ((optionX > 0) && (vUv.x >= lineX)) {\n		uv.x -= lineX;\n	}\n	if ((optionY < 0) && (vUv.y <= lineY)) {\n		uv.y += (1.0 - lineY);\n	}\n	if ((optionY > 0) && (vUv.y >= lineY)) {\n		uv.y -= lineY;\n	}\n	if ((optionX != 0) && (optionY == 0)) {\n		if (optionX > 0) {\n			result = vUv.x > lineX ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else {\n			result = vUv.x > lineX ? texture2D(textureNext, vUv) : texture2D(texturePrev, uv);\n		}\n	}\n	if ((optionX == 0) && (optionY != 0)) {\n		if (optionY > 0) {\n			result = vUv.y > lineY ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else {\n			result = vUv.y > lineY ? texture2D(textureNext, vUv) : texture2D(texturePrev, uv);\n		}\n	}\n	if ((optionX != 0) && (optionY != 0)) {\n		if ((optionX > 0) && (optionY > 0)) {\n			result = (vUv.x > lineX) && (vUv.y > lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else if ((optionX > 0) && (optionY < 0)) {\n			result = (vUv.x > lineX) && (vUv.y < lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else if ((optionX < 0) && (optionY > 0)) {\n			result = (vUv.x < lineX) && (vUv.y > lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n		else {\n			result = (vUv.x < lineX) && (vUv.y < lineY) ? texture2D(texturePrev, uv) : texture2D(textureNext, vUv);\n		}\n	}\n	gl_FragColor = result;\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int optionX;\nuniform int optionY;\nvarying vec2 vUv;\nvoid main() {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	float lineX = optionX > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	float lineY = optionY > 0 ? interpolationFloat(0.0, 1.0, 0.0, 1.0, timePercent, 1) : interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 1);\n	vec2 uv = vUv.xy;\n	if ((optionX < 0) && (vUv.x > lineX)) {\n		uv.x -= lineX;\n	}\n	if ((optionX > 0) && (vUv.x < lineX)) {\n		uv.x += (1.0 - lineX);\n	}\n	if ((optionY < 0) && (vUv.y > lineY)) {\n		uv.y -= lineY;\n	}\n	if ((optionY > 0) && (vUv.y < lineY)) {\n		uv.y += (1.0 - lineY);\n	}\n	if ((optionX != 0) && (optionY == 0)) {\n		if (optionX > 0) {\n			result = vUv.x > lineX ? texture2D(texturePrev, vUv) : texture2D(textureNext, uv);\n		}\n		else {\n			result = vUv.x > lineX ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n	}\n	if ((optionX == 0) && (optionY != 0)) {\n		if (optionY > 0) {\n			result = vUv.y > lineY ? texture2D(texturePrev, vUv) : texture2D(textureNext, uv);\n		}\n		else {\n			result = vUv.y > lineY ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n	}\n	if ((optionX != 0) && (optionY != 0)) {\n		if ((optionX > 0) && (optionY > 0)) {\n			result = (vUv.x < lineX) && (vUv.y < lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n		else if ((optionX > 0) && (optionY < 0)) {\n			result = (vUv.x < lineX) && (vUv.y > lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n		else if ((optionX < 0) && (optionY > 0)) {\n			result = (vUv.x > lineX) && (vUv.y < lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n		else {\n			result = (vUv.x > lineX) && (vUv.y > lineY) ? texture2D(textureNext, uv) : texture2D(texturePrev, vUv);\n		}\n	}\n	gl_FragColor = result;\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722, -0.09991, -0.33609, 0.43600, 0.615, -0.5586, -0.05639);\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec3 result;\n	float resultAlpha;\n	if (timePercent < 0.5) {\n		result = srcColor.rgb * rgb2yuv;\n		result.r += interpolationFloat(0.0, 1.0, 0.0, 0.5, timePercent, 0);\n		resultAlpha = srcColor.a;\n	}\n	else {\n		result = distColor.rgb * rgb2yuv;\n		result.r += interpolationFloat(1.0, 0.0, 0.5, 1.0, timePercent, 0);\n		resultAlpha = distColor.a;\n	}\n	result *= yuv2rgb;\n	gl_FragColor = vec4(result.rgb, resultAlpha);\n}\n";
    }, function(t, e) {
      t.exports = "uniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nattribute vec2 segment;\nattribute float times;\nattribute int option;\nvarying vec2 vUv;\nvarying float fakePercent;\nvoid main() {\n	vUv = uv;\n	float width = segmentWidth * horizontalSegments;\n	float height = segmentHeight * verticalSegments;\n	vec4 newPosition = vec4(position, 1.0);\n	vec2 segmentOrigin = vec2(((segment.x + 0.5) * segmentWidth) - (width * 0.5), (height * 0.5) - ((1.0 * (segment.y + 0.5)) * segmentHeight));\n	if (timePercent > times) {\n		float percent = (timePercent - times) / 0.7;\n		if (percent > 1.0) {\n			percent = 1.0;\n		}\n		if (percent > 0.5) {\n			percent += 1.0;\n		}\n		mat4 matrix = mat4(cos((-1.0 * percent) * 3.14), 0.0, sin((-1.0 * percent) * 3.14), 0.0, 0.0, 1.0, 0.0, 0.0, -sin((-1.0 * percent) * 3.14), 0.0, cos((-1.0 * percent) * 3.14), 0.0, 0.0, 0.0, 0.0, 1.0);\n		if (option == 1) {\n			matrix = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(percent * 3.14), -sin(percent * 3.14), 0.0, 0.0, sin(percent * 3.13), cos(percent * 3.14), 0.0, 0.0, 0.0, 0.0, 1.0);\n		}\n		newPosition.x -= segmentOrigin.x;\n		newPosition.y -= segmentOrigin.y;\n		newPosition = matrix * newPosition;\n		newPosition.x += segmentOrigin.x;\n		newPosition.y += segmentOrigin.y;\n		if (segment.x < (horizontalSegments / 2.0)) {\n			fakePercent = percent - (abs((horizontalSegments / 2.0) - segment.x) * (0.25 / horizontalSegments));\n		}\n		else {\n			fakePercent = percent + (abs((horizontalSegments / 2.0) - segment.x) * (0.25 / horizontalSegments));\n		}\n	}\n	if ((timePercent < 0.0001) || (timePercent > 0.9999)) {\n		gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n		return ;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float fakePercent;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = srcColor;\n	if (fakePercent > 0.5) {\n		color = distColor;\n	}\n	if ((fakePercent < 0.5) && (fakePercent > 0.35)) {\n		color.a = 0.5;\n	}\n	gl_FragColor = color;\n}\n";
    }, function(t, e) {
      t.exports = "#define PI 3.14159265\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform float duration;\nattribute vec2 segment;\nattribute float times;\nvarying vec2 vUv;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	vUv = uv;\n	float width = segmentWidth * horizontalSegments;\n	float height = segmentHeight * verticalSegments;\n	mat4 matrix;\n	float stagePercent;\n	vec4 newPosition = vec4(position, 1.0);\n	float selfTimePercent = (timePercent - times) / (4.0 / 5.0);\n	if (selfTimePercent < 0.0) {\n		selfTimePercent = 0.0;\n	}\n	else if (selfTimePercent > 1.0) {\n		selfTimePercent = 1.0;\n	}\n	if (selfTimePercent < (2.0 / 5.0)) {\n		stagePercent = selfTimePercent / (2.0 / 5.0);\n		newPosition.x -= (0.5 * width);\n		matrix = rotateY(((-1.0 * stagePercent) * PI) * 0.5);\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n	}\n	else if ((selfTimePercent >= (2.0 / 5.0)) && (selfTimePercent < (3.0 / 5.0))) {\n		stagePercent = (selfTimePercent - (2.0 / 5.0)) / (1.0 / 5.0);\n		newPosition.x -= (0.5 * width);\n		newPosition = rotateY((-1.0 * PI) * 0.5) * newPosition;\n		matrix = rotateY(((-1.0 * stagePercent) * PI) * 2.0);\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n		newPosition.x -= (width * stagePercent);\n	}\n	else {\n		float offset = (((newPosition.x + (0.5 * width)) / width) * 2.0) / 5.0;\n		stagePercent = (selfTimePercent - (1.0 / 5.0)) / ((2.0 / 5.0) + offset);\n		if (stagePercent > 1.0) {\n			stagePercent = 1.0;\n		}\n		vec4 vvUvv = vec4(vUv.x - 0.5, vUv.y - 0.5, 0.0, 1.0);\n		vvUvv = rotateY(-1.0 * PI) * vvUvv;\n		vUv = vvUvv.xy + 0.5;\n		newPosition.x -= (0.5 * width);\n		matrix = rotateY((((-1.0 * stagePercent) * PI) * 0.5) - (PI * 2.5));\n		newPosition = matrix * newPosition;\n		newPosition.x += (0.5 * width);\n		newPosition.x -= width;\n	}\n	if ((timePercent < 0.0001) || (timePercent > 0.9999)) {\n		vUv = uv;\n		gl_Position = (projectionMatrix * modelViewMatrix) * vec4(position, 1.0);\n		return ;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = srcColor;\n	if (timePercent > 0.5) {\n		color = distColor;\n	}\n	if (timePercent < 0.0001) {\n		color = srcColor;\n	}\n	else if (timePercent > 0.9999) {\n		color = distColor;\n	}\n	gl_FragColor = color;\n}\n";
    }, function(t, e) {
      t.exports = "#define PI 3.14159265\nattribute float index;\nattribute float type;\nattribute float delay;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segments;\nvarying vec2 vUv;\nvarying float vType;\nvarying float rotatePercent;\nmat4 rotateY(float angle) {\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	vUv = uv;\n	vType = type;\n	vec4 newPosition = vec4(position, 1.0);\n	float selfPercent = (timePercent - delay) / 0.7;\n	rotatePercent = selfPercent;\n	if (selfPercent < 0.0) {\n		selfPercent = 0.0;\n	}\n	else if (selfPercent > 1.0) {\n		selfPercent = 1.0;\n	}\n	float offsetX = ((segments * segmentWidth) * 0.5) - ((index + 0.5) * segmentWidth);\n	float offsetZ = segmentWidth * 0.5;\n	newPosition.x += offsetX;\n	newPosition.z += offsetZ;\n	newPosition.x *= (0.9 + ((abs(timePercent - 0.5) / 0.5) * 0.1));\n	newPosition.z *= (0.9 + ((abs(timePercent - 0.5) / 0.5) * 0.1));\n	newPosition = rotateY((PI * 0.5) * selfPercent) * newPosition;\n	newPosition.x -= offsetX;\n	newPosition.z -= offsetZ;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float vType;\nvarying float rotatePercent;\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983, 1.0, -0.39465, -0.58060, 1.0, 2.03211, 0.0);\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722, -0.09991, -0.33609, 0.43600, 0.615, -0.5586, -0.05639);\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec3 srcYuv;\n	vec3 distYuv;\n	if (rotatePercent < 0.5) {\n		distYuv = distColor.rgb * rgb2yuv;\n		distYuv.r *= (1.0 - (abs(rotatePercent - 0.5) / 0.5));\n		distColor = vec4(distYuv * yuv2rgb, distColor.a);\n	}\n	else {\n		srcYuv = distColor.rgb * rgb2yuv;\n		srcYuv.r *= (abs(rotatePercent - 0.5) / 0.5);\n		srcColor = vec4(srcYuv * yuv2rgb, srcColor.a);\n	}\n	vec4 color = vType < 0.5 ? srcColor : distColor;\n	gl_FragColor = color;\n}\n";
    }, function(t, e) {
      t.exports = "float easeInFloat(float t, float b, float c, float d) {\n	t = t / d;\n	return ((c * t) * t) + b;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.141592653\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float timePercent;\nuniform float segmentWidth;\nuniform float segmentHeight;\nattribute float isLeft;\nvarying vec2 vUv;\nvarying vec4 shadow;\nvoid main() {\n	vUv = uv;\n	float scaleX;\n	float transform;\n	float displacement;\n	vec4 newPosition = vec4(position, 1.0);\n	vec4 glPosition = (projectionMatrix * modelViewMatrix) * newPosition;\n	float crestCount = 24.0;\n	float width = horizontalSegments * segmentWidth;\n	float height = verticalSegments * segmentHeight;\n	float heightFactor = (newPosition.y + (height * 0.5)) / height;\n	float scaleY = interpolationFloat(1.0, 1.05, 0.0, 0.11, timePercent, 0);\n	newPosition.y += (height * 0.5);\n	newPosition.y *= scaleY;\n	newPosition.y -= (height * 0.5);\n	newPosition.y += 10.0;\n	if ((timePercent > 0.0) && (timePercent < 0.333)) {\n		float delay = (1.0 - heightFactor) * 0.1;\n		scaleX = interpolationFloat(1.0, 0.5, 0.0 + delay, 0.333, timePercent, 1);\n	}\n	else if ((timePercent >= 0.333) && (timePercent < 0.5)) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.5, 0.25, 0.333, 0.5, timePercent, 2);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop - incr;\n	}\n	else if ((timePercent >= 0.5) && (timePercent < 0.583)) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.25, 0.5, 0.5, 0.583, timePercent, 1);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop - incr;\n	}\n	else if (timePercent >= 0.583) {\n		float scaleTop = 0.5;\n		float scaleBottom = interpolationFloat(0.5, 0.75, 0.583, 0.666, timePercent, 2);\n		float incr = easeInFloat(1.0 - heightFactor, 0.0, abs(scaleBottom - scaleTop), 1.0);\n		scaleX = scaleTop + incr;\n	}\n	if (timePercent > 0.583) {\n		displacement = (isLeft < 0.5 ? 1.0 : -1.0) * interpolationFloat(0.0, width / 2.0, 0.583, 1.0, timePercent, 0);\n	}\n	float ampTop = interpolationFloat(0.0, 1.0, 0.0, 0.11, timePercent, 0);\n	float ampBottom = interpolationFloat(0.0, 1.0, 0.11, 0.22, timePercent, 0);\n	float amp = ampBottom + (heightFactor * abs(ampBottom - ampTop));\n	float foo = newPosition.x * ((crestCount * PI) / width);\n	newPosition.z = (amp * cos(foo + (PI / 2.0))) * 20.0;\n	transform = (isLeft < 0.5 ? -1.0 : 1.0) * (width * 0.5);\n	newPosition.x += transform;\n	newPosition.x *= scaleX;\n	newPosition.x -= transform;\n	newPosition.x += displacement;\n	shadow = vec4(0.0, 0.0, 0.0, 0.0);\n	if (newPosition.z < 15.0) {\n		float alpha = 0.3 * (1.0 - ((newPosition.z + 20.0) / 35.0));\n		shadow.a = alpha * amp;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying vec4 shadow;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 color = blendSrcOver(shadow, srcColor);\n	gl_FragColor = color;\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265\nuniform float timePercent;\nuniform float aCoefficient;\nuniform float zCurveLimit;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float curve;\n	float progress = option == 1 ? halfWidth - newPosition.x : newPosition.x + halfWidth;\n	float aStart = interpolationFloat(0.00000009, aCoefficient, 0.0, 0.5, timePercent, 0);\n	float aEnd = 0.0000009;\n	float zStart = interpolationFloat(0.0, zCurveLimit, 0.0, 0.5, timePercent, 0);\n	float zEnd = 0.0;\n	float a = interpolationFloat(aStart, aEnd, 0.0, halfWidth * 2.0, progress, 0);\n	float z = interpolationFloat(zStart, zEnd, 0.0, halfWidth * 2.0, progress, 0);\n	newPosition.z -= (((-a * newPosition.y) * newPosition.y) + z);\n	float scaleYStart = interpolationFloat(1.0, 0.8, 0.0, 0.5, timePercent, 0);\n	float scaleYEnd = 1.0;\n	float scaleY = interpolationFloat(scaleYStart, scaleYEnd, 0.0, halfWidth * 2.0, progress, 0);\n	newPosition.y += halfHeight;\n	newPosition.y *= scaleY;\n	float angle = interpolationFloat(0.0, -((2.0 * PI) / 3.0), 0.111, 1.0, timePercent, 1);\n	mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), sin(angle), 0.0, 0.0, -sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	newPosition = rotateX * newPosition;\n	newPosition.y -= halfHeight;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alpha = interpolationFloat(0.0, 0.6, 0.5, 1.0, timePercent, 0);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, alpha);\n	gl_FragColor = blendSrcOver(shadow, srcColor);\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nvarying float shadowAlpha;\nmat2 rotateOrigin(float angle) {\n	return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec2 shadowPosition = vec2(position.xy);\n	float presetAngle = option == 1 ? 0.77 : 0.27;\n	float rotateAngle = PI * presetAngle;\n	float min_r = halfWidth * 0.05;\n	shadowPosition = rotateOrigin(rotateAngle) * shadowPosition;\n	vec4 newPosition = vec4(shadowPosition.xy, position.z, 1.0);\n	float line = interpolationFloat(0.0, halfWidth * 2.8, 0.0, 1.0, timePercent, 1);\n	float dis2BaseLine = halfWidth - newPosition.x;\n	float dis2Line = line - dis2BaseLine;\n	float L = line <= (halfWidth * 2.0) ? line : halfWidth * 2.0;\n	float r = L / PI;\n	r = r < min_r ? min_r : r;\n	float angle = dis2Line / r;\n	if (((dis2Line > 0.0) && (dis2Line < (line * 0.5))) && (r > min_r)) {\n		shadowAlpha = interpolationFloat(0.0, 0.3, 0.0, line * 0.5, dis2Line, 0);\n	}\n	else {\n		shadowAlpha = 0.0;\n	}\n	if (dis2BaseLine < line) {\n		newPosition.x = ((sin(angle) * r) + halfWidth) - line;\n		newPosition.z = (r - (cos(angle) * r)) * 0.5;\n	}\n	vec2 finalPosition = vec2(newPosition.xy);\n	finalPosition = rotateOrigin(-rotateAngle) * finalPosition;\n	gl_Position = (projectionMatrix * modelViewMatrix) * vec4(finalPosition.xy, newPosition.z, 1.0);\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvarying float shadowAlpha;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, shadowAlpha);\n	gl_FragColor = blendSrcOver(shadow, srcColor);\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nmat4 rotateX(float angle) {\n	return mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), sin(angle), 0.0, 0.0, -sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float progress = option == 0 ? halfWidth - newPosition.x : halfWidth + newPosition.x;\n	float delay = interpolationFloat(0.0, 0.08, 0.0, halfWidth * 2.0, progress, 0);\n	float arc = halfHeight - newPosition.y;\n	float L;\n	if (timePercent < 0.8) {\n		L = interpolationFloat(halfHeight * 4.0, halfHeight * 22.0, 0.3 + delay, 0.8, timePercent, 0);\n	}\n	else {\n		L = interpolationFloat(halfHeight * 22.0, halfHeight * 300.0, 0.8, 1.0, timePercent, 0);\n	}\n	float r = L / (2.0 * PI);\n	float angle = PI - (arc / r);\n	float y = sin(angle) * r;\n	float z = cos(angle) * r;\n	newPosition.y = halfHeight - y;\n	newPosition.z = (z + r) * 0.45;\n	float rotateAngle = interpolationFloat(-PI * 0.5, 0.0, 0.0 + delay, 0.4, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(rotateAngle) * newPosition;\n	newPosition.y += halfHeight;\n	float backRotate1 = interpolationFloat(0.0, PI * 0.03, 0.75, 0.9, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(backRotate1) * newPosition;\n	newPosition.y += halfHeight;\n	float backRotate2 = interpolationFloat(0.0, -PI * 0.03, 0.8, 1.0, timePercent, 0);\n	newPosition.y -= halfHeight;\n	newPosition = rotateX(backRotate2) * newPosition;\n	newPosition.y += halfHeight;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float alpha = interpolationFloat(0.0, 0.6, 0.5, 1.0, timePercent, 0);\n	vec4 shadow = vec4(0.0, 0.0, 0.0, 0.0);\n	gl_FragColor = blendSrcOver(shadow, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nvarying vec2 vUv;\nvec2 transform(vec2 uv) {\n	uv.y = (uv.y * height) / width;\n	return uv - vec2(0.5, (0.5 * height) / width);\n}\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	float shadowAngle = PI / 6.0;\n	float clockAngle;\n	vec2 a;\n	vec2 b = transform(vUv);\n	float angle;\n	if (timePercent < 0.5) {\n		a = vec2(0.0, 0.5);\n		clockAngle = interpolationFloat(0.0, PI, 0.0, 0.5, timePercent, 0);\n		if (b.x > 0.0) {\n			angle = acos(((a.x * b.x) + (a.y * b.y)) / (sqrt((a.x * a.x) + (a.y * a.y)) * sqrt((b.x * b.x) + (b.y * b.y))));\n			if (angle < clockAngle) {\n				if (angle > (clockAngle - shadowAngle)) {\n					float shadowAlpha = interpolationFloat(1.0, 0.0, 0.0, 1.0, abs(clockAngle - angle) / shadowAngle, 0);\n					srcColor.a = shadowAlpha;\n				}\n				else {\n					srcColor.a = 0.0;\n				}\n			}\n		}\n		else {\n			srcColor.a = 1.0;\n		}\n	}\n	else {\n		a = vec2(0.0, -0.5);\n		clockAngle = interpolationFloat(0.0, PI + shadowAngle, 0.5, 1.0, timePercent, 0);\n		if (b.x <= 0.0) {\n			angle = acos(((a.x * b.x) + (a.y * b.y)) / (sqrt((a.x * a.x) + (a.y * a.y)) * sqrt((b.x * b.x) + (b.y * b.y))));\n			if (angle < clockAngle) {\n				if (angle > (clockAngle - shadowAngle)) {\n					float shadowAlpha = interpolationFloat(1.0, 0.0, 0.0, 1.0, abs(clockAngle - angle) / shadowAngle, 0);\n					srcColor.a = shadowAlpha;\n				}\n				else {\n					srcColor.a = 0.0;\n				}\n			}\n		}\n		else {\n			srcColor.a = 0.0;\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec2 uv = vUv;\n	bool useSrc = false;\n	vec2 row;\n	float delay = 0.02;\n	bool isVert = bool(option);\n	int segmentCount = isVert ? 10 : 7;\n	float axis = isVert ? uv.y : uv.x;\n	float compareAxis = isVert ? uv.x : uv.y;\n	for (int i = 0; i < segmentCount; i++) {\n		float fi = float(i);\n		row.r = (fi * 1.0) / float(segmentCount);\n		row.g = (float(i + 1) * 1.0) / float(segmentCount);\n		if ((compareAxis <= row.g) && (compareAxis > row.r)) {\n			if ((i % 2) == 0) {\n				float line = interpolationFloat(0.0, 1.0, delay * fi, (delay * fi) + 0.86, timePercent, 1);\n				if (axis < line) {\n					useSrc = false;\n				}\n				else {\n					axis -= line;\n					useSrc = true;\n				}\n			}\n			else {\n				float line = interpolationFloat(1.0, 0.0, delay * fi, (delay * fi) + 0.86, timePercent, 1);\n				if (axis < line) {\n					axis = (1.0 - line) + axis;\n					useSrc = true;\n				}\n				else {\n					useSrc = false;\n				}\n			}\n			break;\n		}\n	}\n	if (isVert) {\n		uv.y = axis;\n	}\n	else {\n		uv.x = axis;\n	}\n	vec4 srcColor = texture2D(texturePrev, uv);\n	vec4 distColor = texture2D(textureNext, uv);\n	gl_FragColor = useSrc ? srcColor : distColor;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nfloat interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform float width;\nuniform float height;\nuniform int option;\nvarying vec2 vUv;\nvoid main() {\n	vec2 uvSrc = vUv;\n	vec2 uvDist = vUv;\n	float scaleSrc = option == 1 ? interpolationFloat(1.0, 2.0, 0.0, 1.0, timePercent, 0) : interpolationFloat(1.0, 0.1, 0.0, 1.0, timePercent, 0);\n	float scaleDist = option == 1 ? interpolationFloat(0.1, 1.0, 0.0, 1.0, timePercent, 0) : interpolationFloat(2.0, 1.0, 0.0, 1.0, timePercent, 0);\n	uvSrc -= 0.5;\n	uvSrc *= scaleSrc;\n	uvSrc += 0.5;\n	uvDist -= 0.5;\n	uvDist *= scaleDist;\n	uvDist += 0.5;\n	vec4 srcColor = texture2D(texturePrev, uvSrc);\n	srcColor.a = interpolationFloat(1.0, 0.0, 0.0, 1.0, timePercent, 0);\n	vec4 distColor;\n	if ((((uvDist.x > 1.0) || (uvDist.x < 0.0)) || (uvDist.y > 1.0)) || (uvDist.y < 0.0)) {\n		distColor = vec4(0.0, 0.0, 0.0, 1.0);\n	}\n	else {\n		distColor = texture2D(textureNext, uvDist);\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\n#define PI 3.14159265358\nuniform float timePercent;\nuniform float horizontalSegments;\nuniform float verticalSegments;\nuniform float segmentWidth;\nuniform float segmentHeight;\nuniform int option;\nvarying vec2 vUv;\nmat4 rotateY(float angle) {\n	if (option == 1) {\n		angle *= -1.0;\n	}\n	return mat4(cos(angle), 0.0, sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angle), 0.0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nvoid main() {\n	float halfWidth = (segmentWidth * horizontalSegments) * 0.5;\n	float halfHeight = (segmentHeight * verticalSegments) * 0.5;\n	vUv = uv;\n	vec4 newPosition = vec4(position, 1.0);\n	float stageOneAngle = PI / 14.0;\n	float stageTwoAngle = (PI * 12.0) / 14.0;\n	float stage_1 = 0.1;\n	float stage_2 = 0.8;\n	if (timePercent < 0.5) {\n		newPosition.z = interpolationFloat(0.0, -100.0, 0.0, 0.5, timePercent, 0);\n	}\n	else {\n		newPosition.z = interpolationFloat(-100.0, 0.0, 0.5, 1.0, timePercent, 0);\n	}\n	if (timePercent < stage_1) {\n		float angle = interpolationFloat(0.0, stageOneAngle, 0.0, stage_1, timePercent, 0);\n		newPosition.x += halfWidth;\n		newPosition *= rotateY(angle);\n		newPosition.x -= halfWidth;\n	}\n	else if ((timePercent >= stage_1) && (timePercent < stage_2)) {\n		if (timePercent > 0.5) {\n			newPosition *= rotateY(PI);\n		}\n		float offset = halfWidth - (sin((PI * 0.5) - stageOneAngle) * halfWidth);\n		float angle = interpolationFloat(0.0, stageTwoAngle, stage_1, stage_2, timePercent, 0);\n		newPosition *= rotateY(angle);\n		newPosition.x += halfWidth;\n		newPosition *= rotateY(stageOneAngle);\n		newPosition.x -= halfWidth;\n		newPosition.x += interpolationFloat(0.0, 2.0 * offset, stage_1, stage_2, timePercent, 0);\n	}\n	else {\n		float angle = interpolationFloat(-stageOneAngle, 0.0, stage_2, 1.0, timePercent, 0);\n		newPosition.x -= halfWidth;\n		newPosition *= rotateY(angle);\n		newPosition.x += halfWidth;\n	}\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	gl_FragColor = timePercent < 0.5 ? srcColor : distColor;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\n#define PI 3.14159265358\nuniform sampler2D texturePrev;\nuniform sampler2D textureNext;\nuniform float timePercent;\nuniform int option;\nvarying vec2 vUv;\nmat2 rotateOrigin(float angle) {\n	return mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}\nvoid main() {\n	float alphaStart;\n	float alphaEnd;\n	float rectStart;\n	float rectEnd;\n	bool isRevert = (option == 3) || (option == 2);\n	bool rotateParam = (option == 3) || (option == 1);\n	if (timePercent <= 0.33) {\n		alphaStart = isRevert ? 1.0 - (timePercent / 0.33) : 1.0;\n		alphaEnd = isRevert ? 1.0 : 1.0 - (timePercent / 0.33);\n		rectStart = isRevert ? 0.0 : 1.5;\n		rectEnd = isRevert ? 0.5 : 2.0;\n	}\n	else if ((timePercent > 0.33) && (timePercent <= 0.66)) {\n		alphaStart = isRevert ? 0.0 : 1.0;\n		alphaEnd = isRevert ? 1.0 : 0.0;\n		rectEnd = isRevert ? (((timePercent - 0.33) / 0.33) * 1.5) + 0.5 : 2.0 - (((timePercent - 0.33) / 0.33) * 1.5);\n		rectStart = rectEnd - 0.5;\n	}\n	else {\n		alphaStart = isRevert ? 0.0 : (1.0 - timePercent) / (1.0 - 0.66);\n		alphaEnd = isRevert ? (1.0 - timePercent) / (1.0 - 0.66) : 0.0;\n		rectStart = isRevert ? 1.5 : 0.0;\n		rectEnd = isRevert ? 2.0 : 0.5;\n	}\n	if (!rotateParam) {\n		rectStart -= 1.0;\n		rectEnd -= 1.0;\n	}\n	float rotate = rotateParam ? PI * 0.25 : PI * 0.75;\n	vec2 rotateUv = vUv * rotateOrigin(rotate);\n	vec4 srcColor = texture2D(texturePrev, vUv);\n	vec4 distColor = texture2D(textureNext, vUv);\n	vec2 startPoint = vec2(rectStart, 0.0) * rotateOrigin(rotate);\n	vec2 endPoint = vec2(rectEnd, 0.0) * rotateOrigin(rotate);\n	if (rotateParam) {\n		if (rotateUv.x >= endPoint.x) {\n			srcColor.a = isRevert ? 1.0 : 0.0;\n		}\n		else if (rotateUv.x <= startPoint.x) {\n			srcColor.a = isRevert ? 0.0 : 1.0;\n		}\n		else {\n			srcColor.a = alphaStart + (((rotateUv.x - startPoint.x) / (0.5 / sqrt(2.0))) * (alphaEnd - alphaStart));\n		}\n	}\n	else {\n		if (rotateUv.x <= endPoint.x) {\n			srcColor.a = isRevert ? 1.0 : 0.0;\n		}\n		else if (rotateUv.x >= startPoint.x) {\n			srcColor.a = isRevert ? 0.0 : 1.0;\n		}\n		else {\n			srcColor.a = alphaStart + (((startPoint.x - rotateUv.x) / (0.5 / sqrt(2.0))) * (alphaEnd - alphaStart));\n		}\n	}\n	gl_FragColor = blendSrcOver(srcColor, distColor);\n}\n";
    }, function(t, e) {
      t.exports = "#define PI 3.14159265\nattribute float left;\nuniform float timePercent;\nuniform float offset;\nvarying vec2 vUv;\nuniform float option;\nvoid main() {\n	vUv = uv;\n	float angle;\n	if (left > 0.0) {\n		angle = (PI / 6.0) * timePercent;\n	}\n	else {\n		angle = (-PI / 6.0) * timePercent;\n	}\n	if (option > 0.5) {\n		if (left > 0.0) {\n			angle = (-PI / 6.0) * timePercent;\n		}\n		else {\n			angle = (PI / 6.0) * timePercent;\n		}\n	}\n	vec4 newPosition = vec4(position, 1.0);\n	mat4 transform;\n	mat4 rotateY = mat4(cos(angle), 0.0, -sin(angle), 0.0, 0.0, 1.0, 0.0, 0.0, sin(angle), 0, cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	if (option > 0.5) {\n		rotateY = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angle), -sin(angle), 0.0, 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 0.0, 1.0);\n	}\n	if (option > 0.5) {\n		if (left > 0.0) {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, offset * timePercent, 0.0, 1.0);\n		}\n		else {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, -offset * timePercent, 0.0, 1.0);\n		}\n	}\n	else {\n		if (left > 0.0) {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, -offset * timePercent, 0.0, 0.0, 1.0);\n		}\n		else {\n			transform = rotateY * mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, offset * timePercent, 0.0, 0.0, 1.0);\n		}\n	}\n	newPosition = transform * newPosition;\n	gl_Position = (projectionMatrix * modelViewMatrix) * newPosition;\n}\n";
    }, function(t, e) {
      t.exports = "uniform sampler2D prevTexture;\nuniform float timePercent;\nvarying vec2 vUv;\nvoid main() {\n	vec4 color = texture2D(prevTexture, vUv);\n	color.a = 1.0 - timePercent;\n	gl_FragColor = color;\n}\n";
    }, function(t, e, i) {
      "use strict";
      (function(t2) {
        var n = i(109), r = i(110), o = setTimeout;
        function s(t3) {
          return Boolean(t3 && void 0 !== t3.length);
        }
        function a() {
        }
        function l(t3) {
          if (!(this instanceof l)) throw new TypeError("Promises must be constructed via new");
          if ("function" != typeof t3) throw new TypeError("not a function");
          this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], f(t3, this);
        }
        function h(t3, e2) {
          for (; 3 === t3._state; ) t3 = t3._value;
          0 !== t3._state ? (t3._handled = true, l._immediateFn(function() {
            var i2 = 1 === t3._state ? e2.onFulfilled : e2.onRejected;
            if (null !== i2) {
              var n2;
              try {
                n2 = i2(t3._value);
              } catch (t4) {
                return void c(e2.promise, t4);
              }
              u(e2.promise, n2);
            } else (1 === t3._state ? u : c)(e2.promise, t3._value);
          })) : t3._deferreds.push(e2);
        }
        function u(t3, e2) {
          try {
            if (e2 === t3) throw new TypeError("A promise cannot be resolved with itself.");
            if (e2 && ("object" == typeof e2 || "function" == typeof e2)) {
              var i2 = e2.then;
              if (e2 instanceof l) return t3._state = 3, t3._value = e2, void d(t3);
              if ("function" == typeof i2) return void f((n2 = i2, r2 = e2, function() {
                n2.apply(r2, arguments);
              }), t3);
            }
            t3._state = 1, t3._value = e2, d(t3);
          } catch (e3) {
            c(t3, e3);
          }
          var n2, r2;
        }
        function c(t3, e2) {
          t3._state = 2, t3._value = e2, d(t3);
        }
        function d(t3) {
          2 === t3._state && 0 === t3._deferreds.length && l._immediateFn(function() {
            t3._handled || l._unhandledRejectionFn(t3._value);
          });
          for (var e2 = 0, i2 = t3._deferreds.length; e2 < i2; e2++) h(t3, t3._deferreds[e2]);
          t3._deferreds = null;
        }
        function p(t3, e2, i2) {
          this.onFulfilled = "function" == typeof t3 ? t3 : null, this.onRejected = "function" == typeof e2 ? e2 : null, this.promise = i2;
        }
        function f(t3, e2) {
          var i2 = false;
          try {
            t3(function(t4) {
              i2 || (i2 = true, u(e2, t4));
            }, function(t4) {
              i2 || (i2 = true, c(e2, t4));
            });
          } catch (t4) {
            if (i2) return;
            i2 = true, c(e2, t4);
          }
        }
        l.prototype.catch = function(t3) {
          return this.then(null, t3);
        }, l.prototype.then = function(t3, e2) {
          var i2 = new this.constructor(a);
          return h(this, new p(t3, e2, i2)), i2;
        }, l.prototype.finally = n.a, l.all = function(t3) {
          return new l(function(e2, i2) {
            if (!s(t3)) return i2(new TypeError("Promise.all accepts an array"));
            var n2 = Array.prototype.slice.call(t3);
            if (0 === n2.length) return e2([]);
            var r2 = n2.length;
            function o2(t4, s2) {
              try {
                if (s2 && ("object" == typeof s2 || "function" == typeof s2)) {
                  var a3 = s2.then;
                  if ("function" == typeof a3) return void a3.call(s2, function(e3) {
                    o2(t4, e3);
                  }, i2);
                }
                n2[t4] = s2, 0 == --r2 && e2(n2);
              } catch (t5) {
                i2(t5);
              }
            }
            for (var a2 = 0; a2 < n2.length; a2++) o2(a2, n2[a2]);
          });
        }, l.allSettled = r.a, l.resolve = function(t3) {
          return t3 && "object" == typeof t3 && t3.constructor === l ? t3 : new l(function(e2) {
            e2(t3);
          });
        }, l.reject = function(t3) {
          return new l(function(e2, i2) {
            i2(t3);
          });
        }, l.race = function(t3) {
          return new l(function(e2, i2) {
            if (!s(t3)) return i2(new TypeError("Promise.race accepts an array"));
            for (var n2 = 0, r2 = t3.length; n2 < r2; n2++) l.resolve(t3[n2]).then(e2, i2);
          });
        }, l._immediateFn = "function" == typeof t2 && function(e2) {
          t2(e2);
        } || function(t3) {
          o(t3, 0);
        }, l._unhandledRejectionFn = function(t3) {
          "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t3);
        }, e.a = l;
      }).call(this, i(140).setImmediate);
    }, function(t, e, i) {
      "use strict";
      e.a = function(t2) {
        var e2 = this.constructor;
        return this.then(function(i2) {
          return e2.resolve(t2()).then(function() {
            return i2;
          });
        }, function(i2) {
          return e2.resolve(t2()).then(function() {
            return e2.reject(i2);
          });
        });
      };
    }, function(t, e, i) {
      "use strict";
      e.a = function(t2) {
        return new this(function(e2, i2) {
          if (!t2 || void 0 === t2.length) return i2(new TypeError(typeof t2 + " " + t2 + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
          var n = Array.prototype.slice.call(t2);
          if (0 === n.length) return e2([]);
          var r = n.length;
          function o(t3, i3) {
            if (i3 && ("object" == typeof i3 || "function" == typeof i3)) {
              var s2 = i3.then;
              if ("function" == typeof s2) return void s2.call(i3, function(e3) {
                o(t3, e3);
              }, function(i4) {
                n[t3] = { status: "rejected", reason: i4 }, 0 == --r && e2(n);
              });
            }
            n[t3] = { status: "fulfilled", value: i3 }, 0 == --r && e2(n);
          }
          for (var s = 0; s < n.length; s++) o(s, n[s]);
        });
      };
    }, function(t, e, i) {
      "use strict";
      var n = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, o = Object.prototype.propertyIsEnumerable;
      function s(t2) {
        if (null == t2) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(t2);
      }
      t.exports = function() {
        try {
          if (!Object.assign) return false;
          var t2 = new String("abc");
          if (t2[5] = "de", "5" === Object.getOwnPropertyNames(t2)[0]) return false;
          for (var e2 = {}, i2 = 0; i2 < 10; i2++) e2["_" + String.fromCharCode(i2)] = i2;
          if ("0123456789" !== Object.getOwnPropertyNames(e2).map(function(t3) {
            return e2[t3];
          }).join("")) return false;
          var n2 = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(t3) {
            n2[t3] = t3;
          }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n2)).join("");
        } catch (t3) {
          return false;
        }
      }() ? Object.assign : function(t2, e2) {
        for (var i2, a, l = s(t2), h = 1; h < arguments.length; h++) {
          for (var u in i2 = Object(arguments[h])) r.call(i2, u) && (l[u] = i2[u]);
          if (n) {
            a = n(i2);
            for (var c = 0; c < a.length; c++) o.call(i2, a[c]) && (l[a[c]] = i2[a[c]]);
          }
        }
        return l;
      };
    }, function(t, e, i) {
      var n = i(20), r = i(15);
      t.exports = function(t2) {
        return true === t2 || false === t2 || r(t2) && "[object Boolean]" == n(t2);
      };
    }, function(t, e) {
      t.exports = "precision mediump float;\nattribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord() {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	filterCoord = aVertexPosition * outputFrame.zw;\n}\n";
    }, function(t, e) {
      t.exports = "vec4 blendSrcOver(vec4 src, vec4 dist) {\n	vec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n	src.r *= src.a;\n	src.g *= src.a;\n	src.b *= src.a;\n	result.a = src.a + (dist.a * (1.0 - src.a));\n	result.r = (src.r + (dist.r * (1.0 - src.a))) / result.a;\n	result.g = (src.g + (dist.g * (1.0 - src.a))) / result.a;\n	result.b = (src.b + (dist.b * (1.0 - src.a))) / result.a;\n	return result;\n}\nprecision mediump float;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nuniform sampler2D uSdfSampler;\nuniform float uSdfIsReady;\nuniform float uSdfMaxDis;\nuniform float uRad;\nuniform vec4 uGlowColor;\nuniform vec2 uSdfPosition;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvoid main() {\n	vec4 texColor = texture2D(uSampler, vTextureCoord);\n	vec4 glowColor = vec4(uGlowColor.rgb * uGlowColor.a, uGlowColor.a);\n	float a = 1.0;\n	if (uSdfIsReady > 0.0) {\n		vec2 cod = vec2(filterCoord.x / uShapeFilterArea.z, filterCoord.y / uShapeFilterArea.w);\n		vec4 sdfColor = texture2D(uSdfSampler, cod + uSdfPosition);\n		float dis = sdfColor.a * uSdfMaxDis;\n		if ((sdfColor.r <= 0.0) && (dis >= (uRad * 0.5))) {\n			a = 1.0 - smoothstep(uRad * 0.5, uRad, dis);\n		}\n	}\n	vec4 resultColor = blendSrcOver(texColor, glowColor);\n	resultColor.rgb *= resultColor.a;\n	resultColor.rgb *= a;\n	resultColor.a *= a;\n	gl_FragColor = uSdfIsReady > 0.0 ? resultColor : texColor;\n}\n";
    }, function(t, e) {
      t.exports = "precision mediump float;\nvarying vec2 vTextureCoord;\nvarying vec2 filterCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nuniform sampler2D uSdfSampler;\nuniform float uSdfIsReady;\nuniform float uSdfMaxDis;\nuniform float uRad;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nvoid main() {\n	vec4 texColor = texture2D(uSampler, vTextureCoord);\n	float alpha = texColor.a;\n	texColor /= texColor.a;\n	if (uSdfIsReady > 0.0) {\n		float dx = uShapeFilterArea.x < 0.0 ? -uShapeFilterArea.x : 0.0;\n		float dy = uShapeFilterArea.y < 0.0 ? -uShapeFilterArea.y : 0.0;\n		vec2 cod = vec2((filterCoord.x + dx) / uShapeFilterArea.z, (filterCoord.y + dy) / uShapeFilterArea.w);\n		vec4 sdfColor = texture2D(uSdfSampler, cod);\n		float dis = sdfColor.a * uSdfMaxDis;\n		if (texColor.a > 0.0392156862745098) {\n			if (dis <= (uRad / 2.0)) {\n				float a = smoothstep(0.0, uRad / 2.0, dis) * 0.1;\n				texColor.rgb *= a;\n				texColor.a = a;\n			}\n			else if ((dis > (uRad / 2.0)) && (dis < (uRad * 1.2))) {\n				float a = (smoothstep(uRad / 2.0, uRad * 1.2, dis) * 0.9) + 0.1;\n				texColor.rgb *= a;\n				texColor.a = a;\n			}\n		}\n		else {\n			texColor.rgba *= 0.0;\n		}\n	}\n	texColor *= alpha;\n	gl_FragColor = texColor;\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nvoid main() {\n	vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n	if (sourceColor.a == 0.0) {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n	}\n	else {\n		gl_FragColor = uColor * sourceColor.a;\n	}\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform vec4 inputSize;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\nuniform float uStartAlpha;\nuniform float uEndAlpha;\nuniform float uStartPos;\nuniform float uEndPos;\nuniform float uHeight;\nvoid main() {\n	vec4 sourceColor = texture2D(uSampler, vTextureCoord);\n	vec2 cod = vTextureCoord * inputSize.xy;\n	float startY = uStartPos * uHeight;\n	float endY = uEndPos * uHeight;\n	if ((cod.y >= startY) && (cod.y <= endY)) {\n		float alpha = uStartAlpha - (((cod.y - startY) / (endY - startY)) * (uStartAlpha - uEndAlpha));\n		gl_FragColor = sourceColor * alpha;\n	}\n	else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n	}\n}\n";
    }, function(t, e) {
      t.exports = "precision mediump float;\nvarying vec2 vTextureCoord;\nuniform vec4 inputSize;\nvarying vec2 filterCoord;\nuniform vec4 uShapeFilterArea;\nuniform sampler2D uSampler;\nvoid main() {\n	vec4 texColor = texture2D(uSampler, vTextureCoord);\n	if (texColor.r > 0.0) {\n		vec2 translateCoord = vec2(filterCoord.x + 10.0, filterCoord.y);\n		vec4 translateColor = texture2D(uSampler, translateCoord * inputSize.zw);\n		if (translateColor.a > 0.0) {\n			gl_FragColor = texColor;\n		}\n		else {\n			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n		}\n	}\n	else {\n		gl_FragColor = texColor;\n	}\n}\n";
    }, function(t, e, i) {
      var n;
      !function(r, o) {
        "use strict";
        var s = "model", a = "name", l = "type", h = "vendor", u = "version", c = "mobile", d = "tablet", p = "smarttv", f = function(t2) {
          for (var e2 = {}, i2 = 0; i2 < t2.length; i2++) e2[t2[i2].toUpperCase()] = t2[i2];
          return e2;
        }, m = function(t2, e2) {
          return "string" == typeof t2 && -1 !== g(e2).indexOf(g(t2));
        }, g = function(t2) {
          return t2.toLowerCase();
        }, v = function(t2, e2) {
          if ("string" == typeof t2) return t2 = t2.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), void 0 === e2 ? t2 : t2.substring(0, 255);
        }, _ = function(t2, e2) {
          for (var i2, n2, r2, o2, s2, a2, l2 = 0; l2 < e2.length && !s2; ) {
            var h2 = e2[l2], u2 = e2[l2 + 1];
            for (i2 = n2 = 0; i2 < h2.length && !s2; ) if (s2 = h2[i2++].exec(t2)) for (r2 = 0; r2 < u2.length; r2++) a2 = s2[++n2], "object" == typeof (o2 = u2[r2]) && o2.length > 0 ? 2 === o2.length ? "function" == typeof o2[1] ? this[o2[0]] = o2[1].call(this, a2) : this[o2[0]] = o2[1] : 3 === o2.length ? "function" != typeof o2[1] || o2[1].exec && o2[1].test ? this[o2[0]] = a2 ? a2.replace(o2[1], o2[2]) : void 0 : this[o2[0]] = a2 ? o2[1].call(this, a2, o2[2]) : void 0 : 4 === o2.length && (this[o2[0]] = a2 ? o2[3].call(this, a2.replace(o2[1], o2[2])) : void 0) : this[o2] = a2 || void 0;
            l2 += 2;
          }
        }, y = function(t2, e2) {
          for (var i2 in e2) if ("object" == typeof e2[i2] && e2[i2].length > 0) {
            for (var n2 = 0; n2 < e2[i2].length; n2++) if (m(e2[i2][n2], t2)) return "?" === i2 ? void 0 : i2;
          } else if (m(e2[i2], t2)) return "?" === i2 ? void 0 : i2;
          return t2;
        }, x = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, b = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [u, [a, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [u, [a, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [a, u], [/opios[\/ ]+([\w\.]+)/i], [u, [a, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [u, [a, "Opera"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [a, u], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [u, [a, "UCBrowser"]], [/\bqbcore\/([\w\.]+)/i], [u, [a, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [u, [a, "WeChat"]], [/konqueror\/([\w\.]+)/i], [u, [a, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [u, [a, "IE"]], [/yabrowser\/([\w\.]+)/i], [u, [a, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[a, /(.+)/, "$1 Secure Browser"], u], [/\bfocus\/([\w\.]+)/i], [u, [a, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [u, [a, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [u, [a, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [u, [a, "Dolphin"]], [/coast\/([\w\.]+)/i], [u, [a, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [u, [a, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [u, [a, "Firefox"]], [/\bqihu|(qi?ho?o?|360)browser/i], [[a, "360 Browser"]], [/(oculus|samsung|sailfish)browser\/([\w\.]+)/i], [[a, /(.+)/, "$1 Browser"], u], [/(comodo_dragon)\/([\w\.]+)/i], [[a, /_/g, " "], u], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [a, u], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i], [a], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[a, "Facebook"], u], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [a, u], [/\bgsa\/([\w\.]+) .*safari\//i], [u, [a, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [u, [a, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[a, "Chrome WebView"], u], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [u, [a, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [a, u], [/version\/([\w\.]+) .*mobile\/\w+ (safari)/i], [u, [a, "Mobile Safari"]], [/version\/([\w\.]+) .*(mobile ?safari|safari)/i], [u, a], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [a, [u, y, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [a, u], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[a, "Netscape"], u], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [u, [a, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [a, u]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [["architecture", "amd64"]], [/(ia32(?=;))/i], [["architecture", g]], [/((?:i[346]|x)86)[;\)]/i], [["architecture", "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [["architecture", "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [["architecture", "armhf"]], [/windows (ce|mobile); ppc;/i], [["architecture", "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [["architecture", /ower/, "", g]], [/(sun4\w)[;\)]/i], [["architecture", "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [["architecture", g]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [s, [h, "Samsung"], [l, d]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [s, [h, "Samsung"], [l, c]], [/\((ip(?:hone|od)[\w ]*);/i], [s, [h, "Apple"], [l, c]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [s, [h, "Apple"], [l, d]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [s, [h, "Huawei"], [l, d]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i], [s, [h, "Huawei"], [l, c]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[s, /_/g, " "], [h, "Xiaomi"], [l, c]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[s, /_/g, " "], [h, "Xiaomi"], [l, d]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [s, [h, "OPPO"], [l, c]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [s, [h, "Vivo"], [l, c]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [s, [h, "Realme"], [l, c]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [s, [h, "Motorola"], [l, c]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [s, [h, "Motorola"], [l, d]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [s, [h, "LG"], [l, d]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [s, [h, "LG"], [l, c]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [s, [h, "Lenovo"], [l, d]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[s, /_/g, " "], [h, "Nokia"], [l, c]], [/(pixel c)\b/i], [s, [h, "Google"], [l, d]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [s, [h, "Google"], [l, c]], [/droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [s, [h, "Sony"], [l, c]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[s, "Xperia Tablet"], [h, "Sony"], [l, d]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [s, [h, "OnePlus"], [l, c]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [s, [h, "Amazon"], [l, d]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[s, /(.+)/g, "Fire Phone $1"], [h, "Amazon"], [l, c]], [/(playbook);[-\w\),; ]+(rim)/i], [s, h, [l, d]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [s, [h, "BlackBerry"], [l, c]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [s, [h, "ASUS"], [l, d]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [s, [h, "ASUS"], [l, c]], [/(nexus 9)/i], [s, [h, "HTC"], [l, d]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i], [h, [s, /_/g, " "], [l, c]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [s, [h, "Acer"], [l, d]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [s, [h, "Meizu"], [l, c]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [s, [h, "Sharp"], [l, c]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [h, s, [l, c]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [h, s, [l, d]], [/(surface duo)/i], [s, [h, "Microsoft"], [l, d]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [s, [h, "Fairphone"], [l, c]], [/(u304aa)/i], [s, [h, "AT&T"], [l, c]], [/\bsie-(\w*)/i], [s, [h, "Siemens"], [l, c]], [/\b(rct\w+) b/i], [s, [h, "RCA"], [l, d]], [/\b(venue[\d ]{2,7}) b/i], [s, [h, "Dell"], [l, d]], [/\b(q(?:mv|ta)\w+) b/i], [s, [h, "Verizon"], [l, d]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [s, [h, "Barnes & Noble"], [l, d]], [/\b(tm\d{3}\w+) b/i], [s, [h, "NuVision"], [l, d]], [/\b(k88) b/i], [s, [h, "ZTE"], [l, d]], [/\b(nx\d{3}j) b/i], [s, [h, "ZTE"], [l, c]], [/\b(gen\d{3}) b.+49h/i], [s, [h, "Swiss"], [l, c]], [/\b(zur\d{3}) b/i], [s, [h, "Swiss"], [l, d]], [/\b((zeki)?tb.*\b) b/i], [s, [h, "Zeki"], [l, d]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[h, "Dragon Touch"], s, [l, d]], [/\b(ns-?\w{0,9}) b/i], [s, [h, "Insignia"], [l, d]], [/\b((nxa|next)-?\w{0,9}) b/i], [s, [h, "NextBook"], [l, d]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[h, "Voice"], s, [l, c]], [/\b(lvtel\-)?(v1[12]) b/i], [[h, "LvTel"], s, [l, c]], [/\b(ph-1) /i], [s, [h, "Essential"], [l, c]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [s, [h, "Envizen"], [l, d]], [/\b(trio[-\w\. ]+) b/i], [s, [h, "MachSpeed"], [l, d]], [/\btu_(1491) b/i], [s, [h, "Rotor"], [l, d]], [/(shield[\w ]+) b/i], [s, [h, "Nvidia"], [l, d]], [/(sprint) (\w+)/i], [h, s, [l, c]], [/(kin\.[onetw]{3})/i], [[s, /\./g, " "], [h, "Microsoft"], [l, c]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [s, [h, "Zebra"], [l, d]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [s, [h, "Zebra"], [l, c]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [h, s, [l, "console"]], [/droid.+; (shield) bui/i], [s, [h, "Nvidia"], [l, "console"]], [/(playstation [345portablevi]+)/i], [s, [h, "Sony"], [l, "console"]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [s, [h, "Microsoft"], [l, "console"]], [/smart-tv.+(samsung)/i], [h, [l, p]], [/hbbtv.+maple;(\d+)/i], [[s, /^/, "SmartTV"], [h, "Samsung"], [l, p]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[h, "LG"], [l, p]], [/(apple) ?tv/i], [h, [s, "Apple TV"], [l, p]], [/crkey/i], [[s, "Chromecast"], [h, "Google"], [l, p]], [/droid.+aft(\w)( bui|\))/i], [s, [h, "Amazon"], [l, p]], [/\(dtv[\);].+(aquos)/i], [s, [h, "Sharp"], [l, p]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[h, v], [s, v], [l, p]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[l, p]], [/((pebble))app/i], [h, s, [l, "wearable"]], [/droid.+; (glass) \d/i], [s, [h, "Google"], [l, "wearable"]], [/droid.+; (wt63?0{2,3})\)/i], [s, [h, "Zebra"], [l, "wearable"]], [/(quest( 2)?)/i], [s, [h, "Facebook"], [l, "wearable"]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [h, [l, "embedded"]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [s, [l, c]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [s, [l, d]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[l, d]], [/(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i], [[l, c]], [/(android[-\w\. ]{0,9});.+buil/i], [s, [h, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [u, [a, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [u, [a, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [a, u], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [u, a]], os: [[/microsoft (windows) (vista|xp)/i], [a, u], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [a, [u, y, x]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[a, "Windows"], [u, y, x]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[u, /_/g, "."], [a, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[a, "Mac OS"], [u, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86)/i], [u, a], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [a, u], [/\(bb(10);/i], [u, [a, "BlackBerry"]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [u, [a, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [u, [a, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [u, [a, "webOS"]], [/crkey\/([\d\.]+)/i], [u, [a, "Chromecast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[a, "Chromium OS"], u], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [a, u], [/(sunos) ?([\w\.\d]*)/i], [[a, "Solaris"], u], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [a, u]] }, T = function(t2, e2) {
          if ("object" == typeof t2 && (e2 = t2, t2 = void 0), !(this instanceof T)) return new T(t2, e2).getResult();
          var i2 = t2 || (void 0 !== r && r.navigator && r.navigator.userAgent ? r.navigator.userAgent : ""), n2 = e2 ? function(t3, e3) {
            var i3 = {};
            for (var n3 in t3) e3[n3] && e3[n3].length % 2 == 0 ? i3[n3] = e3[n3].concat(t3[n3]) : i3[n3] = t3[n3];
            return i3;
          }(b, e2) : b;
          return this.getBrowser = function() {
            var t3, e3 = {};
            return e3[a] = void 0, e3[u] = void 0, _.call(e3, i2, n2.browser), e3.major = "string" == typeof (t3 = e3.version) ? t3.replace(/[^\d\.]/g, "").split(".")[0] : void 0, e3;
          }, this.getCPU = function() {
            var t3 = { architecture: void 0 };
            return _.call(t3, i2, n2.cpu), t3;
          }, this.getDevice = function() {
            var t3 = { vendor: void 0, model: void 0, type: void 0 };
            return _.call(t3, i2, n2.device), t3;
          }, this.getEngine = function() {
            var t3 = { name: void 0, version: void 0 };
            return _.call(t3, i2, n2.engine), t3;
          }, this.getOS = function() {
            var t3 = { name: void 0, version: void 0 };
            return _.call(t3, i2, n2.os), t3;
          }, this.getResult = function() {
            return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
          }, this.getUA = function() {
            return i2;
          }, this.setUA = function(t3) {
            return i2 = "string" == typeof t3 && t3.length > 255 ? v(t3, 255) : t3, this;
          }, this.setUA(i2), this;
        };
        T.VERSION = "1.0.2", T.BROWSER = f([a, u, "major"]), T.CPU = f(["architecture"]), T.DEVICE = f([s, h, l, "console", c, p, d, "wearable", "embedded"]), T.ENGINE = T.OS = f([a, u]), void 0 !== e ? (void 0 !== t && t.exports && (e = t.exports = T), e.UAParser = T) : i(149) ? void 0 === (n = function() {
          return T;
        }.call(e, i, e, t)) || (t.exports = n) : void 0 !== r && (r.UAParser = T);
        var E = void 0 !== r && (r.jQuery || r.Zepto);
        if (E && !E.ua) {
          var S = new T();
          E.ua = S.getResult(), E.ua.get = function() {
            return S.getUA();
          }, E.ua.set = function(t2) {
            S.setUA(t2);
            var e2 = S.getResult();
            for (var i2 in e2) E.ua[i2] = e2[i2];
          };
        }
      }("object" == typeof window ? window : this);
    }, function(t, e, i) {
      (function(i2) {
        var n;
        !function() {
          "use strict";
          var r = function() {
            this.init();
          };
          r.prototype = { init: function() {
            var t2 = this || o;
            return t2._counter = 1e3, t2._html5AudioPool = [], t2.html5PoolSize = 10, t2._codecs = {}, t2._howls = [], t2._muted = false, t2._volume = 1, t2._canPlayEvent = "canplaythrough", t2._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, t2.masterGain = null, t2.noAudio = false, t2.usingWebAudio = true, t2.autoSuspend = true, t2.ctx = null, t2.autoUnlock = true, t2._setup(), t2;
          }, volume: function(t2) {
            var e2 = this || o;
            if (t2 = parseFloat(t2), e2.ctx || p(), void 0 !== t2 && t2 >= 0 && t2 <= 1) {
              if (e2._volume = t2, e2._muted) return e2;
              e2.usingWebAudio && e2.masterGain.gain.setValueAtTime(t2, o.ctx.currentTime);
              for (var i3 = 0; i3 < e2._howls.length; i3++) if (!e2._howls[i3]._webAudio) for (var n2 = e2._howls[i3]._getSoundIds(), r2 = 0; r2 < n2.length; r2++) {
                var s2 = e2._howls[i3]._soundById(n2[r2]);
                s2 && s2._node && (s2._node.volume = s2._volume * t2);
              }
              return e2;
            }
            return e2._volume;
          }, mute: function(t2) {
            var e2 = this || o;
            e2.ctx || p(), e2._muted = t2, e2.usingWebAudio && e2.masterGain.gain.setValueAtTime(t2 ? 0 : e2._volume, o.ctx.currentTime);
            for (var i3 = 0; i3 < e2._howls.length; i3++) if (!e2._howls[i3]._webAudio) for (var n2 = e2._howls[i3]._getSoundIds(), r2 = 0; r2 < n2.length; r2++) {
              var s2 = e2._howls[i3]._soundById(n2[r2]);
              s2 && s2._node && (s2._node.muted = !!t2 || s2._muted);
            }
            return e2;
          }, stop: function() {
            for (var t2 = this || o, e2 = 0; e2 < t2._howls.length; e2++) t2._howls[e2].stop();
            return t2;
          }, unload: function() {
            for (var t2 = this || o, e2 = t2._howls.length - 1; e2 >= 0; e2--) t2._howls[e2].unload();
            return t2.usingWebAudio && t2.ctx && void 0 !== t2.ctx.close && (t2.ctx.close(), t2.ctx = null, p()), t2;
          }, codecs: function(t2) {
            return (this || o)._codecs[t2.replace(/^x-/, "")];
          }, _setup: function() {
            var t2 = this || o;
            if (t2.state = t2.ctx && t2.ctx.state || "suspended", t2._autoSuspend(), !t2.usingWebAudio) if ("undefined" != typeof Audio) try {
              void 0 === new Audio().oncanplaythrough && (t2._canPlayEvent = "canplay");
            } catch (e2) {
              t2.noAudio = true;
            }
            else t2.noAudio = true;
            try {
              new Audio().muted && (t2.noAudio = true);
            } catch (t3) {
            }
            return t2.noAudio || t2._setupCodecs(), t2;
          }, _setupCodecs: function() {
            var t2 = this || o, e2 = null;
            try {
              e2 = "undefined" != typeof Audio ? new Audio() : null;
            } catch (e3) {
              return t2;
            }
            if (!e2 || "function" != typeof e2.canPlayType) return t2;
            var i3 = e2.canPlayType("audio/mpeg;").replace(/^no$/, ""), n2 = t2._navigator ? t2._navigator.userAgent : "", r2 = n2.match(/OPR\/([0-6].)/g), s2 = r2 && parseInt(r2[0].split("/")[1], 10) < 33, a2 = -1 !== n2.indexOf("Safari") && -1 === n2.indexOf("Chrome"), l2 = n2.match(/Version\/(.*?) /), h2 = a2 && l2 && parseInt(l2[1], 10) < 15;
            return t2._codecs = { mp3: !(s2 || !i3 && !e2.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!i3, opus: !!e2.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!e2.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!e2.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(e2.canPlayType('audio/wav; codecs="1"') || e2.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!e2.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!e2.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(e2.canPlayType("audio/x-m4a;") || e2.canPlayType("audio/m4a;") || e2.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(e2.canPlayType("audio/x-m4b;") || e2.canPlayType("audio/m4b;") || e2.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(e2.canPlayType("audio/x-mp4;") || e2.canPlayType("audio/mp4;") || e2.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !(h2 || !e2.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !(h2 || !e2.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!e2.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(e2.canPlayType("audio/x-flac;") || e2.canPlayType("audio/flac;")).replace(/^no$/, "") }, t2;
          }, _unlockAudio: function() {
            var t2 = this || o;
            if (!t2._audioUnlocked && t2.ctx) {
              t2._audioUnlocked = false, t2.autoUnlock = false, t2._mobileUnloaded || 44100 === t2.ctx.sampleRate || (t2._mobileUnloaded = true, t2.unload()), t2._scratchBuffer = t2.ctx.createBuffer(1, 1, 22050);
              var e2 = function(i3) {
                for (; t2._html5AudioPool.length < t2.html5PoolSize; ) try {
                  var n2 = new Audio();
                  n2._unlocked = true, t2._releaseHtml5Audio(n2);
                } catch (i4) {
                  t2.noAudio = true;
                  break;
                }
                for (var r2 = 0; r2 < t2._howls.length; r2++) if (!t2._howls[r2]._webAudio) for (var o2 = t2._howls[r2]._getSoundIds(), s2 = 0; s2 < o2.length; s2++) {
                  var a2 = t2._howls[r2]._soundById(o2[s2]);
                  a2 && a2._node && !a2._node._unlocked && (a2._node._unlocked = true, a2._node.load());
                }
                t2._autoResume();
                var l2 = t2.ctx.createBufferSource();
                l2.buffer = t2._scratchBuffer, l2.connect(t2.ctx.destination), void 0 === l2.start ? l2.noteOn(0) : l2.start(0), "function" == typeof t2.ctx.resume && t2.ctx.resume(), l2.onended = function() {
                  l2.disconnect(0), t2._audioUnlocked = true, document.removeEventListener("touchstart", e2, true), document.removeEventListener("touchend", e2, true), document.removeEventListener("click", e2, true), document.removeEventListener("keydown", e2, true);
                  for (var i4 = 0; i4 < t2._howls.length; i4++) t2._howls[i4]._emit("unlock");
                };
              };
              return document.addEventListener("touchstart", e2, true), document.addEventListener("touchend", e2, true), document.addEventListener("click", e2, true), document.addEventListener("keydown", e2, true), t2;
            }
          }, _obtainHtml5Audio: function() {
            var t2 = this || o;
            if (t2._html5AudioPool.length) return t2._html5AudioPool.pop();
            var e2 = new Audio().play();
            return e2 && "undefined" != typeof Promise && (e2 instanceof Promise || "function" == typeof e2.then) && e2.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            }), new Audio();
          }, _releaseHtml5Audio: function(t2) {
            var e2 = this || o;
            return t2._unlocked && e2._html5AudioPool.push(t2), e2;
          }, _autoSuspend: function() {
            var t2 = this;
            if (t2.autoSuspend && t2.ctx && void 0 !== t2.ctx.suspend && o.usingWebAudio) {
              for (var e2 = 0; e2 < t2._howls.length; e2++) if (t2._howls[e2]._webAudio) {
                for (var i3 = 0; i3 < t2._howls[e2]._sounds.length; i3++) if (!t2._howls[e2]._sounds[i3]._paused) return t2;
              }
              return t2._suspendTimer && clearTimeout(t2._suspendTimer), t2._suspendTimer = setTimeout(function() {
                if (t2.autoSuspend) {
                  t2._suspendTimer = null, t2.state = "suspending";
                  var e3 = function() {
                    t2.state = "suspended", t2._resumeAfterSuspend && (delete t2._resumeAfterSuspend, t2._autoResume());
                  };
                  t2.ctx.suspend().then(e3, e3);
                }
              }, 3e4), t2;
            }
          }, _autoResume: function() {
            var t2 = this;
            if (t2.ctx && void 0 !== t2.ctx.resume && o.usingWebAudio) return "running" === t2.state && "interrupted" !== t2.ctx.state && t2._suspendTimer ? (clearTimeout(t2._suspendTimer), t2._suspendTimer = null) : "suspended" === t2.state || "running" === t2.state && "interrupted" === t2.ctx.state ? (t2.ctx.resume().then(function() {
              t2.state = "running";
              for (var e2 = 0; e2 < t2._howls.length; e2++) t2._howls[e2]._emit("resume");
            }), t2._suspendTimer && (clearTimeout(t2._suspendTimer), t2._suspendTimer = null)) : "suspending" === t2.state && (t2._resumeAfterSuspend = true), t2;
          } };
          var o = new r(), s = function(t2) {
            t2.src && 0 !== t2.src.length ? this.init(t2) : console.error("An array of source files must be passed with any new Howl.");
          };
          s.prototype = { init: function(t2) {
            var e2 = this;
            return o.ctx || p(), e2._autoplay = t2.autoplay || false, e2._format = "string" != typeof t2.format ? t2.format : [t2.format], e2._html5 = t2.html5 || false, e2._muted = t2.mute || false, e2._loop = t2.loop || false, e2._pool = t2.pool || 5, e2._preload = "boolean" != typeof t2.preload && "metadata" !== t2.preload || t2.preload, e2._rate = t2.rate || 1, e2._sprite = t2.sprite || {}, e2._src = "string" != typeof t2.src ? t2.src : [t2.src], e2._volume = void 0 !== t2.volume ? t2.volume : 1, e2._xhr = { method: t2.xhr && t2.xhr.method ? t2.xhr.method : "GET", headers: t2.xhr && t2.xhr.headers ? t2.xhr.headers : null, withCredentials: !(!t2.xhr || !t2.xhr.withCredentials) && t2.xhr.withCredentials }, e2._duration = 0, e2._state = "unloaded", e2._sounds = [], e2._endTimers = {}, e2._queue = [], e2._playLock = false, e2._onend = t2.onend ? [{ fn: t2.onend }] : [], e2._onfade = t2.onfade ? [{ fn: t2.onfade }] : [], e2._onload = t2.onload ? [{ fn: t2.onload }] : [], e2._onloaderror = t2.onloaderror ? [{ fn: t2.onloaderror }] : [], e2._onplayerror = t2.onplayerror ? [{ fn: t2.onplayerror }] : [], e2._onpause = t2.onpause ? [{ fn: t2.onpause }] : [], e2._onplay = t2.onplay ? [{ fn: t2.onplay }] : [], e2._onstop = t2.onstop ? [{ fn: t2.onstop }] : [], e2._onmute = t2.onmute ? [{ fn: t2.onmute }] : [], e2._onvolume = t2.onvolume ? [{ fn: t2.onvolume }] : [], e2._onrate = t2.onrate ? [{ fn: t2.onrate }] : [], e2._onseek = t2.onseek ? [{ fn: t2.onseek }] : [], e2._onunlock = t2.onunlock ? [{ fn: t2.onunlock }] : [], e2._onresume = [], e2._webAudio = o.usingWebAudio && !e2._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(e2), e2._autoplay && e2._queue.push({ event: "play", action: function() {
              e2.play();
            } }), e2._preload && "none" !== e2._preload && e2.load(), e2;
          }, load: function() {
            var t2 = null;
            if (o.noAudio) this._emit("loaderror", null, "No audio support.");
            else {
              "string" == typeof this._src && (this._src = [this._src]);
              for (var e2 = 0; e2 < this._src.length; e2++) {
                var i3, n2;
                if (this._format && this._format[e2]) i3 = this._format[e2];
                else {
                  if ("string" != typeof (n2 = this._src[e2])) {
                    this._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                    continue;
                  }
                  (i3 = /^data:audio\/([^;,]+);/i.exec(n2)) || (i3 = /\.([^.]+)$/.exec(n2.split("?", 1)[0])), i3 && (i3 = i3[1].toLowerCase());
                }
                if (i3 || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), i3 && o.codecs(i3)) {
                  t2 = this._src[e2];
                  break;
                }
              }
              if (t2) return this._src = t2, this._state = "loading", "https:" === window.location.protocol && "http:" === t2.slice(0, 5) && (this._html5 = true, this._webAudio = false), new a(this), this._webAudio && h(this), this;
              this._emit("loaderror", null, "No codec support for selected audio sources.");
            }
          }, play: function(t2, e2) {
            var i3 = this, n2 = null;
            if ("number" == typeof t2) n2 = t2, t2 = null;
            else {
              if ("string" == typeof t2 && "loaded" === i3._state && !i3._sprite[t2]) return null;
              if (void 0 === t2 && (t2 = "__default", !i3._playLock)) {
                for (var r2 = 0, s2 = 0; s2 < i3._sounds.length; s2++) i3._sounds[s2]._paused && !i3._sounds[s2]._ended && (r2++, n2 = i3._sounds[s2]._id);
                1 === r2 ? t2 = null : n2 = null;
              }
            }
            var a2 = n2 ? i3._soundById(n2) : i3._inactiveSound();
            if (!a2) return null;
            if (n2 && !t2 && (t2 = a2._sprite || "__default"), "loaded" !== i3._state) {
              a2._sprite = t2, a2._ended = false;
              var l2 = a2._id;
              return i3._queue.push({ event: "play", action: function() {
                i3.play(l2);
              } }), l2;
            }
            if (n2 && !a2._paused) return e2 || i3._loadQueue("play"), a2._id;
            i3._webAudio && o._autoResume();
            var h2 = Math.max(0, a2._seek > 0 ? a2._seek : i3._sprite[t2][0] / 1e3), u2 = Math.max(0, (i3._sprite[t2][0] + i3._sprite[t2][1]) / 1e3 - h2), c2 = 1e3 * u2 / Math.abs(a2._rate), d2 = i3._sprite[t2][0] / 1e3, p2 = (i3._sprite[t2][0] + i3._sprite[t2][1]) / 1e3;
            a2._sprite = t2, a2._ended = false;
            var f = function() {
              a2._paused = false, a2._seek = h2, a2._start = d2, a2._stop = p2, a2._loop = !(!a2._loop && !i3._sprite[t2][2]);
            };
            if (!(h2 >= p2)) {
              var m = a2._node;
              if (i3._webAudio) {
                var g = function() {
                  i3._playLock = false, f(), i3._refreshBuffer(a2);
                  var t3 = a2._muted || i3._muted ? 0 : a2._volume;
                  m.gain.setValueAtTime(t3, o.ctx.currentTime), a2._playStart = o.ctx.currentTime, void 0 === m.bufferSource.start ? a2._loop ? m.bufferSource.noteGrainOn(0, h2, 86400) : m.bufferSource.noteGrainOn(0, h2, u2) : a2._loop ? m.bufferSource.start(0, h2, 86400) : m.bufferSource.start(0, h2, u2), c2 !== 1 / 0 && (i3._endTimers[a2._id] = setTimeout(i3._ended.bind(i3, a2), c2)), e2 || setTimeout(function() {
                    i3._emit("play", a2._id), i3._loadQueue();
                  }, 0);
                };
                "running" === o.state && "interrupted" !== o.ctx.state ? g() : (i3._playLock = true, i3.once("resume", g), i3._clearTimer(a2._id));
              } else {
                var v = function() {
                  m.currentTime = h2, m.muted = a2._muted || i3._muted || o._muted || m.muted, m.volume = a2._volume * o.volume(), m.playbackRate = a2._rate;
                  try {
                    var n3 = m.play();
                    if (n3 && "undefined" != typeof Promise && (n3 instanceof Promise || "function" == typeof n3.then) ? (i3._playLock = true, f(), n3.then(function() {
                      i3._playLock = false, m._unlocked = true, e2 ? i3._loadQueue() : i3._emit("play", a2._id);
                    }).catch(function() {
                      i3._playLock = false, i3._emit("playerror", a2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a2._ended = true, a2._paused = true;
                    })) : e2 || (i3._playLock = false, f(), i3._emit("play", a2._id)), m.playbackRate = a2._rate, m.paused) return void i3._emit("playerror", a2._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    "__default" !== t2 || a2._loop ? i3._endTimers[a2._id] = setTimeout(i3._ended.bind(i3, a2), c2) : (i3._endTimers[a2._id] = function() {
                      i3._ended(a2), m.removeEventListener("ended", i3._endTimers[a2._id], false);
                    }, m.addEventListener("ended", i3._endTimers[a2._id], false));
                  } catch (t3) {
                    i3._emit("playerror", a2._id, t3);
                  }
                };
                "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = i3._src, m.load());
                var _ = window && window.ejecta || !m.readyState && o._navigator.isCocoonJS;
                if (m.readyState >= 3 || _) v();
                else {
                  i3._playLock = true, i3._state = "loading";
                  var y = function() {
                    i3._state = "loaded", v(), m.removeEventListener(o._canPlayEvent, y, false);
                  };
                  m.addEventListener(o._canPlayEvent, y, false), i3._clearTimer(a2._id);
                }
              }
              return a2._id;
            }
            i3._ended(a2);
          }, pause: function(t2) {
            var e2 = this;
            if ("loaded" !== e2._state || e2._playLock) return e2._queue.push({ event: "pause", action: function() {
              e2.pause(t2);
            } }), e2;
            for (var i3 = e2._getSoundIds(t2), n2 = 0; n2 < i3.length; n2++) {
              e2._clearTimer(i3[n2]);
              var r2 = e2._soundById(i3[n2]);
              if (r2 && !r2._paused && (r2._seek = e2.seek(i3[n2]), r2._rateSeek = 0, r2._paused = true, e2._stopFade(i3[n2]), r2._node)) if (e2._webAudio) {
                if (!r2._node.bufferSource) continue;
                void 0 === r2._node.bufferSource.stop ? r2._node.bufferSource.noteOff(0) : r2._node.bufferSource.stop(0), e2._cleanBuffer(r2._node);
              } else isNaN(r2._node.duration) && r2._node.duration !== 1 / 0 || r2._node.pause();
              arguments[1] || e2._emit("pause", r2 ? r2._id : null);
            }
            return e2;
          }, stop: function(t2, e2) {
            var i3 = this;
            if ("loaded" !== i3._state || i3._playLock) return i3._queue.push({ event: "stop", action: function() {
              i3.stop(t2);
            } }), i3;
            for (var n2 = i3._getSoundIds(t2), r2 = 0; r2 < n2.length; r2++) {
              i3._clearTimer(n2[r2]);
              var o2 = i3._soundById(n2[r2]);
              o2 && (o2._seek = o2._start || 0, o2._rateSeek = 0, o2._paused = true, o2._ended = true, i3._stopFade(n2[r2]), o2._node && (i3._webAudio ? o2._node.bufferSource && (void 0 === o2._node.bufferSource.stop ? o2._node.bufferSource.noteOff(0) : o2._node.bufferSource.stop(0), i3._cleanBuffer(o2._node)) : isNaN(o2._node.duration) && o2._node.duration !== 1 / 0 || (o2._node.currentTime = o2._start || 0, o2._node.pause(), o2._node.duration === 1 / 0 && i3._clearSound(o2._node))), e2 || i3._emit("stop", o2._id));
            }
            return i3;
          }, mute: function(t2, e2) {
            var i3 = this;
            if ("loaded" !== i3._state || i3._playLock) return i3._queue.push({ event: "mute", action: function() {
              i3.mute(t2, e2);
            } }), i3;
            if (void 0 === e2) {
              if ("boolean" != typeof t2) return i3._muted;
              i3._muted = t2;
            }
            for (var n2 = i3._getSoundIds(e2), r2 = 0; r2 < n2.length; r2++) {
              var s2 = i3._soundById(n2[r2]);
              s2 && (s2._muted = t2, s2._interval && i3._stopFade(s2._id), i3._webAudio && s2._node ? s2._node.gain.setValueAtTime(t2 ? 0 : s2._volume, o.ctx.currentTime) : s2._node && (s2._node.muted = !!o._muted || t2), i3._emit("mute", s2._id));
            }
            return i3;
          }, volume: function() {
            var t2, e2, i3, n2 = this, r2 = arguments;
            if (0 === r2.length) return n2._volume;
            if (1 === r2.length || 2 === r2.length && void 0 === r2[1]) {
              var s2 = n2._getSoundIds(), a2 = s2.indexOf(r2[0]);
              a2 >= 0 ? e2 = parseInt(r2[0], 10) : t2 = parseFloat(r2[0]);
            } else r2.length >= 2 && (t2 = parseFloat(r2[0]), e2 = parseInt(r2[1], 10));
            if (!(void 0 !== t2 && t2 >= 0 && t2 <= 1)) return (i3 = e2 ? n2._soundById(e2) : n2._sounds[0]) ? i3._volume : 0;
            if ("loaded" !== n2._state || n2._playLock) return n2._queue.push({ event: "volume", action: function() {
              n2.volume.apply(n2, r2);
            } }), n2;
            void 0 === e2 && (n2._volume = t2), e2 = n2._getSoundIds(e2);
            for (var l2 = 0; l2 < e2.length; l2++) (i3 = n2._soundById(e2[l2])) && (i3._volume = t2, r2[2] || n2._stopFade(e2[l2]), n2._webAudio && i3._node && !i3._muted ? i3._node.gain.setValueAtTime(t2, o.ctx.currentTime) : i3._node && !i3._muted && (i3._node.volume = t2 * o.volume()), n2._emit("volume", i3._id));
            return n2;
          }, fade: function(t2, e2, i3, n2) {
            var r2 = this;
            if ("loaded" !== r2._state || r2._playLock) return r2._queue.push({ event: "fade", action: function() {
              r2.fade(t2, e2, i3, n2);
            } }), r2;
            t2 = Math.min(Math.max(0, parseFloat(t2)), 1), e2 = Math.min(Math.max(0, parseFloat(e2)), 1), i3 = parseFloat(i3), r2.volume(t2, n2);
            for (var s2 = r2._getSoundIds(n2), a2 = 0; a2 < s2.length; a2++) {
              var l2 = r2._soundById(s2[a2]);
              if (l2) {
                if (n2 || r2._stopFade(s2[a2]), r2._webAudio && !l2._muted) {
                  var h2 = o.ctx.currentTime, u2 = h2 + i3 / 1e3;
                  l2._volume = t2, l2._node.gain.setValueAtTime(t2, h2), l2._node.gain.linearRampToValueAtTime(e2, u2);
                }
                r2._startFadeInterval(l2, t2, e2, i3, s2[a2], void 0 === n2);
              }
            }
            return r2;
          }, _startFadeInterval: function(t2, e2, i3, n2, r2, o2) {
            var s2 = this, a2 = e2, l2 = i3 - e2, h2 = Math.abs(l2 / 0.01), u2 = Math.max(4, h2 > 0 ? n2 / h2 : n2), c2 = Date.now();
            t2._fadeTo = i3, t2._interval = setInterval(function() {
              var r3 = (Date.now() - c2) / n2;
              c2 = Date.now(), a2 += l2 * r3, a2 = Math.round(100 * a2) / 100, a2 = l2 < 0 ? Math.max(i3, a2) : Math.min(i3, a2), s2._webAudio ? t2._volume = a2 : s2.volume(a2, t2._id, true), o2 && (s2._volume = a2), (i3 < e2 && a2 <= i3 || i3 > e2 && a2 >= i3) && (clearInterval(t2._interval), t2._interval = null, t2._fadeTo = null, s2.volume(i3, t2._id), s2._emit("fade", t2._id));
            }, u2);
          }, _stopFade: function(t2) {
            var e2 = this._soundById(t2);
            return e2 && e2._interval && (this._webAudio && e2._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(e2._interval), e2._interval = null, this.volume(e2._fadeTo, t2), e2._fadeTo = null, this._emit("fade", t2)), this;
          }, loop: function() {
            var t2, e2, i3, n2 = this, r2 = arguments;
            if (0 === r2.length) return n2._loop;
            if (1 === r2.length) {
              if ("boolean" != typeof r2[0]) return !!(i3 = n2._soundById(parseInt(r2[0], 10))) && i3._loop;
              t2 = r2[0], n2._loop = t2;
            } else 2 === r2.length && (t2 = r2[0], e2 = parseInt(r2[1], 10));
            for (var o2 = n2._getSoundIds(e2), s2 = 0; s2 < o2.length; s2++) (i3 = n2._soundById(o2[s2])) && (i3._loop = t2, n2._webAudio && i3._node && i3._node.bufferSource && (i3._node.bufferSource.loop = t2, t2 && (i3._node.bufferSource.loopStart = i3._start || 0, i3._node.bufferSource.loopEnd = i3._stop, n2.playing(o2[s2]) && (n2.pause(o2[s2], true), n2.play(o2[s2], true)))));
            return n2;
          }, rate: function() {
            var t2, e2, i3, n2 = this, r2 = arguments;
            if (0 === r2.length) e2 = n2._sounds[0]._id;
            else if (1 === r2.length) {
              var s2 = n2._getSoundIds(), a2 = s2.indexOf(r2[0]);
              a2 >= 0 ? e2 = parseInt(r2[0], 10) : t2 = parseFloat(r2[0]);
            } else 2 === r2.length && (t2 = parseFloat(r2[0]), e2 = parseInt(r2[1], 10));
            if ("number" != typeof t2) return (i3 = n2._soundById(e2)) ? i3._rate : n2._rate;
            if ("loaded" !== n2._state || n2._playLock) return n2._queue.push({ event: "rate", action: function() {
              n2.rate.apply(n2, r2);
            } }), n2;
            void 0 === e2 && (n2._rate = t2), e2 = n2._getSoundIds(e2);
            for (var l2 = 0; l2 < e2.length; l2++) if (i3 = n2._soundById(e2[l2])) {
              n2.playing(e2[l2]) && (i3._rateSeek = n2.seek(e2[l2]), i3._playStart = n2._webAudio ? o.ctx.currentTime : i3._playStart), i3._rate = t2, n2._webAudio && i3._node && i3._node.bufferSource ? i3._node.bufferSource.playbackRate.setValueAtTime(t2, o.ctx.currentTime) : i3._node && (i3._node.playbackRate = t2);
              var h2 = n2.seek(e2[l2]), u2 = (n2._sprite[i3._sprite][0] + n2._sprite[i3._sprite][1]) / 1e3 - h2, c2 = 1e3 * u2 / Math.abs(i3._rate);
              !n2._endTimers[e2[l2]] && i3._paused || (n2._clearTimer(e2[l2]), n2._endTimers[e2[l2]] = setTimeout(n2._ended.bind(n2, i3), c2)), n2._emit("rate", i3._id);
            }
            return n2;
          }, seek: function() {
            var t2, e2, i3 = this, n2 = arguments;
            if (0 === n2.length) i3._sounds.length && (e2 = i3._sounds[0]._id);
            else if (1 === n2.length) {
              var r2 = i3._getSoundIds(), s2 = r2.indexOf(n2[0]);
              s2 >= 0 ? e2 = parseInt(n2[0], 10) : i3._sounds.length && (e2 = i3._sounds[0]._id, t2 = parseFloat(n2[0]));
            } else 2 === n2.length && (t2 = parseFloat(n2[0]), e2 = parseInt(n2[1], 10));
            if (void 0 === e2) return 0;
            if ("number" == typeof t2 && ("loaded" !== i3._state || i3._playLock)) return i3._queue.push({ event: "seek", action: function() {
              i3.seek.apply(i3, n2);
            } }), i3;
            var a2 = i3._soundById(e2);
            if (a2) {
              if (!("number" == typeof t2 && t2 >= 0)) {
                if (i3._webAudio) {
                  var l2 = i3.playing(e2) ? o.ctx.currentTime - a2._playStart : 0, h2 = a2._rateSeek ? a2._rateSeek - a2._seek : 0;
                  return a2._seek + (h2 + l2 * Math.abs(a2._rate));
                }
                return a2._node.currentTime;
              }
              var u2 = i3.playing(e2);
              u2 && i3.pause(e2, true), a2._seek = t2, a2._ended = false, i3._clearTimer(e2), i3._webAudio || !a2._node || isNaN(a2._node.duration) || (a2._node.currentTime = t2);
              var c2 = function() {
                u2 && i3.play(e2, true), i3._emit("seek", e2);
              };
              if (u2 && !i3._webAudio) {
                var d2 = function() {
                  i3._playLock ? setTimeout(d2, 0) : c2();
                };
                setTimeout(d2, 0);
              } else c2();
            }
            return i3;
          }, playing: function(t2) {
            if ("number" == typeof t2) {
              var e2 = this._soundById(t2);
              return !!e2 && !e2._paused;
            }
            for (var i3 = 0; i3 < this._sounds.length; i3++) if (!this._sounds[i3]._paused) return true;
            return false;
          }, duration: function(t2) {
            var e2 = this._duration, i3 = this._soundById(t2);
            return i3 && (e2 = this._sprite[i3._sprite][1] / 1e3), e2;
          }, state: function() {
            return this._state;
          }, unload: function() {
            for (var t2 = this, e2 = t2._sounds, i3 = 0; i3 < e2.length; i3++) e2[i3]._paused || t2.stop(e2[i3]._id), t2._webAudio || (t2._clearSound(e2[i3]._node), e2[i3]._node.removeEventListener("error", e2[i3]._errorFn, false), e2[i3]._node.removeEventListener(o._canPlayEvent, e2[i3]._loadFn, false), e2[i3]._node.removeEventListener("ended", e2[i3]._endFn, false), o._releaseHtml5Audio(e2[i3]._node)), delete e2[i3]._node, t2._clearTimer(e2[i3]._id);
            var n2 = o._howls.indexOf(t2);
            n2 >= 0 && o._howls.splice(n2, 1);
            var r2 = true;
            for (i3 = 0; i3 < o._howls.length; i3++) if (o._howls[i3]._src === t2._src || t2._src.indexOf(o._howls[i3]._src) >= 0) {
              r2 = false;
              break;
            }
            return l && r2 && delete l[t2._src], o.noAudio = false, t2._state = "unloaded", t2._sounds = [], t2 = null, null;
          }, on: function(t2, e2, i3, n2) {
            var r2 = this["_on" + t2];
            return "function" == typeof e2 && r2.push(n2 ? { id: i3, fn: e2, once: n2 } : { id: i3, fn: e2 }), this;
          }, off: function(t2, e2, i3) {
            var n2 = this["_on" + t2], r2 = 0;
            if ("number" == typeof e2 && (i3 = e2, e2 = null), e2 || i3) for (r2 = 0; r2 < n2.length; r2++) {
              var o2 = i3 === n2[r2].id;
              if (e2 === n2[r2].fn && o2 || !e2 && o2) {
                n2.splice(r2, 1);
                break;
              }
            }
            else if (t2) this["_on" + t2] = [];
            else {
              var s2 = Object.keys(this);
              for (r2 = 0; r2 < s2.length; r2++) 0 === s2[r2].indexOf("_on") && Array.isArray(this[s2[r2]]) && (this[s2[r2]] = []);
            }
            return this;
          }, once: function(t2, e2, i3) {
            return this.on(t2, e2, i3, 1), this;
          }, _emit: function(t2, e2, i3) {
            for (var n2 = this["_on" + t2], r2 = n2.length - 1; r2 >= 0; r2--) n2[r2].id && n2[r2].id !== e2 && "load" !== t2 || (setTimeout(function(t3) {
              t3.call(this, e2, i3);
            }.bind(this, n2[r2].fn), 0), n2[r2].once && this.off(t2, n2[r2].fn, n2[r2].id));
            return this._loadQueue(t2), this;
          }, _loadQueue: function(t2) {
            if (this._queue.length > 0) {
              var e2 = this._queue[0];
              e2.event === t2 && (this._queue.shift(), this._loadQueue()), t2 || e2.action();
            }
            return this;
          }, _ended: function(t2) {
            var e2 = t2._sprite;
            if (!this._webAudio && t2._node && !t2._node.paused && !t2._node.ended && t2._node.currentTime < t2._stop) return setTimeout(this._ended.bind(this, t2), 100), this;
            var i3 = !(!t2._loop && !this._sprite[e2][2]);
            if (this._emit("end", t2._id), !this._webAudio && i3 && this.stop(t2._id, true).play(t2._id), this._webAudio && i3) {
              this._emit("play", t2._id), t2._seek = t2._start || 0, t2._rateSeek = 0, t2._playStart = o.ctx.currentTime;
              var n2 = 1e3 * (t2._stop - t2._start) / Math.abs(t2._rate);
              this._endTimers[t2._id] = setTimeout(this._ended.bind(this, t2), n2);
            }
            return this._webAudio && !i3 && (t2._paused = true, t2._ended = true, t2._seek = t2._start || 0, t2._rateSeek = 0, this._clearTimer(t2._id), this._cleanBuffer(t2._node), o._autoSuspend()), this._webAudio || i3 || this.stop(t2._id, true), this;
          }, _clearTimer: function(t2) {
            if (this._endTimers[t2]) {
              if ("function" != typeof this._endTimers[t2]) clearTimeout(this._endTimers[t2]);
              else {
                var e2 = this._soundById(t2);
                e2 && e2._node && e2._node.removeEventListener("ended", this._endTimers[t2], false);
              }
              delete this._endTimers[t2];
            }
            return this;
          }, _soundById: function(t2) {
            for (var e2 = 0; e2 < this._sounds.length; e2++) if (t2 === this._sounds[e2]._id) return this._sounds[e2];
            return null;
          }, _inactiveSound: function() {
            this._drain();
            for (var t2 = 0; t2 < this._sounds.length; t2++) if (this._sounds[t2]._ended) return this._sounds[t2].reset();
            return new a(this);
          }, _drain: function() {
            var t2 = this._pool, e2 = 0, i3 = 0;
            if (!(this._sounds.length < t2)) {
              for (i3 = 0; i3 < this._sounds.length; i3++) this._sounds[i3]._ended && e2++;
              for (i3 = this._sounds.length - 1; i3 >= 0; i3--) {
                if (e2 <= t2) return;
                this._sounds[i3]._ended && (this._webAudio && this._sounds[i3]._node && this._sounds[i3]._node.disconnect(0), this._sounds.splice(i3, 1), e2--);
              }
            }
          }, _getSoundIds: function(t2) {
            if (void 0 === t2) {
              for (var e2 = [], i3 = 0; i3 < this._sounds.length; i3++) e2.push(this._sounds[i3]._id);
              return e2;
            }
            return [t2];
          }, _refreshBuffer: function(t2) {
            return t2._node.bufferSource = o.ctx.createBufferSource(), t2._node.bufferSource.buffer = l[this._src], t2._panner ? t2._node.bufferSource.connect(t2._panner) : t2._node.bufferSource.connect(t2._node), t2._node.bufferSource.loop = t2._loop, t2._loop && (t2._node.bufferSource.loopStart = t2._start || 0, t2._node.bufferSource.loopEnd = t2._stop || 0), t2._node.bufferSource.playbackRate.setValueAtTime(t2._rate, o.ctx.currentTime), this;
          }, _cleanBuffer: function(t2) {
            var e2 = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
            if (o._scratchBuffer && t2.bufferSource && (t2.bufferSource.onended = null, t2.bufferSource.disconnect(0), e2)) try {
              t2.bufferSource.buffer = o._scratchBuffer;
            } catch (t3) {
            }
            return t2.bufferSource = null, this;
          }, _clearSound: function(t2) {
            /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t2.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
          } };
          var a = function(t2) {
            this._parent = t2, this.init();
          };
          a.prototype = { init: function() {
            var t2 = this._parent;
            return this._muted = t2._muted, this._loop = t2._loop, this._volume = t2._volume, this._rate = t2._rate, this._seek = 0, this._paused = true, this._ended = true, this._sprite = "__default", this._id = ++o._counter, t2._sounds.push(this), this.create(), this;
          }, create: function() {
            var t2 = this._parent, e2 = o._muted || this._muted || this._parent._muted ? 0 : this._volume;
            return t2._webAudio ? (this._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), this._node.gain.setValueAtTime(e2, o.ctx.currentTime), this._node.paused = true, this._node.connect(o.masterGain)) : o.noAudio || (this._node = o._obtainHtml5Audio(), this._errorFn = this._errorListener.bind(this), this._node.addEventListener("error", this._errorFn, false), this._loadFn = this._loadListener.bind(this), this._node.addEventListener(o._canPlayEvent, this._loadFn, false), this._endFn = this._endListener.bind(this), this._node.addEventListener("ended", this._endFn, false), this._node.src = t2._src, this._node.preload = true === t2._preload ? "auto" : t2._preload, this._node.volume = e2 * o.volume(), this._node.load()), this;
          }, reset: function() {
            var t2 = this._parent;
            return this._muted = t2._muted, this._loop = t2._loop, this._volume = t2._volume, this._rate = t2._rate, this._seek = 0, this._rateSeek = 0, this._paused = true, this._ended = true, this._sprite = "__default", this._id = ++o._counter, this;
          }, _errorListener: function() {
            this._parent._emit("loaderror", this._id, this._node.error ? this._node.error.code : 0), this._node.removeEventListener("error", this._errorFn, false);
          }, _loadListener: function() {
            var t2 = this._parent;
            t2._duration = Math.ceil(10 * this._node.duration) / 10, 0 === Object.keys(t2._sprite).length && (t2._sprite = { __default: [0, 1e3 * t2._duration] }), "loaded" !== t2._state && (t2._state = "loaded", t2._emit("load"), t2._loadQueue()), this._node.removeEventListener(o._canPlayEvent, this._loadFn, false);
          }, _endListener: function() {
            var t2 = this._parent;
            t2._duration === 1 / 0 && (t2._duration = Math.ceil(10 * this._node.duration) / 10, t2._sprite.__default[1] === 1 / 0 && (t2._sprite.__default[1] = 1e3 * t2._duration), t2._ended(this)), this._node.removeEventListener("ended", this._endFn, false);
          } };
          var l = {}, h = function(t2) {
            var e2 = t2._src;
            if (l[e2]) return t2._duration = l[e2].duration, void d(t2);
            if (/^data:[^;]+;base64,/.test(e2)) {
              for (var i3 = atob(e2.split(",")[1]), n2 = new Uint8Array(i3.length), r2 = 0; r2 < i3.length; ++r2) n2[r2] = i3.charCodeAt(r2);
              c(n2.buffer, t2);
            } else {
              var o2 = new XMLHttpRequest();
              o2.open(t2._xhr.method, e2, true), o2.withCredentials = t2._xhr.withCredentials, o2.responseType = "arraybuffer", t2._xhr.headers && Object.keys(t2._xhr.headers).forEach(function(e3) {
                o2.setRequestHeader(e3, t2._xhr.headers[e3]);
              }), o2.onload = function() {
                var e3 = (o2.status + "")[0];
                "0" === e3 || "2" === e3 || "3" === e3 ? c(o2.response, t2) : t2._emit("loaderror", null, "Failed loading audio file with status: " + o2.status + ".");
              }, o2.onerror = function() {
                t2._webAudio && (t2._html5 = true, t2._webAudio = false, t2._sounds = [], delete l[e2], t2.load());
              }, u(o2);
            }
          }, u = function(t2) {
            try {
              t2.send();
            } catch (e2) {
              t2.onerror();
            }
          }, c = function(t2, e2) {
            var i3 = function() {
              e2._emit("loaderror", null, "Decoding audio data failed.");
            }, n2 = function(t3) {
              t3 && e2._sounds.length > 0 ? (l[e2._src] = t3, d(e2, t3)) : i3();
            };
            "undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(t2).then(n2).catch(i3) : o.ctx.decodeAudioData(t2, n2, i3);
          }, d = function(t2, e2) {
            e2 && !t2._duration && (t2._duration = e2.duration), 0 === Object.keys(t2._sprite).length && (t2._sprite = { __default: [0, 1e3 * t2._duration] }), "loaded" !== t2._state && (t2._state = "loaded", t2._emit("load"), t2._loadQueue());
          }, p = function() {
            if (o.usingWebAudio) {
              try {
                "undefined" != typeof AudioContext ? o.ctx = new AudioContext() : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext() : o.usingWebAudio = false;
              } catch (t3) {
                o.usingWebAudio = false;
              }
              o.ctx || (o.usingWebAudio = false);
              var t2 = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform), e2 = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), i3 = e2 ? parseInt(e2[1], 10) : null;
              if (t2 && i3 && i3 < 9) {
                var n2 = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                o._navigator && !n2 && (o.usingWebAudio = false);
              }
              o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup();
            }
          };
          void 0 === (n = function() {
            return { Howler: o, Howl: s };
          }.apply(e, [])) || (t.exports = n), e.Howler = o, e.Howl = s, void 0 !== i2 ? (i2.HowlerGlobal = r, i2.Howler = o, i2.Howl = s, i2.Sound = a) : "undefined" != typeof window && (window.HowlerGlobal = r, window.Howler = o, window.Howl = s, window.Sound = a);
        }(), /*!
         *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
         *  
         *  howler.js v2.2.3
         *  howlerjs.com
         *
         *  (c) 2013-2020, James Simpson of GoldFire Studios
         *  goldfirestudios.com
         *
         *  MIT License
         */
        function() {
          "use strict";
          var t2;
          HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t3) {
            if (!this.ctx || !this.ctx.listener) return this;
            for (var e3 = this._howls.length - 1; e3 >= 0; e3--) this._howls[e3].stereo(t3);
            return this;
          }, HowlerGlobal.prototype.pos = function(t3, e3, i3) {
            return this.ctx && this.ctx.listener ? (e3 = "number" != typeof e3 ? this._pos[1] : e3, i3 = "number" != typeof i3 ? this._pos[2] : i3, "number" != typeof t3 ? this._pos : (this._pos = [t3, e3, i3], void 0 !== this.ctx.listener.positionX ? (this.ctx.listener.positionX.setTargetAtTime(this._pos[0], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionY.setTargetAtTime(this._pos[1], Howler.ctx.currentTime, 0.1), this.ctx.listener.positionZ.setTargetAtTime(this._pos[2], Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setPosition(this._pos[0], this._pos[1], this._pos[2]), this)) : this;
          }, HowlerGlobal.prototype.orientation = function(t3, e3, i3, n2, r, o) {
            if (!this.ctx || !this.ctx.listener) return this;
            var s = this._orientation;
            return e3 = "number" != typeof e3 ? s[1] : e3, i3 = "number" != typeof i3 ? s[2] : i3, n2 = "number" != typeof n2 ? s[3] : n2, r = "number" != typeof r ? s[4] : r, o = "number" != typeof o ? s[5] : o, "number" != typeof t3 ? s : (this._orientation = [t3, e3, i3, n2, r, o], void 0 !== this.ctx.listener.forwardX ? (this.ctx.listener.forwardX.setTargetAtTime(t3, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardY.setTargetAtTime(e3, Howler.ctx.currentTime, 0.1), this.ctx.listener.forwardZ.setTargetAtTime(i3, Howler.ctx.currentTime, 0.1), this.ctx.listener.upX.setTargetAtTime(n2, Howler.ctx.currentTime, 0.1), this.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, 0.1), this.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, 0.1)) : this.ctx.listener.setOrientation(t3, e3, i3, n2, r, o), this);
          }, Howl.prototype.init = (t2 = Howl.prototype.init, function(e3) {
            return this._orientation = e3.orientation || [1, 0, 0], this._stereo = e3.stereo || null, this._pos = e3.pos || null, this._pannerAttr = { coneInnerAngle: void 0 !== e3.coneInnerAngle ? e3.coneInnerAngle : 360, coneOuterAngle: void 0 !== e3.coneOuterAngle ? e3.coneOuterAngle : 360, coneOuterGain: void 0 !== e3.coneOuterGain ? e3.coneOuterGain : 0, distanceModel: void 0 !== e3.distanceModel ? e3.distanceModel : "inverse", maxDistance: void 0 !== e3.maxDistance ? e3.maxDistance : 1e4, panningModel: void 0 !== e3.panningModel ? e3.panningModel : "HRTF", refDistance: void 0 !== e3.refDistance ? e3.refDistance : 1, rolloffFactor: void 0 !== e3.rolloffFactor ? e3.rolloffFactor : 1 }, this._onstereo = e3.onstereo ? [{ fn: e3.onstereo }] : [], this._onpos = e3.onpos ? [{ fn: e3.onpos }] : [], this._onorientation = e3.onorientation ? [{ fn: e3.onorientation }] : [], t2.call(this, e3);
          }), Howl.prototype.stereo = function(t3, i3) {
            var n2 = this;
            if (!n2._webAudio) return n2;
            if ("loaded" !== n2._state) return n2._queue.push({ event: "stereo", action: function() {
              n2.stereo(t3, i3);
            } }), n2;
            var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
            if (void 0 === i3) {
              if ("number" != typeof t3) return n2._stereo;
              n2._stereo = t3, n2._pos = [t3, 0, 0];
            }
            for (var o = n2._getSoundIds(i3), s = 0; s < o.length; s++) {
              var a = n2._soundById(o[s]);
              if (a) {
                if ("number" != typeof t3) return a._stereo;
                a._stereo = t3, a._pos = [t3, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || e2(a, r), "spatial" === r ? void 0 !== a._panner.positionX ? (a._panner.positionX.setValueAtTime(t3, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(t3, 0, 0) : a._panner.pan.setValueAtTime(t3, Howler.ctx.currentTime)), n2._emit("stereo", a._id);
              }
            }
            return n2;
          }, Howl.prototype.pos = function(t3, i3, n2, r) {
            var o = this;
            if (!o._webAudio) return o;
            if ("loaded" !== o._state) return o._queue.push({ event: "pos", action: function() {
              o.pos(t3, i3, n2, r);
            } }), o;
            if (i3 = "number" != typeof i3 ? 0 : i3, n2 = "number" != typeof n2 ? -0.5 : n2, void 0 === r) {
              if ("number" != typeof t3) return o._pos;
              o._pos = [t3, i3, n2];
            }
            for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
              var l = o._soundById(s[a]);
              if (l) {
                if ("number" != typeof t3) return l._pos;
                l._pos = [t3, i3, n2], l._node && (l._panner && !l._panner.pan || e2(l, "spatial"), void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(t3, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(i3, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(n2, Howler.ctx.currentTime)) : l._panner.setPosition(t3, i3, n2)), o._emit("pos", l._id);
              }
            }
            return o;
          }, Howl.prototype.orientation = function(t3, i3, n2, r) {
            var o = this;
            if (!o._webAudio) return o;
            if ("loaded" !== o._state) return o._queue.push({ event: "orientation", action: function() {
              o.orientation(t3, i3, n2, r);
            } }), o;
            if (i3 = "number" != typeof i3 ? o._orientation[1] : i3, n2 = "number" != typeof n2 ? o._orientation[2] : n2, void 0 === r) {
              if ("number" != typeof t3) return o._orientation;
              o._orientation = [t3, i3, n2];
            }
            for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
              var l = o._soundById(s[a]);
              if (l) {
                if ("number" != typeof t3) return l._orientation;
                l._orientation = [t3, i3, n2], l._node && (l._panner || (l._pos || (l._pos = o._pos || [0, 0, -0.5]), e2(l, "spatial")), void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(t3, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(i3, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(n2, Howler.ctx.currentTime)) : l._panner.setOrientation(t3, i3, n2)), o._emit("orientation", l._id);
              }
            }
            return o;
          }, Howl.prototype.pannerAttr = function() {
            var t3, i3, n2, r = this, o = arguments;
            if (!r._webAudio) return r;
            if (0 === o.length) return r._pannerAttr;
            if (1 === o.length) {
              if ("object" != typeof o[0]) return (n2 = r._soundById(parseInt(o[0], 10))) ? n2._pannerAttr : r._pannerAttr;
              t3 = o[0], void 0 === i3 && (t3.pannerAttr || (t3.pannerAttr = { coneInnerAngle: t3.coneInnerAngle, coneOuterAngle: t3.coneOuterAngle, coneOuterGain: t3.coneOuterGain, distanceModel: t3.distanceModel, maxDistance: t3.maxDistance, refDistance: t3.refDistance, rolloffFactor: t3.rolloffFactor, panningModel: t3.panningModel }), r._pannerAttr = { coneInnerAngle: void 0 !== t3.pannerAttr.coneInnerAngle ? t3.pannerAttr.coneInnerAngle : r._coneInnerAngle, coneOuterAngle: void 0 !== t3.pannerAttr.coneOuterAngle ? t3.pannerAttr.coneOuterAngle : r._coneOuterAngle, coneOuterGain: void 0 !== t3.pannerAttr.coneOuterGain ? t3.pannerAttr.coneOuterGain : r._coneOuterGain, distanceModel: void 0 !== t3.pannerAttr.distanceModel ? t3.pannerAttr.distanceModel : r._distanceModel, maxDistance: void 0 !== t3.pannerAttr.maxDistance ? t3.pannerAttr.maxDistance : r._maxDistance, refDistance: void 0 !== t3.pannerAttr.refDistance ? t3.pannerAttr.refDistance : r._refDistance, rolloffFactor: void 0 !== t3.pannerAttr.rolloffFactor ? t3.pannerAttr.rolloffFactor : r._rolloffFactor, panningModel: void 0 !== t3.pannerAttr.panningModel ? t3.pannerAttr.panningModel : r._panningModel });
            } else 2 === o.length && (t3 = o[0], i3 = parseInt(o[1], 10));
            for (var s = r._getSoundIds(i3), a = 0; a < s.length; a++) if (n2 = r._soundById(s[a])) {
              var l = n2._pannerAttr;
              l = { coneInnerAngle: void 0 !== t3.coneInnerAngle ? t3.coneInnerAngle : l.coneInnerAngle, coneOuterAngle: void 0 !== t3.coneOuterAngle ? t3.coneOuterAngle : l.coneOuterAngle, coneOuterGain: void 0 !== t3.coneOuterGain ? t3.coneOuterGain : l.coneOuterGain, distanceModel: void 0 !== t3.distanceModel ? t3.distanceModel : l.distanceModel, maxDistance: void 0 !== t3.maxDistance ? t3.maxDistance : l.maxDistance, refDistance: void 0 !== t3.refDistance ? t3.refDistance : l.refDistance, rolloffFactor: void 0 !== t3.rolloffFactor ? t3.rolloffFactor : l.rolloffFactor, panningModel: void 0 !== t3.panningModel ? t3.panningModel : l.panningModel };
              var h = n2._panner;
              h ? (h.coneInnerAngle = l.coneInnerAngle, h.coneOuterAngle = l.coneOuterAngle, h.coneOuterGain = l.coneOuterGain, h.distanceModel = l.distanceModel, h.maxDistance = l.maxDistance, h.refDistance = l.refDistance, h.rolloffFactor = l.rolloffFactor, h.panningModel = l.panningModel) : (n2._pos || (n2._pos = r._pos || [0, 0, -0.5]), e2(n2, "spatial"));
            }
            return r;
          }, Sound.prototype.init = /* @__PURE__ */ function(t3) {
            return function() {
              var e3 = this._parent;
              this._orientation = e3._orientation, this._stereo = e3._stereo, this._pos = e3._pos, this._pannerAttr = e3._pannerAttr, t3.call(this), this._stereo ? e3.stereo(this._stereo) : this._pos && e3.pos(this._pos[0], this._pos[1], this._pos[2], this._id);
            };
          }(Sound.prototype.init), Sound.prototype.reset = /* @__PURE__ */ function(t3) {
            return function() {
              var e3 = this._parent;
              return this._orientation = e3._orientation, this._stereo = e3._stereo, this._pos = e3._pos, this._pannerAttr = e3._pannerAttr, this._stereo ? e3.stereo(this._stereo) : this._pos ? e3.pos(this._pos[0], this._pos[1], this._pos[2], this._id) : this._panner && (this._panner.disconnect(0), this._panner = void 0, e3._refreshBuffer(this)), t3.call(this);
            };
          }(Sound.prototype.reset);
          var e2 = function(t3, e3) {
            "spatial" === (e3 = e3 || "spatial") ? (t3._panner = Howler.ctx.createPanner(), t3._panner.coneInnerAngle = t3._pannerAttr.coneInnerAngle, t3._panner.coneOuterAngle = t3._pannerAttr.coneOuterAngle, t3._panner.coneOuterGain = t3._pannerAttr.coneOuterGain, t3._panner.distanceModel = t3._pannerAttr.distanceModel, t3._panner.maxDistance = t3._pannerAttr.maxDistance, t3._panner.refDistance = t3._pannerAttr.refDistance, t3._panner.rolloffFactor = t3._pannerAttr.rolloffFactor, t3._panner.panningModel = t3._pannerAttr.panningModel, void 0 !== t3._panner.positionX ? (t3._panner.positionX.setValueAtTime(t3._pos[0], Howler.ctx.currentTime), t3._panner.positionY.setValueAtTime(t3._pos[1], Howler.ctx.currentTime), t3._panner.positionZ.setValueAtTime(t3._pos[2], Howler.ctx.currentTime)) : t3._panner.setPosition(t3._pos[0], t3._pos[1], t3._pos[2]), void 0 !== t3._panner.orientationX ? (t3._panner.orientationX.setValueAtTime(t3._orientation[0], Howler.ctx.currentTime), t3._panner.orientationY.setValueAtTime(t3._orientation[1], Howler.ctx.currentTime), t3._panner.orientationZ.setValueAtTime(t3._orientation[2], Howler.ctx.currentTime)) : t3._panner.setOrientation(t3._orientation[0], t3._orientation[1], t3._orientation[2])) : (t3._panner = Howler.ctx.createStereoPanner(), t3._panner.pan.setValueAtTime(t3._stereo, Howler.ctx.currentTime)), t3._panner.connect(t3._node), t3._paused || t3._parent.pause(t3._id, true).play(t3._id, true);
          };
        }();
      }).call(this, i(17));
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nvarying vec2 vVertexPosition;\nvarying float vPercent;\nvarying float vDirection;\nvarying float vTransition;\nuniform sampler2D uSampler;\nvoid main() {\n	vec4 outputColor;\n	float percent = vPercent;\n	float direction = vDirection;\n	if (vTransition < 0.0) {\n		percent = 1.0 - percent;\n		if ((vDirection > 1.5) && (vDirection < 2.5)) {\n			direction = 1.0;\n		}\n		else if ((vDirection > 0.5) && (vDirection < 1.5)) {\n			direction = 2.0;\n		}\n		else if ((vDirection > 2.5) && (vDirection < 3.5)) {\n			direction = 4.0;\n		}\n		else {\n			direction = 3.0;\n		}\n	}\n	if ((direction > 1.5) && (direction < 2.5)) {\n		if (vVertexPosition.y >= (1.0 - percent)) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.y >= (1.0 - percent)) && (vVertexPosition.y <= ((1.0 - percent) + 0.2))) {\n			outputColor = outputColor * ((vVertexPosition.y - (1.0 - percent)) / 0.2);\n		}\n	}\n	else if ((direction > 0.5) && (direction < 1.5)) {\n		if (vVertexPosition.y <= percent) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.y <= percent) && (vVertexPosition.y >= (percent - 0.2))) {\n			outputColor = outputColor * (1.0 - ((vVertexPosition.y - (percent - 0.2)) / 0.2));\n		}\n	}\n	else if ((direction > 2.5) && (direction < 3.5)) {\n		if (vVertexPosition.x <= percent) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.x <= percent) && (vVertexPosition.x >= (percent - 0.2))) {\n			outputColor = outputColor * (1.0 - ((vVertexPosition.x - (percent - 0.2)) / 0.2));\n		}\n	}\n	else {\n		if (vVertexPosition.x >= (1.0 - percent)) {\n			outputColor = texture2D(uSampler, vTextureCoord);\n		}\n		else {\n			outputColor = vec4(0.0, 0.0, 0.0, 0.0);\n		}\n		if ((vVertexPosition.x >= (1.0 - percent)) && (vVertexPosition.x <= ((1.0 - percent) + 0.2))) {\n			outputColor = outputColor * ((vVertexPosition.x - (1.0 - percent)) / 0.2);\n		}\n	}\n	gl_FragColor = outputColor;\n}\n";
    }, function(t, e) {
      t.exports = "attribute vec2 aVertexPosition;\nuniform mat3 projectionMatrix;\nvarying vec2 vTextureCoord;\nvarying vec2 vVertexPosition;\nvarying float vPercent;\nvarying float vDirection;\nvarying float vTransition;\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\nuniform float percent;\nuniform float direction;\nuniform float transition;\nvec4 filterVertexPosition() {\n	vec2 position = (aVertexPosition * max(outputFrame.zw, vec2(0.))) + outputFrame.xy;\n	return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\nvec2 filterTextureCoord(vec2 aVertexPosition) {\n	return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\nvoid main() {\n	vTransition = transition;\n	vDirection = direction;\n	vPercent = percent;\n	vVertexPosition = aVertexPosition;\n	vec2 localVertexPosition = aVertexPosition;\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord(localVertexPosition);\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nuniform float transition;\nvoid main() {\n	float alpha = (transition * (percent - 0.5)) + 0.5;\n	vec4 color1 = texture2D(uSampler, vTextureCoord);\n	gl_FragColor = color1 * alpha;\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 position = vec2(uBoundRect.z - filterCoord.x, uBoundRect.w - filterCoord.y);\n	float timePercent = transition > 0.0 ? percent : 1.0 - percent;\n	float barCount = 6.0;\n	float barWidth = (option < 0.5 ? uBoundRect.w : uBoundRect.z) / barCount;\n	float alphaWidthPercent = 0.03;\n	float alphaWidth = alphaWidthPercent * (option < 0.5 ? uBoundRect.w : uBoundRect.z);\n	float selectAxis = option < 0.5 ? -position.y : -position.x;\n	float countAxis = floor(selectAxis / barWidth);\n	float modAxis = mod(selectAxis, barWidth);\n	float timePosition = barWidth * timePercent;\n	if (modAxis < timePosition) {\n		outputColor = outputColor;\n	}\n	else if (modAxis < (timePosition + alphaWidth)) {\n		outputColor = (outputColor * ((alphaWidth - modAxis) + timePosition)) / alphaWidth;\n	}\n	else {\n		outputColor = outputColor * 0.0;\n	}\n	gl_FragColor = outputColor;\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 position = vec2(uBoundRect.z - filterCoord.x, uBoundRect.w - filterCoord.y);\n	float timePercent = transition > 0.0 ? percent : 1.0 - percent;\n	float barCount = 6.0;\n	float horizontalBarWidth = uBoundRect.z / barCount;\n	float verticalBarWidth = uBoundRect.w / barCount;\n	float alphaWidthPercent = 0.01;\n	float alphaWidth = alphaWidthPercent * (option < 0.5 ? uBoundRect.z : uBoundRect.w);\n	float timePosition = horizontalBarWidth * timePercent;\n	float countAxisY = floor(-position.y / verticalBarWidth);\n	float modAxisY = mod(-position.y, verticalBarWidth);\n	float countAxisX = floor(-position.x / horizontalBarWidth);\n	float modAxisX = mod(-position.x, horizontalBarWidth);\n	float modAxis = modAxisX;\n	if (option < 0.5) {\n		if (mod(countAxisY, 2.0) > 0.5) {\n			countAxisX = floor(((horizontalBarWidth * 0.5) - position.x) / horizontalBarWidth);\n			modAxisX = mod((horizontalBarWidth * 0.5) - position.x, horizontalBarWidth);\n		}\n		modAxis = modAxisX;\n	}\n	else {\n		if (mod(countAxisX, 2.0) > 0.5) {\n			countAxisY = floor(((verticalBarWidth * 0.5) - position.y) / verticalBarWidth);\n			modAxisY = mod((verticalBarWidth * 0.5) - position.y, verticalBarWidth);\n		}\n		modAxis = modAxisY;\n	}\n	if (modAxis < timePosition) {\n		outputColor = outputColor;\n	}\n	else if (modAxis < (timePosition + alphaWidth)) {\n		outputColor = (outputColor * ((alphaWidth - modAxis) + timePosition)) / alphaWidth;\n	}\n	else {\n		outputColor = outputColor * 0.0;\n	}\n	gl_FragColor = outputColor;\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 inputSize;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform sampler2D dissolveSampler;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	float splitWidth = max(uBoundRect.z, uBoundRect.w) / 3.0;\n	vec2 position = mod(filterCoord.xy, splitWidth);\n	vec2 loopTime = floor(filterCoord.xy / splitWidth);\n	if (loopTime.x > 0.5) {\n		position.x = splitWidth - position.x;\n	}\n	if (loopTime.y > 0.5) {\n		position.y = splitWidth - position.y;\n	}\n	vec4 dissolveColor = texture2D(dissolveSampler, position.xy / splitWidth);\n	float timePercent = transition > 0.0 ? percent : 1.0 - percent;\n	if (dissolveColor.r < percent) {\n		gl_FragColor = outputColor;\n	}\n	else {\n		gl_FragColor = vec4(0, 0, 0, 0);\n	}\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform sampler2D dissolveSampler;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 position = vec2(uBoundRect.z - filterCoord.x, uBoundRect.w - filterCoord.y);\n	vec4 dissolveColor;\n	if (option > 0.5) {\n		dissolveColor = texture2D(dissolveSampler, vec2(vTextureCoord.x, 0.0));\n	}\n	else {\n		dissolveColor = texture2D(dissolveSampler, vec2(0.0, vTextureCoord.y));\n	}\n	if (dissolveColor.r < percent) {\n		gl_FragColor = outputColor * min(percent + dissolveColor.r, 1.0);\n	}\n	else {\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n	}\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	float radius = sqrt(pow(uBoundRect.z, 2.0) + pow(uBoundRect.w, 2.0)) / 2.0;\n	float alphaWidth = 0.1;\n	float pointDistance = sqrt(pow(point.x, 2.0) + pow(point.y, 2.0));\n	float alphaRadiusFormula;\n	if (option > 0.5) {\n		if (transition > 0.0) {\n			alphaRadiusFormula = 1.0 - ((pointDistance - (radius * timePercent)) / (alphaWidth * radius));\n		}\n		else {\n			alphaRadiusFormula = (pointDistance - (radius * timePercent)) / (alphaWidth * radius);\n		}\n	}\n	else {\n		if (transition > 0.0) {\n			alphaRadiusFormula = (pointDistance - (radius * (1.0 - timePercent))) / (alphaWidth * radius);\n		}\n		else {\n			alphaRadiusFormula = 1.0 - ((pointDistance - (radius * (1.0 - timePercent))) / (alphaWidth * radius));\n		}\n	}\n	if (option > 0.5) {\n		if (pointDistance < (radius * timePercent)) {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n		else if (pointDistance < (radius * (timePercent + alphaWidth))) {\n			gl_FragColor = outputColor * alphaRadiusFormula;\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n	}\n	else {\n		if (pointDistance < (radius * (1.0 - timePercent))) {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n		else if (pointDistance < (radius * ((1.0 - timePercent) + alphaWidth))) {\n			gl_FragColor = outputColor * alphaRadiusFormula;\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n	}\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	if (option < 0.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float alphaWidth = 0.2;\n	vec2 halfRect = uBoundRect.zw / 2.0;\n	vec2 absPoint = abs(point.xy);\n	vec2 alphaFormula = vec2(((halfRect.x * (timePercent + alphaWidth)) - absPoint.x) / (halfRect.x * alphaWidth), ((halfRect.y * (timePercent + alphaWidth)) - absPoint.y) / (halfRect.y * alphaWidth));\n	if (option < 0.5) {\n		if ((absPoint.x < (halfRect.x * timePercent)) && (absPoint.y < (halfRect.y * timePercent))) {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n		else if ((absPoint.x < (halfRect.x * (timePercent + alphaWidth))) && (absPoint.y < (halfRect.y * (timePercent + alphaWidth)))) {\n			if (absPoint.x > absPoint.y) {\n				gl_FragColor = outputColor * (transition > 0.0 ? 1.0 - alphaFormula.x : alphaFormula.x);\n			}\n			else {\n				gl_FragColor = outputColor * (transition > 0.0 ? 1.0 - alphaFormula.y : alphaFormula.y);\n			}\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n	}\n	else {\n		if ((absPoint.x < (halfRect.x * timePercent)) && (absPoint.y < (halfRect.y * timePercent))) {\n			gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n		}\n		else if ((absPoint.x < (halfRect.x * (timePercent + alphaWidth))) && (absPoint.y < (halfRect.y * (timePercent + alphaWidth)))) {\n			if (absPoint.x > absPoint.y) {\n				gl_FragColor = outputColor * (transition > 0.0 ? alphaFormula.x : 1.0 - alphaFormula.x);\n			}\n			else {\n				gl_FragColor = outputColor * (transition > 0.0 ? alphaFormula.y : 1.0 - alphaFormula.y);\n			}\n		}\n		else {\n			gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n		}\n	}\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), (uBoundRect.w / 2.0) - filterCoord.y);\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	if (option < 0.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float alphaWidth = 0.1;\n	float rightTop = (((2.0 * uBoundRect.w) * timePercent) - ((uBoundRect.w * point.x) / uBoundRect.z)) - point.y;\n	float rightBottom = (((uBoundRect.w * point.x) / uBoundRect.z) - ((2.0 * uBoundRect.w) * timePercent)) - point.y;\n	float leftTop = (((2.0 * uBoundRect.w) * timePercent) + ((uBoundRect.w * point.x) / uBoundRect.z)) - point.y;\n	float leftBottom = (((-uBoundRect.w * point.x) / uBoundRect.z) - ((2.0 * uBoundRect.w) * timePercent)) - point.y;\n	if (((option < 0.5) && (transition > 0.0)) || ((option > 0.5) && (transition < 0.0))) {\n		if ((point.x >= 0.0) && (point.y >= 0.0)) {\n			if (rightTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor;\n			}\n			else if (rightTop < 0.0) {\n				gl_FragColor = outputColor * (-rightTop / (alphaWidth * uBoundRect.w));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n		if ((point.x >= 0.0) && (point.y <= 0.0)) {\n			if (rightBottom < 0.0) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (rightBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = (outputColor * rightBottom) / (alphaWidth * uBoundRect.w);\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n		if ((point.x <= 0.0) && (point.y >= 0.0)) {\n			if (leftTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor;\n			}\n			else if (leftTop < 0.0) {\n				gl_FragColor = outputColor * (-leftTop / (alphaWidth * uBoundRect.w));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n		if ((point.x <= 0.0) && (point.y <= 0.0)) {\n			if (leftBottom < 0.0) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (leftBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = (outputColor * leftBottom) / (alphaWidth * uBoundRect.w);\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n	}\n	else {\n		if ((point.x >= 0.0) && (point.y >= 0.0)) {\n			if (rightTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (rightTop < 0.0) {\n				gl_FragColor = outputColor * (1.0 + (rightTop / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n		if ((point.x >= 0.0) && (point.y <= 0.0)) {\n			if (rightBottom < 0.0) {\n				gl_FragColor = outputColor;\n			}\n			else if (rightBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor * (1.0 - (rightBottom / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n		if ((point.x <= 0.0) && (point.y >= 0.0)) {\n			if (leftTop < (-alphaWidth * uBoundRect.w)) {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n			else if (leftTop < 0.0) {\n				gl_FragColor = outputColor * (1.0 + (leftTop / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = outputColor;\n			}\n		}\n		if ((point.x <= 0.0) && (point.y <= 0.0)) {\n			if (leftBottom < 0.0) {\n				gl_FragColor = outputColor;\n			}\n			else if (leftBottom < (alphaWidth * uBoundRect.w)) {\n				gl_FragColor = outputColor * (1.0 - (leftBottom / (alphaWidth * uBoundRect.w)));\n			}\n			else {\n				gl_FragColor = vec4(0, 0, 0, 0);\n			}\n		}\n	}\n}\n";
    }, function(t, e) {
      t.exports = "float interpolationFloat(float from, float to, float start, float end, float timePercent, int timing) {\n	float pi = 3.14159265358;\n	float current;\n	float duration = 1.0;\n	if (timePercent < start) {\n		current = 0.0;\n	}\n	else if (timePercent > end) {\n		current = 1.0;\n	}\n	else {\n		current = (timePercent - start) / (end - start);\n	}\n	if (timing == 0) {\n		return ((current / duration) * (to - from)) + from;\n	}\n	else if (timing == 1) {\n		current = current / duration;\n		return (((to - from) * current) * current) + from;\n	}\n	else if (timing == 2) {\n		current = current / duration;\n		return (((-1.0 * (to - from)) * current) * (current - 2.0)) + from;\n	}\n	else {\n		current /= (duration / 2.0);\n		if (current < 1.0) {\n			return ((((to - from) / 2.0) * current) * current) + from;\n		}\n		current--;\n		return ((-(to - from) / 2.0) * ((current * (current - 2.0)) - 1.0)) + from;\n	}\n}\nvarying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	float timePercent = interpolationFloat(0.0, 1.0, 0.0, 1.0, percent, 2);\n	if (option < 0.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float alphaWidth = 0.1;\n	vec2 absPoint = abs(point);\n	vec2 halfRect = uBoundRect.zw / 2.0;\n	vec2 alphaFormula = vec2(((halfRect.x * (timePercent + alphaWidth)) - absPoint.x) / (halfRect.x * alphaWidth), ((halfRect.y * (timePercent + alphaWidth)) - absPoint.y) / (halfRect.y * alphaWidth));\n	if (((option < 0.5) && (transition > 0.0)) || ((option > 0.5) && (transition < 0.0))) {\n		if ((absPoint.x < ((uBoundRect.z * 0.5) * timePercent)) || (absPoint.y < ((uBoundRect.w * 0.5) * timePercent))) {\n			gl_FragColor = vec4(0, 0, 0, 0);\n		}\n		else if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) || (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n			if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) && (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n				gl_FragColor = (outputColor * (1.0 - alphaFormula.x)) * (1.0 - alphaFormula.y);\n			}\n			else if (absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) {\n				gl_FragColor = outputColor * (1.0 - alphaFormula.x);\n			}\n			else {\n				gl_FragColor = outputColor * (1.0 - alphaFormula.y);\n			}\n		}\n		else {\n			gl_FragColor = outputColor;\n		}\n	}\n	else {\n		if ((absPoint.x < ((uBoundRect.z * 0.5) * timePercent)) || (absPoint.y < ((uBoundRect.w * 0.5) * timePercent))) {\n			gl_FragColor = outputColor;\n		}\n		else if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) || (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n			if ((absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) && (absPoint.y < ((uBoundRect.w * 0.5) * (timePercent + alphaWidth)))) {\n				gl_FragColor = outputColor * (1.0 - ((1.0 - alphaFormula.x) * (1.0 - alphaFormula.y)));\n			}\n			else if (absPoint.x < ((uBoundRect.z * 0.5) * (timePercent + alphaWidth))) {\n				gl_FragColor = outputColor * alphaFormula.x;\n			}\n			else {\n				gl_FragColor = outputColor * alphaFormula.y;\n			}\n		}\n		else {\n			gl_FragColor = vec4(0, 0, 0, 0);\n		}\n	}\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	vec2 absPoint = abs(point);\n	vec2 halfRect = uBoundRect.zw / 2.0;\n	float alphaWidth = 0.1;\n	float timePercent = percent;\n	if (option < 1.5) {\n		timePercent = 1.0 - timePercent;\n	}\n	float axis = (option > 0.5) && (option < 2.5) ? absPoint.y : absPoint.x;\n	float compareAxis = (option > 0.5) && (option < 2.5) ? halfRect.y : halfRect.x;\n	float alphaColor = abs(((timePercent * compareAxis) - axis) / (alphaWidth * compareAxis));\n	vec4 beginColor;\n	vec4 endColor;\n	if ((option > 1.5) && (option < 3.5)) {\n		if (transition < 0.0) {\n			beginColor = vec4(0, 0, 0, 0);\n			endColor = outputColor;\n		}\n		else {\n			beginColor = outputColor;\n			endColor = vec4(0, 0, 0, 0);\n			alphaColor = 1.0 - alphaColor;\n		}\n	}\n	else {\n		if (transition < 0.0) {\n			beginColor = outputColor;\n			endColor = vec4(0, 0, 0, 0);\n			alphaColor = 1.0 - alphaColor;\n		}\n		else {\n			beginColor = vec4(0, 0, 0, 0);\n			endColor = outputColor;\n		}\n	}\n	if (axis < (timePercent * compareAxis)) {\n		gl_FragColor = beginColor;\n	}\n	else if (axis < ((timePercent + alphaWidth) * compareAxis)) {\n		gl_FragColor = outputColor * alphaColor;\n	}\n	else {\n		gl_FragColor = endColor;\n	}\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x, filterCoord.y);\n	if ((option > 0.5) && (option < 1.5)) {\n		point = filterCoord.xy;\n	}\n	else if ((option > 1.5) && (option < 2.5)) {\n		point = uBoundRect.zw - point.xy;\n	}\n	else if ((option > 2.5) && (option < 3.5)) {\n		point = vec2(uBoundRect.z - filterCoord.x, filterCoord.y);\n	}\n	else {\n		point = vec2(filterCoord.x, uBoundRect.w - filterCoord.y);\n	}\n	float squareCount = 16.0;\n	float horzBarWidth = uBoundRect.z / squareCount;\n	float verticalBarWidth = uBoundRect.w / squareCount;\n	float horzCount = floor(point.x / horzBarWidth);\n	float verticalCount = floor(point.y / verticalBarWidth);\n	float timePercent = (percent * squareCount) * 2.5;\n	vec4 alphaStage;\n	if (transition > 0.0) {\n		alphaStage = vec4(0.2, 0.4, 0.6, 0.8);\n	}\n	else {\n		alphaStage = vec4(0.8, 0.6, 0.4, 0.2);\n	}\n	if ((horzCount + verticalCount) < (timePercent - 4.0)) {\n		gl_FragColor = transition > 0.0 ? outputColor : vec4(0, 0, 0, 0);\n	}\n	else if ((horzCount + verticalCount) < (timePercent - 3.0)) {\n		gl_FragColor = outputColor * alphaStage.w;\n	}\n	else if ((horzCount + verticalCount) < (timePercent - 2.0)) {\n		gl_FragColor = outputColor * alphaStage.z;\n	}\n	else if ((horzCount + verticalCount) < (timePercent - 1.0)) {\n		gl_FragColor = outputColor * alphaStage.y;\n	}\n	else if ((horzCount + verticalCount) < timePercent) {\n		gl_FragColor = outputColor * alphaStage.x;\n	}\n	else {\n		gl_FragColor = transition > 0.0 ? vec4(0, 0, 0, 0) : outputColor;\n	}\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\n#define PI 3.1415926538\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	vec2 start = vec2(0.0, -1.0);\n	float arc = acos((dot(point.xy, start) / length(point)) / length(start));\n	if ((point.x == 0.0) && (point.y < 0.0)) {\n		arc = 0.0;\n	}\n	if ((point.x == 0.0) && (point.y > 0.0)) {\n		arc = PI;\n	}\n	float alphaBarArcWidth = 0.3;\n	float timePercent = (percent * PI) * (1.0 + alphaBarArcWidth);\n	vec3 colorAlpha = transition > 0.0 ? vec3(1.0, (timePercent - arc) / alphaBarArcWidth, 0.0) : vec3(0.0, 1.0 - ((timePercent - arc) / alphaBarArcWidth), 1.0);\n	if ((arc + alphaBarArcWidth) <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.x;\n	}\n	else if (arc <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.y;\n	}\n	else {\n		gl_FragColor = outputColor * colorAlpha.z;\n	}\n}\n";
    }, function(t, e) {
      t.exports = "varying vec2 vTextureCoord;\nuniform float percent;\nuniform sampler2D uSampler;\nvarying vec2 filterCoord;\nuniform vec4 uBoundRect;\nuniform float transition;\nuniform float option;\n#define PI 3.1415926538\nvoid main() {\n	vec4 outputColor = texture2D(uSampler, vTextureCoord);\n	vec2 point = vec2(filterCoord.x - (uBoundRect.z / 2.0), filterCoord.y - (uBoundRect.w / 2.0));\n	vec2 start = vec2(0.0, -1.0);\n	float arc = acos((dot(point.xy, start) / length(point)) / length(start));\n	if ((point.x == 0.0) && (point.y < 0.0)) {\n		arc = 0.0;\n	}\n	if ((point.x == 0.0) && (point.y > 0.0)) {\n		arc = PI;\n	}\n	if (point.x < 0.0) {\n		arc = (2.0 * PI) - arc;\n	}\n	arc = arc == 0.0 ? arc : mod(arc, (2.0 * PI) / option);\n	float totalAlphaBarArcWidth = 0.75;\n	float alphaBarArcWidth = totalAlphaBarArcWidth / option;\n	float timePercent = ((percent * PI) * (2.0 + totalAlphaBarArcWidth)) / option;\n	vec3 colorAlpha = transition > 0.0 ? vec3(1.0, (timePercent - arc) / alphaBarArcWidth, 0.0) : vec3(0.0, 1.0 - ((timePercent - arc) / alphaBarArcWidth), 1.0);\n	if ((arc + alphaBarArcWidth) <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.x;\n	}\n	else if (arc <= timePercent) {\n		gl_FragColor = outputColor * colorAlpha.y;\n	}\n	else {\n		gl_FragColor = outputColor * colorAlpha.z;\n	}\n}\n";
    }, function(t, e, i) {
      var n = i(150);
      t.exports = function(t2, e2) {
        return n(t2, e2);
      };
    }, function(t, e, i) {
      var n = i(24), r = Object.prototype, o = r.hasOwnProperty, s = r.toString, a = n ? n.toStringTag : void 0;
      t.exports = function(t2) {
        var e2 = o.call(t2, a), i2 = t2[a];
        try {
          t2[a] = void 0;
          var n2 = true;
        } catch (t3) {
        }
        var r2 = s.call(t2);
        return n2 && (e2 ? t2[a] = i2 : delete t2[a]), r2;
      };
    }, function(t, e) {
      var i = Object.prototype.toString;
      t.exports = function(t2) {
        return i.call(t2);
      };
    }, function(t, e, i) {
      "use strict";
      (function(t2) {
        var e2 = i(108), n = i(111), r = i.n(n);
        "undefined" == typeof globalThis && ("undefined" != typeof self ? self.globalThis = self : void 0 !== t2 && (t2.globalThis = t2)), globalThis.Promise || (globalThis.Promise = e2.a), Object.assign || (Object.assign = r.a);
        if (Date.now && Date.prototype.getTime || (Date.now = function() {
          return (/* @__PURE__ */ new Date()).getTime();
        }), !globalThis.performance || !globalThis.performance.now) {
          var o = Date.now();
          globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
            return Date.now() - o;
          };
        }
        for (var s = Date.now(), a = ["ms", "moz", "webkit", "o"], l = 0; l < a.length && !globalThis.requestAnimationFrame; ++l) {
          var h = a[l];
          globalThis.requestAnimationFrame = globalThis[h + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[h + "CancelAnimationFrame"] || globalThis[h + "CancelRequestAnimationFrame"];
        }
        globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(t3) {
          if ("function" != typeof t3) throw new TypeError(t3 + "is not a function");
          var e3 = Date.now(), i2 = 16 + s - e3;
          return i2 < 0 && (i2 = 0), s = e3, globalThis.self.setTimeout(function() {
            s = Date.now(), t3(performance.now());
          }, i2);
        }), globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(t3) {
          return clearTimeout(t3);
        }), Math.sign || (Math.sign = function(t3) {
          return 0 === (t3 = Number(t3)) || isNaN(t3) ? t3 : t3 > 0 ? 1 : -1;
        }), Number.isInteger || (Number.isInteger = function(t3) {
          return "number" == typeof t3 && isFinite(t3) && Math.floor(t3) === t3;
        }), globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array), globalThis.Float32Array || (globalThis.Float32Array = Array), globalThis.Uint32Array || (globalThis.Uint32Array = Array), globalThis.Uint16Array || (globalThis.Uint16Array = Array), globalThis.Uint8Array || (globalThis.Uint8Array = Array), globalThis.Int32Array || (globalThis.Int32Array = Array);
      }).call(this, i(17));
    }, function(t, e, i) {
      (function(t2) {
        var n = void 0 !== t2 && t2 || "undefined" != typeof self && self || window, r = Function.prototype.apply;
        function o(t3, e2) {
          this._id = t3, this._clearFn = e2;
        }
        e.setTimeout = function() {
          return new o(r.call(setTimeout, n, arguments), clearTimeout);
        }, e.setInterval = function() {
          return new o(r.call(setInterval, n, arguments), clearInterval);
        }, e.clearTimeout = e.clearInterval = function(t3) {
          t3 && t3.close();
        }, o.prototype.unref = o.prototype.ref = function() {
        }, o.prototype.close = function() {
          this._clearFn.call(n, this._id);
        }, e.enroll = function(t3, e2) {
          clearTimeout(t3._idleTimeoutId), t3._idleTimeout = e2;
        }, e.unenroll = function(t3) {
          clearTimeout(t3._idleTimeoutId), t3._idleTimeout = -1;
        }, e._unrefActive = e.active = function(t3) {
          clearTimeout(t3._idleTimeoutId);
          var e2 = t3._idleTimeout;
          e2 >= 0 && (t3._idleTimeoutId = setTimeout(function() {
            t3._onTimeout && t3._onTimeout();
          }, e2));
        }, i(141), e.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t2 && t2.setImmediate || this && this.setImmediate, e.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t2 && t2.clearImmediate || this && this.clearImmediate;
      }).call(this, i(17));
    }, function(t, e, i) {
      (function(t2, e2) {
        !function(t3, i2) {
          "use strict";
          if (!t3.setImmediate) {
            var n, r, o, s, a, l = 1, h = {}, u = false, c = t3.document, d = Object.getPrototypeOf && Object.getPrototypeOf(t3);
            d = d && d.setTimeout ? d : t3, "[object process]" === {}.toString.call(t3.process) ? n = function(t4) {
              e2.nextTick(function() {
                f(t4);
              });
            } : !function() {
              if (t3.postMessage && !t3.importScripts) {
                var e3 = true, i3 = t3.onmessage;
                return t3.onmessage = function() {
                  e3 = false;
                }, t3.postMessage("", "*"), t3.onmessage = i3, e3;
              }
            }() ? t3.MessageChannel ? ((o = new MessageChannel()).port1.onmessage = function(t4) {
              f(t4.data);
            }, n = function(t4) {
              o.port2.postMessage(t4);
            }) : c && "onreadystatechange" in c.createElement("script") ? (r = c.documentElement, n = function(t4) {
              var e3 = c.createElement("script");
              e3.onreadystatechange = function() {
                f(t4), e3.onreadystatechange = null, r.removeChild(e3), e3 = null;
              }, r.appendChild(e3);
            }) : n = function(t4) {
              setTimeout(f, 0, t4);
            } : (s = "setImmediate$" + Math.random() + "$", a = function(e3) {
              e3.source === t3 && "string" == typeof e3.data && 0 === e3.data.indexOf(s) && f(+e3.data.slice(s.length));
            }, t3.addEventListener ? t3.addEventListener("message", a, false) : t3.attachEvent("onmessage", a), n = function(e3) {
              t3.postMessage(s + e3, "*");
            }), d.setImmediate = function(t4) {
              "function" != typeof t4 && (t4 = new Function("" + t4));
              for (var e3 = new Array(arguments.length - 1), i3 = 0; i3 < e3.length; i3++) e3[i3] = arguments[i3 + 1];
              var r2 = { callback: t4, args: e3 };
              return h[l] = r2, n(l), l++;
            }, d.clearImmediate = p;
          }
          function p(t4) {
            delete h[t4];
          }
          function f(t4) {
            if (u) setTimeout(f, 0, t4);
            else {
              var e3 = h[t4];
              if (e3) {
                u = true;
                try {
                  !function(t5) {
                    var e4 = t5.callback, i3 = t5.args;
                    switch (i3.length) {
                      case 0:
                        e4();
                        break;
                      case 1:
                        e4(i3[0]);
                        break;
                      case 2:
                        e4(i3[0], i3[1]);
                        break;
                      case 3:
                        e4(i3[0], i3[1], i3[2]);
                        break;
                      default:
                        e4.apply(void 0, i3);
                    }
                  }(e3);
                } finally {
                  p(t4), u = false;
                }
              }
            }
          }
        }("undefined" == typeof self ? void 0 === t2 ? this : t2 : self);
      }).call(this, i(17), i(142));
    }, function(t, e) {
      var i, n, r = t.exports = {};
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function s() {
        throw new Error("clearTimeout has not been defined");
      }
      function a(t2) {
        if (i === setTimeout) return setTimeout(t2, 0);
        if ((i === o || !i) && setTimeout) return i = setTimeout, setTimeout(t2, 0);
        try {
          return i(t2, 0);
        } catch (e2) {
          try {
            return i.call(null, t2, 0);
          } catch (e3) {
            return i.call(this, t2, 0);
          }
        }
      }
      !function() {
        try {
          i = "function" == typeof setTimeout ? setTimeout : o;
        } catch (t2) {
          i = o;
        }
        try {
          n = "function" == typeof clearTimeout ? clearTimeout : s;
        } catch (t2) {
          n = s;
        }
      }();
      var l, h = [], u = false, c = -1;
      function d() {
        u && l && (u = false, l.length ? h = l.concat(h) : c = -1, h.length && p());
      }
      function p() {
        if (!u) {
          var t2 = a(d);
          u = true;
          for (var e2 = h.length; e2; ) {
            for (l = h, h = []; ++c < e2; ) l && l[c].run();
            c = -1, e2 = h.length;
          }
          l = null, u = false, function(t3) {
            if (n === clearTimeout) return clearTimeout(t3);
            if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t3);
            try {
              n(t3);
            } catch (e3) {
              try {
                return n.call(null, t3);
              } catch (e4) {
                return n.call(this, t3);
              }
            }
          }(t2);
        }
      }
      function f(t2, e2) {
        this.fun = t2, this.array = e2;
      }
      function m() {
      }
      r.nextTick = function(t2) {
        var e2 = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i2 = 1; i2 < arguments.length; i2++) e2[i2 - 1] = arguments[i2];
        h.push(new f(t2, e2)), 1 !== h.length || u || a(p);
      }, f.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, r.title = "browser", r.browser = true, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = m, r.addListener = m, r.once = m, r.off = m, r.removeListener = m, r.removeAllListeners = m, r.emit = m, r.prependListener = m, r.prependOnceListener = m, r.listeners = function(t2) {
        return [];
      }, r.binding = function(t2) {
        throw new Error("process.binding is not supported");
      }, r.cwd = function() {
        return "/";
      }, r.chdir = function(t2) {
        throw new Error("process.chdir is not supported");
      }, r.umask = function() {
        return 0;
      };
    }, function(t, e, i) {
      (function(t2, n) {
        var r;
        !function(o) {
          e && e.nodeType, t2 && t2.nodeType;
          var s = "object" == typeof n && n;
          s.global !== s && s.window !== s && s.self;
          var a, l = 2147483647, h = /^xn--/, u = /[^\x20-\x7E]/, c = /[\x2E\u3002\uFF0E\uFF61]/g, d = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, p = Math.floor, f = String.fromCharCode;
          function m(t3) {
            throw new RangeError(d[t3]);
          }
          function g(t3, e2) {
            for (var i2 = t3.length, n2 = []; i2--; ) n2[i2] = e2(t3[i2]);
            return n2;
          }
          function v(t3, e2) {
            var i2 = t3.split("@"), n2 = "";
            return i2.length > 1 && (n2 = i2[0] + "@", t3 = i2[1]), n2 + g((t3 = t3.replace(c, ".")).split("."), e2).join(".");
          }
          function _(t3) {
            for (var e2, i2, n2 = [], r2 = 0, o2 = t3.length; r2 < o2; ) (e2 = t3.charCodeAt(r2++)) >= 55296 && e2 <= 56319 && r2 < o2 ? 56320 == (64512 & (i2 = t3.charCodeAt(r2++))) ? n2.push(((1023 & e2) << 10) + (1023 & i2) + 65536) : (n2.push(e2), r2--) : n2.push(e2);
            return n2;
          }
          function y(t3) {
            return g(t3, function(t4) {
              var e2 = "";
              return t4 > 65535 && (e2 += f((t4 -= 65536) >>> 10 & 1023 | 55296), t4 = 56320 | 1023 & t4), e2 += f(t4);
            }).join("");
          }
          function x(t3, e2) {
            return t3 + 22 + 75 * (t3 < 26) - ((0 != e2) << 5);
          }
          function b(t3, e2, i2) {
            var n2 = 0;
            for (t3 = i2 ? p(t3 / 700) : t3 >> 1, t3 += p(t3 / e2); t3 > 455; n2 += 36) t3 = p(t3 / 35);
            return p(n2 + 36 * t3 / (t3 + 38));
          }
          function T(t3) {
            var e2, i2, n2, r2, o2, s2, a2, h2, u2, c2, d2, f2 = [], g2 = t3.length, v2 = 0, _2 = 128, x2 = 72;
            for ((i2 = t3.lastIndexOf("-")) < 0 && (i2 = 0), n2 = 0; n2 < i2; ++n2) t3.charCodeAt(n2) >= 128 && m("not-basic"), f2.push(t3.charCodeAt(n2));
            for (r2 = i2 > 0 ? i2 + 1 : 0; r2 < g2; ) {
              for (o2 = v2, s2 = 1, a2 = 36; r2 >= g2 && m("invalid-input"), ((h2 = (d2 = t3.charCodeAt(r2++)) - 48 < 10 ? d2 - 22 : d2 - 65 < 26 ? d2 - 65 : d2 - 97 < 26 ? d2 - 97 : 36) >= 36 || h2 > p((l - v2) / s2)) && m("overflow"), v2 += h2 * s2, !(h2 < (u2 = a2 <= x2 ? 1 : a2 >= x2 + 26 ? 26 : a2 - x2)); a2 += 36) s2 > p(l / (c2 = 36 - u2)) && m("overflow"), s2 *= c2;
              x2 = b(v2 - o2, e2 = f2.length + 1, 0 == o2), p(v2 / e2) > l - _2 && m("overflow"), _2 += p(v2 / e2), v2 %= e2, f2.splice(v2++, 0, _2);
            }
            return y(f2);
          }
          function E(t3) {
            var e2, i2, n2, r2, o2, s2, a2, h2, u2, c2, d2, g2, v2, y2, T2, E2 = [];
            for (g2 = (t3 = _(t3)).length, e2 = 128, i2 = 0, o2 = 72, s2 = 0; s2 < g2; ++s2) (d2 = t3[s2]) < 128 && E2.push(f(d2));
            for (n2 = r2 = E2.length, r2 && E2.push("-"); n2 < g2; ) {
              for (a2 = l, s2 = 0; s2 < g2; ++s2) (d2 = t3[s2]) >= e2 && d2 < a2 && (a2 = d2);
              for (a2 - e2 > p((l - i2) / (v2 = n2 + 1)) && m("overflow"), i2 += (a2 - e2) * v2, e2 = a2, s2 = 0; s2 < g2; ++s2) if ((d2 = t3[s2]) < e2 && ++i2 > l && m("overflow"), d2 == e2) {
                for (h2 = i2, u2 = 36; !(h2 < (c2 = u2 <= o2 ? 1 : u2 >= o2 + 26 ? 26 : u2 - o2)); u2 += 36) T2 = h2 - c2, y2 = 36 - c2, E2.push(f(x(c2 + T2 % y2, 0))), h2 = p(T2 / y2);
                E2.push(f(x(h2, 0))), o2 = b(i2, v2, n2 == r2), i2 = 0, ++n2;
              }
              ++i2, ++e2;
            }
            return E2.join("");
          }
          a = { version: "1.4.1", ucs2: { decode: _, encode: y }, decode: T, encode: E, toASCII: function(t3) {
            return v(t3, function(t4) {
              return u.test(t4) ? "xn--" + E(t4) : t4;
            });
          }, toUnicode: function(t3) {
            return v(t3, function(t4) {
              return h.test(t4) ? T(t4.slice(4).toLowerCase()) : t4;
            });
          } }, void 0 === (r = function() {
            return a;
          }.call(e, i, e, t2)) || (t2.exports = r);
        }();
      }).call(this, i(25)(t), i(17));
    }, function(t, e, i) {
      "use strict";
      t.exports = { isString: function(t2) {
        return "string" == typeof t2;
      }, isObject: function(t2) {
        return "object" == typeof t2 && null !== t2;
      }, isNull: function(t2) {
        return null === t2;
      }, isNullOrUndefined: function(t2) {
        return null == t2;
      } };
    }, function(t, e, i) {
      "use strict";
      e.decode = e.parse = i(146), e.encode = e.stringify = i(147);
    }, function(t, e, i) {
      "use strict";
      function n(t2, e2) {
        return Object.prototype.hasOwnProperty.call(t2, e2);
      }
      t.exports = function(t2, e2, i2, o) {
        e2 = e2 || "&", i2 = i2 || "=";
        var s = {};
        if ("string" != typeof t2 || 0 === t2.length) return s;
        var a = /\+/g;
        t2 = t2.split(e2);
        var l = 1e3;
        o && "number" == typeof o.maxKeys && (l = o.maxKeys);
        var h = t2.length;
        l > 0 && h > l && (h = l);
        for (var u = 0; u < h; ++u) {
          var c, d, p, f, m = t2[u].replace(a, "%20"), g = m.indexOf(i2);
          g >= 0 ? (c = m.substr(0, g), d = m.substr(g + 1)) : (c = m, d = ""), p = decodeURIComponent(c), f = decodeURIComponent(d), n(s, p) ? r(s[p]) ? s[p].push(f) : s[p] = [s[p], f] : s[p] = f;
        }
        return s;
      };
      var r = Array.isArray || function(t2) {
        return "[object Array]" === Object.prototype.toString.call(t2);
      };
    }, function(t, e, i) {
      "use strict";
      var n = function(t2) {
        switch (typeof t2) {
          case "string":
            return t2;
          case "boolean":
            return t2 ? "true" : "false";
          case "number":
            return isFinite(t2) ? t2 : "";
          default:
            return "";
        }
      };
      t.exports = function(t2, e2, i2, a) {
        return e2 = e2 || "&", i2 = i2 || "=", null === t2 && (t2 = void 0), "object" == typeof t2 ? o(s(t2), function(s2) {
          var a2 = encodeURIComponent(n(s2)) + i2;
          return r(t2[s2]) ? o(t2[s2], function(t3) {
            return a2 + encodeURIComponent(n(t3));
          }).join(e2) : a2 + encodeURIComponent(n(t2[s2]));
        }).join(e2) : a ? encodeURIComponent(n(a)) + i2 + encodeURIComponent(n(t2)) : "";
      };
      var r = Array.isArray || function(t2) {
        return "[object Array]" === Object.prototype.toString.call(t2);
      };
      function o(t2, e2) {
        if (t2.map) return t2.map(e2);
        for (var i2 = [], n2 = 0; n2 < t2.length; n2++) i2.push(e2(t2[n2], n2));
        return i2;
      }
      var s = Object.keys || function(t2) {
        var e2 = [];
        for (var i2 in t2) Object.prototype.hasOwnProperty.call(t2, i2) && e2.push(i2);
        return e2;
      };
    }, function(t, e) {
      var i = function() {
      };
      i.prototype = { fit: function(t2) {
        var e2, i2, n, r, o = t2.length, s = o > 0 ? t2[0].width : 0, a = o > 0 ? t2[0].height : 0;
        for (this.root = { x: 0, y: 0, width: s, height: a }, e2 = 0; e2 < o; e2++) n = t2[e2], (i2 = this.findNode(this.root, n.width, n.height)) ? (r = this.splitNode(i2, n.width, n.height), n.x = r.x, n.y = r.y) : (r = this.growNode(n.width, n.height), n.x = r.x, n.y = r.y);
      }, findNode: function(t2, e2, i2) {
        return t2.used ? this.findNode(t2.right, e2, i2) || this.findNode(t2.down, e2, i2) : e2 <= t2.width && i2 <= t2.height ? t2 : null;
      }, splitNode: function(t2, e2, i2) {
        return t2.used = true, t2.down = { x: t2.x, y: t2.y + i2, width: t2.width, height: t2.height - i2 }, t2.right = { x: t2.x + e2, y: t2.y, width: t2.width - e2, height: i2 }, t2;
      }, growNode: function(t2, e2) {
        var i2 = t2 <= this.root.width, n = e2 <= this.root.height, r = n && this.root.height >= this.root.width + t2, o = i2 && this.root.width >= this.root.height + e2;
        return r ? this.growRight(t2, e2) : o ? this.growDown(t2, e2) : n ? this.growRight(t2, e2) : i2 ? this.growDown(t2, e2) : null;
      }, growRight: function(t2, e2) {
        var i2;
        return this.root = { used: true, x: 0, y: 0, width: this.root.width + t2, height: this.root.height, down: this.root, right: { x: this.root.width, y: 0, width: t2, height: this.root.height } }, (i2 = this.findNode(this.root, t2, e2)) ? this.splitNode(i2, t2, e2) : null;
      }, growDown: function(t2, e2) {
        var i2;
        return this.root = { used: true, x: 0, y: 0, width: this.root.width, height: this.root.height + e2, down: { x: 0, y: this.root.height, width: this.root.width, height: e2 }, right: this.root }, (i2 = this.findNode(this.root, t2, e2)) ? this.splitNode(i2, t2, e2) : null;
      } }, t.exports = i;
    }, function(t, e) {
      (function(e2) {
        t.exports = e2;
      }).call(this, {});
    }, function(t, e, i) {
      var n = i(151), r = i(15);
      t.exports = function t2(e2, i2, o, s, a) {
        return e2 === i2 || (null == e2 || null == i2 || !r(e2) && !r(i2) ? e2 != e2 && i2 != i2 : n(e2, i2, o, s, t2, a));
      };
    }, function(t, e, i) {
      var n = i(54), r = i(57), o = i(183), s = i(186), a = i(31), l = i(30), h = i(40), u = i(64), c = "[object Object]", d = Object.prototype.hasOwnProperty;
      t.exports = function(t2, e2, i2, p, f, m) {
        var g = l(t2), v = l(e2), _ = g ? "[object Array]" : a(t2), y = v ? "[object Array]" : a(e2), x = (_ = "[object Arguments]" == _ ? c : _) == c, b = (y = "[object Arguments]" == y ? c : y) == c, T = _ == y;
        if (T && h(t2)) {
          if (!h(e2)) return false;
          g = true, x = false;
        }
        if (T && !x) return m || (m = new n()), g || u(t2) ? r(t2, e2, i2, p, f, m) : o(t2, e2, _, i2, p, f, m);
        if (!(1 & i2)) {
          var E = x && d.call(t2, "__wrapped__"), S = b && d.call(e2, "__wrapped__");
          if (E || S) {
            var w = E ? t2.value() : t2, A = S ? e2.value() : e2;
            return m || (m = new n()), f(w, A, i2, p, m);
          }
        }
        return !!T && (m || (m = new n()), s(t2, e2, i2, p, f, m));
      };
    }, function(t, e) {
      t.exports = function() {
        this.__data__ = [], this.size = 0;
      };
    }, function(t, e, i) {
      var n = i(27), r = Array.prototype.splice;
      t.exports = function(t2) {
        var e2 = this.__data__, i2 = n(e2, t2);
        return !(i2 < 0) && (i2 == e2.length - 1 ? e2.pop() : r.call(e2, i2, 1), --this.size, true);
      };
    }, function(t, e, i) {
      var n = i(27);
      t.exports = function(t2) {
        var e2 = this.__data__, i2 = n(e2, t2);
        return i2 < 0 ? void 0 : e2[i2][1];
      };
    }, function(t, e, i) {
      var n = i(27);
      t.exports = function(t2) {
        return n(this.__data__, t2) > -1;
      };
    }, function(t, e, i) {
      var n = i(27);
      t.exports = function(t2, e2) {
        var i2 = this.__data__, r = n(i2, t2);
        return r < 0 ? (++this.size, i2.push([t2, e2])) : i2[r][1] = e2, this;
      };
    }, function(t, e, i) {
      var n = i(26);
      t.exports = function() {
        this.__data__ = new n(), this.size = 0;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = this.__data__, i = e2.delete(t2);
        return this.size = e2.size, i;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        return this.__data__.get(t2);
      };
    }, function(t, e) {
      t.exports = function(t2) {
        return this.__data__.has(t2);
      };
    }, function(t, e, i) {
      var n = i(26), r = i(37), o = i(56);
      t.exports = function(t2, e2) {
        var i2 = this.__data__;
        if (i2 instanceof n) {
          var s = i2.__data__;
          if (!r || s.length < 199) return s.push([t2, e2]), this.size = ++i2.size, this;
          i2 = this.__data__ = new o(s);
        }
        return i2.set(t2, e2), this.size = i2.size, this;
      };
    }, function(t, e, i) {
      var n = i(33), r = i(163), o = i(21), s = i(55), a = /^\[object .+?Constructor\]$/, l = Function.prototype, h = Object.prototype, u = l.toString, c = h.hasOwnProperty, d = RegExp("^" + u.call(c).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      t.exports = function(t2) {
        return !(!o(t2) || r(t2)) && (n(t2) ? d : a).test(s(t2));
      };
    }, function(t, e, i) {
      var n, r = i(164), o = (n = /[^.]+$/.exec(r && r.keys && r.keys.IE_PROTO || "")) ? "Symbol(src)_1." + n : "";
      t.exports = function(t2) {
        return !!o && o in t2;
      };
    }, function(t, e, i) {
      var n = i(14)["__core-js_shared__"];
      t.exports = n;
    }, function(t, e) {
      t.exports = function(t2, e2) {
        return null == t2 ? void 0 : t2[e2];
      };
    }, function(t, e, i) {
      var n = i(167), r = i(26), o = i(37);
      t.exports = function() {
        this.size = 0, this.__data__ = { hash: new n(), map: new (o || r)(), string: new n() };
      };
    }, function(t, e, i) {
      var n = i(168), r = i(169), o = i(170), s = i(171), a = i(172);
      function l(t2) {
        var e2 = -1, i2 = null == t2 ? 0 : t2.length;
        for (this.clear(); ++e2 < i2; ) {
          var n2 = t2[e2];
          this.set(n2[0], n2[1]);
        }
      }
      l.prototype.clear = n, l.prototype.delete = r, l.prototype.get = o, l.prototype.has = s, l.prototype.set = a, t.exports = l;
    }, function(t, e, i) {
      var n = i(28);
      t.exports = function() {
        this.__data__ = n ? n(null) : {}, this.size = 0;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = this.has(t2) && delete this.__data__[t2];
        return this.size -= e2 ? 1 : 0, e2;
      };
    }, function(t, e, i) {
      var n = i(28), r = Object.prototype.hasOwnProperty;
      t.exports = function(t2) {
        var e2 = this.__data__;
        if (n) {
          var i2 = e2[t2];
          return "__lodash_hash_undefined__" === i2 ? void 0 : i2;
        }
        return r.call(e2, t2) ? e2[t2] : void 0;
      };
    }, function(t, e, i) {
      var n = i(28), r = Object.prototype.hasOwnProperty;
      t.exports = function(t2) {
        var e2 = this.__data__;
        return n ? void 0 !== e2[t2] : r.call(e2, t2);
      };
    }, function(t, e, i) {
      var n = i(28);
      t.exports = function(t2, e2) {
        var i2 = this.__data__;
        return this.size += this.has(t2) ? 0 : 1, i2[t2] = n && void 0 === e2 ? "__lodash_hash_undefined__" : e2, this;
      };
    }, function(t, e, i) {
      var n = i(29);
      t.exports = function(t2) {
        var e2 = n(this, t2).delete(t2);
        return this.size -= e2 ? 1 : 0, e2;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = typeof t2;
        return "string" == e2 || "number" == e2 || "symbol" == e2 || "boolean" == e2 ? "__proto__" !== t2 : null === t2;
      };
    }, function(t, e, i) {
      var n = i(29);
      t.exports = function(t2) {
        return n(this, t2).get(t2);
      };
    }, function(t, e, i) {
      var n = i(29);
      t.exports = function(t2) {
        return n(this, t2).has(t2);
      };
    }, function(t, e, i) {
      var n = i(29);
      t.exports = function(t2, e2) {
        var i2 = n(this, t2), r = i2.size;
        return i2.set(t2, e2), this.size += i2.size == r ? 0 : 1, this;
      };
    }, function(t, e, i) {
      var n = i(56), r = i(179), o = i(180);
      function s(t2) {
        var e2 = -1, i2 = null == t2 ? 0 : t2.length;
        for (this.__data__ = new n(); ++e2 < i2; ) this.add(t2[e2]);
      }
      s.prototype.add = s.prototype.push = r, s.prototype.has = o, t.exports = s;
    }, function(t, e) {
      t.exports = function(t2) {
        return this.__data__.set(t2, "__lodash_hash_undefined__"), this;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        return this.__data__.has(t2);
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        for (var i = -1, n = null == t2 ? 0 : t2.length; ++i < n; ) if (e2(t2[i], i, t2)) return true;
        return false;
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        return t2.has(e2);
      };
    }, function(t, e, i) {
      var n = i(24), r = i(58), o = i(36), s = i(57), a = i(184), l = i(185), h = n ? n.prototype : void 0, u = h ? h.valueOf : void 0;
      t.exports = function(t2, e2, i2, n2, h2, c, d) {
        switch (i2) {
          case "[object DataView]":
            if (t2.byteLength != e2.byteLength || t2.byteOffset != e2.byteOffset) return false;
            t2 = t2.buffer, e2 = e2.buffer;
          case "[object ArrayBuffer]":
            return !(t2.byteLength != e2.byteLength || !c(new r(t2), new r(e2)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return o(+t2, +e2);
          case "[object Error]":
            return t2.name == e2.name && t2.message == e2.message;
          case "[object RegExp]":
          case "[object String]":
            return t2 == e2 + "";
          case "[object Map]":
            var p = a;
          case "[object Set]":
            var f = 1 & n2;
            if (p || (p = l), t2.size != e2.size && !f) return false;
            var m = d.get(t2);
            if (m) return m == e2;
            n2 |= 2, d.set(t2, e2);
            var g = s(p(t2), p(e2), n2, h2, c, d);
            return d.delete(t2), g;
          case "[object Symbol]":
            if (u) return u.call(t2) == u.call(e2);
        }
        return false;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = -1, i = Array(t2.size);
        return t2.forEach(function(t3, n) {
          i[++e2] = [n, t3];
        }), i;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = -1, i = Array(t2.size);
        return t2.forEach(function(t3) {
          i[++e2] = t3;
        }), i;
      };
    }, function(t, e, i) {
      var n = i(59), r = Object.prototype.hasOwnProperty;
      t.exports = function(t2, e2, i2, o, s, a) {
        var l = 1 & i2, h = n(t2), u = h.length;
        if (u != n(e2).length && !l) return false;
        for (var c = u; c--; ) {
          var d = h[c];
          if (!(l ? d in e2 : r.call(e2, d))) return false;
        }
        var p = a.get(t2), f = a.get(e2);
        if (p && f) return p == e2 && f == t2;
        var m = true;
        a.set(t2, e2), a.set(e2, t2);
        for (var g = l; ++c < u; ) {
          var v = t2[d = h[c]], _ = e2[d];
          if (o) var y = l ? o(_, v, d, e2, t2, a) : o(v, _, d, t2, e2, a);
          if (!(void 0 === y ? v === _ || s(v, _, i2, o, a) : y)) {
            m = false;
            break;
          }
          g || (g = "constructor" == d);
        }
        if (m && !g) {
          var x = t2.constructor, b = e2.constructor;
          x == b || !("constructor" in t2) || !("constructor" in e2) || "function" == typeof x && x instanceof x && "function" == typeof b && b instanceof b || (m = false);
        }
        return a.delete(t2), a.delete(e2), m;
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        for (var i = -1, n = null == t2 ? 0 : t2.length, r = 0, o = []; ++i < n; ) {
          var s = t2[i];
          e2(s, i, t2) && (o[r++] = s);
        }
        return o;
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        for (var i = -1, n = Array(t2); ++i < t2; ) n[i] = e2(i);
        return n;
      };
    }, function(t, e, i) {
      var n = i(190), r = i(15), o = Object.prototype, s = o.hasOwnProperty, a = o.propertyIsEnumerable, l = n(/* @__PURE__ */ function() {
        return arguments;
      }()) ? n : function(t2) {
        return r(t2) && s.call(t2, "callee") && !a.call(t2, "callee");
      };
      t.exports = l;
    }, function(t, e, i) {
      var n = i(20), r = i(15);
      t.exports = function(t2) {
        return r(t2) && "[object Arguments]" == n(t2);
      };
    }, function(t, e) {
      t.exports = function() {
        return false;
      };
    }, function(t, e) {
      var i = /^(?:0|[1-9]\d*)$/;
      t.exports = function(t2, e2) {
        var n = typeof t2;
        return !!(e2 = null == e2 ? 9007199254740991 : e2) && ("number" == n || "symbol" != n && i.test(t2)) && t2 > -1 && t2 % 1 == 0 && t2 < e2;
      };
    }, function(t, e, i) {
      var n = i(20), r = i(65), o = i(15), s = {};
      s["[object Float32Array]"] = s["[object Float64Array]"] = s["[object Int8Array]"] = s["[object Int16Array]"] = s["[object Int32Array]"] = s["[object Uint8Array]"] = s["[object Uint8ClampedArray]"] = s["[object Uint16Array]"] = s["[object Uint32Array]"] = true, s["[object Arguments]"] = s["[object Array]"] = s["[object ArrayBuffer]"] = s["[object Boolean]"] = s["[object DataView]"] = s["[object Date]"] = s["[object Error]"] = s["[object Function]"] = s["[object Map]"] = s["[object Number]"] = s["[object Object]"] = s["[object RegExp]"] = s["[object Set]"] = s["[object String]"] = s["[object WeakMap]"] = false, t.exports = function(t2) {
        return o(t2) && r(t2.length) && !!s[n(t2)];
      };
    }, function(t, e, i) {
      var n = i(43), r = i(195), o = Object.prototype.hasOwnProperty;
      t.exports = function(t2) {
        if (!n(t2)) return r(t2);
        var e2 = [];
        for (var i2 in Object(t2)) o.call(t2, i2) && "constructor" != i2 && e2.push(i2);
        return e2;
      };
    }, function(t, e, i) {
      var n = i(66)(Object.keys, Object);
      t.exports = n;
    }, function(t, e, i) {
      var n = i(22)(i(14), "DataView");
      t.exports = n;
    }, function(t, e, i) {
      var n = i(22)(i(14), "Promise");
      t.exports = n;
    }, function(t, e, i) {
      var n = i(22)(i(14), "Set");
      t.exports = n;
    }, function(t, e, i) {
      var n = i(22)(i(14), "WeakMap");
      t.exports = n;
    }, function(t, e, i) {
      var n = i(14);
      t.exports = function() {
        return n.Date.now();
      };
    }, function(t, e, i) {
      var n = i(202), r = i(21), o = i(204), s = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, l = /^0o[0-7]+$/i, h = parseInt;
      t.exports = function(t2) {
        if ("number" == typeof t2) return t2;
        if (o(t2)) return NaN;
        if (r(t2)) {
          var e2 = "function" == typeof t2.valueOf ? t2.valueOf() : t2;
          t2 = r(e2) ? e2 + "" : e2;
        }
        if ("string" != typeof t2) return 0 === t2 ? t2 : +t2;
        t2 = n(t2);
        var i2 = a.test(t2);
        return i2 || l.test(t2) ? h(t2.slice(2), i2 ? 2 : 8) : s.test(t2) ? NaN : +t2;
      };
    }, function(t, e, i) {
      var n = i(203), r = /^\s+/;
      t.exports = function(t2) {
        return t2 ? t2.slice(0, n(t2) + 1).replace(r, "") : t2;
      };
    }, function(t, e) {
      var i = /\s/;
      t.exports = function(t2) {
        for (var e2 = t2.length; e2-- && i.test(t2.charAt(e2)); ) ;
        return e2;
      };
    }, function(t, e, i) {
      var n = i(20), r = i(15);
      t.exports = function(t2) {
        return "symbol" == typeof t2 || r(t2) && "[object Symbol]" == n(t2);
      };
    }, function(t, e, i) {
      var n = i(54), r = i(206), o = i(68), s = i(208), a = i(209), l = i(212), h = i(213), u = i(214), c = i(215), d = i(59), p = i(216), f = i(31), m = i(217), g = i(218), v = i(223), _ = i(30), y = i(40), x = i(225), b = i(21), T = i(227), E = i(39), S = i(44), w = {};
      w["[object Arguments]"] = w["[object Array]"] = w["[object ArrayBuffer]"] = w["[object DataView]"] = w["[object Boolean]"] = w["[object Date]"] = w["[object Float32Array]"] = w["[object Float64Array]"] = w["[object Int8Array]"] = w["[object Int16Array]"] = w["[object Int32Array]"] = w["[object Map]"] = w["[object Number]"] = w["[object Object]"] = w["[object RegExp]"] = w["[object Set]"] = w["[object String]"] = w["[object Symbol]"] = w["[object Uint8Array]"] = w["[object Uint8ClampedArray]"] = w["[object Uint16Array]"] = w["[object Uint32Array]"] = true, w["[object Error]"] = w["[object Function]"] = w["[object WeakMap]"] = false, t.exports = function t2(e2, i2, A, M, C, R) {
        var I, P = 1 & i2, O = 2 & i2, N = 4 & i2;
        if (A && (I = C ? A(e2, M, C, R) : A(e2)), void 0 !== I) return I;
        if (!b(e2)) return e2;
        var L = _(e2);
        if (L) {
          if (I = m(e2), !P) return h(e2, I);
        } else {
          var D = f(e2), F = "[object Function]" == D || "[object GeneratorFunction]" == D;
          if (y(e2)) return l(e2, P);
          if ("[object Object]" == D || "[object Arguments]" == D || F && !C) {
            if (I = O || F ? {} : v(e2), !P) return O ? c(e2, a(I, e2)) : u(e2, s(I, e2));
          } else {
            if (!w[D]) return C ? e2 : {};
            I = g(e2, D, P);
          }
        }
        R || (R = new n());
        var B = R.get(e2);
        if (B) return B;
        R.set(e2, I), T(e2) ? e2.forEach(function(n2) {
          I.add(t2(n2, i2, A, n2, e2, R));
        }) : x(e2) && e2.forEach(function(n2, r2) {
          I.set(r2, t2(n2, i2, A, r2, e2, R));
        });
        var U = L ? void 0 : (N ? O ? p : d : O ? S : E)(e2);
        return r(U || e2, function(n2, r2) {
          U && (n2 = e2[r2 = n2]), o(I, r2, t2(n2, i2, A, r2, e2, R));
        }), I;
      };
    }, function(t, e) {
      t.exports = function(t2, e2) {
        for (var i = -1, n = null == t2 ? 0 : t2.length; ++i < n && false !== e2(t2[i], i, t2); ) ;
        return t2;
      };
    }, function(t, e, i) {
      var n = i(22), r = function() {
        try {
          var t2 = n(Object, "defineProperty");
          return t2({}, "", {}), t2;
        } catch (t3) {
        }
      }();
      t.exports = r;
    }, function(t, e, i) {
      var n = i(32), r = i(39);
      t.exports = function(t2, e2) {
        return t2 && n(e2, r(e2), t2);
      };
    }, function(t, e, i) {
      var n = i(32), r = i(44);
      t.exports = function(t2, e2) {
        return t2 && n(e2, r(e2), t2);
      };
    }, function(t, e, i) {
      var n = i(21), r = i(43), o = i(211), s = Object.prototype.hasOwnProperty;
      t.exports = function(t2) {
        if (!n(t2)) return o(t2);
        var e2 = r(t2), i2 = [];
        for (var a in t2) ("constructor" != a || !e2 && s.call(t2, a)) && i2.push(a);
        return i2;
      };
    }, function(t, e) {
      t.exports = function(t2) {
        var e2 = [];
        if (null != t2) for (var i in Object(t2)) e2.push(i);
        return e2;
      };
    }, function(t, e, i) {
      (function(t2) {
        var n = i(14), r = e && !e.nodeType && e, o = r && "object" == typeof t2 && t2 && !t2.nodeType && t2, s = o && o.exports === r ? n.Buffer : void 0, a = s ? s.allocUnsafe : void 0;
        t2.exports = function(t3, e2) {
          if (e2) return t3.slice();
          var i2 = t3.length, n2 = a ? a(i2) : new t3.constructor(i2);
          return t3.copy(n2), n2;
        };
      }).call(this, i(25)(t));
    }, function(t, e) {
      t.exports = function(t2, e2) {
        var i = -1, n = t2.length;
        for (e2 || (e2 = Array(n)); ++i < n; ) e2[i] = t2[i];
        return e2;
      };
    }, function(t, e, i) {
      var n = i(32), r = i(38);
      t.exports = function(t2, e2) {
        return n(t2, r(t2), e2);
      };
    }, function(t, e, i) {
      var n = i(32), r = i(70);
      t.exports = function(t2, e2) {
        return n(t2, r(t2), e2);
      };
    }, function(t, e, i) {
      var n = i(60), r = i(70), o = i(44);
      t.exports = function(t2) {
        return n(t2, o, r);
      };
    }, function(t, e) {
      var i = Object.prototype.hasOwnProperty;
      t.exports = function(t2) {
        var e2 = t2.length, n = new t2.constructor(e2);
        return e2 && "string" == typeof t2[0] && i.call(t2, "index") && (n.index = t2.index, n.input = t2.input), n;
      };
    }, function(t, e, i) {
      var n = i(45), r = i(219), o = i(220), s = i(221), a = i(222);
      t.exports = function(t2, e2, i2) {
        var l = t2.constructor;
        switch (e2) {
          case "[object ArrayBuffer]":
            return n(t2);
          case "[object Boolean]":
          case "[object Date]":
            return new l(+t2);
          case "[object DataView]":
            return r(t2, i2);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return a(t2, i2);
          case "[object Map]":
            return new l();
          case "[object Number]":
          case "[object String]":
            return new l(t2);
          case "[object RegExp]":
            return o(t2);
          case "[object Set]":
            return new l();
          case "[object Symbol]":
            return s(t2);
        }
      };
    }, function(t, e, i) {
      var n = i(45);
      t.exports = function(t2, e2) {
        var i2 = e2 ? n(t2.buffer) : t2.buffer;
        return new t2.constructor(i2, t2.byteOffset, t2.byteLength);
      };
    }, function(t, e) {
      var i = /\w*$/;
      t.exports = function(t2) {
        var e2 = new t2.constructor(t2.source, i.exec(t2));
        return e2.lastIndex = t2.lastIndex, e2;
      };
    }, function(t, e, i) {
      var n = i(24), r = n ? n.prototype : void 0, o = r ? r.valueOf : void 0;
      t.exports = function(t2) {
        return o ? Object(o.call(t2)) : {};
      };
    }, function(t, e, i) {
      var n = i(45);
      t.exports = function(t2, e2) {
        var i2 = e2 ? n(t2.buffer) : t2.buffer;
        return new t2.constructor(i2, t2.byteOffset, t2.length);
      };
    }, function(t, e, i) {
      var n = i(224), r = i(71), o = i(43);
      t.exports = function(t2) {
        return "function" != typeof t2.constructor || o(t2) ? {} : n(r(t2));
      };
    }, function(t, e, i) {
      var n = i(21), r = Object.create, o = /* @__PURE__ */ function() {
        function t2() {
        }
        return function(e2) {
          if (!n(e2)) return {};
          if (r) return r(e2);
          t2.prototype = e2;
          var i2 = new t2();
          return t2.prototype = void 0, i2;
        };
      }();
      t.exports = o;
    }, function(t, e, i) {
      var n = i(226), r = i(41), o = i(42), s = o && o.isMap, a = s ? r(s) : n;
      t.exports = a;
    }, function(t, e, i) {
      var n = i(31), r = i(15);
      t.exports = function(t2) {
        return r(t2) && "[object Map]" == n(t2);
      };
    }, function(t, e, i) {
      var n = i(228), r = i(41), o = i(42), s = o && o.isSet, a = s ? r(s) : n;
      t.exports = a;
    }, function(t, e, i) {
      var n = i(31), r = i(15);
      t.exports = function(t2) {
        return r(t2) && "[object Set]" == n(t2);
      };
    }, function(t, e, i) {
      "use strict";
      i.r(e), i.d(e, "delay", function() {
        return dT;
      }), i.d(e, "waitUntil", function() {
        return pT;
      }), i.d(e, "SLIDE_EVENTS", function() {
        return fT;
      }), i.d(e, "Slide", function() {
        return _T;
      });
      const n = [];
      for (let t2 = 0; t2 < 256; t2++) n[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
      Math.PI, Math.PI;
      function r() {
        const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
        return (n[255 & t2] + n[t2 >> 8 & 255] + n[t2 >> 16 & 255] + n[t2 >> 24 & 255] + "-" + n[255 & e2] + n[e2 >> 8 & 255] + "-" + n[e2 >> 16 & 15 | 64] + n[e2 >> 24 & 255] + "-" + n[63 & i2 | 128] + n[i2 >> 8 & 255] + "-" + n[i2 >> 16 & 255] + n[i2 >> 24 & 255] + n[255 & r2] + n[r2 >> 8 & 255] + n[r2 >> 16 & 255] + n[r2 >> 24 & 255]).toUpperCase();
      }
      var o = i(23);
      class s {
        addEventListener(t2, e2) {
          void 0 === this._listeners && (this._listeners = {});
          const i2 = this._listeners;
          void 0 === i2[t2] && (i2[t2] = []), -1 === i2[t2].indexOf(e2) && i2[t2].push(e2);
        }
        hasEventListener(t2, e2) {
          if (void 0 === this._listeners) return false;
          const i2 = this._listeners;
          return void 0 !== i2[t2] && -1 !== i2[t2].indexOf(e2);
        }
        removeEventListener(t2, e2) {
          if (void 0 === this._listeners) return;
          const i2 = this._listeners[t2];
          if (void 0 !== i2) {
            const t3 = i2.indexOf(e2);
            -1 !== t3 && i2.splice(t3, 1);
          }
        }
        dispatchEvent(t2) {
          if (void 0 === this._listeners) return;
          const e2 = this._listeners[t2.type];
          if (void 0 !== e2) {
            t2.target = this;
            const i2 = e2.slice(0);
            for (let e3 = 0, n2 = i2.length; e3 < n2; e3++) i2[e3].call(this, t2);
            t2.target = null;
          }
        }
      }
      const a = [];
      for (let t2 = 0; t2 < 256; t2++) a[t2] = (t2 < 16 ? "0" : "") + t2.toString(16);
      const l = Math.PI / 180, h = 180 / Math.PI;
      function u() {
        const t2 = 4294967295 * Math.random() | 0, e2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0;
        return (a[255 & t2] + a[t2 >> 8 & 255] + a[t2 >> 16 & 255] + a[t2 >> 24 & 255] + "-" + a[255 & e2] + a[e2 >> 8 & 255] + "-" + a[e2 >> 16 & 15 | 64] + a[e2 >> 24 & 255] + "-" + a[63 & i2 | 128] + a[i2 >> 8 & 255] + "-" + a[i2 >> 16 & 255] + a[i2 >> 24 & 255] + a[255 & n2] + a[n2 >> 8 & 255] + a[n2 >> 16 & 255] + a[n2 >> 24 & 255]).toUpperCase();
      }
      function c(t2, e2, i2) {
        return Math.max(e2, Math.min(i2, t2));
      }
      function d(t2, e2) {
        return (t2 % e2 + e2) % e2;
      }
      function p(t2, e2, i2) {
        return (1 - i2) * t2 + i2 * e2;
      }
      function f(t2) {
        return 0 == (t2 & t2 - 1) && 0 !== t2;
      }
      function m(t2) {
        return Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
      }
      class g {
        constructor(t2 = 0, e2 = 0) {
          this.x = t2, this.y = e2;
        }
        get width() {
          return this.x;
        }
        set width(t2) {
          this.x = t2;
        }
        get height() {
          return this.y;
        }
        set height(t2) {
          this.y = t2;
        }
        set(t2, e2) {
          return this.x = t2, this.y = e2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this;
        }
        multiply(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this;
        }
        divide(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        applyMatrix3(t2) {
          const e2 = this.x, i2 = this.y, n2 = t2.elements;
          return this.x = n2[0] * e2 + n2[3] * i2 + n2[6], this.y = n2[1] * e2 + n2[4] * i2 + n2[7], this;
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this;
        }
        clampLength(t2, e2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y;
        }
        cross(t2) {
          return this.x * t2.y - this.y * t2.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(t2) {
          return Math.sqrt(this.distanceToSquared(t2));
        }
        distanceToSquared(t2) {
          const e2 = this.x - t2.x, i2 = this.y - t2.y;
          return e2 * e2 + i2 * i2;
        }
        manhattanDistanceTo(t2) {
          return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this;
        }
        lerpVectors(t2, e2, i2) {
          return this.x = t2.x + (e2.x - t2.x) * i2, this.y = t2.y + (e2.y - t2.y) * i2, this;
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2;
        }
        fromBufferAttribute(t2, e2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this;
        }
        rotateAround(t2, e2) {
          const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = this.x - t2.x, o2 = this.y - t2.y;
          return this.x = r2 * i2 - o2 * n2 + t2.x, this.y = r2 * n2 + o2 * i2 + t2.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
      }
      g.prototype.isVector2 = true;
      class v {
        constructor() {
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
        set(t2, e2, i2, n2, r2, o2, s2, a2, l2) {
          const h2 = this.elements;
          return h2[0] = t2, h2[1] = n2, h2[2] = s2, h2[3] = e2, h2[4] = r2, h2[5] = a2, h2[6] = i2, h2[7] = o2, h2[8] = l2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t2) {
          const e2 = this.elements, i2 = t2.elements;
          return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], this;
        }
        extractBasis(t2, e2, i2) {
          return t2.setFromMatrix3Column(this, 0), e2.setFromMatrix3Column(this, 1), i2.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(t2) {
          const e2 = t2.elements;
          return this.set(e2[0], e2[4], e2[8], e2[1], e2[5], e2[9], e2[2], e2[6], e2[10]), this;
        }
        multiply(t2) {
          return this.multiplyMatrices(this, t2);
        }
        premultiply(t2) {
          return this.multiplyMatrices(t2, this);
        }
        multiplyMatrices(t2, e2) {
          const i2 = t2.elements, n2 = e2.elements, r2 = this.elements, o2 = i2[0], s2 = i2[3], a2 = i2[6], l2 = i2[1], h2 = i2[4], u2 = i2[7], c2 = i2[2], d2 = i2[5], p2 = i2[8], f2 = n2[0], m2 = n2[3], g2 = n2[6], v2 = n2[1], _2 = n2[4], y2 = n2[7], x2 = n2[2], b2 = n2[5], T2 = n2[8];
          return r2[0] = o2 * f2 + s2 * v2 + a2 * x2, r2[3] = o2 * m2 + s2 * _2 + a2 * b2, r2[6] = o2 * g2 + s2 * y2 + a2 * T2, r2[1] = l2 * f2 + h2 * v2 + u2 * x2, r2[4] = l2 * m2 + h2 * _2 + u2 * b2, r2[7] = l2 * g2 + h2 * y2 + u2 * T2, r2[2] = c2 * f2 + d2 * v2 + p2 * x2, r2[5] = c2 * m2 + d2 * _2 + p2 * b2, r2[8] = c2 * g2 + d2 * y2 + p2 * T2, this;
        }
        multiplyScalar(t2) {
          const e2 = this.elements;
          return e2[0] *= t2, e2[3] *= t2, e2[6] *= t2, e2[1] *= t2, e2[4] *= t2, e2[7] *= t2, e2[2] *= t2, e2[5] *= t2, e2[8] *= t2, this;
        }
        determinant() {
          const t2 = this.elements, e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], h2 = t2[8];
          return e2 * o2 * h2 - e2 * s2 * l2 - i2 * r2 * h2 + i2 * s2 * a2 + n2 * r2 * l2 - n2 * o2 * a2;
        }
        invert() {
          const t2 = this.elements, e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], h2 = t2[8], u2 = h2 * o2 - s2 * l2, c2 = s2 * a2 - h2 * r2, d2 = l2 * r2 - o2 * a2, p2 = e2 * u2 + i2 * c2 + n2 * d2;
          if (0 === p2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f2 = 1 / p2;
          return t2[0] = u2 * f2, t2[1] = (n2 * l2 - h2 * i2) * f2, t2[2] = (s2 * i2 - n2 * o2) * f2, t2[3] = c2 * f2, t2[4] = (h2 * e2 - n2 * a2) * f2, t2[5] = (n2 * r2 - s2 * e2) * f2, t2[6] = d2 * f2, t2[7] = (i2 * a2 - l2 * e2) * f2, t2[8] = (o2 * e2 - i2 * r2) * f2, this;
        }
        transpose() {
          let t2;
          const e2 = this.elements;
          return t2 = e2[1], e2[1] = e2[3], e2[3] = t2, t2 = e2[2], e2[2] = e2[6], e2[6] = t2, t2 = e2[5], e2[5] = e2[7], e2[7] = t2, this;
        }
        getNormalMatrix(t2) {
          return this.setFromMatrix4(t2).invert().transpose();
        }
        transposeIntoArray(t2) {
          const e2 = this.elements;
          return t2[0] = e2[0], t2[1] = e2[3], t2[2] = e2[6], t2[3] = e2[1], t2[4] = e2[4], t2[5] = e2[7], t2[6] = e2[2], t2[7] = e2[5], t2[8] = e2[8], this;
        }
        setUvTransform(t2, e2, i2, n2, r2, o2, s2) {
          const a2 = Math.cos(r2), l2 = Math.sin(r2);
          return this.set(i2 * a2, i2 * l2, -i2 * (a2 * o2 + l2 * s2) + o2 + t2, -n2 * l2, n2 * a2, -n2 * (-l2 * o2 + a2 * s2) + s2 + e2, 0, 0, 1), this;
        }
        scale(t2, e2) {
          const i2 = this.elements;
          return i2[0] *= t2, i2[3] *= t2, i2[6] *= t2, i2[1] *= e2, i2[4] *= e2, i2[7] *= e2, this;
        }
        rotate(t2) {
          const e2 = Math.cos(t2), i2 = Math.sin(t2), n2 = this.elements, r2 = n2[0], o2 = n2[3], s2 = n2[6], a2 = n2[1], l2 = n2[4], h2 = n2[7];
          return n2[0] = e2 * r2 + i2 * a2, n2[3] = e2 * o2 + i2 * l2, n2[6] = e2 * s2 + i2 * h2, n2[1] = -i2 * r2 + e2 * a2, n2[4] = -i2 * o2 + e2 * l2, n2[7] = -i2 * s2 + e2 * h2, this;
        }
        translate(t2, e2) {
          const i2 = this.elements;
          return i2[0] += t2 * i2[2], i2[3] += t2 * i2[5], i2[6] += t2 * i2[8], i2[1] += e2 * i2[2], i2[4] += e2 * i2[5], i2[7] += e2 * i2[8], this;
        }
        equals(t2) {
          const e2 = this.elements, i2 = t2.elements;
          for (let t3 = 0; t3 < 9; t3++) if (e2[t3] !== i2[t3]) return false;
          return true;
        }
        fromArray(t2, e2 = 0) {
          for (let i2 = 0; i2 < 9; i2++) this.elements[i2] = t2[i2 + e2];
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const i2 = this.elements;
          return t2[e2] = i2[0], t2[e2 + 1] = i2[1], t2[e2 + 2] = i2[2], t2[e2 + 3] = i2[3], t2[e2 + 4] = i2[4], t2[e2 + 5] = i2[5], t2[e2 + 6] = i2[6], t2[e2 + 7] = i2[7], t2[e2 + 8] = i2[8], t2;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      let _;
      v.prototype.isMatrix3 = true;
      class y {
        static getDataURL(t2) {
          if (/^data:/i.test(t2.src)) return t2.src;
          if ("undefined" == typeof HTMLCanvasElement) return t2.src;
          let e2;
          if (t2 instanceof HTMLCanvasElement) e2 = t2;
          else {
            void 0 === _ && (_ = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _.width = t2.width, _.height = t2.height;
            const i2 = _.getContext("2d");
            t2 instanceof ImageData ? i2.putImageData(t2, 0, 0) : i2.drawImage(t2, 0, 0, t2.width, t2.height), e2 = _;
          }
          return e2.width > 2048 || e2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t2), e2.toDataURL("image/jpeg", 0.6)) : e2.toDataURL("image/png");
        }
      }
      let x = 0;
      class b extends s {
        constructor(t2 = b.DEFAULT_IMAGE, e2 = b.DEFAULT_MAPPING, i2 = 1001, n2 = 1001, r2 = 1006, o2 = 1008, s2 = 1023, a2 = 1009, l2 = 1, h2 = 3e3) {
          super(), Object.defineProperty(this, "id", { value: x++ }), this.uuid = u(), this.name = "", this.image = t2, this.mipmaps = [], this.mapping = e2, this.wrapS = i2, this.wrapT = n2, this.magFilter = r2, this.minFilter = o2, this.anisotropy = l2, this.format = s2, this.internalFormat = null, this.type = a2, this.offset = new g(0, 0), this.repeat = new g(1, 1), this.center = new g(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new v(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = h2, this.version = 0, this.onUpdate = null;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.name = t2.name, this.image = t2.image, this.mipmaps = t2.mipmaps.slice(0), this.mapping = t2.mapping, this.wrapS = t2.wrapS, this.wrapT = t2.wrapT, this.magFilter = t2.magFilter, this.minFilter = t2.minFilter, this.anisotropy = t2.anisotropy, this.format = t2.format, this.internalFormat = t2.internalFormat, this.type = t2.type, this.offset.copy(t2.offset), this.repeat.copy(t2.repeat), this.center.copy(t2.center), this.rotation = t2.rotation, this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrix.copy(t2.matrix), this.generateMipmaps = t2.generateMipmaps, this.premultiplyAlpha = t2.premultiplyAlpha, this.flipY = t2.flipY, this.unpackAlignment = t2.unpackAlignment, this.encoding = t2.encoding, this;
        }
        toJSON(t2) {
          const e2 = void 0 === t2 || "string" == typeof t2;
          if (!e2 && void 0 !== t2.textures[this.uuid]) return t2.textures[this.uuid];
          const i2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
          if (void 0 !== this.image) {
            const n2 = this.image;
            if (void 0 === n2.uuid && (n2.uuid = u()), !e2 && void 0 === t2.images[n2.uuid]) {
              let e3;
              if (Array.isArray(n2)) {
                e3 = [];
                for (let t3 = 0, i3 = n2.length; t3 < i3; t3++) n2[t3].isDataTexture ? e3.push(T(n2[t3].image)) : e3.push(T(n2[t3]));
              } else e3 = T(n2);
              t2.images[n2.uuid] = { uuid: n2.uuid, url: e3 };
            }
            i2.image = n2.uuid;
          }
          return e2 || (t2.textures[this.uuid] = i2), i2;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(t2) {
          if (300 !== this.mapping) return t2;
          if (t2.applyMatrix3(this.matrix), t2.x < 0 || t2.x > 1) switch (this.wrapS) {
            case 1e3:
              t2.x = t2.x - Math.floor(t2.x);
              break;
            case 1001:
              t2.x = t2.x < 0 ? 0 : 1;
              break;
            case 1002:
              1 === Math.abs(Math.floor(t2.x) % 2) ? t2.x = Math.ceil(t2.x) - t2.x : t2.x = t2.x - Math.floor(t2.x);
          }
          if (t2.y < 0 || t2.y > 1) switch (this.wrapT) {
            case 1e3:
              t2.y = t2.y - Math.floor(t2.y);
              break;
            case 1001:
              t2.y = t2.y < 0 ? 0 : 1;
              break;
            case 1002:
              1 === Math.abs(Math.floor(t2.y) % 2) ? t2.y = Math.ceil(t2.y) - t2.y : t2.y = t2.y - Math.floor(t2.y);
          }
          return this.flipY && (t2.y = 1 - t2.y), t2;
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
      }
      function T(t2) {
        return "undefined" != typeof HTMLImageElement && t2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap ? y.getDataURL(t2) : t2.data ? { data: Array.prototype.slice.call(t2.data), width: t2.width, height: t2.height, type: t2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      b.DEFAULT_IMAGE = void 0, b.DEFAULT_MAPPING = 300, b.prototype.isTexture = true;
      class E {
        constructor(t2 = 0, e2 = 0, i2 = 0, n2 = 1) {
          this.x = t2, this.y = e2, this.z = i2, this.w = n2;
        }
        get width() {
          return this.z;
        }
        set width(t2) {
          this.z = t2;
        }
        get height() {
          return this.w;
        }
        set height(t2) {
          this.w = t2;
        }
        set(t2, e2, i2, n2) {
          return this.x = t2, this.y = e2, this.z = i2, this.w = n2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this.z = t2, this.w = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setZ(t2) {
          return this.z = t2, this;
        }
        setW(t2) {
          return this.w = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            case 2:
              this.z = e2;
              break;
            case 3:
              this.w = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this.z = t2.z, this.w = void 0 !== t2.w ? t2.w : 1, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this.w += t2.w, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this.z += t2, this.w += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this.w = t2.w + e2.w, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this.w += t2.w * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this.w -= t2.w, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this.z -= t2, this.w -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this.w = t2.w - e2.w, this;
        }
        multiply(t2) {
          return this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this.w *= t2.w, this;
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this.z *= t2, this.w *= t2, this;
        }
        applyMatrix4(t2) {
          const e2 = this.x, i2 = this.y, n2 = this.z, r2 = this.w, o2 = t2.elements;
          return this.x = o2[0] * e2 + o2[4] * i2 + o2[8] * n2 + o2[12] * r2, this.y = o2[1] * e2 + o2[5] * i2 + o2[9] * n2 + o2[13] * r2, this.z = o2[2] * e2 + o2[6] * i2 + o2[10] * n2 + o2[14] * r2, this.w = o2[3] * e2 + o2[7] * i2 + o2[11] * n2 + o2[15] * r2, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        setAxisAngleFromQuaternion(t2) {
          this.w = 2 * Math.acos(t2.w);
          const e2 = Math.sqrt(1 - t2.w * t2.w);
          return e2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t2.x / e2, this.y = t2.y / e2, this.z = t2.z / e2), this;
        }
        setAxisAngleFromRotationMatrix(t2) {
          let e2, i2, n2, r2;
          const o2 = t2.elements, s2 = o2[0], a2 = o2[4], l2 = o2[8], h2 = o2[1], u2 = o2[5], c2 = o2[9], d2 = o2[2], p2 = o2[6], f2 = o2[10];
          if (Math.abs(a2 - h2) < 0.01 && Math.abs(l2 - d2) < 0.01 && Math.abs(c2 - p2) < 0.01) {
            if (Math.abs(a2 + h2) < 0.1 && Math.abs(l2 + d2) < 0.1 && Math.abs(c2 + p2) < 0.1 && Math.abs(s2 + u2 + f2 - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            e2 = Math.PI;
            const t3 = (s2 + 1) / 2, o3 = (u2 + 1) / 2, m3 = (f2 + 1) / 2, g2 = (a2 + h2) / 4, v2 = (l2 + d2) / 4, _2 = (c2 + p2) / 4;
            return t3 > o3 && t3 > m3 ? t3 < 0.01 ? (i2 = 0, n2 = 0.707106781, r2 = 0.707106781) : (i2 = Math.sqrt(t3), n2 = g2 / i2, r2 = v2 / i2) : o3 > m3 ? o3 < 0.01 ? (i2 = 0.707106781, n2 = 0, r2 = 0.707106781) : (n2 = Math.sqrt(o3), i2 = g2 / n2, r2 = _2 / n2) : m3 < 0.01 ? (i2 = 0.707106781, n2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(m3), i2 = v2 / r2, n2 = _2 / r2), this.set(i2, n2, r2, e2), this;
          }
          let m2 = Math.sqrt((p2 - c2) * (p2 - c2) + (l2 - d2) * (l2 - d2) + (h2 - a2) * (h2 - a2));
          return Math.abs(m2) < 1e-3 && (m2 = 1), this.x = (p2 - c2) / m2, this.y = (l2 - d2) / m2, this.z = (h2 - a2) / m2, this.w = Math.acos((s2 + u2 + f2 - 1) / 2), this;
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this.w = Math.min(this.w, t2.w), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this.w = Math.max(this.w, t2.w), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this.w = Math.max(t2.w, Math.min(e2.w, this.w)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this.w = Math.max(t2, Math.min(e2, this.w)), this;
        }
        clampLength(t2, e2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y + this.z * t2.z + this.w * t2.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this.w += (t2.w - this.w) * e2, this;
        }
        lerpVectors(t2, e2, i2) {
          return this.x = t2.x + (e2.x - t2.x) * i2, this.y = t2.y + (e2.y - t2.y) * i2, this.z = t2.z + (e2.z - t2.z) * i2, this.w = t2.w + (e2.w - t2.w) * i2, this;
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y && t2.z === this.z && t2.w === this.w;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this.w = t2[e2 + 3], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2[e2 + 3] = this.w, t2;
        }
        fromBufferAttribute(t2, e2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this.w = t2.getW(e2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
      }
      E.prototype.isVector4 = true;
      class S extends s {
        constructor(t2, e2, i2 = {}) {
          super(), this.width = t2, this.height = e2, this.depth = 1, this.scissor = new E(0, 0, t2, e2), this.scissorTest = false, this.viewport = new E(0, 0, t2, e2), this.texture = new b(void 0, i2.mapping, i2.wrapS, i2.wrapT, i2.magFilter, i2.minFilter, i2.format, i2.type, i2.anisotropy, i2.encoding), this.texture.image = { width: t2, height: e2, depth: 1 }, this.texture.generateMipmaps = void 0 !== i2.generateMipmaps && i2.generateMipmaps, this.texture.minFilter = void 0 !== i2.minFilter ? i2.minFilter : 1006, this.depthBuffer = void 0 === i2.depthBuffer || i2.depthBuffer, this.stencilBuffer = void 0 !== i2.stencilBuffer && i2.stencilBuffer, this.depthTexture = void 0 !== i2.depthTexture ? i2.depthTexture : null;
        }
        setTexture(t2) {
          t2.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t2;
        }
        setSize(t2, e2, i2 = 1) {
          this.width === t2 && this.height === e2 && this.depth === i2 || (this.width = t2, this.height = e2, this.depth = i2, this.texture.image.width = t2, this.texture.image.height = e2, this.texture.image.depth = i2, this.dispose()), this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.copy(t2.viewport), this.texture = t2.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      S.prototype.isWebGLRenderTarget = true;
      (class extends S {
        constructor(t2, e2, i2) {
          super(t2, e2);
          const n2 = this.texture;
          this.texture = [];
          for (let t3 = 0; t3 < i2; t3++) this.texture[t3] = n2.clone();
        }
        setSize(t2, e2, i2 = 1) {
          if (this.width !== t2 || this.height !== e2 || this.depth !== i2) {
            this.width = t2, this.height = e2, this.depth = i2;
            for (let n2 = 0, r2 = this.texture.length; n2 < r2; n2++) this.texture[n2].image.width = t2, this.texture[n2].image.height = e2, this.texture[n2].image.depth = i2;
            this.dispose();
          }
          return this.viewport.set(0, 0, t2, e2), this.scissor.set(0, 0, t2, e2), this;
        }
        copy(t2) {
          this.dispose(), this.width = t2.width, this.height = t2.height, this.depth = t2.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t2.depthBuffer, this.stencilBuffer = t2.stencilBuffer, this.depthTexture = t2.depthTexture, this.texture.length = 0;
          for (let e2 = 0, i2 = t2.texture.length; e2 < i2; e2++) this.texture[e2] = t2.texture[e2].clone();
          return this;
        }
      }).prototype.isWebGLMultipleRenderTargets = true;
      class w extends S {
        constructor(t2, e2, i2) {
          super(t2, e2, i2), this.samples = 4;
        }
        copy(t2) {
          return super.copy.call(this, t2), this.samples = t2.samples, this;
        }
      }
      w.prototype.isWebGLMultisampleRenderTarget = true;
      class A {
        constructor(t2 = 0, e2 = 0, i2 = 0, n2 = 1) {
          this._x = t2, this._y = e2, this._z = i2, this._w = n2;
        }
        static slerp(t2, e2, i2, n2) {
          return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i2.slerpQuaternions(t2, e2, n2);
        }
        static slerpFlat(t2, e2, i2, n2, r2, o2, s2) {
          let a2 = i2[n2 + 0], l2 = i2[n2 + 1], h2 = i2[n2 + 2], u2 = i2[n2 + 3];
          const c2 = r2[o2 + 0], d2 = r2[o2 + 1], p2 = r2[o2 + 2], f2 = r2[o2 + 3];
          if (0 === s2) return t2[e2 + 0] = a2, t2[e2 + 1] = l2, t2[e2 + 2] = h2, void (t2[e2 + 3] = u2);
          if (1 === s2) return t2[e2 + 0] = c2, t2[e2 + 1] = d2, t2[e2 + 2] = p2, void (t2[e2 + 3] = f2);
          if (u2 !== f2 || a2 !== c2 || l2 !== d2 || h2 !== p2) {
            let t3 = 1 - s2;
            const e3 = a2 * c2 + l2 * d2 + h2 * p2 + u2 * f2, i3 = e3 >= 0 ? 1 : -1, n3 = 1 - e3 * e3;
            if (n3 > Number.EPSILON) {
              const r4 = Math.sqrt(n3), o3 = Math.atan2(r4, e3 * i3);
              t3 = Math.sin(t3 * o3) / r4, s2 = Math.sin(s2 * o3) / r4;
            }
            const r3 = s2 * i3;
            if (a2 = a2 * t3 + c2 * r3, l2 = l2 * t3 + d2 * r3, h2 = h2 * t3 + p2 * r3, u2 = u2 * t3 + f2 * r3, t3 === 1 - s2) {
              const t4 = 1 / Math.sqrt(a2 * a2 + l2 * l2 + h2 * h2 + u2 * u2);
              a2 *= t4, l2 *= t4, h2 *= t4, u2 *= t4;
            }
          }
          t2[e2] = a2, t2[e2 + 1] = l2, t2[e2 + 2] = h2, t2[e2 + 3] = u2;
        }
        static multiplyQuaternionsFlat(t2, e2, i2, n2, r2, o2) {
          const s2 = i2[n2], a2 = i2[n2 + 1], l2 = i2[n2 + 2], h2 = i2[n2 + 3], u2 = r2[o2], c2 = r2[o2 + 1], d2 = r2[o2 + 2], p2 = r2[o2 + 3];
          return t2[e2] = s2 * p2 + h2 * u2 + a2 * d2 - l2 * c2, t2[e2 + 1] = a2 * p2 + h2 * c2 + l2 * u2 - s2 * d2, t2[e2 + 2] = l2 * p2 + h2 * d2 + s2 * c2 - a2 * u2, t2[e2 + 3] = h2 * p2 - s2 * u2 - a2 * c2 - l2 * d2, t2;
        }
        get x() {
          return this._x;
        }
        set x(t2) {
          this._x = t2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t2) {
          this._y = t2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t2) {
          this._z = t2, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t2) {
          this._w = t2, this._onChangeCallback();
        }
        set(t2, e2, i2, n2) {
          return this._x = t2, this._y = e2, this._z = i2, this._w = n2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t2) {
          return this._x = t2.x, this._y = t2.y, this._z = t2.z, this._w = t2.w, this._onChangeCallback(), this;
        }
        setFromEuler(t2, e2) {
          if (!t2 || !t2.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
          const i2 = t2._x, n2 = t2._y, r2 = t2._z, o2 = t2._order, s2 = Math.cos, a2 = Math.sin, l2 = s2(i2 / 2), h2 = s2(n2 / 2), u2 = s2(r2 / 2), c2 = a2(i2 / 2), d2 = a2(n2 / 2), p2 = a2(r2 / 2);
          switch (o2) {
            case "XYZ":
              this._x = c2 * h2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 - c2 * h2 * p2, this._z = l2 * h2 * p2 + c2 * d2 * u2, this._w = l2 * h2 * u2 - c2 * d2 * p2;
              break;
            case "YXZ":
              this._x = c2 * h2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 - c2 * h2 * p2, this._z = l2 * h2 * p2 - c2 * d2 * u2, this._w = l2 * h2 * u2 + c2 * d2 * p2;
              break;
            case "ZXY":
              this._x = c2 * h2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 + c2 * h2 * p2, this._z = l2 * h2 * p2 + c2 * d2 * u2, this._w = l2 * h2 * u2 - c2 * d2 * p2;
              break;
            case "ZYX":
              this._x = c2 * h2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 + c2 * h2 * p2, this._z = l2 * h2 * p2 - c2 * d2 * u2, this._w = l2 * h2 * u2 + c2 * d2 * p2;
              break;
            case "YZX":
              this._x = c2 * h2 * u2 + l2 * d2 * p2, this._y = l2 * d2 * u2 + c2 * h2 * p2, this._z = l2 * h2 * p2 - c2 * d2 * u2, this._w = l2 * h2 * u2 - c2 * d2 * p2;
              break;
            case "XZY":
              this._x = c2 * h2 * u2 - l2 * d2 * p2, this._y = l2 * d2 * u2 - c2 * h2 * p2, this._z = l2 * h2 * p2 + c2 * d2 * u2, this._w = l2 * h2 * u2 + c2 * d2 * p2;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o2);
          }
          return false !== e2 && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t2, e2) {
          const i2 = e2 / 2, n2 = Math.sin(i2);
          return this._x = t2.x * n2, this._y = t2.y * n2, this._z = t2.z * n2, this._w = Math.cos(i2), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t2) {
          const e2 = t2.elements, i2 = e2[0], n2 = e2[4], r2 = e2[8], o2 = e2[1], s2 = e2[5], a2 = e2[9], l2 = e2[2], h2 = e2[6], u2 = e2[10], c2 = i2 + s2 + u2;
          if (c2 > 0) {
            const t3 = 0.5 / Math.sqrt(c2 + 1);
            this._w = 0.25 / t3, this._x = (h2 - a2) * t3, this._y = (r2 - l2) * t3, this._z = (o2 - n2) * t3;
          } else if (i2 > s2 && i2 > u2) {
            const t3 = 2 * Math.sqrt(1 + i2 - s2 - u2);
            this._w = (h2 - a2) / t3, this._x = 0.25 * t3, this._y = (n2 + o2) / t3, this._z = (r2 + l2) / t3;
          } else if (s2 > u2) {
            const t3 = 2 * Math.sqrt(1 + s2 - i2 - u2);
            this._w = (r2 - l2) / t3, this._x = (n2 + o2) / t3, this._y = 0.25 * t3, this._z = (a2 + h2) / t3;
          } else {
            const t3 = 2 * Math.sqrt(1 + u2 - i2 - s2);
            this._w = (o2 - n2) / t3, this._x = (r2 + l2) / t3, this._y = (a2 + h2) / t3, this._z = 0.25 * t3;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t2, e2) {
          let i2 = t2.dot(e2) + 1;
          return i2 < Number.EPSILON ? (i2 = 0, Math.abs(t2.x) > Math.abs(t2.z) ? (this._x = -t2.y, this._y = t2.x, this._z = 0, this._w = i2) : (this._x = 0, this._y = -t2.z, this._z = t2.y, this._w = i2)) : (this._x = t2.y * e2.z - t2.z * e2.y, this._y = t2.z * e2.x - t2.x * e2.z, this._z = t2.x * e2.y - t2.y * e2.x, this._w = i2), this.normalize();
        }
        angleTo(t2) {
          return 2 * Math.acos(Math.abs(c(this.dot(t2), -1, 1)));
        }
        rotateTowards(t2, e2) {
          const i2 = this.angleTo(t2);
          if (0 === i2) return this;
          const n2 = Math.min(1, e2 / i2);
          return this.slerp(t2, n2), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(t2) {
          return this._x * t2._x + this._y * t2._y + this._z * t2._z + this._w * t2._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let t2 = this.length();
          return 0 === t2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t2 = 1 / t2, this._x = this._x * t2, this._y = this._y * t2, this._z = this._z * t2, this._w = this._w * t2), this._onChangeCallback(), this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t2, e2)) : this.multiplyQuaternions(this, t2);
        }
        premultiply(t2) {
          return this.multiplyQuaternions(t2, this);
        }
        multiplyQuaternions(t2, e2) {
          const i2 = t2._x, n2 = t2._y, r2 = t2._z, o2 = t2._w, s2 = e2._x, a2 = e2._y, l2 = e2._z, h2 = e2._w;
          return this._x = i2 * h2 + o2 * s2 + n2 * l2 - r2 * a2, this._y = n2 * h2 + o2 * a2 + r2 * s2 - i2 * l2, this._z = r2 * h2 + o2 * l2 + i2 * a2 - n2 * s2, this._w = o2 * h2 - i2 * s2 - n2 * a2 - r2 * l2, this._onChangeCallback(), this;
        }
        slerp(t2, e2) {
          if (0 === e2) return this;
          if (1 === e2) return this.copy(t2);
          const i2 = this._x, n2 = this._y, r2 = this._z, o2 = this._w;
          let s2 = o2 * t2._w + i2 * t2._x + n2 * t2._y + r2 * t2._z;
          if (s2 < 0 ? (this._w = -t2._w, this._x = -t2._x, this._y = -t2._y, this._z = -t2._z, s2 = -s2) : this.copy(t2), s2 >= 1) return this._w = o2, this._x = i2, this._y = n2, this._z = r2, this;
          const a2 = 1 - s2 * s2;
          if (a2 <= Number.EPSILON) {
            const t3 = 1 - e2;
            return this._w = t3 * o2 + e2 * this._w, this._x = t3 * i2 + e2 * this._x, this._y = t3 * n2 + e2 * this._y, this._z = t3 * r2 + e2 * this._z, this.normalize(), this._onChangeCallback(), this;
          }
          const l2 = Math.sqrt(a2), h2 = Math.atan2(l2, s2), u2 = Math.sin((1 - e2) * h2) / l2, c2 = Math.sin(e2 * h2) / l2;
          return this._w = o2 * u2 + this._w * c2, this._x = i2 * u2 + this._x * c2, this._y = n2 * u2 + this._y * c2, this._z = r2 * u2 + this._z * c2, this._onChangeCallback(), this;
        }
        slerpQuaternions(t2, e2, i2) {
          this.copy(t2).slerp(e2, i2);
        }
        equals(t2) {
          return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._w === this._w;
        }
        fromArray(t2, e2 = 0) {
          return this._x = t2[e2], this._y = t2[e2 + 1], this._z = t2[e2 + 2], this._w = t2[e2 + 3], this._onChangeCallback(), this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._w, t2;
        }
        fromBufferAttribute(t2, e2) {
          return this._x = t2.getX(e2), this._y = t2.getY(e2), this._z = t2.getZ(e2), this._w = t2.getW(e2), this;
        }
        _onChange(t2) {
          return this._onChangeCallback = t2, this;
        }
        _onChangeCallback() {
        }
      }
      A.prototype.isQuaternion = true;
      class M {
        constructor(t2 = 0, e2 = 0, i2 = 0) {
          this.x = t2, this.y = e2, this.z = i2;
        }
        set(t2, e2, i2) {
          return void 0 === i2 && (i2 = this.z), this.x = t2, this.y = e2, this.z = i2, this;
        }
        setScalar(t2) {
          return this.x = t2, this.y = t2, this.z = t2, this;
        }
        setX(t2) {
          return this.x = t2, this;
        }
        setY(t2) {
          return this.y = t2, this;
        }
        setZ(t2) {
          return this.z = t2, this;
        }
        setComponent(t2, e2) {
          switch (t2) {
            case 0:
              this.x = e2;
              break;
            case 1:
              this.y = e2;
              break;
            case 2:
              this.z = e2;
              break;
            default:
              throw new Error("index is out of range: " + t2);
          }
          return this;
        }
        getComponent(t2) {
          switch (t2) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t2);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t2) {
          return this.x = t2.x, this.y = t2.y, this.z = t2.z, this;
        }
        add(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t2, e2)) : (this.x += t2.x, this.y += t2.y, this.z += t2.z, this);
        }
        addScalar(t2) {
          return this.x += t2, this.y += t2, this.z += t2, this;
        }
        addVectors(t2, e2) {
          return this.x = t2.x + e2.x, this.y = t2.y + e2.y, this.z = t2.z + e2.z, this;
        }
        addScaledVector(t2, e2) {
          return this.x += t2.x * e2, this.y += t2.y * e2, this.z += t2.z * e2, this;
        }
        sub(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t2, e2)) : (this.x -= t2.x, this.y -= t2.y, this.z -= t2.z, this);
        }
        subScalar(t2) {
          return this.x -= t2, this.y -= t2, this.z -= t2, this;
        }
        subVectors(t2, e2) {
          return this.x = t2.x - e2.x, this.y = t2.y - e2.y, this.z = t2.z - e2.z, this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t2, e2)) : (this.x *= t2.x, this.y *= t2.y, this.z *= t2.z, this);
        }
        multiplyScalar(t2) {
          return this.x *= t2, this.y *= t2, this.z *= t2, this;
        }
        multiplyVectors(t2, e2) {
          return this.x = t2.x * e2.x, this.y = t2.y * e2.y, this.z = t2.z * e2.z, this;
        }
        applyEuler(t2) {
          return t2 && t2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(R.setFromEuler(t2));
        }
        applyAxisAngle(t2, e2) {
          return this.applyQuaternion(R.setFromAxisAngle(t2, e2));
        }
        applyMatrix3(t2) {
          const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.elements;
          return this.x = r2[0] * e2 + r2[3] * i2 + r2[6] * n2, this.y = r2[1] * e2 + r2[4] * i2 + r2[7] * n2, this.z = r2[2] * e2 + r2[5] * i2 + r2[8] * n2, this;
        }
        applyNormalMatrix(t2) {
          return this.applyMatrix3(t2).normalize();
        }
        applyMatrix4(t2) {
          const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.elements, o2 = 1 / (r2[3] * e2 + r2[7] * i2 + r2[11] * n2 + r2[15]);
          return this.x = (r2[0] * e2 + r2[4] * i2 + r2[8] * n2 + r2[12]) * o2, this.y = (r2[1] * e2 + r2[5] * i2 + r2[9] * n2 + r2[13]) * o2, this.z = (r2[2] * e2 + r2[6] * i2 + r2[10] * n2 + r2[14]) * o2, this;
        }
        applyQuaternion(t2) {
          const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.x, o2 = t2.y, s2 = t2.z, a2 = t2.w, l2 = a2 * e2 + o2 * n2 - s2 * i2, h2 = a2 * i2 + s2 * e2 - r2 * n2, u2 = a2 * n2 + r2 * i2 - o2 * e2, c2 = -r2 * e2 - o2 * i2 - s2 * n2;
          return this.x = l2 * a2 + c2 * -r2 + h2 * -s2 - u2 * -o2, this.y = h2 * a2 + c2 * -o2 + u2 * -r2 - l2 * -s2, this.z = u2 * a2 + c2 * -s2 + l2 * -o2 - h2 * -r2, this;
        }
        project(t2) {
          return this.applyMatrix4(t2.matrixWorldInverse).applyMatrix4(t2.projectionMatrix);
        }
        unproject(t2) {
          return this.applyMatrix4(t2.projectionMatrixInverse).applyMatrix4(t2.matrixWorld);
        }
        transformDirection(t2) {
          const e2 = this.x, i2 = this.y, n2 = this.z, r2 = t2.elements;
          return this.x = r2[0] * e2 + r2[4] * i2 + r2[8] * n2, this.y = r2[1] * e2 + r2[5] * i2 + r2[9] * n2, this.z = r2[2] * e2 + r2[6] * i2 + r2[10] * n2, this.normalize();
        }
        divide(t2) {
          return this.x /= t2.x, this.y /= t2.y, this.z /= t2.z, this;
        }
        divideScalar(t2) {
          return this.multiplyScalar(1 / t2);
        }
        min(t2) {
          return this.x = Math.min(this.x, t2.x), this.y = Math.min(this.y, t2.y), this.z = Math.min(this.z, t2.z), this;
        }
        max(t2) {
          return this.x = Math.max(this.x, t2.x), this.y = Math.max(this.y, t2.y), this.z = Math.max(this.z, t2.z), this;
        }
        clamp(t2, e2) {
          return this.x = Math.max(t2.x, Math.min(e2.x, this.x)), this.y = Math.max(t2.y, Math.min(e2.y, this.y)), this.z = Math.max(t2.z, Math.min(e2.z, this.z)), this;
        }
        clampScalar(t2, e2) {
          return this.x = Math.max(t2, Math.min(e2, this.x)), this.y = Math.max(t2, Math.min(e2, this.y)), this.z = Math.max(t2, Math.min(e2, this.z)), this;
        }
        clampLength(t2, e2) {
          const i2 = this.length();
          return this.divideScalar(i2 || 1).multiplyScalar(Math.max(t2, Math.min(e2, i2)));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(t2) {
          return this.x * t2.x + this.y * t2.y + this.z * t2.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t2) {
          return this.normalize().multiplyScalar(t2);
        }
        lerp(t2, e2) {
          return this.x += (t2.x - this.x) * e2, this.y += (t2.y - this.y) * e2, this.z += (t2.z - this.z) * e2, this;
        }
        lerpVectors(t2, e2, i2) {
          return this.x = t2.x + (e2.x - t2.x) * i2, this.y = t2.y + (e2.y - t2.y) * i2, this.z = t2.z + (e2.z - t2.z) * i2, this;
        }
        cross(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t2, e2)) : this.crossVectors(this, t2);
        }
        crossVectors(t2, e2) {
          const i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = e2.x, s2 = e2.y, a2 = e2.z;
          return this.x = n2 * a2 - r2 * s2, this.y = r2 * o2 - i2 * a2, this.z = i2 * s2 - n2 * o2, this;
        }
        projectOnVector(t2) {
          const e2 = t2.lengthSq();
          if (0 === e2) return this.set(0, 0, 0);
          const i2 = t2.dot(this) / e2;
          return this.copy(t2).multiplyScalar(i2);
        }
        projectOnPlane(t2) {
          return C.copy(this).projectOnVector(t2), this.sub(C);
        }
        reflect(t2) {
          return this.sub(C.copy(t2).multiplyScalar(2 * this.dot(t2)));
        }
        angleTo(t2) {
          const e2 = Math.sqrt(this.lengthSq() * t2.lengthSq());
          if (0 === e2) return Math.PI / 2;
          const i2 = this.dot(t2) / e2;
          return Math.acos(c(i2, -1, 1));
        }
        distanceTo(t2) {
          return Math.sqrt(this.distanceToSquared(t2));
        }
        distanceToSquared(t2) {
          const e2 = this.x - t2.x, i2 = this.y - t2.y, n2 = this.z - t2.z;
          return e2 * e2 + i2 * i2 + n2 * n2;
        }
        manhattanDistanceTo(t2) {
          return Math.abs(this.x - t2.x) + Math.abs(this.y - t2.y) + Math.abs(this.z - t2.z);
        }
        setFromSpherical(t2) {
          return this.setFromSphericalCoords(t2.radius, t2.phi, t2.theta);
        }
        setFromSphericalCoords(t2, e2, i2) {
          const n2 = Math.sin(e2) * t2;
          return this.x = n2 * Math.sin(i2), this.y = Math.cos(e2) * t2, this.z = n2 * Math.cos(i2), this;
        }
        setFromCylindrical(t2) {
          return this.setFromCylindricalCoords(t2.radius, t2.theta, t2.y);
        }
        setFromCylindricalCoords(t2, e2, i2) {
          return this.x = t2 * Math.sin(e2), this.y = i2, this.z = t2 * Math.cos(e2), this;
        }
        setFromMatrixPosition(t2) {
          const e2 = t2.elements;
          return this.x = e2[12], this.y = e2[13], this.z = e2[14], this;
        }
        setFromMatrixScale(t2) {
          const e2 = this.setFromMatrixColumn(t2, 0).length(), i2 = this.setFromMatrixColumn(t2, 1).length(), n2 = this.setFromMatrixColumn(t2, 2).length();
          return this.x = e2, this.y = i2, this.z = n2, this;
        }
        setFromMatrixColumn(t2, e2) {
          return this.fromArray(t2.elements, 4 * e2);
        }
        setFromMatrix3Column(t2, e2) {
          return this.fromArray(t2.elements, 3 * e2);
        }
        equals(t2) {
          return t2.x === this.x && t2.y === this.y && t2.z === this.z;
        }
        fromArray(t2, e2 = 0) {
          return this.x = t2[e2], this.y = t2[e2 + 1], this.z = t2[e2 + 2], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.x, t2[e2 + 1] = this.y, t2[e2 + 2] = this.z, t2;
        }
        fromBufferAttribute(t2, e2, i2) {
          return void 0 !== i2 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t2.getX(e2), this.y = t2.getY(e2), this.z = t2.getZ(e2), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
      }
      M.prototype.isVector3 = true;
      const C = new M(), R = new A();
      class I {
        constructor(t2 = new M(1 / 0, 1 / 0, 1 / 0), e2 = new M(-1 / 0, -1 / 0, -1 / 0)) {
          this.min = t2, this.max = e2;
        }
        set(t2, e2) {
          return this.min.copy(t2), this.max.copy(e2), this;
        }
        setFromArray(t2) {
          let e2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, o2 = -1 / 0, s2 = -1 / 0;
          for (let a2 = 0, l2 = t2.length; a2 < l2; a2 += 3) {
            const l3 = t2[a2], h2 = t2[a2 + 1], u2 = t2[a2 + 2];
            l3 < e2 && (e2 = l3), h2 < i2 && (i2 = h2), u2 < n2 && (n2 = u2), l3 > r2 && (r2 = l3), h2 > o2 && (o2 = h2), u2 > s2 && (s2 = u2);
          }
          return this.min.set(e2, i2, n2), this.max.set(r2, o2, s2), this;
        }
        setFromBufferAttribute(t2) {
          let e2 = 1 / 0, i2 = 1 / 0, n2 = 1 / 0, r2 = -1 / 0, o2 = -1 / 0, s2 = -1 / 0;
          for (let a2 = 0, l2 = t2.count; a2 < l2; a2++) {
            const l3 = t2.getX(a2), h2 = t2.getY(a2), u2 = t2.getZ(a2);
            l3 < e2 && (e2 = l3), h2 < i2 && (i2 = h2), u2 < n2 && (n2 = u2), l3 > r2 && (r2 = l3), h2 > o2 && (o2 = h2), u2 > s2 && (s2 = u2);
          }
          return this.min.set(e2, i2, n2), this.max.set(r2, o2, s2), this;
        }
        setFromPoints(t2) {
          this.makeEmpty();
          for (let e2 = 0, i2 = t2.length; e2 < i2; e2++) this.expandByPoint(t2[e2]);
          return this;
        }
        setFromCenterAndSize(t2, e2) {
          const i2 = O.copy(e2).multiplyScalar(0.5);
          return this.min.copy(t2).sub(i2), this.max.copy(t2).add(i2), this;
        }
        setFromObject(t2) {
          return this.makeEmpty(), this.expandByObject(t2);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.min.copy(t2.min), this.max.copy(t2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(t2) {
          return this.isEmpty() ? t2.set(0, 0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t2) {
          return this.isEmpty() ? t2.set(0, 0, 0) : t2.subVectors(this.max, this.min);
        }
        expandByPoint(t2) {
          return this.min.min(t2), this.max.max(t2), this;
        }
        expandByVector(t2) {
          return this.min.sub(t2), this.max.add(t2), this;
        }
        expandByScalar(t2) {
          return this.min.addScalar(-t2), this.max.addScalar(t2), this;
        }
        expandByObject(t2) {
          t2.updateWorldMatrix(false, false);
          const e2 = t2.geometry;
          void 0 !== e2 && (null === e2.boundingBox && e2.computeBoundingBox(), N.copy(e2.boundingBox), N.applyMatrix4(t2.matrixWorld), this.union(N));
          const i2 = t2.children;
          for (let t3 = 0, e3 = i2.length; t3 < e3; t3++) this.expandByObject(i2[t3]);
          return this;
        }
        containsPoint(t2) {
          return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y || t2.z < this.min.z || t2.z > this.max.z);
        }
        containsBox(t2) {
          return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y && this.min.z <= t2.min.z && t2.max.z <= this.max.z;
        }
        getParameter(t2, e2) {
          return e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y), (t2.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(t2) {
          return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y || t2.max.z < this.min.z || t2.min.z > this.max.z);
        }
        intersectsSphere(t2) {
          return this.clampPoint(t2.center, O), O.distanceToSquared(t2.center) <= t2.radius * t2.radius;
        }
        intersectsPlane(t2) {
          let e2, i2;
          return t2.normal.x > 0 ? (e2 = t2.normal.x * this.min.x, i2 = t2.normal.x * this.max.x) : (e2 = t2.normal.x * this.max.x, i2 = t2.normal.x * this.min.x), t2.normal.y > 0 ? (e2 += t2.normal.y * this.min.y, i2 += t2.normal.y * this.max.y) : (e2 += t2.normal.y * this.max.y, i2 += t2.normal.y * this.min.y), t2.normal.z > 0 ? (e2 += t2.normal.z * this.min.z, i2 += t2.normal.z * this.max.z) : (e2 += t2.normal.z * this.max.z, i2 += t2.normal.z * this.min.z), e2 <= -t2.constant && i2 >= -t2.constant;
        }
        intersectsTriangle(t2) {
          if (this.isEmpty()) return false;
          this.getCenter(G), H.subVectors(this.max, G), L.subVectors(t2.a, G), D.subVectors(t2.b, G), F.subVectors(t2.c, G), B.subVectors(D, L), U.subVectors(F, D), k.subVectors(L, F);
          let e2 = [0, -B.z, B.y, 0, -U.z, U.y, 0, -k.z, k.y, B.z, 0, -B.x, U.z, 0, -U.x, k.z, 0, -k.x, -B.y, B.x, 0, -U.y, U.x, 0, -k.y, k.x, 0];
          return !!V(e2, L, D, F, H) && (e2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!V(e2, L, D, F, H) && (j.crossVectors(B, U), e2 = [j.x, j.y, j.z], V(e2, L, D, F, H)));
        }
        clampPoint(t2, e2) {
          return e2.copy(t2).clamp(this.min, this.max);
        }
        distanceToPoint(t2) {
          return O.copy(t2).clamp(this.min, this.max).sub(t2).length();
        }
        getBoundingSphere(t2) {
          return this.getCenter(t2.center), t2.radius = 0.5 * this.getSize(O).length(), t2;
        }
        intersect(t2) {
          return this.min.max(t2.min), this.max.min(t2.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(t2) {
          return this.min.min(t2.min), this.max.max(t2.max), this;
        }
        applyMatrix4(t2) {
          return this.isEmpty() || (P[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t2), P[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t2), P[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t2), P[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t2), P[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t2), P[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t2), P[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t2), P[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t2), this.setFromPoints(P)), this;
        }
        translate(t2) {
          return this.min.add(t2), this.max.add(t2), this;
        }
        equals(t2) {
          return t2.min.equals(this.min) && t2.max.equals(this.max);
        }
      }
      I.prototype.isBox3 = true;
      const P = [new M(), new M(), new M(), new M(), new M(), new M(), new M(), new M()], O = new M(), N = new I(), L = new M(), D = new M(), F = new M(), B = new M(), U = new M(), k = new M(), G = new M(), H = new M(), j = new M(), z = new M();
      function V(t2, e2, i2, n2, r2) {
        for (let o2 = 0, s2 = t2.length - 3; o2 <= s2; o2 += 3) {
          z.fromArray(t2, o2);
          const s3 = r2.x * Math.abs(z.x) + r2.y * Math.abs(z.y) + r2.z * Math.abs(z.z), a2 = e2.dot(z), l2 = i2.dot(z), h2 = n2.dot(z);
          if (Math.max(-Math.max(a2, l2, h2), Math.min(a2, l2, h2)) > s3) return false;
        }
        return true;
      }
      const X = new I(), W = new M(), Y = new M(), q = new M();
      class Z {
        constructor(t2 = new M(), e2 = -1) {
          this.center = t2, this.radius = e2;
        }
        set(t2, e2) {
          return this.center.copy(t2), this.radius = e2, this;
        }
        setFromPoints(t2, e2) {
          const i2 = this.center;
          void 0 !== e2 ? i2.copy(e2) : X.setFromPoints(t2).getCenter(i2);
          let n2 = 0;
          for (let e3 = 0, r2 = t2.length; e3 < r2; e3++) n2 = Math.max(n2, i2.distanceToSquared(t2[e3]));
          return this.radius = Math.sqrt(n2), this;
        }
        copy(t2) {
          return this.center.copy(t2.center), this.radius = t2.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(t2) {
          return t2.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t2) {
          return t2.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t2) {
          const e2 = this.radius + t2.radius;
          return t2.center.distanceToSquared(this.center) <= e2 * e2;
        }
        intersectsBox(t2) {
          return t2.intersectsSphere(this);
        }
        intersectsPlane(t2) {
          return Math.abs(t2.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t2, e2) {
          const i2 = this.center.distanceToSquared(t2);
          return e2.copy(t2), i2 > this.radius * this.radius && (e2.sub(this.center).normalize(), e2.multiplyScalar(this.radius).add(this.center)), e2;
        }
        getBoundingBox(t2) {
          return this.isEmpty() ? (t2.makeEmpty(), t2) : (t2.set(this.center, this.center), t2.expandByScalar(this.radius), t2);
        }
        applyMatrix4(t2) {
          return this.center.applyMatrix4(t2), this.radius = this.radius * t2.getMaxScaleOnAxis(), this;
        }
        translate(t2) {
          return this.center.add(t2), this;
        }
        expandByPoint(t2) {
          q.subVectors(t2, this.center);
          const e2 = q.lengthSq();
          if (e2 > this.radius * this.radius) {
            const t3 = Math.sqrt(e2), i2 = 0.5 * (t3 - this.radius);
            this.center.add(q.multiplyScalar(i2 / t3)), this.radius += i2;
          }
          return this;
        }
        union(t2) {
          return Y.subVectors(t2.center, this.center).normalize().multiplyScalar(t2.radius), this.expandByPoint(W.copy(t2.center).add(Y)), this.expandByPoint(W.copy(t2.center).sub(Y)), this;
        }
        equals(t2) {
          return t2.center.equals(this.center) && t2.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const J = new M(), K = new M(), Q = new M(), $ = new M(), tt = new M(), et = new M(), it = new M();
      class nt {
        constructor(t2 = new M(), e2 = new M(0, 0, -1)) {
          this.origin = t2, this.direction = e2;
        }
        set(t2, e2) {
          return this.origin.copy(t2), this.direction.copy(e2), this;
        }
        copy(t2) {
          return this.origin.copy(t2.origin), this.direction.copy(t2.direction), this;
        }
        at(t2, e2) {
          return e2.copy(this.direction).multiplyScalar(t2).add(this.origin);
        }
        lookAt(t2) {
          return this.direction.copy(t2).sub(this.origin).normalize(), this;
        }
        recast(t2) {
          return this.origin.copy(this.at(t2, J)), this;
        }
        closestPointToPoint(t2, e2) {
          e2.subVectors(t2, this.origin);
          const i2 = e2.dot(this.direction);
          return i2 < 0 ? e2.copy(this.origin) : e2.copy(this.direction).multiplyScalar(i2).add(this.origin);
        }
        distanceToPoint(t2) {
          return Math.sqrt(this.distanceSqToPoint(t2));
        }
        distanceSqToPoint(t2) {
          const e2 = J.subVectors(t2, this.origin).dot(this.direction);
          return e2 < 0 ? this.origin.distanceToSquared(t2) : (J.copy(this.direction).multiplyScalar(e2).add(this.origin), J.distanceToSquared(t2));
        }
        distanceSqToSegment(t2, e2, i2, n2) {
          K.copy(t2).add(e2).multiplyScalar(0.5), Q.copy(e2).sub(t2).normalize(), $.copy(this.origin).sub(K);
          const r2 = 0.5 * t2.distanceTo(e2), o2 = -this.direction.dot(Q), s2 = $.dot(this.direction), a2 = -$.dot(Q), l2 = $.lengthSq(), h2 = Math.abs(1 - o2 * o2);
          let u2, c2, d2, p2;
          if (h2 > 0) if (u2 = o2 * a2 - s2, c2 = o2 * s2 - a2, p2 = r2 * h2, u2 >= 0) if (c2 >= -p2) if (c2 <= p2) {
            const t3 = 1 / h2;
            u2 *= t3, c2 *= t3, d2 = u2 * (u2 + o2 * c2 + 2 * s2) + c2 * (o2 * u2 + c2 + 2 * a2) + l2;
          } else c2 = r2, u2 = Math.max(0, -(o2 * c2 + s2)), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2;
          else c2 = -r2, u2 = Math.max(0, -(o2 * c2 + s2)), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2;
          else c2 <= -p2 ? (u2 = Math.max(0, -(-o2 * r2 + s2)), c2 = u2 > 0 ? -r2 : Math.min(Math.max(-r2, -a2), r2), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2) : c2 <= p2 ? (u2 = 0, c2 = Math.min(Math.max(-r2, -a2), r2), d2 = c2 * (c2 + 2 * a2) + l2) : (u2 = Math.max(0, -(o2 * r2 + s2)), c2 = u2 > 0 ? r2 : Math.min(Math.max(-r2, -a2), r2), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2);
          else c2 = o2 > 0 ? -r2 : r2, u2 = Math.max(0, -(o2 * c2 + s2)), d2 = -u2 * u2 + c2 * (c2 + 2 * a2) + l2;
          return i2 && i2.copy(this.direction).multiplyScalar(u2).add(this.origin), n2 && n2.copy(Q).multiplyScalar(c2).add(K), d2;
        }
        intersectSphere(t2, e2) {
          J.subVectors(t2.center, this.origin);
          const i2 = J.dot(this.direction), n2 = J.dot(J) - i2 * i2, r2 = t2.radius * t2.radius;
          if (n2 > r2) return null;
          const o2 = Math.sqrt(r2 - n2), s2 = i2 - o2, a2 = i2 + o2;
          return s2 < 0 && a2 < 0 ? null : s2 < 0 ? this.at(a2, e2) : this.at(s2, e2);
        }
        intersectsSphere(t2) {
          return this.distanceSqToPoint(t2.center) <= t2.radius * t2.radius;
        }
        distanceToPlane(t2) {
          const e2 = t2.normal.dot(this.direction);
          if (0 === e2) return 0 === t2.distanceToPoint(this.origin) ? 0 : null;
          const i2 = -(this.origin.dot(t2.normal) + t2.constant) / e2;
          return i2 >= 0 ? i2 : null;
        }
        intersectPlane(t2, e2) {
          const i2 = this.distanceToPlane(t2);
          return null === i2 ? null : this.at(i2, e2);
        }
        intersectsPlane(t2) {
          const e2 = t2.distanceToPoint(this.origin);
          if (0 === e2) return true;
          return t2.normal.dot(this.direction) * e2 < 0;
        }
        intersectBox(t2, e2) {
          let i2, n2, r2, o2, s2, a2;
          const l2 = 1 / this.direction.x, h2 = 1 / this.direction.y, u2 = 1 / this.direction.z, c2 = this.origin;
          return l2 >= 0 ? (i2 = (t2.min.x - c2.x) * l2, n2 = (t2.max.x - c2.x) * l2) : (i2 = (t2.max.x - c2.x) * l2, n2 = (t2.min.x - c2.x) * l2), h2 >= 0 ? (r2 = (t2.min.y - c2.y) * h2, o2 = (t2.max.y - c2.y) * h2) : (r2 = (t2.max.y - c2.y) * h2, o2 = (t2.min.y - c2.y) * h2), i2 > o2 || r2 > n2 ? null : ((r2 > i2 || i2 != i2) && (i2 = r2), (o2 < n2 || n2 != n2) && (n2 = o2), u2 >= 0 ? (s2 = (t2.min.z - c2.z) * u2, a2 = (t2.max.z - c2.z) * u2) : (s2 = (t2.max.z - c2.z) * u2, a2 = (t2.min.z - c2.z) * u2), i2 > a2 || s2 > n2 ? null : ((s2 > i2 || i2 != i2) && (i2 = s2), (a2 < n2 || n2 != n2) && (n2 = a2), n2 < 0 ? null : this.at(i2 >= 0 ? i2 : n2, e2)));
        }
        intersectsBox(t2) {
          return null !== this.intersectBox(t2, J);
        }
        intersectTriangle(t2, e2, i2, n2, r2) {
          tt.subVectors(e2, t2), et.subVectors(i2, t2), it.crossVectors(tt, et);
          let o2, s2 = this.direction.dot(it);
          if (s2 > 0) {
            if (n2) return null;
            o2 = 1;
          } else {
            if (!(s2 < 0)) return null;
            o2 = -1, s2 = -s2;
          }
          $.subVectors(this.origin, t2);
          const a2 = o2 * this.direction.dot(et.crossVectors($, et));
          if (a2 < 0) return null;
          const l2 = o2 * this.direction.dot(tt.cross($));
          if (l2 < 0) return null;
          if (a2 + l2 > s2) return null;
          const h2 = -o2 * $.dot(it);
          return h2 < 0 ? null : this.at(h2 / s2, r2);
        }
        applyMatrix4(t2) {
          return this.origin.applyMatrix4(t2), this.direction.transformDirection(t2), this;
        }
        equals(t2) {
          return t2.origin.equals(this.origin) && t2.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class rt {
        constructor() {
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
        set(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2) {
          const g2 = this.elements;
          return g2[0] = t2, g2[4] = e2, g2[8] = i2, g2[12] = n2, g2[1] = r2, g2[5] = o2, g2[9] = s2, g2[13] = a2, g2[2] = l2, g2[6] = h2, g2[10] = u2, g2[14] = c2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new rt().fromArray(this.elements);
        }
        copy(t2) {
          const e2 = this.elements, i2 = t2.elements;
          return e2[0] = i2[0], e2[1] = i2[1], e2[2] = i2[2], e2[3] = i2[3], e2[4] = i2[4], e2[5] = i2[5], e2[6] = i2[6], e2[7] = i2[7], e2[8] = i2[8], e2[9] = i2[9], e2[10] = i2[10], e2[11] = i2[11], e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], e2[15] = i2[15], this;
        }
        copyPosition(t2) {
          const e2 = this.elements, i2 = t2.elements;
          return e2[12] = i2[12], e2[13] = i2[13], e2[14] = i2[14], this;
        }
        setFromMatrix3(t2) {
          const e2 = t2.elements;
          return this.set(e2[0], e2[3], e2[6], 0, e2[1], e2[4], e2[7], 0, e2[2], e2[5], e2[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(t2, e2, i2) {
          return t2.setFromMatrixColumn(this, 0), e2.setFromMatrixColumn(this, 1), i2.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(t2, e2, i2) {
          return this.set(t2.x, e2.x, i2.x, 0, t2.y, e2.y, i2.y, 0, t2.z, e2.z, i2.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(t2) {
          const e2 = this.elements, i2 = t2.elements, n2 = 1 / ot.setFromMatrixColumn(t2, 0).length(), r2 = 1 / ot.setFromMatrixColumn(t2, 1).length(), o2 = 1 / ot.setFromMatrixColumn(t2, 2).length();
          return e2[0] = i2[0] * n2, e2[1] = i2[1] * n2, e2[2] = i2[2] * n2, e2[3] = 0, e2[4] = i2[4] * r2, e2[5] = i2[5] * r2, e2[6] = i2[6] * r2, e2[7] = 0, e2[8] = i2[8] * o2, e2[9] = i2[9] * o2, e2[10] = i2[10] * o2, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
        }
        makeRotationFromEuler(t2) {
          t2 && t2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
          const e2 = this.elements, i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = Math.cos(i2), s2 = Math.sin(i2), a2 = Math.cos(n2), l2 = Math.sin(n2), h2 = Math.cos(r2), u2 = Math.sin(r2);
          if ("XYZ" === t2.order) {
            const t3 = o2 * h2, i3 = o2 * u2, n3 = s2 * h2, r3 = s2 * u2;
            e2[0] = a2 * h2, e2[4] = -a2 * u2, e2[8] = l2, e2[1] = i3 + n3 * l2, e2[5] = t3 - r3 * l2, e2[9] = -s2 * a2, e2[2] = r3 - t3 * l2, e2[6] = n3 + i3 * l2, e2[10] = o2 * a2;
          } else if ("YXZ" === t2.order) {
            const t3 = a2 * h2, i3 = a2 * u2, n3 = l2 * h2, r3 = l2 * u2;
            e2[0] = t3 + r3 * s2, e2[4] = n3 * s2 - i3, e2[8] = o2 * l2, e2[1] = o2 * u2, e2[5] = o2 * h2, e2[9] = -s2, e2[2] = i3 * s2 - n3, e2[6] = r3 + t3 * s2, e2[10] = o2 * a2;
          } else if ("ZXY" === t2.order) {
            const t3 = a2 * h2, i3 = a2 * u2, n3 = l2 * h2, r3 = l2 * u2;
            e2[0] = t3 - r3 * s2, e2[4] = -o2 * u2, e2[8] = n3 + i3 * s2, e2[1] = i3 + n3 * s2, e2[5] = o2 * h2, e2[9] = r3 - t3 * s2, e2[2] = -o2 * l2, e2[6] = s2, e2[10] = o2 * a2;
          } else if ("ZYX" === t2.order) {
            const t3 = o2 * h2, i3 = o2 * u2, n3 = s2 * h2, r3 = s2 * u2;
            e2[0] = a2 * h2, e2[4] = n3 * l2 - i3, e2[8] = t3 * l2 + r3, e2[1] = a2 * u2, e2[5] = r3 * l2 + t3, e2[9] = i3 * l2 - n3, e2[2] = -l2, e2[6] = s2 * a2, e2[10] = o2 * a2;
          } else if ("YZX" === t2.order) {
            const t3 = o2 * a2, i3 = o2 * l2, n3 = s2 * a2, r3 = s2 * l2;
            e2[0] = a2 * h2, e2[4] = r3 - t3 * u2, e2[8] = n3 * u2 + i3, e2[1] = u2, e2[5] = o2 * h2, e2[9] = -s2 * h2, e2[2] = -l2 * h2, e2[6] = i3 * u2 + n3, e2[10] = t3 - r3 * u2;
          } else if ("XZY" === t2.order) {
            const t3 = o2 * a2, i3 = o2 * l2, n3 = s2 * a2, r3 = s2 * l2;
            e2[0] = a2 * h2, e2[4] = -u2, e2[8] = l2 * h2, e2[1] = t3 * u2 + r3, e2[5] = o2 * h2, e2[9] = i3 * u2 - n3, e2[2] = n3 * u2 - i3, e2[6] = s2 * h2, e2[10] = r3 * u2 + t3;
          }
          return e2[3] = 0, e2[7] = 0, e2[11] = 0, e2[12] = 0, e2[13] = 0, e2[14] = 0, e2[15] = 1, this;
        }
        makeRotationFromQuaternion(t2) {
          return this.compose(at, t2, lt);
        }
        lookAt(t2, e2, i2) {
          const n2 = this.elements;
          return ct.subVectors(t2, e2), 0 === ct.lengthSq() && (ct.z = 1), ct.normalize(), ht.crossVectors(i2, ct), 0 === ht.lengthSq() && (1 === Math.abs(i2.z) ? ct.x += 1e-4 : ct.z += 1e-4, ct.normalize(), ht.crossVectors(i2, ct)), ht.normalize(), ut.crossVectors(ct, ht), n2[0] = ht.x, n2[4] = ut.x, n2[8] = ct.x, n2[1] = ht.y, n2[5] = ut.y, n2[9] = ct.y, n2[2] = ht.z, n2[6] = ut.z, n2[10] = ct.z, this;
        }
        multiply(t2, e2) {
          return void 0 !== e2 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t2, e2)) : this.multiplyMatrices(this, t2);
        }
        premultiply(t2) {
          return this.multiplyMatrices(t2, this);
        }
        multiplyMatrices(t2, e2) {
          const i2 = t2.elements, n2 = e2.elements, r2 = this.elements, o2 = i2[0], s2 = i2[4], a2 = i2[8], l2 = i2[12], h2 = i2[1], u2 = i2[5], c2 = i2[9], d2 = i2[13], p2 = i2[2], f2 = i2[6], m2 = i2[10], g2 = i2[14], v2 = i2[3], _2 = i2[7], y2 = i2[11], x2 = i2[15], b2 = n2[0], T2 = n2[4], E2 = n2[8], S2 = n2[12], w2 = n2[1], A2 = n2[5], M2 = n2[9], C2 = n2[13], R2 = n2[2], I2 = n2[6], P2 = n2[10], O2 = n2[14], N2 = n2[3], L2 = n2[7], D2 = n2[11], F2 = n2[15];
          return r2[0] = o2 * b2 + s2 * w2 + a2 * R2 + l2 * N2, r2[4] = o2 * T2 + s2 * A2 + a2 * I2 + l2 * L2, r2[8] = o2 * E2 + s2 * M2 + a2 * P2 + l2 * D2, r2[12] = o2 * S2 + s2 * C2 + a2 * O2 + l2 * F2, r2[1] = h2 * b2 + u2 * w2 + c2 * R2 + d2 * N2, r2[5] = h2 * T2 + u2 * A2 + c2 * I2 + d2 * L2, r2[9] = h2 * E2 + u2 * M2 + c2 * P2 + d2 * D2, r2[13] = h2 * S2 + u2 * C2 + c2 * O2 + d2 * F2, r2[2] = p2 * b2 + f2 * w2 + m2 * R2 + g2 * N2, r2[6] = p2 * T2 + f2 * A2 + m2 * I2 + g2 * L2, r2[10] = p2 * E2 + f2 * M2 + m2 * P2 + g2 * D2, r2[14] = p2 * S2 + f2 * C2 + m2 * O2 + g2 * F2, r2[3] = v2 * b2 + _2 * w2 + y2 * R2 + x2 * N2, r2[7] = v2 * T2 + _2 * A2 + y2 * I2 + x2 * L2, r2[11] = v2 * E2 + _2 * M2 + y2 * P2 + x2 * D2, r2[15] = v2 * S2 + _2 * C2 + y2 * O2 + x2 * F2, this;
        }
        multiplyScalar(t2) {
          const e2 = this.elements;
          return e2[0] *= t2, e2[4] *= t2, e2[8] *= t2, e2[12] *= t2, e2[1] *= t2, e2[5] *= t2, e2[9] *= t2, e2[13] *= t2, e2[2] *= t2, e2[6] *= t2, e2[10] *= t2, e2[14] *= t2, e2[3] *= t2, e2[7] *= t2, e2[11] *= t2, e2[15] *= t2, this;
        }
        determinant() {
          const t2 = this.elements, e2 = t2[0], i2 = t2[4], n2 = t2[8], r2 = t2[12], o2 = t2[1], s2 = t2[5], a2 = t2[9], l2 = t2[13], h2 = t2[2], u2 = t2[6], c2 = t2[10], d2 = t2[14];
          return t2[3] * (+r2 * a2 * u2 - n2 * l2 * u2 - r2 * s2 * c2 + i2 * l2 * c2 + n2 * s2 * d2 - i2 * a2 * d2) + t2[7] * (+e2 * a2 * d2 - e2 * l2 * c2 + r2 * o2 * c2 - n2 * o2 * d2 + n2 * l2 * h2 - r2 * a2 * h2) + t2[11] * (+e2 * l2 * u2 - e2 * s2 * d2 - r2 * o2 * u2 + i2 * o2 * d2 + r2 * s2 * h2 - i2 * l2 * h2) + t2[15] * (-n2 * s2 * h2 - e2 * a2 * u2 + e2 * s2 * c2 + n2 * o2 * u2 - i2 * o2 * c2 + i2 * a2 * h2);
        }
        transpose() {
          const t2 = this.elements;
          let e2;
          return e2 = t2[1], t2[1] = t2[4], t2[4] = e2, e2 = t2[2], t2[2] = t2[8], t2[8] = e2, e2 = t2[6], t2[6] = t2[9], t2[9] = e2, e2 = t2[3], t2[3] = t2[12], t2[12] = e2, e2 = t2[7], t2[7] = t2[13], t2[13] = e2, e2 = t2[11], t2[11] = t2[14], t2[14] = e2, this;
        }
        setPosition(t2, e2, i2) {
          const n2 = this.elements;
          return t2.isVector3 ? (n2[12] = t2.x, n2[13] = t2.y, n2[14] = t2.z) : (n2[12] = t2, n2[13] = e2, n2[14] = i2), this;
        }
        invert() {
          const t2 = this.elements, e2 = t2[0], i2 = t2[1], n2 = t2[2], r2 = t2[3], o2 = t2[4], s2 = t2[5], a2 = t2[6], l2 = t2[7], h2 = t2[8], u2 = t2[9], c2 = t2[10], d2 = t2[11], p2 = t2[12], f2 = t2[13], m2 = t2[14], g2 = t2[15], v2 = u2 * m2 * l2 - f2 * c2 * l2 + f2 * a2 * d2 - s2 * m2 * d2 - u2 * a2 * g2 + s2 * c2 * g2, _2 = p2 * c2 * l2 - h2 * m2 * l2 - p2 * a2 * d2 + o2 * m2 * d2 + h2 * a2 * g2 - o2 * c2 * g2, y2 = h2 * f2 * l2 - p2 * u2 * l2 + p2 * s2 * d2 - o2 * f2 * d2 - h2 * s2 * g2 + o2 * u2 * g2, x2 = p2 * u2 * a2 - h2 * f2 * a2 - p2 * s2 * c2 + o2 * f2 * c2 + h2 * s2 * m2 - o2 * u2 * m2, b2 = e2 * v2 + i2 * _2 + n2 * y2 + r2 * x2;
          if (0 === b2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const T2 = 1 / b2;
          return t2[0] = v2 * T2, t2[1] = (f2 * c2 * r2 - u2 * m2 * r2 - f2 * n2 * d2 + i2 * m2 * d2 + u2 * n2 * g2 - i2 * c2 * g2) * T2, t2[2] = (s2 * m2 * r2 - f2 * a2 * r2 + f2 * n2 * l2 - i2 * m2 * l2 - s2 * n2 * g2 + i2 * a2 * g2) * T2, t2[3] = (u2 * a2 * r2 - s2 * c2 * r2 - u2 * n2 * l2 + i2 * c2 * l2 + s2 * n2 * d2 - i2 * a2 * d2) * T2, t2[4] = _2 * T2, t2[5] = (h2 * m2 * r2 - p2 * c2 * r2 + p2 * n2 * d2 - e2 * m2 * d2 - h2 * n2 * g2 + e2 * c2 * g2) * T2, t2[6] = (p2 * a2 * r2 - o2 * m2 * r2 - p2 * n2 * l2 + e2 * m2 * l2 + o2 * n2 * g2 - e2 * a2 * g2) * T2, t2[7] = (o2 * c2 * r2 - h2 * a2 * r2 + h2 * n2 * l2 - e2 * c2 * l2 - o2 * n2 * d2 + e2 * a2 * d2) * T2, t2[8] = y2 * T2, t2[9] = (p2 * u2 * r2 - h2 * f2 * r2 - p2 * i2 * d2 + e2 * f2 * d2 + h2 * i2 * g2 - e2 * u2 * g2) * T2, t2[10] = (o2 * f2 * r2 - p2 * s2 * r2 + p2 * i2 * l2 - e2 * f2 * l2 - o2 * i2 * g2 + e2 * s2 * g2) * T2, t2[11] = (h2 * s2 * r2 - o2 * u2 * r2 - h2 * i2 * l2 + e2 * u2 * l2 + o2 * i2 * d2 - e2 * s2 * d2) * T2, t2[12] = x2 * T2, t2[13] = (h2 * f2 * n2 - p2 * u2 * n2 + p2 * i2 * c2 - e2 * f2 * c2 - h2 * i2 * m2 + e2 * u2 * m2) * T2, t2[14] = (p2 * s2 * n2 - o2 * f2 * n2 - p2 * i2 * a2 + e2 * f2 * a2 + o2 * i2 * m2 - e2 * s2 * m2) * T2, t2[15] = (o2 * u2 * n2 - h2 * s2 * n2 + h2 * i2 * a2 - e2 * u2 * a2 - o2 * i2 * c2 + e2 * s2 * c2) * T2, this;
        }
        scale(t2) {
          const e2 = this.elements, i2 = t2.x, n2 = t2.y, r2 = t2.z;
          return e2[0] *= i2, e2[4] *= n2, e2[8] *= r2, e2[1] *= i2, e2[5] *= n2, e2[9] *= r2, e2[2] *= i2, e2[6] *= n2, e2[10] *= r2, e2[3] *= i2, e2[7] *= n2, e2[11] *= r2, this;
        }
        getMaxScaleOnAxis() {
          const t2 = this.elements, e2 = t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2], i2 = t2[4] * t2[4] + t2[5] * t2[5] + t2[6] * t2[6], n2 = t2[8] * t2[8] + t2[9] * t2[9] + t2[10] * t2[10];
          return Math.sqrt(Math.max(e2, i2, n2));
        }
        makeTranslation(t2, e2, i2) {
          return this.set(1, 0, 0, t2, 0, 1, 0, e2, 0, 0, 1, i2, 0, 0, 0, 1), this;
        }
        makeRotationX(t2) {
          const e2 = Math.cos(t2), i2 = Math.sin(t2);
          return this.set(1, 0, 0, 0, 0, e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(t2) {
          const e2 = Math.cos(t2), i2 = Math.sin(t2);
          return this.set(e2, 0, i2, 0, 0, 1, 0, 0, -i2, 0, e2, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(t2) {
          const e2 = Math.cos(t2), i2 = Math.sin(t2);
          return this.set(e2, -i2, 0, 0, i2, e2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(t2, e2) {
          const i2 = Math.cos(e2), n2 = Math.sin(e2), r2 = 1 - i2, o2 = t2.x, s2 = t2.y, a2 = t2.z, l2 = r2 * o2, h2 = r2 * s2;
          return this.set(l2 * o2 + i2, l2 * s2 - n2 * a2, l2 * a2 + n2 * s2, 0, l2 * s2 + n2 * a2, h2 * s2 + i2, h2 * a2 - n2 * o2, 0, l2 * a2 - n2 * s2, h2 * a2 + n2 * o2, r2 * a2 * a2 + i2, 0, 0, 0, 0, 1), this;
        }
        makeScale(t2, e2, i2) {
          return this.set(t2, 0, 0, 0, 0, e2, 0, 0, 0, 0, i2, 0, 0, 0, 0, 1), this;
        }
        makeShear(t2, e2, i2, n2, r2, o2) {
          return this.set(1, i2, r2, 0, t2, 1, o2, 0, e2, n2, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t2, e2, i2) {
          const n2 = this.elements, r2 = e2._x, o2 = e2._y, s2 = e2._z, a2 = e2._w, l2 = r2 + r2, h2 = o2 + o2, u2 = s2 + s2, c2 = r2 * l2, d2 = r2 * h2, p2 = r2 * u2, f2 = o2 * h2, m2 = o2 * u2, g2 = s2 * u2, v2 = a2 * l2, _2 = a2 * h2, y2 = a2 * u2, x2 = i2.x, b2 = i2.y, T2 = i2.z;
          return n2[0] = (1 - (f2 + g2)) * x2, n2[1] = (d2 + y2) * x2, n2[2] = (p2 - _2) * x2, n2[3] = 0, n2[4] = (d2 - y2) * b2, n2[5] = (1 - (c2 + g2)) * b2, n2[6] = (m2 + v2) * b2, n2[7] = 0, n2[8] = (p2 + _2) * T2, n2[9] = (m2 - v2) * T2, n2[10] = (1 - (c2 + f2)) * T2, n2[11] = 0, n2[12] = t2.x, n2[13] = t2.y, n2[14] = t2.z, n2[15] = 1, this;
        }
        decompose(t2, e2, i2) {
          const n2 = this.elements;
          let r2 = ot.set(n2[0], n2[1], n2[2]).length();
          const o2 = ot.set(n2[4], n2[5], n2[6]).length(), s2 = ot.set(n2[8], n2[9], n2[10]).length();
          this.determinant() < 0 && (r2 = -r2), t2.x = n2[12], t2.y = n2[13], t2.z = n2[14], st.copy(this);
          const a2 = 1 / r2, l2 = 1 / o2, h2 = 1 / s2;
          return st.elements[0] *= a2, st.elements[1] *= a2, st.elements[2] *= a2, st.elements[4] *= l2, st.elements[5] *= l2, st.elements[6] *= l2, st.elements[8] *= h2, st.elements[9] *= h2, st.elements[10] *= h2, e2.setFromRotationMatrix(st), i2.x = r2, i2.y = o2, i2.z = s2, this;
        }
        makePerspective(t2, e2, i2, n2, r2, o2) {
          void 0 === o2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
          const s2 = this.elements, a2 = 2 * r2 / (e2 - t2), l2 = 2 * r2 / (i2 - n2), h2 = (e2 + t2) / (e2 - t2), u2 = (i2 + n2) / (i2 - n2), c2 = -(o2 + r2) / (o2 - r2), d2 = -2 * o2 * r2 / (o2 - r2);
          return s2[0] = a2, s2[4] = 0, s2[8] = h2, s2[12] = 0, s2[1] = 0, s2[5] = l2, s2[9] = u2, s2[13] = 0, s2[2] = 0, s2[6] = 0, s2[10] = c2, s2[14] = d2, s2[3] = 0, s2[7] = 0, s2[11] = -1, s2[15] = 0, this;
        }
        makeOrthographic(t2, e2, i2, n2, r2, o2) {
          const s2 = this.elements, a2 = 1 / (e2 - t2), l2 = 1 / (i2 - n2), h2 = 1 / (o2 - r2), u2 = (e2 + t2) * a2, c2 = (i2 + n2) * l2, d2 = (o2 + r2) * h2;
          return s2[0] = 2 * a2, s2[4] = 0, s2[8] = 0, s2[12] = -u2, s2[1] = 0, s2[5] = 2 * l2, s2[9] = 0, s2[13] = -c2, s2[2] = 0, s2[6] = 0, s2[10] = -2 * h2, s2[14] = -d2, s2[3] = 0, s2[7] = 0, s2[11] = 0, s2[15] = 1, this;
        }
        equals(t2) {
          const e2 = this.elements, i2 = t2.elements;
          for (let t3 = 0; t3 < 16; t3++) if (e2[t3] !== i2[t3]) return false;
          return true;
        }
        fromArray(t2, e2 = 0) {
          for (let i2 = 0; i2 < 16; i2++) this.elements[i2] = t2[i2 + e2];
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const i2 = this.elements;
          return t2[e2] = i2[0], t2[e2 + 1] = i2[1], t2[e2 + 2] = i2[2], t2[e2 + 3] = i2[3], t2[e2 + 4] = i2[4], t2[e2 + 5] = i2[5], t2[e2 + 6] = i2[6], t2[e2 + 7] = i2[7], t2[e2 + 8] = i2[8], t2[e2 + 9] = i2[9], t2[e2 + 10] = i2[10], t2[e2 + 11] = i2[11], t2[e2 + 12] = i2[12], t2[e2 + 13] = i2[13], t2[e2 + 14] = i2[14], t2[e2 + 15] = i2[15], t2;
        }
      }
      rt.prototype.isMatrix4 = true;
      const ot = new M(), st = new rt(), at = new M(0, 0, 0), lt = new M(1, 1, 1), ht = new M(), ut = new M(), ct = new M(), dt = new rt(), pt = new A();
      class ft {
        constructor(t2 = 0, e2 = 0, i2 = 0, n2 = ft.DefaultOrder) {
          this._x = t2, this._y = e2, this._z = i2, this._order = n2;
        }
        get x() {
          return this._x;
        }
        set x(t2) {
          this._x = t2, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t2) {
          this._y = t2, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t2) {
          this._z = t2, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t2) {
          this._order = t2, this._onChangeCallback();
        }
        set(t2, e2, i2, n2 = this._order) {
          return this._x = t2, this._y = e2, this._z = i2, this._order = n2, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t2) {
          return this._x = t2._x, this._y = t2._y, this._z = t2._z, this._order = t2._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(t2, e2 = this._order, i2 = true) {
          const n2 = t2.elements, r2 = n2[0], o2 = n2[4], s2 = n2[8], a2 = n2[1], l2 = n2[5], h2 = n2[9], u2 = n2[2], d2 = n2[6], p2 = n2[10];
          switch (e2) {
            case "XYZ":
              this._y = Math.asin(c(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(-h2, p2), this._z = Math.atan2(-o2, r2)) : (this._x = Math.atan2(d2, l2), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-c(h2, -1, 1)), Math.abs(h2) < 0.9999999 ? (this._y = Math.atan2(s2, p2), this._z = Math.atan2(a2, l2)) : (this._y = Math.atan2(-u2, r2), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(c(d2, -1, 1)), Math.abs(d2) < 0.9999999 ? (this._y = Math.atan2(-u2, p2), this._z = Math.atan2(-o2, l2)) : (this._y = 0, this._z = Math.atan2(a2, r2));
              break;
            case "ZYX":
              this._y = Math.asin(-c(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._x = Math.atan2(d2, p2), this._z = Math.atan2(a2, r2)) : (this._x = 0, this._z = Math.atan2(-o2, l2));
              break;
            case "YZX":
              this._z = Math.asin(c(a2, -1, 1)), Math.abs(a2) < 0.9999999 ? (this._x = Math.atan2(-h2, l2), this._y = Math.atan2(-u2, r2)) : (this._x = 0, this._y = Math.atan2(s2, p2));
              break;
            case "XZY":
              this._z = Math.asin(-c(o2, -1, 1)), Math.abs(o2) < 0.9999999 ? (this._x = Math.atan2(d2, l2), this._y = Math.atan2(s2, r2)) : (this._x = Math.atan2(-h2, p2), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e2);
          }
          return this._order = e2, true === i2 && this._onChangeCallback(), this;
        }
        setFromQuaternion(t2, e2, i2) {
          return dt.makeRotationFromQuaternion(t2), this.setFromRotationMatrix(dt, e2, i2);
        }
        setFromVector3(t2, e2 = this._order) {
          return this.set(t2.x, t2.y, t2.z, e2);
        }
        reorder(t2) {
          return pt.setFromEuler(this), this.setFromQuaternion(pt, t2);
        }
        equals(t2) {
          return t2._x === this._x && t2._y === this._y && t2._z === this._z && t2._order === this._order;
        }
        fromArray(t2) {
          return this._x = t2[0], this._y = t2[1], this._z = t2[2], void 0 !== t2[3] && (this._order = t2[3]), this._onChangeCallback(), this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this._x, t2[e2 + 1] = this._y, t2[e2 + 2] = this._z, t2[e2 + 3] = this._order, t2;
        }
        toVector3(t2) {
          return t2 ? t2.set(this._x, this._y, this._z) : new M(this._x, this._y, this._z);
        }
        _onChange(t2) {
          return this._onChangeCallback = t2, this;
        }
        _onChangeCallback() {
        }
      }
      ft.prototype.isEuler = true, ft.DefaultOrder = "XYZ", ft.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class mt {
        constructor() {
          this.mask = 1;
        }
        set(t2) {
          this.mask = 1 << t2 | 0;
        }
        enable(t2) {
          this.mask |= 1 << t2 | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t2) {
          this.mask ^= 1 << t2 | 0;
        }
        disable(t2) {
          this.mask &= ~(1 << t2 | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t2) {
          return 0 != (this.mask & t2.mask);
        }
      }
      let gt = 0;
      const vt = new M(), _t = new A(), yt = new rt(), xt = new M(), bt = new M(), Tt = new M(), Et = new A(), St = new M(1, 0, 0), wt = new M(0, 1, 0), At = new M(0, 0, 1), Mt = { type: "added" }, Ct = { type: "removed" };
      class Rt extends s {
        constructor() {
          super(), Object.defineProperty(this, "id", { value: gt++ }), this.uuid = u(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Rt.DefaultUp.clone();
          const t2 = new M(), e2 = new ft(), i2 = new A(), n2 = new M(1, 1, 1);
          e2._onChange(function() {
            i2.setFromEuler(e2, false);
          }), i2._onChange(function() {
            e2.setFromQuaternion(i2, void 0, false);
          }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t2 }, rotation: { configurable: true, enumerable: true, value: e2 }, quaternion: { configurable: true, enumerable: true, value: i2 }, scale: { configurable: true, enumerable: true, value: n2 }, modelViewMatrix: { value: new rt() }, normalMatrix: { value: new v() } }), this.matrix = new rt(), this.matrixWorld = new rt(), this.matrixAutoUpdate = Rt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new mt(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(t2) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t2), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t2) {
          return this.quaternion.premultiply(t2), this;
        }
        setRotationFromAxisAngle(t2, e2) {
          this.quaternion.setFromAxisAngle(t2, e2);
        }
        setRotationFromEuler(t2) {
          this.quaternion.setFromEuler(t2, true);
        }
        setRotationFromMatrix(t2) {
          this.quaternion.setFromRotationMatrix(t2);
        }
        setRotationFromQuaternion(t2) {
          this.quaternion.copy(t2);
        }
        rotateOnAxis(t2, e2) {
          return _t.setFromAxisAngle(t2, e2), this.quaternion.multiply(_t), this;
        }
        rotateOnWorldAxis(t2, e2) {
          return _t.setFromAxisAngle(t2, e2), this.quaternion.premultiply(_t), this;
        }
        rotateX(t2) {
          return this.rotateOnAxis(St, t2);
        }
        rotateY(t2) {
          return this.rotateOnAxis(wt, t2);
        }
        rotateZ(t2) {
          return this.rotateOnAxis(At, t2);
        }
        translateOnAxis(t2, e2) {
          return vt.copy(t2).applyQuaternion(this.quaternion), this.position.add(vt.multiplyScalar(e2)), this;
        }
        translateX(t2) {
          return this.translateOnAxis(St, t2);
        }
        translateY(t2) {
          return this.translateOnAxis(wt, t2);
        }
        translateZ(t2) {
          return this.translateOnAxis(At, t2);
        }
        localToWorld(t2) {
          return t2.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(t2) {
          return t2.applyMatrix4(yt.copy(this.matrixWorld).invert());
        }
        lookAt(t2, e2, i2) {
          t2.isVector3 ? xt.copy(t2) : xt.set(t2, e2, i2);
          const n2 = this.parent;
          this.updateWorldMatrix(true, false), bt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? yt.lookAt(bt, xt, this.up) : yt.lookAt(xt, bt, this.up), this.quaternion.setFromRotationMatrix(yt), n2 && (yt.extractRotation(n2.matrixWorld), _t.setFromRotationMatrix(yt), this.quaternion.premultiply(_t.invert()));
        }
        add(t2) {
          if (arguments.length > 1) {
            for (let t3 = 0; t3 < arguments.length; t3++) this.add(arguments[t3]);
            return this;
          }
          return t2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t2), this) : (t2 && t2.isObject3D ? (null !== t2.parent && t2.parent.remove(t2), t2.parent = this, this.children.push(t2), t2.dispatchEvent(Mt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t2), this);
        }
        remove(t2) {
          if (arguments.length > 1) {
            for (let t3 = 0; t3 < arguments.length; t3++) this.remove(arguments[t3]);
            return this;
          }
          const e2 = this.children.indexOf(t2);
          return -1 !== e2 && (t2.parent = null, this.children.splice(e2, 1), t2.dispatchEvent(Ct)), this;
        }
        removeFromParent() {
          const t2 = this.parent;
          return null !== t2 && t2.remove(this), this;
        }
        clear() {
          for (let t2 = 0; t2 < this.children.length; t2++) {
            const e2 = this.children[t2];
            e2.parent = null, e2.dispatchEvent(Ct);
          }
          return this.children.length = 0, this;
        }
        attach(t2) {
          return this.updateWorldMatrix(true, false), yt.copy(this.matrixWorld).invert(), null !== t2.parent && (t2.parent.updateWorldMatrix(true, false), yt.multiply(t2.parent.matrixWorld)), t2.applyMatrix4(yt), this.add(t2), t2.updateWorldMatrix(false, true), this;
        }
        getObjectById(t2) {
          return this.getObjectByProperty("id", t2);
        }
        getObjectByName(t2) {
          return this.getObjectByProperty("name", t2);
        }
        getObjectByProperty(t2, e2) {
          if (this[t2] === e2) return this;
          for (let i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
            const n3 = this.children[i2].getObjectByProperty(t2, e2);
            if (void 0 !== n3) return n3;
          }
        }
        getWorldPosition(t2) {
          return this.updateWorldMatrix(true, false), t2.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(t2) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(bt, t2, Tt), t2;
        }
        getWorldScale(t2) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(bt, Et, t2), t2;
        }
        getWorldDirection(t2) {
          this.updateWorldMatrix(true, false);
          const e2 = this.matrixWorld.elements;
          return t2.set(e2[8], e2[9], e2[10]).normalize();
        }
        raycast() {
        }
        traverse(t2) {
          t2(this);
          const e2 = this.children;
          for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].traverse(t2);
        }
        traverseVisible(t2) {
          if (false === this.visible) return;
          t2(this);
          const e2 = this.children;
          for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].traverseVisible(t2);
        }
        traverseAncestors(t2) {
          const e2 = this.parent;
          null !== e2 && (t2(e2), e2.traverseAncestors(t2));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(t2) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t2 = true);
          const e2 = this.children;
          for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) e2[i2].updateMatrixWorld(t2);
        }
        updateWorldMatrix(t2, e2) {
          const i2 = this.parent;
          if (true === t2 && null !== i2 && i2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === e2) {
            const t3 = this.children;
            for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) t3[e3].updateWorldMatrix(false, true);
          }
        }
        toJSON(t2) {
          const e2 = void 0 === t2 || "string" == typeof t2, i2 = {};
          e2 && (t2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, i2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
          const n2 = {};
          function r2(e3, i3) {
            return void 0 === e3[i3.uuid] && (e3[i3.uuid] = i3.toJSON(t2)), i3.uuid;
          }
          if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), true === this.castShadow && (n2.castShadow = true), true === this.receiveShadow && (n2.receiveShadow = true), false === this.visible && (n2.visible = false), false === this.frustumCulled && (n2.frustumCulled = false), 0 !== this.renderOrder && (n2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), n2.layers = this.layers.mask, n2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (n2.matrixAutoUpdate = false), this.isInstancedMesh && (n2.type = "InstancedMesh", n2.count = this.count, n2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (n2.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? n2.background = this.background.toJSON() : this.background.isTexture && (n2.background = this.background.toJSON(t2).uuid)), this.environment && this.environment.isTexture && (n2.environment = this.environment.toJSON(t2).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            n2.geometry = r2(t2.geometries, this.geometry);
            const e3 = this.geometry.parameters;
            if (void 0 !== e3 && void 0 !== e3.shapes) {
              const i3 = e3.shapes;
              if (Array.isArray(i3)) for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
                const n4 = i3[e4];
                r2(t2.shapes, n4);
              }
              else r2(t2.shapes, i3);
            }
          }
          if (this.isSkinnedMesh && (n2.bindMode = this.bindMode, n2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r2(t2.skeletons, this.skeleton), n2.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
            const e3 = [];
            for (let i3 = 0, n3 = this.material.length; i3 < n3; i3++) e3.push(r2(t2.materials, this.material[i3]));
            n2.material = e3;
          } else n2.material = r2(t2.materials, this.material);
          if (this.children.length > 0) {
            n2.children = [];
            for (let e3 = 0; e3 < this.children.length; e3++) n2.children.push(this.children[e3].toJSON(t2).object);
          }
          if (this.animations.length > 0) {
            n2.animations = [];
            for (let e3 = 0; e3 < this.animations.length; e3++) {
              const i3 = this.animations[e3];
              n2.animations.push(r2(t2.animations, i3));
            }
          }
          if (e2) {
            const e3 = o2(t2.geometries), n3 = o2(t2.materials), r3 = o2(t2.textures), s2 = o2(t2.images), a2 = o2(t2.shapes), l2 = o2(t2.skeletons), h2 = o2(t2.animations);
            e3.length > 0 && (i2.geometries = e3), n3.length > 0 && (i2.materials = n3), r3.length > 0 && (i2.textures = r3), s2.length > 0 && (i2.images = s2), a2.length > 0 && (i2.shapes = a2), l2.length > 0 && (i2.skeletons = l2), h2.length > 0 && (i2.animations = h2);
          }
          return i2.object = n2, i2;
          function o2(t3) {
            const e3 = [];
            for (const i3 in t3) {
              const n3 = t3[i3];
              delete n3.metadata, e3.push(n3);
            }
            return e3;
          }
        }
        clone(t2) {
          return new this.constructor().copy(this, t2);
        }
        copy(t2, e2 = true) {
          if (this.name = t2.name, this.up.copy(t2.up), this.position.copy(t2.position), this.rotation.order = t2.rotation.order, this.quaternion.copy(t2.quaternion), this.scale.copy(t2.scale), this.matrix.copy(t2.matrix), this.matrixWorld.copy(t2.matrixWorld), this.matrixAutoUpdate = t2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t2.matrixWorldNeedsUpdate, this.layers.mask = t2.layers.mask, this.visible = t2.visible, this.castShadow = t2.castShadow, this.receiveShadow = t2.receiveShadow, this.frustumCulled = t2.frustumCulled, this.renderOrder = t2.renderOrder, this.userData = JSON.parse(JSON.stringify(t2.userData)), true === e2) for (let e3 = 0; e3 < t2.children.length; e3++) {
            const i2 = t2.children[e3];
            this.add(i2.clone());
          }
          return this;
        }
      }
      Rt.DefaultUp = new M(0, 1, 0), Rt.DefaultMatrixAutoUpdate = true, Rt.prototype.isObject3D = true;
      const It = new M(), Pt = new M(), Ot = new M(), Nt = new M(), Lt = new M(), Dt = new M(), Ft = new M(), Bt = new M(), Ut = new M(), kt = new M();
      class Gt {
        constructor(t2 = new M(), e2 = new M(), i2 = new M()) {
          this.a = t2, this.b = e2, this.c = i2;
        }
        static getNormal(t2, e2, i2, n2) {
          n2.subVectors(i2, e2), It.subVectors(t2, e2), n2.cross(It);
          const r2 = n2.lengthSq();
          return r2 > 0 ? n2.multiplyScalar(1 / Math.sqrt(r2)) : n2.set(0, 0, 0);
        }
        static getBarycoord(t2, e2, i2, n2, r2) {
          It.subVectors(n2, e2), Pt.subVectors(i2, e2), Ot.subVectors(t2, e2);
          const o2 = It.dot(It), s2 = It.dot(Pt), a2 = It.dot(Ot), l2 = Pt.dot(Pt), h2 = Pt.dot(Ot), u2 = o2 * l2 - s2 * s2;
          if (0 === u2) return r2.set(-2, -1, -1);
          const c2 = 1 / u2, d2 = (l2 * a2 - s2 * h2) * c2, p2 = (o2 * h2 - s2 * a2) * c2;
          return r2.set(1 - d2 - p2, p2, d2);
        }
        static containsPoint(t2, e2, i2, n2) {
          return this.getBarycoord(t2, e2, i2, n2, Nt), Nt.x >= 0 && Nt.y >= 0 && Nt.x + Nt.y <= 1;
        }
        static getUV(t2, e2, i2, n2, r2, o2, s2, a2) {
          return this.getBarycoord(t2, e2, i2, n2, Nt), a2.set(0, 0), a2.addScaledVector(r2, Nt.x), a2.addScaledVector(o2, Nt.y), a2.addScaledVector(s2, Nt.z), a2;
        }
        static isFrontFacing(t2, e2, i2, n2) {
          return It.subVectors(i2, e2), Pt.subVectors(t2, e2), It.cross(Pt).dot(n2) < 0;
        }
        set(t2, e2, i2) {
          return this.a.copy(t2), this.b.copy(e2), this.c.copy(i2), this;
        }
        setFromPointsAndIndices(t2, e2, i2, n2) {
          return this.a.copy(t2[e2]), this.b.copy(t2[i2]), this.c.copy(t2[n2]), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.a.copy(t2.a), this.b.copy(t2.b), this.c.copy(t2.c), this;
        }
        getArea() {
          return It.subVectors(this.c, this.b), Pt.subVectors(this.a, this.b), 0.5 * It.cross(Pt).length();
        }
        getMidpoint(t2) {
          return t2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(t2) {
          return Gt.getNormal(this.a, this.b, this.c, t2);
        }
        getPlane(t2) {
          return t2.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t2, e2) {
          return Gt.getBarycoord(t2, this.a, this.b, this.c, e2);
        }
        getUV(t2, e2, i2, n2, r2) {
          return Gt.getUV(t2, this.a, this.b, this.c, e2, i2, n2, r2);
        }
        containsPoint(t2) {
          return Gt.containsPoint(t2, this.a, this.b, this.c);
        }
        isFrontFacing(t2) {
          return Gt.isFrontFacing(this.a, this.b, this.c, t2);
        }
        intersectsBox(t2) {
          return t2.intersectsTriangle(this);
        }
        closestPointToPoint(t2, e2) {
          const i2 = this.a, n2 = this.b, r2 = this.c;
          let o2, s2;
          Lt.subVectors(n2, i2), Dt.subVectors(r2, i2), Bt.subVectors(t2, i2);
          const a2 = Lt.dot(Bt), l2 = Dt.dot(Bt);
          if (a2 <= 0 && l2 <= 0) return e2.copy(i2);
          Ut.subVectors(t2, n2);
          const h2 = Lt.dot(Ut), u2 = Dt.dot(Ut);
          if (h2 >= 0 && u2 <= h2) return e2.copy(n2);
          const c2 = a2 * u2 - h2 * l2;
          if (c2 <= 0 && a2 >= 0 && h2 <= 0) return o2 = a2 / (a2 - h2), e2.copy(i2).addScaledVector(Lt, o2);
          kt.subVectors(t2, r2);
          const d2 = Lt.dot(kt), p2 = Dt.dot(kt);
          if (p2 >= 0 && d2 <= p2) return e2.copy(r2);
          const f2 = d2 * l2 - a2 * p2;
          if (f2 <= 0 && l2 >= 0 && p2 <= 0) return s2 = l2 / (l2 - p2), e2.copy(i2).addScaledVector(Dt, s2);
          const m2 = h2 * p2 - d2 * u2;
          if (m2 <= 0 && u2 - h2 >= 0 && d2 - p2 >= 0) return Ft.subVectors(r2, n2), s2 = (u2 - h2) / (u2 - h2 + (d2 - p2)), e2.copy(n2).addScaledVector(Ft, s2);
          const g2 = 1 / (m2 + f2 + c2);
          return o2 = f2 * g2, s2 = c2 * g2, e2.copy(i2).addScaledVector(Lt, o2).addScaledVector(Dt, s2);
        }
        equals(t2) {
          return t2.a.equals(this.a) && t2.b.equals(this.b) && t2.c.equals(this.c);
        }
      }
      let Ht = 0;
      class jt extends s {
        constructor() {
          super(), Object.defineProperty(this, "id", { value: Ht++ }), this.uuid = u(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
        }
        onBuild() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t2) {
          if (void 0 !== t2) for (const e2 in t2) {
            const i2 = t2[e2];
            if (void 0 === i2) {
              console.warn("THREE.Material: '" + e2 + "' parameter is undefined.");
              continue;
            }
            if ("shading" === e2) {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i2;
              continue;
            }
            const n2 = this[e2];
            void 0 !== n2 ? n2 && n2.isColor ? n2.set(i2) : n2 && n2.isVector3 && i2 && i2.isVector3 ? n2.copy(i2) : this[e2] = i2 : console.warn("THREE." + this.type + ": '" + e2 + "' is not a property of this material.");
          }
        }
        toJSON(t2) {
          const e2 = void 0 === t2 || "string" == typeof t2;
          e2 && (t2 = { textures: {}, images: {} });
          const i2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
          function n2(t3) {
            const e3 = [];
            for (const i3 in t3) {
              const n3 = t3[i3];
              delete n3.metadata, e3.push(n3);
            }
            return e3;
          }
          if (i2.uuid = this.uuid, i2.type = this.type, "" !== this.name && (i2.name = this.name), this.color && this.color.isColor && (i2.color = this.color.getHex()), void 0 !== this.roughness && (i2.roughness = this.roughness), void 0 !== this.metalness && (i2.metalness = this.metalness), this.sheen && this.sheen.isColor && (i2.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i2.specular = this.specular.getHex()), void 0 !== this.shininess && (i2.shininess = this.shininess), void 0 !== this.clearcoat && (i2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i2.clearcoatMap = this.clearcoatMap.toJSON(t2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t2).uuid, i2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i2.map = this.map.toJSON(t2).uuid), this.matcap && this.matcap.isTexture && (i2.matcap = this.matcap.toJSON(t2).uuid), this.alphaMap && this.alphaMap.isTexture && (i2.alphaMap = this.alphaMap.toJSON(t2).uuid), this.lightMap && this.lightMap.isTexture && (i2.lightMap = this.lightMap.toJSON(t2).uuid, i2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i2.aoMap = this.aoMap.toJSON(t2).uuid, i2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i2.bumpMap = this.bumpMap.toJSON(t2).uuid, i2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i2.normalMap = this.normalMap.toJSON(t2).uuid, i2.normalMapType = this.normalMapType, i2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i2.displacementMap = this.displacementMap.toJSON(t2).uuid, i2.displacementScale = this.displacementScale, i2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i2.roughnessMap = this.roughnessMap.toJSON(t2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i2.metalnessMap = this.metalnessMap.toJSON(t2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i2.emissiveMap = this.emissiveMap.toJSON(t2).uuid), this.specularMap && this.specularMap.isTexture && (i2.specularMap = this.specularMap.toJSON(t2).uuid), this.envMap && this.envMap.isTexture && (i2.envMap = this.envMap.toJSON(t2).uuid, void 0 !== this.combine && (i2.combine = this.combine)), void 0 !== this.envMapIntensity && (i2.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i2.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i2.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i2.gradientMap = this.gradientMap.toJSON(t2).uuid), void 0 !== this.transmission && (i2.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i2.transmissionMap = this.transmissionMap.toJSON(t2).uuid), void 0 !== this.thickness && (i2.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i2.thicknessMap = this.thicknessMap.toJSON(t2).uuid), void 0 !== this.attenuationDistance && (i2.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (i2.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (i2.size = this.size), null !== this.shadowSide && (i2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i2.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i2.blending = this.blending), 0 !== this.side && (i2.side = this.side), this.vertexColors && (i2.vertexColors = true), this.opacity < 1 && (i2.opacity = this.opacity), true === this.transparent && (i2.transparent = this.transparent), i2.depthFunc = this.depthFunc, i2.depthTest = this.depthTest, i2.depthWrite = this.depthWrite, i2.colorWrite = this.colorWrite, i2.stencilWrite = this.stencilWrite, i2.stencilWriteMask = this.stencilWriteMask, i2.stencilFunc = this.stencilFunc, i2.stencilRef = this.stencilRef, i2.stencilFuncMask = this.stencilFuncMask, i2.stencilFail = this.stencilFail, i2.stencilZFail = this.stencilZFail, i2.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i2.rotation = this.rotation), true === this.polygonOffset && (i2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (i2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i2.linewidth = this.linewidth), void 0 !== this.dashSize && (i2.dashSize = this.dashSize), void 0 !== this.gapSize && (i2.gapSize = this.gapSize), void 0 !== this.scale && (i2.scale = this.scale), true === this.dithering && (i2.dithering = true), this.alphaTest > 0 && (i2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (i2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (i2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (i2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i2.wireframeLinejoin = this.wireframeLinejoin), true === this.morphTargets && (i2.morphTargets = true), true === this.morphNormals && (i2.morphNormals = true), true === this.flatShading && (i2.flatShading = this.flatShading), false === this.visible && (i2.visible = false), false === this.toneMapped && (i2.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), e2) {
            const e3 = n2(t2.textures), r2 = n2(t2.images);
            e3.length > 0 && (i2.textures = e3), r2.length > 0 && (i2.images = r2);
          }
          return i2;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          this.name = t2.name, this.fog = t2.fog, this.blending = t2.blending, this.side = t2.side, this.vertexColors = t2.vertexColors, this.opacity = t2.opacity, this.transparent = t2.transparent, this.blendSrc = t2.blendSrc, this.blendDst = t2.blendDst, this.blendEquation = t2.blendEquation, this.blendSrcAlpha = t2.blendSrcAlpha, this.blendDstAlpha = t2.blendDstAlpha, this.blendEquationAlpha = t2.blendEquationAlpha, this.depthFunc = t2.depthFunc, this.depthTest = t2.depthTest, this.depthWrite = t2.depthWrite, this.stencilWriteMask = t2.stencilWriteMask, this.stencilFunc = t2.stencilFunc, this.stencilRef = t2.stencilRef, this.stencilFuncMask = t2.stencilFuncMask, this.stencilFail = t2.stencilFail, this.stencilZFail = t2.stencilZFail, this.stencilZPass = t2.stencilZPass, this.stencilWrite = t2.stencilWrite;
          const e2 = t2.clippingPlanes;
          let i2 = null;
          if (null !== e2) {
            const t3 = e2.length;
            i2 = new Array(t3);
            for (let n2 = 0; n2 !== t3; ++n2) i2[n2] = e2[n2].clone();
          }
          return this.clippingPlanes = i2, this.clipIntersection = t2.clipIntersection, this.clipShadows = t2.clipShadows, this.shadowSide = t2.shadowSide, this.colorWrite = t2.colorWrite, this.precision = t2.precision, this.polygonOffset = t2.polygonOffset, this.polygonOffsetFactor = t2.polygonOffsetFactor, this.polygonOffsetUnits = t2.polygonOffsetUnits, this.dithering = t2.dithering, this.alphaTest = t2.alphaTest, this.alphaToCoverage = t2.alphaToCoverage, this.premultipliedAlpha = t2.premultipliedAlpha, this.visible = t2.visible, this.toneMapped = t2.toneMapped, this.userData = JSON.parse(JSON.stringify(t2.userData)), this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
      }
      jt.prototype.isMaterial = true;
      const zt = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Vt = { h: 0, s: 0, l: 0 }, Xt = { h: 0, s: 0, l: 0 };
      function Wt(t2, e2, i2) {
        return i2 < 0 && (i2 += 1), i2 > 1 && (i2 -= 1), i2 < 1 / 6 ? t2 + 6 * (e2 - t2) * i2 : i2 < 0.5 ? e2 : i2 < 2 / 3 ? t2 + 6 * (e2 - t2) * (2 / 3 - i2) : t2;
      }
      function Yt(t2) {
        return t2 < 0.04045 ? 0.0773993808 * t2 : Math.pow(0.9478672986 * t2 + 0.0521327014, 2.4);
      }
      function qt(t2) {
        return t2 < 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 0.41666) - 0.055;
      }
      class Zt {
        constructor(t2, e2, i2) {
          return void 0 === e2 && void 0 === i2 ? this.set(t2) : this.setRGB(t2, e2, i2);
        }
        set(t2) {
          return t2 && t2.isColor ? this.copy(t2) : "number" == typeof t2 ? this.setHex(t2) : "string" == typeof t2 && this.setStyle(t2), this;
        }
        setScalar(t2) {
          return this.r = t2, this.g = t2, this.b = t2, this;
        }
        setHex(t2) {
          return t2 = Math.floor(t2), this.r = (t2 >> 16 & 255) / 255, this.g = (t2 >> 8 & 255) / 255, this.b = (255 & t2) / 255, this;
        }
        setRGB(t2, e2, i2) {
          return this.r = t2, this.g = e2, this.b = i2, this;
        }
        setHSL(t2, e2, i2) {
          if (t2 = d(t2, 1), e2 = c(e2, 0, 1), i2 = c(i2, 0, 1), 0 === e2) this.r = this.g = this.b = i2;
          else {
            const n2 = i2 <= 0.5 ? i2 * (1 + e2) : i2 + e2 - i2 * e2, r2 = 2 * i2 - n2;
            this.r = Wt(r2, n2, t2 + 1 / 3), this.g = Wt(r2, n2, t2), this.b = Wt(r2, n2, t2 - 1 / 3);
          }
          return this;
        }
        setStyle(t2) {
          function e2(e3) {
            void 0 !== e3 && parseFloat(e3) < 1 && console.warn("THREE.Color: Alpha component of " + t2 + " will be ignored.");
          }
          let i2;
          if (i2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t2)) {
            let t3;
            const n2 = i2[1], r2 = i2[2];
            switch (n2) {
              case "rgb":
              case "rgba":
                if (t3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) return this.r = Math.min(255, parseInt(t3[1], 10)) / 255, this.g = Math.min(255, parseInt(t3[2], 10)) / 255, this.b = Math.min(255, parseInt(t3[3], 10)) / 255, e2(t3[4]), this;
                if (t3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) return this.r = Math.min(100, parseInt(t3[1], 10)) / 100, this.g = Math.min(100, parseInt(t3[2], 10)) / 100, this.b = Math.min(100, parseInt(t3[3], 10)) / 100, e2(t3[4]), this;
                break;
              case "hsl":
              case "hsla":
                if (t3 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) {
                  const i3 = parseFloat(t3[1]) / 360, n3 = parseInt(t3[2], 10) / 100, r3 = parseInt(t3[3], 10) / 100;
                  return e2(t3[4]), this.setHSL(i3, n3, r3);
                }
            }
          } else if (i2 = /^\#([A-Fa-f\d]+)$/.exec(t2)) {
            const t3 = i2[1], e3 = t3.length;
            if (3 === e3) return this.r = parseInt(t3.charAt(0) + t3.charAt(0), 16) / 255, this.g = parseInt(t3.charAt(1) + t3.charAt(1), 16) / 255, this.b = parseInt(t3.charAt(2) + t3.charAt(2), 16) / 255, this;
            if (6 === e3) return this.r = parseInt(t3.charAt(0) + t3.charAt(1), 16) / 255, this.g = parseInt(t3.charAt(2) + t3.charAt(3), 16) / 255, this.b = parseInt(t3.charAt(4) + t3.charAt(5), 16) / 255, this;
          }
          return t2 && t2.length > 0 ? this.setColorName(t2) : this;
        }
        setColorName(t2) {
          const e2 = zt[t2.toLowerCase()];
          return void 0 !== e2 ? this.setHex(e2) : console.warn("THREE.Color: Unknown color " + t2), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t2) {
          return this.r = t2.r, this.g = t2.g, this.b = t2.b, this;
        }
        copyGammaToLinear(t2, e2 = 2) {
          return this.r = Math.pow(t2.r, e2), this.g = Math.pow(t2.g, e2), this.b = Math.pow(t2.b, e2), this;
        }
        copyLinearToGamma(t2, e2 = 2) {
          const i2 = e2 > 0 ? 1 / e2 : 1;
          return this.r = Math.pow(t2.r, i2), this.g = Math.pow(t2.g, i2), this.b = Math.pow(t2.b, i2), this;
        }
        convertGammaToLinear(t2) {
          return this.copyGammaToLinear(this, t2), this;
        }
        convertLinearToGamma(t2) {
          return this.copyLinearToGamma(this, t2), this;
        }
        copySRGBToLinear(t2) {
          return this.r = Yt(t2.r), this.g = Yt(t2.g), this.b = Yt(t2.b), this;
        }
        copyLinearToSRGB(t2) {
          return this.r = qt(t2.r), this.g = qt(t2.g), this.b = qt(t2.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex() {
          return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
        }
        getHexString() {
          return ("000000" + this.getHex().toString(16)).slice(-6);
        }
        getHSL(t2) {
          const e2 = this.r, i2 = this.g, n2 = this.b, r2 = Math.max(e2, i2, n2), o2 = Math.min(e2, i2, n2);
          let s2, a2;
          const l2 = (o2 + r2) / 2;
          if (o2 === r2) s2 = 0, a2 = 0;
          else {
            const t3 = r2 - o2;
            switch (a2 = l2 <= 0.5 ? t3 / (r2 + o2) : t3 / (2 - r2 - o2), r2) {
              case e2:
                s2 = (i2 - n2) / t3 + (i2 < n2 ? 6 : 0);
                break;
              case i2:
                s2 = (n2 - e2) / t3 + 2;
                break;
              case n2:
                s2 = (e2 - i2) / t3 + 4;
            }
            s2 /= 6;
          }
          return t2.h = s2, t2.s = a2, t2.l = l2, t2;
        }
        getStyle() {
          return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
        }
        offsetHSL(t2, e2, i2) {
          return this.getHSL(Vt), Vt.h += t2, Vt.s += e2, Vt.l += i2, this.setHSL(Vt.h, Vt.s, Vt.l), this;
        }
        add(t2) {
          return this.r += t2.r, this.g += t2.g, this.b += t2.b, this;
        }
        addColors(t2, e2) {
          return this.r = t2.r + e2.r, this.g = t2.g + e2.g, this.b = t2.b + e2.b, this;
        }
        addScalar(t2) {
          return this.r += t2, this.g += t2, this.b += t2, this;
        }
        sub(t2) {
          return this.r = Math.max(0, this.r - t2.r), this.g = Math.max(0, this.g - t2.g), this.b = Math.max(0, this.b - t2.b), this;
        }
        multiply(t2) {
          return this.r *= t2.r, this.g *= t2.g, this.b *= t2.b, this;
        }
        multiplyScalar(t2) {
          return this.r *= t2, this.g *= t2, this.b *= t2, this;
        }
        lerp(t2, e2) {
          return this.r += (t2.r - this.r) * e2, this.g += (t2.g - this.g) * e2, this.b += (t2.b - this.b) * e2, this;
        }
        lerpColors(t2, e2, i2) {
          return this.r = t2.r + (e2.r - t2.r) * i2, this.g = t2.g + (e2.g - t2.g) * i2, this.b = t2.b + (e2.b - t2.b) * i2, this;
        }
        lerpHSL(t2, e2) {
          this.getHSL(Vt), t2.getHSL(Xt);
          const i2 = p(Vt.h, Xt.h, e2), n2 = p(Vt.s, Xt.s, e2), r2 = p(Vt.l, Xt.l, e2);
          return this.setHSL(i2, n2, r2), this;
        }
        equals(t2) {
          return t2.r === this.r && t2.g === this.g && t2.b === this.b;
        }
        fromArray(t2, e2 = 0) {
          return this.r = t2[e2], this.g = t2[e2 + 1], this.b = t2[e2 + 2], this;
        }
        toArray(t2 = [], e2 = 0) {
          return t2[e2] = this.r, t2[e2 + 1] = this.g, t2[e2 + 2] = this.b, t2;
        }
        fromBufferAttribute(t2, e2) {
          return this.r = t2.getX(e2), this.g = t2.getY(e2), this.b = t2.getZ(e2), true === t2.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
        }
        toJSON() {
          return this.getHex();
        }
      }
      Zt.NAMES = zt, Zt.prototype.isColor = true, Zt.prototype.r = 1, Zt.prototype.g = 1, Zt.prototype.b = 1;
      class Jt extends jt {
        constructor(t2) {
          super(), this.type = "MeshBasicMaterial", this.color = new Zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this;
        }
      }
      Jt.prototype.isMeshBasicMaterial = true;
      const Kt = new M(), Qt = new g();
      class $t {
        constructor(t2, e2, i2) {
          if (Array.isArray(t2)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.name = "", this.array = t2, this.itemSize = e2, this.count = void 0 !== t2 ? t2.length / e2 : 0, this.normalized = true === i2, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
        setUsage(t2) {
          return this.usage = t2, this;
        }
        copy(t2) {
          return this.name = t2.name, this.array = new t2.array.constructor(t2.array), this.itemSize = t2.itemSize, this.count = t2.count, this.normalized = t2.normalized, this.usage = t2.usage, this;
        }
        copyAt(t2, e2, i2) {
          t2 *= this.itemSize, i2 *= e2.itemSize;
          for (let n2 = 0, r2 = this.itemSize; n2 < r2; n2++) this.array[t2 + n2] = e2.array[i2 + n2];
          return this;
        }
        copyArray(t2) {
          return this.array.set(t2), this;
        }
        copyColorsArray(t2) {
          const e2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            let r3 = t2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n2), r3 = new Zt()), e2[i2++] = r3.r, e2[i2++] = r3.g, e2[i2++] = r3.b;
          }
          return this;
        }
        copyVector2sArray(t2) {
          const e2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            let r3 = t2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n2), r3 = new g()), e2[i2++] = r3.x, e2[i2++] = r3.y;
          }
          return this;
        }
        copyVector3sArray(t2) {
          const e2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            let r3 = t2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n2), r3 = new M()), e2[i2++] = r3.x, e2[i2++] = r3.y, e2[i2++] = r3.z;
          }
          return this;
        }
        copyVector4sArray(t2) {
          const e2 = this.array;
          let i2 = 0;
          for (let n2 = 0, r2 = t2.length; n2 < r2; n2++) {
            let r3 = t2[n2];
            void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n2), r3 = new E()), e2[i2++] = r3.x, e2[i2++] = r3.y, e2[i2++] = r3.z, e2[i2++] = r3.w;
          }
          return this;
        }
        applyMatrix3(t2) {
          if (2 === this.itemSize) for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Qt.fromBufferAttribute(this, e2), Qt.applyMatrix3(t2), this.setXY(e2, Qt.x, Qt.y);
          else if (3 === this.itemSize) for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Kt.fromBufferAttribute(this, e2), Kt.applyMatrix3(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
          return this;
        }
        applyMatrix4(t2) {
          for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Kt.x = this.getX(e2), Kt.y = this.getY(e2), Kt.z = this.getZ(e2), Kt.applyMatrix4(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
          return this;
        }
        applyNormalMatrix(t2) {
          for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Kt.x = this.getX(e2), Kt.y = this.getY(e2), Kt.z = this.getZ(e2), Kt.applyNormalMatrix(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
          return this;
        }
        transformDirection(t2) {
          for (let e2 = 0, i2 = this.count; e2 < i2; e2++) Kt.x = this.getX(e2), Kt.y = this.getY(e2), Kt.z = this.getZ(e2), Kt.transformDirection(t2), this.setXYZ(e2, Kt.x, Kt.y, Kt.z);
          return this;
        }
        set(t2, e2 = 0) {
          return this.array.set(t2, e2), this;
        }
        getX(t2) {
          return this.array[t2 * this.itemSize];
        }
        setX(t2, e2) {
          return this.array[t2 * this.itemSize] = e2, this;
        }
        getY(t2) {
          return this.array[t2 * this.itemSize + 1];
        }
        setY(t2, e2) {
          return this.array[t2 * this.itemSize + 1] = e2, this;
        }
        getZ(t2) {
          return this.array[t2 * this.itemSize + 2];
        }
        setZ(t2, e2) {
          return this.array[t2 * this.itemSize + 2] = e2, this;
        }
        getW(t2) {
          return this.array[t2 * this.itemSize + 3];
        }
        setW(t2, e2) {
          return this.array[t2 * this.itemSize + 3] = e2, this;
        }
        setXY(t2, e2, i2) {
          return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = i2, this;
        }
        setXYZ(t2, e2, i2, n2) {
          return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = i2, this.array[t2 + 2] = n2, this;
        }
        setXYZW(t2, e2, i2, n2, r2) {
          return t2 *= this.itemSize, this.array[t2 + 0] = e2, this.array[t2 + 1] = i2, this.array[t2 + 2] = n2, this.array[t2 + 3] = r2, this;
        }
        onUpload(t2) {
          return this.onUploadCallback = t2, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
          return "" !== this.name && (t2.name = this.name), 35044 !== this.usage && (t2.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t2.updateRange = this.updateRange), t2;
        }
      }
      $t.prototype.isBufferAttribute = true;
      class te extends $t {
        constructor(t2, e2, i2) {
          super(new Uint16Array(t2), e2, i2);
        }
      }
      class ee extends $t {
        constructor(t2, e2, i2) {
          super(new Int32Array(t2), e2, i2);
        }
      }
      class ie extends $t {
        constructor(t2, e2, i2) {
          super(new Uint32Array(t2), e2, i2);
        }
      }
      (class extends $t {
        constructor(t2, e2, i2) {
          super(new Uint16Array(t2), e2, i2);
        }
      }).prototype.isFloat16BufferAttribute = true;
      class ne extends $t {
        constructor(t2, e2, i2) {
          super(new Float32Array(t2), e2, i2);
        }
      }
      function re(t2) {
        if (0 === t2.length) return -1 / 0;
        let e2 = t2[0];
        for (let i2 = 1, n2 = t2.length; i2 < n2; ++i2) t2[i2] > e2 && (e2 = t2[i2]);
        return e2;
      }
      Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
      let oe = 0;
      const se = new rt(), ae = new Rt(), le = new M(), he = new I(), ue = new I(), ce = new M();
      class de extends s {
        constructor() {
          super(), Object.defineProperty(this, "id", { value: oe++ }), this.uuid = u(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(t2) {
          return Array.isArray(t2) ? this.index = new (re(t2) > 65535 ? ie : te)(t2, 1) : this.index = t2, this;
        }
        getAttribute(t2) {
          return this.attributes[t2];
        }
        setAttribute(t2, e2) {
          return this.attributes[t2] = e2, this;
        }
        deleteAttribute(t2) {
          return delete this.attributes[t2], this;
        }
        hasAttribute(t2) {
          return void 0 !== this.attributes[t2];
        }
        addGroup(t2, e2, i2 = 0) {
          this.groups.push({ start: t2, count: e2, materialIndex: i2 });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t2, e2) {
          this.drawRange.start = t2, this.drawRange.count = e2;
        }
        applyMatrix4(t2) {
          const e2 = this.attributes.position;
          void 0 !== e2 && (e2.applyMatrix4(t2), e2.needsUpdate = true);
          const i2 = this.attributes.normal;
          if (void 0 !== i2) {
            const e3 = new v().getNormalMatrix(t2);
            i2.applyNormalMatrix(e3), i2.needsUpdate = true;
          }
          const n2 = this.attributes.tangent;
          return void 0 !== n2 && (n2.transformDirection(t2), n2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
        }
        applyQuaternion(t2) {
          return se.makeRotationFromQuaternion(t2), this.applyMatrix4(se), this;
        }
        rotateX(t2) {
          return se.makeRotationX(t2), this.applyMatrix4(se), this;
        }
        rotateY(t2) {
          return se.makeRotationY(t2), this.applyMatrix4(se), this;
        }
        rotateZ(t2) {
          return se.makeRotationZ(t2), this.applyMatrix4(se), this;
        }
        translate(t2, e2, i2) {
          return se.makeTranslation(t2, e2, i2), this.applyMatrix4(se), this;
        }
        scale(t2, e2, i2) {
          return se.makeScale(t2, e2, i2), this.applyMatrix4(se), this;
        }
        lookAt(t2) {
          return ae.lookAt(t2), ae.updateMatrix(), this.applyMatrix4(ae.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(le).negate(), this.translate(le.x, le.y, le.z), this;
        }
        setFromPoints(t2) {
          const e2 = [];
          for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) {
            const n3 = t2[i2];
            e2.push(n3.x, n3.y, n3.z || 0);
          }
          return this.setAttribute("position", new ne(e2, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new I());
          const t2 = this.attributes.position, e2 = this.morphAttributes.position;
          if (t2 && t2.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new M(-1 / 0, -1 / 0, -1 / 0), new M(1 / 0, 1 / 0, 1 / 0));
          if (void 0 !== t2) {
            if (this.boundingBox.setFromBufferAttribute(t2), e2) for (let t3 = 0, i2 = e2.length; t3 < i2; t3++) {
              const i3 = e2[t3];
              he.setFromBufferAttribute(i3), this.morphTargetsRelative ? (ce.addVectors(this.boundingBox.min, he.min), this.boundingBox.expandByPoint(ce), ce.addVectors(this.boundingBox.max, he.max), this.boundingBox.expandByPoint(ce)) : (this.boundingBox.expandByPoint(he.min), this.boundingBox.expandByPoint(he.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Z());
          const t2 = this.attributes.position, e2 = this.morphAttributes.position;
          if (t2 && t2.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new M(), 1 / 0);
          if (t2) {
            const i2 = this.boundingSphere.center;
            if (he.setFromBufferAttribute(t2), e2) for (let t3 = 0, i3 = e2.length; t3 < i3; t3++) {
              const i4 = e2[t3];
              ue.setFromBufferAttribute(i4), this.morphTargetsRelative ? (ce.addVectors(he.min, ue.min), he.expandByPoint(ce), ce.addVectors(he.max, ue.max), he.expandByPoint(ce)) : (he.expandByPoint(ue.min), he.expandByPoint(ue.max));
            }
            he.getCenter(i2);
            let n2 = 0;
            for (let e3 = 0, r2 = t2.count; e3 < r2; e3++) ce.fromBufferAttribute(t2, e3), n2 = Math.max(n2, i2.distanceToSquared(ce));
            if (e2) for (let r2 = 0, o2 = e2.length; r2 < o2; r2++) {
              const o3 = e2[r2], s2 = this.morphTargetsRelative;
              for (let e3 = 0, r3 = o3.count; e3 < r3; e3++) ce.fromBufferAttribute(o3, e3), s2 && (le.fromBufferAttribute(t2, e3), ce.add(le)), n2 = Math.max(n2, i2.distanceToSquared(ce));
            }
            this.boundingSphere.radius = Math.sqrt(n2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeFaceNormals() {
        }
        computeTangents() {
          const t2 = this.index, e2 = this.attributes;
          if (null === t2 || void 0 === e2.position || void 0 === e2.normal || void 0 === e2.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          const i2 = t2.array, n2 = e2.position.array, r2 = e2.normal.array, o2 = e2.uv.array, s2 = n2.length / 3;
          void 0 === e2.tangent && this.setAttribute("tangent", new $t(new Float32Array(4 * s2), 4));
          const a2 = e2.tangent.array, l2 = [], h2 = [];
          for (let t3 = 0; t3 < s2; t3++) l2[t3] = new M(), h2[t3] = new M();
          const u2 = new M(), c2 = new M(), d2 = new M(), p2 = new g(), f2 = new g(), m2 = new g(), v2 = new M(), _2 = new M();
          function y2(t3, e3, i3) {
            u2.fromArray(n2, 3 * t3), c2.fromArray(n2, 3 * e3), d2.fromArray(n2, 3 * i3), p2.fromArray(o2, 2 * t3), f2.fromArray(o2, 2 * e3), m2.fromArray(o2, 2 * i3), c2.sub(u2), d2.sub(u2), f2.sub(p2), m2.sub(p2);
            const r3 = 1 / (f2.x * m2.y - m2.x * f2.y);
            isFinite(r3) && (v2.copy(c2).multiplyScalar(m2.y).addScaledVector(d2, -f2.y).multiplyScalar(r3), _2.copy(d2).multiplyScalar(f2.x).addScaledVector(c2, -m2.x).multiplyScalar(r3), l2[t3].add(v2), l2[e3].add(v2), l2[i3].add(v2), h2[t3].add(_2), h2[e3].add(_2), h2[i3].add(_2));
          }
          let x2 = this.groups;
          0 === x2.length && (x2 = [{ start: 0, count: i2.length }]);
          for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
            const e4 = x2[t3], n3 = e4.start;
            for (let t4 = n3, r3 = n3 + e4.count; t4 < r3; t4 += 3) y2(i2[t4 + 0], i2[t4 + 1], i2[t4 + 2]);
          }
          const b2 = new M(), T2 = new M(), E2 = new M(), S2 = new M();
          function w2(t3) {
            E2.fromArray(r2, 3 * t3), S2.copy(E2);
            const e3 = l2[t3];
            b2.copy(e3), b2.sub(E2.multiplyScalar(E2.dot(e3))).normalize(), T2.crossVectors(S2, e3);
            const i3 = T2.dot(h2[t3]) < 0 ? -1 : 1;
            a2[4 * t3] = b2.x, a2[4 * t3 + 1] = b2.y, a2[4 * t3 + 2] = b2.z, a2[4 * t3 + 3] = i3;
          }
          for (let t3 = 0, e3 = x2.length; t3 < e3; ++t3) {
            const e4 = x2[t3], n3 = e4.start;
            for (let t4 = n3, r3 = n3 + e4.count; t4 < r3; t4 += 3) w2(i2[t4 + 0]), w2(i2[t4 + 1]), w2(i2[t4 + 2]);
          }
        }
        computeVertexNormals() {
          const t2 = this.index, e2 = this.getAttribute("position");
          if (void 0 !== e2) {
            let i2 = this.getAttribute("normal");
            if (void 0 === i2) i2 = new $t(new Float32Array(3 * e2.count), 3), this.setAttribute("normal", i2);
            else for (let t3 = 0, e3 = i2.count; t3 < e3; t3++) i2.setXYZ(t3, 0, 0, 0);
            const n2 = new M(), r2 = new M(), o2 = new M(), s2 = new M(), a2 = new M(), l2 = new M(), h2 = new M(), u2 = new M();
            if (t2) for (let c2 = 0, d2 = t2.count; c2 < d2; c2 += 3) {
              const d3 = t2.getX(c2 + 0), p2 = t2.getX(c2 + 1), f2 = t2.getX(c2 + 2);
              n2.fromBufferAttribute(e2, d3), r2.fromBufferAttribute(e2, p2), o2.fromBufferAttribute(e2, f2), h2.subVectors(o2, r2), u2.subVectors(n2, r2), h2.cross(u2), s2.fromBufferAttribute(i2, d3), a2.fromBufferAttribute(i2, p2), l2.fromBufferAttribute(i2, f2), s2.add(h2), a2.add(h2), l2.add(h2), i2.setXYZ(d3, s2.x, s2.y, s2.z), i2.setXYZ(p2, a2.x, a2.y, a2.z), i2.setXYZ(f2, l2.x, l2.y, l2.z);
            }
            else for (let t3 = 0, s3 = e2.count; t3 < s3; t3 += 3) n2.fromBufferAttribute(e2, t3 + 0), r2.fromBufferAttribute(e2, t3 + 1), o2.fromBufferAttribute(e2, t3 + 2), h2.subVectors(o2, r2), u2.subVectors(n2, r2), h2.cross(u2), i2.setXYZ(t3 + 0, h2.x, h2.y, h2.z), i2.setXYZ(t3 + 1, h2.x, h2.y, h2.z), i2.setXYZ(t3 + 2, h2.x, h2.y, h2.z);
            this.normalizeNormals(), i2.needsUpdate = true;
          }
        }
        merge(t2, e2) {
          if (!t2 || !t2.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t2);
          void 0 === e2 && (e2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
          const i2 = this.attributes;
          for (const n2 in i2) {
            if (void 0 === t2.attributes[n2]) continue;
            const r2 = i2[n2].array, o2 = t2.attributes[n2], s2 = o2.array, a2 = o2.itemSize * e2, l2 = Math.min(s2.length, r2.length - a2);
            for (let t3 = 0, e3 = a2; t3 < l2; t3++, e3++) r2[e3] = s2[t3];
          }
          return this;
        }
        normalizeNormals() {
          const t2 = this.attributes.normal;
          for (let e2 = 0, i2 = t2.count; e2 < i2; e2++) ce.fromBufferAttribute(t2, e2), ce.normalize(), t2.setXYZ(e2, ce.x, ce.y, ce.z);
        }
        toNonIndexed() {
          function t2(t3, e3) {
            const i3 = t3.array, n3 = t3.itemSize, r3 = t3.normalized, o3 = new i3.constructor(e3.length * n3);
            let s2 = 0, a2 = 0;
            for (let r4 = 0, l2 = e3.length; r4 < l2; r4++) {
              s2 = t3.isInterleavedBufferAttribute ? e3[r4] * t3.data.stride + t3.offset : e3[r4] * n3;
              for (let t4 = 0; t4 < n3; t4++) o3[a2++] = i3[s2++];
            }
            return new $t(o3, n3, r3);
          }
          if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const e2 = new de(), i2 = this.index.array, n2 = this.attributes;
          for (const r3 in n2) {
            const o3 = t2(n2[r3], i2);
            e2.setAttribute(r3, o3);
          }
          const r2 = this.morphAttributes;
          for (const n3 in r2) {
            const o3 = [], s2 = r2[n3];
            for (let e3 = 0, n4 = s2.length; e3 < n4; e3++) {
              const n5 = t2(s2[e3], i2);
              o3.push(n5);
            }
            e2.morphAttributes[n3] = o3;
          }
          e2.morphTargetsRelative = this.morphTargetsRelative;
          const o2 = this.groups;
          for (let t3 = 0, i3 = o2.length; t3 < i3; t3++) {
            const i4 = o2[t3];
            e2.addGroup(i4.start, i4.count, i4.materialIndex);
          }
          return e2;
        }
        toJSON() {
          const t2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
          if (t2.uuid = this.uuid, t2.type = this.type, "" !== this.name && (t2.name = this.name), Object.keys(this.userData).length > 0 && (t2.userData = this.userData), void 0 !== this.parameters) {
            const e3 = this.parameters;
            for (const i3 in e3) void 0 !== e3[i3] && (t2[i3] = e3[i3]);
            return t2;
          }
          t2.data = { attributes: {} };
          const e2 = this.index;
          null !== e2 && (t2.data.index = { type: e2.array.constructor.name, array: Array.prototype.slice.call(e2.array) });
          const i2 = this.attributes;
          for (const e3 in i2) {
            const n3 = i2[e3];
            t2.data.attributes[e3] = n3.toJSON(t2.data);
          }
          const n2 = {};
          let r2 = false;
          for (const e3 in this.morphAttributes) {
            const i3 = this.morphAttributes[e3], o3 = [];
            for (let e4 = 0, n3 = i3.length; e4 < n3; e4++) {
              const n4 = i3[e4];
              o3.push(n4.toJSON(t2.data));
            }
            o3.length > 0 && (n2[e3] = o3, r2 = true);
          }
          r2 && (t2.data.morphAttributes = n2, t2.data.morphTargetsRelative = this.morphTargetsRelative);
          const o2 = this.groups;
          o2.length > 0 && (t2.data.groups = JSON.parse(JSON.stringify(o2)));
          const s2 = this.boundingSphere;
          return null !== s2 && (t2.data.boundingSphere = { center: s2.center.toArray(), radius: s2.radius }), t2;
        }
        clone() {
          return new de().copy(this);
        }
        copy(t2) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const e2 = {};
          this.name = t2.name;
          const i2 = t2.index;
          null !== i2 && this.setIndex(i2.clone(e2));
          const n2 = t2.attributes;
          for (const t3 in n2) {
            const i3 = n2[t3];
            this.setAttribute(t3, i3.clone(e2));
          }
          const r2 = t2.morphAttributes;
          for (const t3 in r2) {
            const i3 = [], n3 = r2[t3];
            for (let t4 = 0, r3 = n3.length; t4 < r3; t4++) i3.push(n3[t4].clone(e2));
            this.morphAttributes[t3] = i3;
          }
          this.morphTargetsRelative = t2.morphTargetsRelative;
          const o2 = t2.groups;
          for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
            const e4 = o2[t3];
            this.addGroup(e4.start, e4.count, e4.materialIndex);
          }
          const s2 = t2.boundingBox;
          null !== s2 && (this.boundingBox = s2.clone());
          const a2 = t2.boundingSphere;
          return null !== a2 && (this.boundingSphere = a2.clone()), this.drawRange.start = t2.drawRange.start, this.drawRange.count = t2.drawRange.count, this.userData = t2.userData, this;
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      de.prototype.isBufferGeometry = true;
      const pe = new rt(), fe = new nt(), me = new Z(), ge = new M(), ve = new M(), _e = new M(), ye = new M(), xe = new M(), be = new M(), Te = new M(), Ee = new M(), Se = new M(), we = new g(), Ae = new g(), Me = new g(), Ce = new M(), Re = new M();
      class Ie extends Rt {
        constructor(t2 = new de(), e2 = new Jt()) {
          super(), this.type = "Mesh", this.geometry = t2, this.material = e2, this.updateMorphTargets();
        }
        copy(t2) {
          return super.copy(t2), void 0 !== t2.morphTargetInfluences && (this.morphTargetInfluences = t2.morphTargetInfluences.slice()), void 0 !== t2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t2.morphTargetDictionary)), this.material = t2.material, this.geometry = t2.geometry, this;
        }
        updateMorphTargets() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) {
            const e2 = t2.morphAttributes, i2 = Object.keys(e2);
            if (i2.length > 0) {
              const t3 = e2[i2[0]];
              if (void 0 !== t3) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) {
                  const i4 = t3[e3].name || String(e3);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[i4] = e3;
                }
              }
            }
          } else {
            const e2 = t2.morphTargets;
            void 0 !== e2 && e2.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        raycast(t2, e2) {
          const i2 = this.geometry, n2 = this.material, r2 = this.matrixWorld;
          if (void 0 === n2) return;
          if (null === i2.boundingSphere && i2.computeBoundingSphere(), me.copy(i2.boundingSphere), me.applyMatrix4(r2), false === t2.ray.intersectsSphere(me)) return;
          if (pe.copy(r2).invert(), fe.copy(t2.ray).applyMatrix4(pe), null !== i2.boundingBox && false === fe.intersectsBox(i2.boundingBox)) return;
          let o2;
          if (i2.isBufferGeometry) {
            const r3 = i2.index, s2 = i2.attributes.position, a2 = i2.morphAttributes.position, l2 = i2.morphTargetsRelative, h2 = i2.attributes.uv, u2 = i2.attributes.uv2, c2 = i2.groups, d2 = i2.drawRange;
            if (null !== r3) if (Array.isArray(n2)) for (let i3 = 0, p2 = c2.length; i3 < p2; i3++) {
              const p3 = c2[i3], f2 = n2[p3.materialIndex];
              for (let i4 = Math.max(p3.start, d2.start), n3 = Math.min(p3.start + p3.count, d2.start + d2.count); i4 < n3; i4 += 3) {
                const n4 = r3.getX(i4), c3 = r3.getX(i4 + 1), d3 = r3.getX(i4 + 2);
                o2 = Pe(this, f2, t2, fe, s2, a2, l2, h2, u2, n4, c3, d3), o2 && (o2.faceIndex = Math.floor(i4 / 3), o2.face.materialIndex = p3.materialIndex, e2.push(o2));
              }
            }
            else {
              for (let i3 = Math.max(0, d2.start), c3 = Math.min(r3.count, d2.start + d2.count); i3 < c3; i3 += 3) {
                const c4 = r3.getX(i3), d3 = r3.getX(i3 + 1), p2 = r3.getX(i3 + 2);
                o2 = Pe(this, n2, t2, fe, s2, a2, l2, h2, u2, c4, d3, p2), o2 && (o2.faceIndex = Math.floor(i3 / 3), e2.push(o2));
              }
            }
            else if (void 0 !== s2) if (Array.isArray(n2)) for (let i3 = 0, r4 = c2.length; i3 < r4; i3++) {
              const r5 = c2[i3], p2 = n2[r5.materialIndex];
              for (let i4 = Math.max(r5.start, d2.start), n3 = Math.min(r5.start + r5.count, d2.start + d2.count); i4 < n3; i4 += 3) {
                o2 = Pe(this, p2, t2, fe, s2, a2, l2, h2, u2, i4, i4 + 1, i4 + 2), o2 && (o2.faceIndex = Math.floor(i4 / 3), o2.face.materialIndex = r5.materialIndex, e2.push(o2));
              }
            }
            else {
              for (let i3 = Math.max(0, d2.start), r4 = Math.min(s2.count, d2.start + d2.count); i3 < r4; i3 += 3) {
                o2 = Pe(this, n2, t2, fe, s2, a2, l2, h2, u2, i3, i3 + 1, i3 + 2), o2 && (o2.faceIndex = Math.floor(i3 / 3), e2.push(o2));
              }
            }
          } else i2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      function Pe(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2) {
        ge.fromBufferAttribute(r2, h2), ve.fromBufferAttribute(r2, u2), _e.fromBufferAttribute(r2, c2);
        const d2 = t2.morphTargetInfluences;
        if (e2.morphTargets && o2 && d2) {
          Te.set(0, 0, 0), Ee.set(0, 0, 0), Se.set(0, 0, 0);
          for (let t3 = 0, e3 = o2.length; t3 < e3; t3++) {
            const e4 = d2[t3], i3 = o2[t3];
            0 !== e4 && (ye.fromBufferAttribute(i3, h2), xe.fromBufferAttribute(i3, u2), be.fromBufferAttribute(i3, c2), s2 ? (Te.addScaledVector(ye, e4), Ee.addScaledVector(xe, e4), Se.addScaledVector(be, e4)) : (Te.addScaledVector(ye.sub(ge), e4), Ee.addScaledVector(xe.sub(ve), e4), Se.addScaledVector(be.sub(_e), e4)));
          }
          ge.add(Te), ve.add(Ee), _e.add(Se);
        }
        t2.isSkinnedMesh && (t2.boneTransform(h2, ge), t2.boneTransform(u2, ve), t2.boneTransform(c2, _e));
        const p2 = function(t3, e3, i3, n3, r3, o3, s3, a3) {
          let l3;
          if (l3 = 1 === e3.side ? n3.intersectTriangle(s3, o3, r3, true, a3) : n3.intersectTriangle(r3, o3, s3, 2 !== e3.side, a3), null === l3) return null;
          Re.copy(a3), Re.applyMatrix4(t3.matrixWorld);
          const h3 = i3.ray.origin.distanceTo(Re);
          return h3 < i3.near || h3 > i3.far ? null : { distance: h3, point: Re.clone(), object: t3 };
        }(t2, e2, i2, n2, ge, ve, _e, Ce);
        if (p2) {
          a2 && (we.fromBufferAttribute(a2, h2), Ae.fromBufferAttribute(a2, u2), Me.fromBufferAttribute(a2, c2), p2.uv = Gt.getUV(Ce, ge, ve, _e, we, Ae, Me, new g())), l2 && (we.fromBufferAttribute(l2, h2), Ae.fromBufferAttribute(l2, u2), Me.fromBufferAttribute(l2, c2), p2.uv2 = Gt.getUV(Ce, ge, ve, _e, we, Ae, Me, new g()));
          const t3 = { a: h2, b: u2, c: c2, normal: new M(), materialIndex: 0 };
          Gt.getNormal(ge, ve, _e, t3.normal), p2.face = t3;
        }
        return p2;
      }
      Ie.prototype.isMesh = true;
      class Oe extends de {
        constructor(t2 = 1, e2 = 1, i2 = 1, n2 = 1, r2 = 1, o2 = 1) {
          super(), this.type = "BoxGeometry", this.parameters = { width: t2, height: e2, depth: i2, widthSegments: n2, heightSegments: r2, depthSegments: o2 };
          const s2 = this;
          n2 = Math.floor(n2), r2 = Math.floor(r2), o2 = Math.floor(o2);
          const a2 = [], l2 = [], h2 = [], u2 = [];
          let c2 = 0, d2 = 0;
          function p2(t3, e3, i3, n3, r3, o3, p3, f2, m2, g2, v2) {
            const _2 = o3 / m2, y2 = p3 / g2, x2 = o3 / 2, b2 = p3 / 2, T2 = f2 / 2, E2 = m2 + 1, S2 = g2 + 1;
            let w2 = 0, A2 = 0;
            const C2 = new M();
            for (let o4 = 0; o4 < S2; o4++) {
              const s3 = o4 * y2 - b2;
              for (let a3 = 0; a3 < E2; a3++) {
                const c3 = a3 * _2 - x2;
                C2[t3] = c3 * n3, C2[e3] = s3 * r3, C2[i3] = T2, l2.push(C2.x, C2.y, C2.z), C2[t3] = 0, C2[e3] = 0, C2[i3] = f2 > 0 ? 1 : -1, h2.push(C2.x, C2.y, C2.z), u2.push(a3 / m2), u2.push(1 - o4 / g2), w2 += 1;
              }
            }
            for (let t4 = 0; t4 < g2; t4++) for (let e4 = 0; e4 < m2; e4++) {
              const i4 = c2 + e4 + E2 * t4, n4 = c2 + e4 + E2 * (t4 + 1), r4 = c2 + (e4 + 1) + E2 * (t4 + 1), o4 = c2 + (e4 + 1) + E2 * t4;
              a2.push(i4, n4, o4), a2.push(n4, r4, o4), A2 += 6;
            }
            s2.addGroup(d2, A2, v2), d2 += A2, c2 += w2;
          }
          p2("z", "y", "x", -1, -1, i2, e2, t2, o2, r2, 0), p2("z", "y", "x", 1, -1, i2, e2, -t2, o2, r2, 1), p2("x", "z", "y", 1, 1, t2, i2, e2, n2, o2, 2), p2("x", "z", "y", 1, -1, t2, i2, -e2, n2, o2, 3), p2("x", "y", "z", 1, -1, t2, e2, i2, n2, r2, 4), p2("x", "y", "z", -1, -1, t2, e2, -i2, n2, r2, 5), this.setIndex(a2), this.setAttribute("position", new ne(l2, 3)), this.setAttribute("normal", new ne(h2, 3)), this.setAttribute("uv", new ne(u2, 2));
        }
        static fromJSON(t2) {
          return new Oe(t2.width, t2.height, t2.depth, t2.widthSegments, t2.heightSegments, t2.depthSegments);
        }
      }
      function Ne(t2) {
        const e2 = {};
        for (const i2 in t2) {
          e2[i2] = {};
          for (const n2 in t2[i2]) {
            const r2 = t2[i2][n2];
            r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? e2[i2][n2] = r2.clone() : Array.isArray(r2) ? e2[i2][n2] = r2.slice() : e2[i2][n2] = r2;
          }
        }
        return e2;
      }
      function Le(t2) {
        const e2 = {};
        for (let i2 = 0; i2 < t2.length; i2++) {
          const n2 = Ne(t2[i2]);
          for (const t3 in n2) e2[t3] = n2[t3];
        }
        return e2;
      }
      const De = { clone: Ne, merge: Le };
      class Fe extends jt {
        constructor(t2) {
          super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== t2 && (void 0 !== t2.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t2));
        }
        copy(t2) {
          return super.copy(t2), this.fragmentShader = t2.fragmentShader, this.vertexShader = t2.vertexShader, this.uniforms = Ne(t2.uniforms), this.defines = Object.assign({}, t2.defines), this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.lights = t2.lights, this.clipping = t2.clipping, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.extensions = Object.assign({}, t2.extensions), this.glslVersion = t2.glslVersion, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          e2.glslVersion = this.glslVersion, e2.uniforms = {};
          for (const i3 in this.uniforms) {
            const n2 = this.uniforms[i3].value;
            n2 && n2.isTexture ? e2.uniforms[i3] = { type: "t", value: n2.toJSON(t2).uuid } : n2 && n2.isColor ? e2.uniforms[i3] = { type: "c", value: n2.getHex() } : n2 && n2.isVector2 ? e2.uniforms[i3] = { type: "v2", value: n2.toArray() } : n2 && n2.isVector3 ? e2.uniforms[i3] = { type: "v3", value: n2.toArray() } : n2 && n2.isVector4 ? e2.uniforms[i3] = { type: "v4", value: n2.toArray() } : n2 && n2.isMatrix3 ? e2.uniforms[i3] = { type: "m3", value: n2.toArray() } : n2 && n2.isMatrix4 ? e2.uniforms[i3] = { type: "m4", value: n2.toArray() } : e2.uniforms[i3] = { value: n2 };
          }
          Object.keys(this.defines).length > 0 && (e2.defines = this.defines), e2.vertexShader = this.vertexShader, e2.fragmentShader = this.fragmentShader;
          const i2 = {};
          for (const t3 in this.extensions) true === this.extensions[t3] && (i2[t3] = true);
          return Object.keys(i2).length > 0 && (e2.extensions = i2), e2;
        }
      }
      Fe.prototype.isShaderMaterial = true;
      class Be extends Rt {
        constructor() {
          super(), this.type = "Camera", this.matrixWorldInverse = new rt(), this.projectionMatrix = new rt(), this.projectionMatrixInverse = new rt();
        }
        copy(t2, e2) {
          return super.copy(t2, e2), this.matrixWorldInverse.copy(t2.matrixWorldInverse), this.projectionMatrix.copy(t2.projectionMatrix), this.projectionMatrixInverse.copy(t2.projectionMatrixInverse), this;
        }
        getWorldDirection(t2) {
          this.updateWorldMatrix(true, false);
          const e2 = this.matrixWorld.elements;
          return t2.set(-e2[8], -e2[9], -e2[10]).normalize();
        }
        updateMatrixWorld(t2) {
          super.updateMatrixWorld(t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t2, e2) {
          super.updateWorldMatrix(t2, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Be.prototype.isCamera = true;
      class Ue extends Be {
        constructor(t2 = 50, e2 = 1, i2 = 0.1, n2 = 2e3) {
          super(), this.type = "PerspectiveCamera", this.fov = t2, this.zoom = 1, this.near = i2, this.far = n2, this.focus = 10, this.aspect = e2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(t2, e2) {
          return super.copy(t2, e2), this.fov = t2.fov, this.zoom = t2.zoom, this.near = t2.near, this.far = t2.far, this.focus = t2.focus, this.aspect = t2.aspect, this.view = null === t2.view ? null : Object.assign({}, t2.view), this.filmGauge = t2.filmGauge, this.filmOffset = t2.filmOffset, this;
        }
        setFocalLength(t2) {
          const e2 = 0.5 * this.getFilmHeight() / t2;
          this.fov = 2 * h * Math.atan(e2), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t2 = Math.tan(0.5 * l * this.fov);
          return 0.5 * this.getFilmHeight() / t2;
        }
        getEffectiveFOV() {
          return 2 * h * Math.atan(Math.tan(0.5 * l * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(t2, e2, i2, n2, r2, o2) {
          this.aspect = t2 / e2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = o2, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t2 = this.near;
          let e2 = t2 * Math.tan(0.5 * l * this.fov) / this.zoom, i2 = 2 * e2, n2 = this.aspect * i2, r2 = -0.5 * n2;
          const o2 = this.view;
          if (null !== this.view && this.view.enabled) {
            const t3 = o2.fullWidth, s3 = o2.fullHeight;
            r2 += o2.offsetX * n2 / t3, e2 -= o2.offsetY * i2 / s3, n2 *= o2.width / t3, i2 *= o2.height / s3;
          }
          const s2 = this.filmOffset;
          0 !== s2 && (r2 += t2 * s2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r2, r2 + n2, e2, e2 - i2, t2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.fov = this.fov, e2.object.zoom = this.zoom, e2.object.near = this.near, e2.object.far = this.far, e2.object.focus = this.focus, e2.object.aspect = this.aspect, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2.object.filmGauge = this.filmGauge, e2.object.filmOffset = this.filmOffset, e2;
        }
      }
      Ue.prototype.isPerspectiveCamera = true;
      class ke extends Rt {
        constructor(t2, e2, i2) {
          if (super(), this.type = "CubeCamera", true !== i2.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
          this.renderTarget = i2;
          const n2 = new Ue(90, 1, t2, e2);
          n2.layers = this.layers, n2.up.set(0, -1, 0), n2.lookAt(new M(1, 0, 0)), this.add(n2);
          const r2 = new Ue(90, 1, t2, e2);
          r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new M(-1, 0, 0)), this.add(r2);
          const o2 = new Ue(90, 1, t2, e2);
          o2.layers = this.layers, o2.up.set(0, 0, 1), o2.lookAt(new M(0, 1, 0)), this.add(o2);
          const s2 = new Ue(90, 1, t2, e2);
          s2.layers = this.layers, s2.up.set(0, 0, -1), s2.lookAt(new M(0, -1, 0)), this.add(s2);
          const a2 = new Ue(90, 1, t2, e2);
          a2.layers = this.layers, a2.up.set(0, -1, 0), a2.lookAt(new M(0, 0, 1)), this.add(a2);
          const l2 = new Ue(90, 1, t2, e2);
          l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new M(0, 0, -1)), this.add(l2);
        }
        update(t2, e2) {
          null === this.parent && this.updateMatrixWorld();
          const i2 = this.renderTarget, [n2, r2, o2, s2, a2, l2] = this.children, h2 = t2.xr.enabled, u2 = t2.getRenderTarget();
          t2.xr.enabled = false;
          const c2 = i2.texture.generateMipmaps;
          i2.texture.generateMipmaps = false, t2.setRenderTarget(i2, 0), t2.render(e2, n2), t2.setRenderTarget(i2, 1), t2.render(e2, r2), t2.setRenderTarget(i2, 2), t2.render(e2, o2), t2.setRenderTarget(i2, 3), t2.render(e2, s2), t2.setRenderTarget(i2, 4), t2.render(e2, a2), i2.texture.generateMipmaps = c2, t2.setRenderTarget(i2, 5), t2.render(e2, l2), t2.setRenderTarget(u2), t2.xr.enabled = h2;
        }
      }
      class Ge extends b {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2) {
          super(t2 = void 0 !== t2 ? t2 : [], e2 = void 0 !== e2 ? e2 : 301, i2, n2, r2, o2, s2 = void 0 !== s2 ? s2 : 1022, a2, l2, h2), this._needsFlipEnvMap = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(t2) {
          this.image = t2;
        }
      }
      Ge.prototype.isCubeTexture = true;
      class He extends S {
        constructor(t2, e2, i2) {
          Number.isInteger(e2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e2 = i2), super(t2, t2, e2), e2 = e2 || {}, this.texture = new Ge(void 0, e2.mapping, e2.wrapS, e2.wrapT, e2.magFilter, e2.minFilter, e2.format, e2.type, e2.anisotropy, e2.encoding), this.texture.generateMipmaps = void 0 !== e2.generateMipmaps && e2.generateMipmaps, this.texture.minFilter = void 0 !== e2.minFilter ? e2.minFilter : 1006, this.texture._needsFlipEnvMap = false;
        }
        fromEquirectangularTexture(t2, e2) {
          this.texture.type = e2.type, this.texture.format = 1023, this.texture.encoding = e2.encoding, this.texture.generateMipmaps = e2.generateMipmaps, this.texture.minFilter = e2.minFilter, this.texture.magFilter = e2.magFilter;
          const i2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, n2 = new Oe(5, 5, 5), r2 = new Fe({ name: "CubemapFromEquirect", uniforms: Ne(i2.uniforms), vertexShader: i2.vertexShader, fragmentShader: i2.fragmentShader, side: 1, blending: 0 });
          r2.uniforms.tEquirect.value = e2;
          const o2 = new Ie(n2, r2), s2 = e2.minFilter;
          1008 === e2.minFilter && (e2.minFilter = 1006);
          return new ke(1, 10, this).update(t2, o2), e2.minFilter = s2, o2.geometry.dispose(), o2.material.dispose(), this;
        }
        clear(t2, e2, i2, n2) {
          const r2 = t2.getRenderTarget();
          for (let r3 = 0; r3 < 6; r3++) t2.setRenderTarget(this, r3), t2.clear(e2, i2, n2);
          t2.setRenderTarget(r2);
        }
      }
      He.prototype.isWebGLCubeRenderTarget = true;
      const je = new M(), ze = new M(), Ve = new v();
      class Xe {
        constructor(t2 = new M(1, 0, 0), e2 = 0) {
          this.normal = t2, this.constant = e2;
        }
        set(t2, e2) {
          return this.normal.copy(t2), this.constant = e2, this;
        }
        setComponents(t2, e2, i2, n2) {
          return this.normal.set(t2, e2, i2), this.constant = n2, this;
        }
        setFromNormalAndCoplanarPoint(t2, e2) {
          return this.normal.copy(t2), this.constant = -e2.dot(this.normal), this;
        }
        setFromCoplanarPoints(t2, e2, i2) {
          const n2 = je.subVectors(i2, e2).cross(ze.subVectors(t2, e2)).normalize();
          return this.setFromNormalAndCoplanarPoint(n2, t2), this;
        }
        copy(t2) {
          return this.normal.copy(t2.normal), this.constant = t2.constant, this;
        }
        normalize() {
          const t2 = 1 / this.normal.length();
          return this.normal.multiplyScalar(t2), this.constant *= t2, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(t2) {
          return this.normal.dot(t2) + this.constant;
        }
        distanceToSphere(t2) {
          return this.distanceToPoint(t2.center) - t2.radius;
        }
        projectPoint(t2, e2) {
          return e2.copy(this.normal).multiplyScalar(-this.distanceToPoint(t2)).add(t2);
        }
        intersectLine(t2, e2) {
          const i2 = t2.delta(je), n2 = this.normal.dot(i2);
          if (0 === n2) return 0 === this.distanceToPoint(t2.start) ? e2.copy(t2.start) : null;
          const r2 = -(t2.start.dot(this.normal) + this.constant) / n2;
          return r2 < 0 || r2 > 1 ? null : e2.copy(i2).multiplyScalar(r2).add(t2.start);
        }
        intersectsLine(t2) {
          const e2 = this.distanceToPoint(t2.start), i2 = this.distanceToPoint(t2.end);
          return e2 < 0 && i2 > 0 || i2 < 0 && e2 > 0;
        }
        intersectsBox(t2) {
          return t2.intersectsPlane(this);
        }
        intersectsSphere(t2) {
          return t2.intersectsPlane(this);
        }
        coplanarPoint(t2) {
          return t2.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t2, e2) {
          const i2 = e2 || Ve.getNormalMatrix(t2), n2 = this.coplanarPoint(je).applyMatrix4(t2), r2 = this.normal.applyMatrix3(i2).normalize();
          return this.constant = -n2.dot(r2), this;
        }
        translate(t2) {
          return this.constant -= t2.dot(this.normal), this;
        }
        equals(t2) {
          return t2.normal.equals(this.normal) && t2.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      Xe.prototype.isPlane = true;
      const We = new Z(), Ye = new M();
      class qe {
        constructor(t2 = new Xe(), e2 = new Xe(), i2 = new Xe(), n2 = new Xe(), r2 = new Xe(), o2 = new Xe()) {
          this.planes = [t2, e2, i2, n2, r2, o2];
        }
        set(t2, e2, i2, n2, r2, o2) {
          const s2 = this.planes;
          return s2[0].copy(t2), s2[1].copy(e2), s2[2].copy(i2), s2[3].copy(n2), s2[4].copy(r2), s2[5].copy(o2), this;
        }
        copy(t2) {
          const e2 = this.planes;
          for (let i2 = 0; i2 < 6; i2++) e2[i2].copy(t2.planes[i2]);
          return this;
        }
        setFromProjectionMatrix(t2) {
          const e2 = this.planes, i2 = t2.elements, n2 = i2[0], r2 = i2[1], o2 = i2[2], s2 = i2[3], a2 = i2[4], l2 = i2[5], h2 = i2[6], u2 = i2[7], c2 = i2[8], d2 = i2[9], p2 = i2[10], f2 = i2[11], m2 = i2[12], g2 = i2[13], v2 = i2[14], _2 = i2[15];
          return e2[0].setComponents(s2 - n2, u2 - a2, f2 - c2, _2 - m2).normalize(), e2[1].setComponents(s2 + n2, u2 + a2, f2 + c2, _2 + m2).normalize(), e2[2].setComponents(s2 + r2, u2 + l2, f2 + d2, _2 + g2).normalize(), e2[3].setComponents(s2 - r2, u2 - l2, f2 - d2, _2 - g2).normalize(), e2[4].setComponents(s2 - o2, u2 - h2, f2 - p2, _2 - v2).normalize(), e2[5].setComponents(s2 + o2, u2 + h2, f2 + p2, _2 + v2).normalize(), this;
        }
        intersectsObject(t2) {
          const e2 = t2.geometry;
          return null === e2.boundingSphere && e2.computeBoundingSphere(), We.copy(e2.boundingSphere).applyMatrix4(t2.matrixWorld), this.intersectsSphere(We);
        }
        intersectsSprite(t2) {
          return We.center.set(0, 0, 0), We.radius = 0.7071067811865476, We.applyMatrix4(t2.matrixWorld), this.intersectsSphere(We);
        }
        intersectsSphere(t2) {
          const e2 = this.planes, i2 = t2.center, n2 = -t2.radius;
          for (let t3 = 0; t3 < 6; t3++) {
            if (e2[t3].distanceToPoint(i2) < n2) return false;
          }
          return true;
        }
        intersectsBox(t2) {
          const e2 = this.planes;
          for (let i2 = 0; i2 < 6; i2++) {
            const n2 = e2[i2];
            if (Ye.x = n2.normal.x > 0 ? t2.max.x : t2.min.x, Ye.y = n2.normal.y > 0 ? t2.max.y : t2.min.y, Ye.z = n2.normal.z > 0 ? t2.max.z : t2.min.z, n2.distanceToPoint(Ye) < 0) return false;
          }
          return true;
        }
        containsPoint(t2) {
          const e2 = this.planes;
          for (let i2 = 0; i2 < 6; i2++) if (e2[i2].distanceToPoint(t2) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Ze() {
        let t2 = null, e2 = false, i2 = null, n2 = null;
        function r2(e3, o2) {
          i2(e3, o2), n2 = t2.requestAnimationFrame(r2);
        }
        return { start: function() {
          true !== e2 && null !== i2 && (n2 = t2.requestAnimationFrame(r2), e2 = true);
        }, stop: function() {
          t2.cancelAnimationFrame(n2), e2 = false;
        }, setAnimationLoop: function(t3) {
          i2 = t3;
        }, setContext: function(e3) {
          t2 = e3;
        } };
      }
      function Je(t2, e2) {
        const i2 = e2.isWebGL2, n2 = /* @__PURE__ */ new WeakMap();
        return { get: function(t3) {
          return t3.isInterleavedBufferAttribute && (t3 = t3.data), n2.get(t3);
        }, remove: function(e3) {
          e3.isInterleavedBufferAttribute && (e3 = e3.data);
          const i3 = n2.get(e3);
          i3 && (t2.deleteBuffer(i3.buffer), n2.delete(e3));
        }, update: function(e3, r2) {
          if (e3.isGLBufferAttribute) {
            const t3 = n2.get(e3);
            return void ((!t3 || t3.version < e3.version) && n2.set(e3, { buffer: e3.buffer, type: e3.type, bytesPerElement: e3.elementSize, version: e3.version }));
          }
          e3.isInterleavedBufferAttribute && (e3 = e3.data);
          const o2 = n2.get(e3);
          void 0 === o2 ? n2.set(e3, function(e4, n3) {
            const r3 = e4.array, o3 = e4.usage, s2 = t2.createBuffer();
            t2.bindBuffer(n3, s2), t2.bufferData(n3, r3, o3), e4.onUploadCallback();
            let a2 = 5126;
            return r3 instanceof Float32Array ? a2 = 5126 : r3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r3 instanceof Uint16Array ? e4.isFloat16BufferAttribute ? i2 ? a2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a2 = 5123 : r3 instanceof Int16Array ? a2 = 5122 : r3 instanceof Uint32Array ? a2 = 5125 : r3 instanceof Int32Array ? a2 = 5124 : r3 instanceof Int8Array ? a2 = 5120 : (r3 instanceof Uint8Array || r3 instanceof Uint8ClampedArray) && (a2 = 5121), { buffer: s2, type: a2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: e4.version };
          }(e3, r2)) : o2.version < e3.version && (!function(e4, n3, r3) {
            const o3 = n3.array, s2 = n3.updateRange;
            t2.bindBuffer(r3, e4), -1 === s2.count ? t2.bufferSubData(r3, 0, o3) : (i2 ? t2.bufferSubData(r3, s2.offset * o3.BYTES_PER_ELEMENT, o3, s2.offset, s2.count) : t2.bufferSubData(r3, s2.offset * o3.BYTES_PER_ELEMENT, o3.subarray(s2.offset, s2.offset + s2.count)), s2.count = -1);
          }(o2.buffer, e3, r2), o2.version = e3.version);
        } };
      }
      class Ke extends de {
        constructor(t2 = 1, e2 = 1, i2 = 1, n2 = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = { width: t2, height: e2, widthSegments: i2, heightSegments: n2 };
          const r2 = t2 / 2, o2 = e2 / 2, s2 = Math.floor(i2), a2 = Math.floor(n2), l2 = s2 + 1, h2 = a2 + 1, u2 = t2 / s2, c2 = e2 / a2, d2 = [], p2 = [], f2 = [], m2 = [];
          for (let t3 = 0; t3 < h2; t3++) {
            const e3 = t3 * c2 - o2;
            for (let i3 = 0; i3 < l2; i3++) {
              const n3 = i3 * u2 - r2;
              p2.push(n3, -e3, 0), f2.push(0, 0, 1), m2.push(i3 / s2), m2.push(1 - t3 / a2);
            }
          }
          for (let t3 = 0; t3 < a2; t3++) for (let e3 = 0; e3 < s2; e3++) {
            const i3 = e3 + l2 * t3, n3 = e3 + l2 * (t3 + 1), r3 = e3 + 1 + l2 * (t3 + 1), o3 = e3 + 1 + l2 * t3;
            d2.push(i3, n3, o3), d2.push(n3, r3, o3);
          }
          this.setIndex(d2), this.setAttribute("position", new ne(p2, 3)), this.setAttribute("normal", new ne(f2, 3)), this.setAttribute("uv", new ne(m2, 2));
        }
        static fromJSON(t2) {
          return new Ke(t2.width, t2.height, t2.widthSegments, t2.heightSegments);
        }
      }
      const Qe = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotVH ) {\n	float fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSNMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n	vec3 v = normalize( cameraPosition - pos );\n	float ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n	vec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n		normal, v, roughnessFactor, material.diffuseColor, totalSpecular,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec4 vWorldPosition;\n	vec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n		vec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n		vec3 modelScale;\n		modelScale.x = length(vec3(modelMatrix[0].xyz));\n		modelScale.y = length(vec3(modelMatrix[1].xyz));\n		modelScale.z = length(vec3(modelMatrix[2].xyz));\n		return normalize(refractionVector) * thickness * modelScale;\n	}\n	float applyIorToRoughness(float roughness, float ior) {\n		return roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n	}\n	vec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n		float framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n		return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n	}\n	vec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n		if (attenuationDistance == 0.0) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n			vec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);			return transmittance * radiance;\n		}\n	}\n	vec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance) {\n		vec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n		vec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n		return (1.0 - specularColor) * attenuatedColor * baseColor;\n	}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform vec3 attenuationColor;\n	uniform float attenuationDistance;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#ifdef USE_TRANSMISSION\n	varying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" }, $e = { common: { diffuse: { value: new Zt(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new v() }, uv2Transform: { value: new v() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new g(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Zt(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Zt(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new v() } }, sprite: { diffuse: { value: new Zt(16777215) }, opacity: { value: 1 }, center: { value: new g(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new v() } } }, ti = { basic: { uniforms: Le([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.fog]), vertexShader: Qe.meshbasic_vert, fragmentShader: Qe.meshbasic_frag }, lambert: { uniforms: Le([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.fog, $e.lights, { emissive: { value: new Zt(0) } }]), vertexShader: Qe.meshlambert_vert, fragmentShader: Qe.meshlambert_frag }, phong: { uniforms: Le([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.fog, $e.lights, { emissive: { value: new Zt(0) }, specular: { value: new Zt(1118481) }, shininess: { value: 30 } }]), vertexShader: Qe.meshphong_vert, fragmentShader: Qe.meshphong_frag }, standard: { uniforms: Le([$e.common, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.roughnessmap, $e.metalnessmap, $e.fog, $e.lights, { emissive: { value: new Zt(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Qe.meshphysical_vert, fragmentShader: Qe.meshphysical_frag }, toon: { uniforms: Le([$e.common, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.gradientmap, $e.fog, $e.lights, { emissive: { value: new Zt(0) } }]), vertexShader: Qe.meshtoon_vert, fragmentShader: Qe.meshtoon_frag }, matcap: { uniforms: Le([$e.common, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.fog, { matcap: { value: null } }]), vertexShader: Qe.meshmatcap_vert, fragmentShader: Qe.meshmatcap_frag }, points: { uniforms: Le([$e.points, $e.fog]), vertexShader: Qe.points_vert, fragmentShader: Qe.points_frag }, dashed: { uniforms: Le([$e.common, $e.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Qe.linedashed_vert, fragmentShader: Qe.linedashed_frag }, depth: { uniforms: Le([$e.common, $e.displacementmap]), vertexShader: Qe.depth_vert, fragmentShader: Qe.depth_frag }, normal: { uniforms: Le([$e.common, $e.bumpmap, $e.normalmap, $e.displacementmap, { opacity: { value: 1 } }]), vertexShader: Qe.normal_vert, fragmentShader: Qe.normal_frag }, sprite: { uniforms: Le([$e.sprite, $e.fog]), vertexShader: Qe.sprite_vert, fragmentShader: Qe.sprite_frag }, background: { uniforms: { uvTransform: { value: new v() }, t2D: { value: null } }, vertexShader: Qe.background_vert, fragmentShader: Qe.background_frag }, cube: { uniforms: Le([$e.envmap, { opacity: { value: 1 } }]), vertexShader: Qe.cube_vert, fragmentShader: Qe.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Qe.equirect_vert, fragmentShader: Qe.equirect_frag }, distanceRGBA: { uniforms: Le([$e.common, $e.displacementmap, { referencePosition: { value: new M() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Qe.distanceRGBA_vert, fragmentShader: Qe.distanceRGBA_frag }, shadow: { uniforms: Le([$e.lights, $e.fog, { color: { value: new Zt(0) }, opacity: { value: 1 } }]), vertexShader: Qe.shadow_vert, fragmentShader: Qe.shadow_frag } };
      function ei(t2, e2, i2, n2, r2) {
        const o2 = new Zt(0);
        let s2, a2, l2 = 0, h2 = null, u2 = 0, c2 = null;
        function d2(t3, e3) {
          i2.buffers.color.setClear(t3.r, t3.g, t3.b, e3, r2);
        }
        return { getClearColor: function() {
          return o2;
        }, setClearColor: function(t3, e3 = 1) {
          o2.set(t3), l2 = e3, d2(o2, l2);
        }, getClearAlpha: function() {
          return l2;
        }, setClearAlpha: function(t3) {
          l2 = t3, d2(o2, l2);
        }, render: function(i3, r3) {
          let p2 = false, f2 = true === r3.isScene ? r3.background : null;
          f2 && f2.isTexture && (f2 = e2.get(f2));
          const m2 = t2.xr, g2 = m2.getSession && m2.getSession();
          g2 && "additive" === g2.environmentBlendMode && (f2 = null), null === f2 ? d2(o2, l2) : f2 && f2.isColor && (d2(f2, 1), p2 = true), (t2.autoClear || p2) && t2.clear(t2.autoClearColor, t2.autoClearDepth, t2.autoClearStencil), f2 && (f2.isCubeTexture || 306 === f2.mapping) ? (void 0 === a2 && (a2 = new Ie(new Oe(1, 1, 1), new Fe({ name: "BackgroundCubeMaterial", uniforms: Ne(ti.cube.uniforms), vertexShader: ti.cube.vertexShader, fragmentShader: ti.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), a2.geometry.deleteAttribute("normal"), a2.geometry.deleteAttribute("uv"), a2.onBeforeRender = function(t3, e3, i4) {
            this.matrixWorld.copyPosition(i4.matrixWorld);
          }, Object.defineProperty(a2.material, "envMap", { get: function() {
            return this.uniforms.envMap.value;
          } }), n2.update(a2)), a2.material.uniforms.envMap.value = f2, a2.material.uniforms.flipEnvMap.value = f2.isCubeTexture && f2._needsFlipEnvMap ? -1 : 1, h2 === f2 && u2 === f2.version && c2 === t2.toneMapping || (a2.material.needsUpdate = true, h2 = f2, u2 = f2.version, c2 = t2.toneMapping), i3.unshift(a2, a2.geometry, a2.material, 0, 0, null)) : f2 && f2.isTexture && (void 0 === s2 && (s2 = new Ie(new Ke(2, 2), new Fe({ name: "BackgroundMaterial", uniforms: Ne(ti.background.uniforms), vertexShader: ti.background.vertexShader, fragmentShader: ti.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), s2.geometry.deleteAttribute("normal"), Object.defineProperty(s2.material, "map", { get: function() {
            return this.uniforms.t2D.value;
          } }), n2.update(s2)), s2.material.uniforms.t2D.value = f2, true === f2.matrixAutoUpdate && f2.updateMatrix(), s2.material.uniforms.uvTransform.value.copy(f2.matrix), h2 === f2 && u2 === f2.version && c2 === t2.toneMapping || (s2.material.needsUpdate = true, h2 = f2, u2 = f2.version, c2 = t2.toneMapping), i3.unshift(s2, s2.geometry, s2.material, 0, 0, null));
        } };
      }
      function ii(t2, e2, i2, n2) {
        const r2 = t2.getParameter(34921), o2 = n2.isWebGL2 ? null : e2.get("OES_vertex_array_object"), s2 = n2.isWebGL2 || null !== o2, a2 = {}, l2 = d2(null);
        let h2 = l2;
        function u2(e3) {
          return n2.isWebGL2 ? t2.bindVertexArray(e3) : o2.bindVertexArrayOES(e3);
        }
        function c2(e3) {
          return n2.isWebGL2 ? t2.deleteVertexArray(e3) : o2.deleteVertexArrayOES(e3);
        }
        function d2(t3) {
          const e3 = [], i3 = [], n3 = [];
          for (let t4 = 0; t4 < r2; t4++) e3[t4] = 0, i3[t4] = 0, n3[t4] = 0;
          return { geometry: null, program: null, wireframe: false, newAttributes: e3, enabledAttributes: i3, attributeDivisors: n3, object: t3, attributes: {}, index: null };
        }
        function p2() {
          const t3 = h2.newAttributes;
          for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) t3[e3] = 0;
        }
        function f2(t3) {
          m2(t3, 0);
        }
        function m2(i3, r3) {
          const o3 = h2.newAttributes, s3 = h2.enabledAttributes, a3 = h2.attributeDivisors;
          if (o3[i3] = 1, 0 === s3[i3] && (t2.enableVertexAttribArray(i3), s3[i3] = 1), a3[i3] !== r3) {
            (n2.isWebGL2 ? t2 : e2.get("ANGLE_instanced_arrays"))[n2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i3, r3), a3[i3] = r3;
          }
        }
        function g2() {
          const e3 = h2.newAttributes, i3 = h2.enabledAttributes;
          for (let n3 = 0, r3 = i3.length; n3 < r3; n3++) i3[n3] !== e3[n3] && (t2.disableVertexAttribArray(n3), i3[n3] = 0);
        }
        function v2(e3, i3, r3, o3, s3, a3) {
          true !== n2.isWebGL2 || 5124 !== r3 && 5125 !== r3 ? t2.vertexAttribPointer(e3, i3, r3, o3, s3, a3) : t2.vertexAttribIPointer(e3, i3, r3, s3, a3);
        }
        function _2() {
          y2(), h2 !== l2 && (h2 = l2, u2(h2.object));
        }
        function y2() {
          l2.geometry = null, l2.program = null, l2.wireframe = false;
        }
        return { setup: function(r3, l3, c3, _3, y3) {
          let x2 = false;
          if (s2) {
            const e3 = function(e4, i3, r4) {
              const s3 = true === r4.wireframe;
              let l4 = a2[e4.id];
              void 0 === l4 && (l4 = {}, a2[e4.id] = l4);
              let h3 = l4[i3.id];
              void 0 === h3 && (h3 = {}, l4[i3.id] = h3);
              let u3 = h3[s3];
              void 0 === u3 && (u3 = d2(n2.isWebGL2 ? t2.createVertexArray() : o2.createVertexArrayOES()), h3[s3] = u3);
              return u3;
            }(_3, c3, l3);
            h2 !== e3 && (h2 = e3, u2(h2.object)), x2 = function(t3, e4) {
              const i3 = h2.attributes, n3 = t3.attributes;
              let r4 = 0;
              for (const t4 in n3) {
                const e5 = i3[t4], o3 = n3[t4];
                if (void 0 === e5) return true;
                if (e5.attribute !== o3) return true;
                if (e5.data !== o3.data) return true;
                r4++;
              }
              return h2.attributesNum !== r4 || h2.index !== e4;
            }(_3, y3), x2 && function(t3, e4) {
              const i3 = {}, n3 = t3.attributes;
              let r4 = 0;
              for (const t4 in n3) {
                const e5 = n3[t4], o3 = {};
                o3.attribute = e5, e5.data && (o3.data = e5.data), i3[t4] = o3, r4++;
              }
              h2.attributes = i3, h2.attributesNum = r4, h2.index = e4;
            }(_3, y3);
          } else {
            const t3 = true === l3.wireframe;
            h2.geometry === _3.id && h2.program === c3.id && h2.wireframe === t3 || (h2.geometry = _3.id, h2.program = c3.id, h2.wireframe = t3, x2 = true);
          }
          true === r3.isInstancedMesh && (x2 = true), null !== y3 && i2.update(y3, 34963), x2 && (!function(r4, o3, s3, a3) {
            if (false === n2.isWebGL2 && (r4.isInstancedMesh || a3.isInstancedBufferGeometry) && null === e2.get("ANGLE_instanced_arrays")) return;
            p2();
            const l4 = a3.attributes, h3 = s3.getAttributes(), u3 = o3.defaultAttributeValues;
            for (const e3 in h3) {
              const n3 = h3[e3];
              if (n3 >= 0) {
                const o4 = l4[e3];
                if (void 0 !== o4) {
                  const e4 = o4.normalized, r5 = o4.itemSize, s4 = i2.get(o4);
                  if (void 0 === s4) continue;
                  const l5 = s4.buffer, h4 = s4.type, u4 = s4.bytesPerElement;
                  if (o4.isInterleavedBufferAttribute) {
                    const i3 = o4.data, s5 = i3.stride, c4 = o4.offset;
                    i3 && i3.isInstancedInterleavedBuffer ? (m2(n3, i3.meshPerAttribute), void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = i3.meshPerAttribute * i3.count)) : f2(n3), t2.bindBuffer(34962, l5), v2(n3, r5, h4, e4, s5 * u4, c4 * u4);
                  } else o4.isInstancedBufferAttribute ? (m2(n3, o4.meshPerAttribute), void 0 === a3._maxInstanceCount && (a3._maxInstanceCount = o4.meshPerAttribute * o4.count)) : f2(n3), t2.bindBuffer(34962, l5), v2(n3, r5, h4, e4, 0, 0);
                } else if ("instanceMatrix" === e3) {
                  const e4 = i2.get(r4.instanceMatrix);
                  if (void 0 === e4) continue;
                  const o5 = e4.buffer, s4 = e4.type;
                  m2(n3 + 0, 1), m2(n3 + 1, 1), m2(n3 + 2, 1), m2(n3 + 3, 1), t2.bindBuffer(34962, o5), t2.vertexAttribPointer(n3 + 0, 4, s4, false, 64, 0), t2.vertexAttribPointer(n3 + 1, 4, s4, false, 64, 16), t2.vertexAttribPointer(n3 + 2, 4, s4, false, 64, 32), t2.vertexAttribPointer(n3 + 3, 4, s4, false, 64, 48);
                } else if ("instanceColor" === e3) {
                  const e4 = i2.get(r4.instanceColor);
                  if (void 0 === e4) continue;
                  const o5 = e4.buffer, s4 = e4.type;
                  m2(n3, 1), t2.bindBuffer(34962, o5), t2.vertexAttribPointer(n3, 3, s4, false, 12, 0);
                } else if (void 0 !== u3) {
                  const i3 = u3[e3];
                  if (void 0 !== i3) switch (i3.length) {
                    case 2:
                      t2.vertexAttrib2fv(n3, i3);
                      break;
                    case 3:
                      t2.vertexAttrib3fv(n3, i3);
                      break;
                    case 4:
                      t2.vertexAttrib4fv(n3, i3);
                      break;
                    default:
                      t2.vertexAttrib1fv(n3, i3);
                  }
                }
              }
            }
            g2();
          }(r3, l3, c3, _3), null !== y3 && t2.bindBuffer(34963, i2.get(y3).buffer));
        }, reset: _2, resetDefaultState: y2, dispose: function() {
          _2();
          for (const t3 in a2) {
            const e3 = a2[t3];
            for (const t4 in e3) {
              const i3 = e3[t4];
              for (const t5 in i3) c2(i3[t5].object), delete i3[t5];
              delete e3[t4];
            }
            delete a2[t3];
          }
        }, releaseStatesOfGeometry: function(t3) {
          if (void 0 === a2[t3.id]) return;
          const e3 = a2[t3.id];
          for (const t4 in e3) {
            const i3 = e3[t4];
            for (const t5 in i3) c2(i3[t5].object), delete i3[t5];
            delete e3[t4];
          }
          delete a2[t3.id];
        }, releaseStatesOfProgram: function(t3) {
          for (const e3 in a2) {
            const i3 = a2[e3];
            if (void 0 === i3[t3.id]) continue;
            const n3 = i3[t3.id];
            for (const t4 in n3) c2(n3[t4].object), delete n3[t4];
            delete i3[t3.id];
          }
        }, initAttributes: p2, enableAttribute: f2, disableUnusedAttributes: g2 };
      }
      function ni(t2, e2, i2, n2) {
        const r2 = n2.isWebGL2;
        let o2;
        this.setMode = function(t3) {
          o2 = t3;
        }, this.render = function(e3, n3) {
          t2.drawArrays(o2, e3, n3), i2.update(n3, o2, 1);
        }, this.renderInstances = function(n3, s2, a2) {
          if (0 === a2) return;
          let l2, h2;
          if (r2) l2 = t2, h2 = "drawArraysInstanced";
          else if (l2 = e2.get("ANGLE_instanced_arrays"), h2 = "drawArraysInstancedANGLE", null === l2) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          l2[h2](o2, n3, s2, a2), i2.update(s2, o2, a2);
        };
      }
      function ri(t2, e2, i2) {
        let n2;
        function r2(e3) {
          if ("highp" === e3) {
            if (t2.getShaderPrecisionFormat(35633, 36338).precision > 0 && t2.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            e3 = "mediump";
          }
          return "mediump" === e3 && t2.getShaderPrecisionFormat(35633, 36337).precision > 0 && t2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
        }
        const o2 = "undefined" != typeof WebGL2RenderingContext && t2 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t2 instanceof WebGL2ComputeRenderingContext;
        let s2 = void 0 !== i2.precision ? i2.precision : "highp";
        const a2 = r2(s2);
        a2 !== s2 && (console.warn("THREE.WebGLRenderer:", s2, "not supported, using", a2, "instead."), s2 = a2);
        const l2 = o2 || e2.has("WEBGL_draw_buffers"), h2 = true === i2.logarithmicDepthBuffer, u2 = t2.getParameter(34930), c2 = t2.getParameter(35660), d2 = t2.getParameter(3379), p2 = t2.getParameter(34076), f2 = t2.getParameter(34921), m2 = t2.getParameter(36347), g2 = t2.getParameter(36348), v2 = t2.getParameter(36349), _2 = c2 > 0, y2 = o2 || e2.has("OES_texture_float");
        return { isWebGL2: o2, drawBuffers: l2, getMaxAnisotropy: function() {
          if (void 0 !== n2) return n2;
          if (true === e2.has("EXT_texture_filter_anisotropic")) {
            const i3 = e2.get("EXT_texture_filter_anisotropic");
            n2 = t2.getParameter(i3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n2 = 0;
          return n2;
        }, getMaxPrecision: r2, precision: s2, logarithmicDepthBuffer: h2, maxTextures: u2, maxVertexTextures: c2, maxTextureSize: d2, maxCubemapSize: p2, maxAttributes: f2, maxVertexUniforms: m2, maxVaryings: g2, maxFragmentUniforms: v2, vertexTextures: _2, floatFragmentTextures: y2, floatVertexTextures: _2 && y2, maxSamples: o2 ? t2.getParameter(36183) : 0 };
      }
      function oi(t2) {
        const e2 = this;
        let i2 = null, n2 = 0, r2 = false, o2 = false;
        const s2 = new Xe(), a2 = new v(), l2 = { value: null, needsUpdate: false };
        function h2() {
          l2.value !== i2 && (l2.value = i2, l2.needsUpdate = n2 > 0), e2.numPlanes = n2, e2.numIntersection = 0;
        }
        function u2(t3, i3, n3, r3) {
          const o3 = null !== t3 ? t3.length : 0;
          let h3 = null;
          if (0 !== o3) {
            if (h3 = l2.value, true !== r3 || null === h3) {
              const e3 = n3 + 4 * o3, r4 = i3.matrixWorldInverse;
              a2.getNormalMatrix(r4), (null === h3 || h3.length < e3) && (h3 = new Float32Array(e3));
              for (let e4 = 0, i4 = n3; e4 !== o3; ++e4, i4 += 4) s2.copy(t3[e4]).applyMatrix4(r4, a2), s2.normal.toArray(h3, i4), h3[i4 + 3] = s2.constant;
            }
            l2.value = h3, l2.needsUpdate = true;
          }
          return e2.numPlanes = o3, e2.numIntersection = 0, h3;
        }
        this.uniform = l2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t3, e3, o3) {
          const s3 = 0 !== t3.length || e3 || 0 !== n2 || r2;
          return r2 = e3, i2 = u2(t3, o3, 0), n2 = t3.length, s3;
        }, this.beginShadows = function() {
          o2 = true, u2(null);
        }, this.endShadows = function() {
          o2 = false, h2();
        }, this.setState = function(e3, s3, a3) {
          const c2 = e3.clippingPlanes, d2 = e3.clipIntersection, p2 = e3.clipShadows, f2 = t2.get(e3);
          if (!r2 || null === c2 || 0 === c2.length || o2 && !p2) o2 ? u2(null) : h2();
          else {
            const t3 = o2 ? 0 : n2, e4 = 4 * t3;
            let r3 = f2.clippingState || null;
            l2.value = r3, r3 = u2(c2, s3, e4, a3);
            for (let t4 = 0; t4 !== e4; ++t4) r3[t4] = i2[t4];
            f2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += t3;
          }
        };
      }
      function si(t2) {
        let e2 = /* @__PURE__ */ new WeakMap();
        function i2(t3, e3) {
          return 303 === e3 ? t3.mapping = 301 : 304 === e3 && (t3.mapping = 302), t3;
        }
        function n2(t3) {
          const i3 = t3.target;
          i3.removeEventListener("dispose", n2);
          const r2 = e2.get(i3);
          void 0 !== r2 && (e2.delete(i3), r2.dispose());
        }
        return { get: function(r2) {
          if (r2 && r2.isTexture) {
            const o2 = r2.mapping;
            if (303 === o2 || 304 === o2) {
              if (e2.has(r2)) {
                return i2(e2.get(r2).texture, r2.mapping);
              }
              {
                const o3 = r2.image;
                if (o3 && o3.height > 0) {
                  const s2 = t2.getRenderTarget(), a2 = new He(o3.height / 2);
                  return a2.fromEquirectangularTexture(t2, r2), e2.set(r2, a2), t2.setRenderTarget(s2), r2.addEventListener("dispose", n2), i2(a2.texture, r2.mapping);
                }
                return null;
              }
            }
          }
          return r2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function ai(t2) {
        const e2 = {};
        function i2(i3) {
          if (void 0 !== e2[i3]) return e2[i3];
          let n2;
          switch (i3) {
            case "WEBGL_depth_texture":
              n2 = t2.getExtension("WEBGL_depth_texture") || t2.getExtension("MOZ_WEBGL_depth_texture") || t2.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n2 = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n2 = t2.getExtension("WEBGL_compressed_texture_s3tc") || t2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n2 = t2.getExtension("WEBGL_compressed_texture_pvrtc") || t2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n2 = t2.getExtension(i3);
          }
          return e2[i3] = n2, n2;
        }
        return { has: function(t3) {
          return null !== i2(t3);
        }, init: function(t3) {
          t3.isWebGL2 ? i2("EXT_color_buffer_float") : (i2("WEBGL_depth_texture"), i2("OES_texture_float"), i2("OES_texture_half_float"), i2("OES_texture_half_float_linear"), i2("OES_standard_derivatives"), i2("OES_element_index_uint"), i2("OES_vertex_array_object"), i2("ANGLE_instanced_arrays")), i2("OES_texture_float_linear"), i2("EXT_color_buffer_half_float");
        }, get: function(t3) {
          const e3 = i2(t3);
          return null === e3 && console.warn("THREE.WebGLRenderer: " + t3 + " extension not supported."), e3;
        } };
      }
      function li(t2, e2, i2, n2) {
        const r2 = {}, o2 = /* @__PURE__ */ new WeakMap();
        function s2(t3) {
          const a3 = t3.target;
          null !== a3.index && e2.remove(a3.index);
          for (const t4 in a3.attributes) e2.remove(a3.attributes[t4]);
          a3.removeEventListener("dispose", s2), delete r2[a3.id];
          const l2 = o2.get(a3);
          l2 && (e2.remove(l2), o2.delete(a3)), n2.releaseStatesOfGeometry(a3), true === a3.isInstancedBufferGeometry && delete a3._maxInstanceCount, i2.memory.geometries--;
        }
        function a2(t3) {
          const i3 = [], n3 = t3.index, r3 = t3.attributes.position;
          let s3 = 0;
          if (null !== n3) {
            const t4 = n3.array;
            s3 = n3.version;
            for (let e3 = 0, n4 = t4.length; e3 < n4; e3 += 3) {
              const n5 = t4[e3 + 0], r4 = t4[e3 + 1], o3 = t4[e3 + 2];
              i3.push(n5, r4, r4, o3, o3, n5);
            }
          } else {
            const t4 = r3.array;
            s3 = r3.version;
            for (let e3 = 0, n4 = t4.length / 3 - 1; e3 < n4; e3 += 3) {
              const t5 = e3 + 0, n5 = e3 + 1, r4 = e3 + 2;
              i3.push(t5, n5, n5, r4, r4, t5);
            }
          }
          const a3 = new (re(i3) > 65535 ? ie : te)(i3, 1);
          a3.version = s3;
          const l2 = o2.get(t3);
          l2 && e2.remove(l2), o2.set(t3, a3);
        }
        return { get: function(t3, e3) {
          return true === r2[e3.id] || (e3.addEventListener("dispose", s2), r2[e3.id] = true, i2.memory.geometries++), e3;
        }, update: function(t3) {
          const i3 = t3.attributes;
          for (const t4 in i3) e2.update(i3[t4], 34962);
          const n3 = t3.morphAttributes;
          for (const t4 in n3) {
            const i4 = n3[t4];
            for (let t5 = 0, n4 = i4.length; t5 < n4; t5++) e2.update(i4[t5], 34962);
          }
        }, getWireframeAttribute: function(t3) {
          const e3 = o2.get(t3);
          if (e3) {
            const i3 = t3.index;
            null !== i3 && e3.version < i3.version && a2(t3);
          } else a2(t3);
          return o2.get(t3);
        } };
      }
      function hi(t2, e2, i2, n2) {
        const r2 = n2.isWebGL2;
        let o2, s2, a2;
        this.setMode = function(t3) {
          o2 = t3;
        }, this.setIndex = function(t3) {
          s2 = t3.type, a2 = t3.bytesPerElement;
        }, this.render = function(e3, n3) {
          t2.drawElements(o2, n3, s2, e3 * a2), i2.update(n3, o2, 1);
        }, this.renderInstances = function(n3, l2, h2) {
          if (0 === h2) return;
          let u2, c2;
          if (r2) u2 = t2, c2 = "drawElementsInstanced";
          else if (u2 = e2.get("ANGLE_instanced_arrays"), c2 = "drawElementsInstancedANGLE", null === u2) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          u2[c2](o2, l2, s2, n3 * a2, h2), i2.update(l2, o2, h2);
        };
      }
      function ui(t2) {
        const e2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return { memory: { geometries: 0, textures: 0 }, render: e2, programs: null, autoReset: true, reset: function() {
          e2.frame++, e2.calls = 0, e2.triangles = 0, e2.points = 0, e2.lines = 0;
        }, update: function(t3, i2, n2) {
          switch (e2.calls++, i2) {
            case 4:
              e2.triangles += n2 * (t3 / 3);
              break;
            case 1:
              e2.lines += n2 * (t3 / 2);
              break;
            case 3:
              e2.lines += n2 * (t3 - 1);
              break;
            case 2:
              e2.lines += n2 * t3;
              break;
            case 0:
              e2.points += n2 * t3;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", i2);
          }
        } };
      }
      function ci(t2, e2) {
        return t2[0] - e2[0];
      }
      function di(t2, e2) {
        return Math.abs(e2[1]) - Math.abs(t2[1]);
      }
      function pi(t2) {
        const e2 = {}, i2 = new Float32Array(8), n2 = [];
        for (let t3 = 0; t3 < 8; t3++) n2[t3] = [t3, 0];
        return { update: function(r2, o2, s2, a2) {
          const l2 = r2.morphTargetInfluences, h2 = void 0 === l2 ? 0 : l2.length;
          let u2 = e2[o2.id];
          if (void 0 === u2 || u2.length !== h2) {
            u2 = [];
            for (let t3 = 0; t3 < h2; t3++) u2[t3] = [t3, 0];
            e2[o2.id] = u2;
          }
          for (let t3 = 0; t3 < h2; t3++) {
            const e3 = u2[t3];
            e3[0] = t3, e3[1] = l2[t3];
          }
          u2.sort(di);
          for (let t3 = 0; t3 < 8; t3++) t3 < h2 && u2[t3][1] ? (n2[t3][0] = u2[t3][0], n2[t3][1] = u2[t3][1]) : (n2[t3][0] = Number.MAX_SAFE_INTEGER, n2[t3][1] = 0);
          n2.sort(ci);
          const c2 = s2.morphTargets && o2.morphAttributes.position, d2 = s2.morphNormals && o2.morphAttributes.normal;
          let p2 = 0;
          for (let t3 = 0; t3 < 8; t3++) {
            const e3 = n2[t3], r3 = e3[0], s3 = e3[1];
            r3 !== Number.MAX_SAFE_INTEGER && s3 ? (c2 && o2.getAttribute("morphTarget" + t3) !== c2[r3] && o2.setAttribute("morphTarget" + t3, c2[r3]), d2 && o2.getAttribute("morphNormal" + t3) !== d2[r3] && o2.setAttribute("morphNormal" + t3, d2[r3]), i2[t3] = s3, p2 += s3) : (c2 && true === o2.hasAttribute("morphTarget" + t3) && o2.deleteAttribute("morphTarget" + t3), d2 && true === o2.hasAttribute("morphNormal" + t3) && o2.deleteAttribute("morphNormal" + t3), i2[t3] = 0);
          }
          const f2 = o2.morphTargetsRelative ? 1 : 1 - p2;
          a2.getUniforms().setValue(t2, "morphTargetBaseInfluence", f2), a2.getUniforms().setValue(t2, "morphTargetInfluences", i2);
        } };
      }
      function fi(t2, e2, i2, n2) {
        let r2 = /* @__PURE__ */ new WeakMap();
        function o2(t3) {
          const e3 = t3.target;
          e3.removeEventListener("dispose", o2), i2.remove(e3.instanceMatrix), null !== e3.instanceColor && i2.remove(e3.instanceColor);
        }
        return { update: function(t3) {
          const s2 = n2.render.frame, a2 = t3.geometry, l2 = e2.get(t3, a2);
          return r2.get(l2) !== s2 && (e2.update(l2), r2.set(l2, s2)), t3.isInstancedMesh && (false === t3.hasEventListener("dispose", o2) && t3.addEventListener("dispose", o2), i2.update(t3.instanceMatrix, 34962), null !== t3.instanceColor && i2.update(t3.instanceColor, 34962)), l2;
        }, dispose: function() {
          r2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      ti.physical = { uniforms: Le([ti.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new g(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Zt(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new g() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Zt(0) } }]), vertexShader: Qe.meshphysical_vert, fragmentShader: Qe.meshphysical_frag };
      class mi extends b {
        constructor(t2 = null, e2 = 1, i2 = 1, n2 = 1) {
          super(null), this.image = { data: t2, width: e2, height: i2, depth: n2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
        }
      }
      mi.prototype.isDataTexture2DArray = true;
      class gi extends b {
        constructor(t2 = null, e2 = 1, i2 = 1, n2 = 1) {
          super(null), this.image = { data: t2, width: e2, height: i2, depth: n2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
        }
      }
      gi.prototype.isDataTexture3D = true;
      const vi = new b(), _i = new mi(), yi = new gi(), xi = new Ge(), bi = [], Ti = [], Ei = new Float32Array(16), Si = new Float32Array(9), wi = new Float32Array(4);
      function Ai(t2, e2, i2) {
        const n2 = t2[0];
        if (n2 <= 0 || n2 > 0) return t2;
        const r2 = e2 * i2;
        let o2 = bi[r2];
        if (void 0 === o2 && (o2 = new Float32Array(r2), bi[r2] = o2), 0 !== e2) {
          n2.toArray(o2, 0);
          for (let n3 = 1, r3 = 0; n3 !== e2; ++n3) r3 += i2, t2[n3].toArray(o2, r3);
        }
        return o2;
      }
      function Mi(t2, e2) {
        if (t2.length !== e2.length) return false;
        for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) if (t2[i2] !== e2[i2]) return false;
        return true;
      }
      function Ci(t2, e2) {
        for (let i2 = 0, n2 = e2.length; i2 < n2; i2++) t2[i2] = e2[i2];
      }
      function Ri(t2, e2) {
        let i2 = Ti[e2];
        void 0 === i2 && (i2 = new Int32Array(e2), Ti[e2] = i2);
        for (let n2 = 0; n2 !== e2; ++n2) i2[n2] = t2.allocateTextureUnit();
        return i2;
      }
      function Ii(t2, e2) {
        const i2 = this.cache;
        i2[0] !== e2 && (t2.uniform1f(this.addr, e2), i2[0] = e2);
      }
      function Pi(t2, e2) {
        const i2 = this.cache;
        if (void 0 !== e2.x) i2[0] === e2.x && i2[1] === e2.y || (t2.uniform2f(this.addr, e2.x, e2.y), i2[0] = e2.x, i2[1] = e2.y);
        else {
          if (Mi(i2, e2)) return;
          t2.uniform2fv(this.addr, e2), Ci(i2, e2);
        }
      }
      function Oi(t2, e2) {
        const i2 = this.cache;
        if (void 0 !== e2.x) i2[0] === e2.x && i2[1] === e2.y && i2[2] === e2.z || (t2.uniform3f(this.addr, e2.x, e2.y, e2.z), i2[0] = e2.x, i2[1] = e2.y, i2[2] = e2.z);
        else if (void 0 !== e2.r) i2[0] === e2.r && i2[1] === e2.g && i2[2] === e2.b || (t2.uniform3f(this.addr, e2.r, e2.g, e2.b), i2[0] = e2.r, i2[1] = e2.g, i2[2] = e2.b);
        else {
          if (Mi(i2, e2)) return;
          t2.uniform3fv(this.addr, e2), Ci(i2, e2);
        }
      }
      function Ni(t2, e2) {
        const i2 = this.cache;
        if (void 0 !== e2.x) i2[0] === e2.x && i2[1] === e2.y && i2[2] === e2.z && i2[3] === e2.w || (t2.uniform4f(this.addr, e2.x, e2.y, e2.z, e2.w), i2[0] = e2.x, i2[1] = e2.y, i2[2] = e2.z, i2[3] = e2.w);
        else {
          if (Mi(i2, e2)) return;
          t2.uniform4fv(this.addr, e2), Ci(i2, e2);
        }
      }
      function Li(t2, e2) {
        const i2 = this.cache, n2 = e2.elements;
        if (void 0 === n2) {
          if (Mi(i2, e2)) return;
          t2.uniformMatrix2fv(this.addr, false, e2), Ci(i2, e2);
        } else {
          if (Mi(i2, n2)) return;
          wi.set(n2), t2.uniformMatrix2fv(this.addr, false, wi), Ci(i2, n2);
        }
      }
      function Di(t2, e2) {
        const i2 = this.cache, n2 = e2.elements;
        if (void 0 === n2) {
          if (Mi(i2, e2)) return;
          t2.uniformMatrix3fv(this.addr, false, e2), Ci(i2, e2);
        } else {
          if (Mi(i2, n2)) return;
          Si.set(n2), t2.uniformMatrix3fv(this.addr, false, Si), Ci(i2, n2);
        }
      }
      function Fi(t2, e2) {
        const i2 = this.cache, n2 = e2.elements;
        if (void 0 === n2) {
          if (Mi(i2, e2)) return;
          t2.uniformMatrix4fv(this.addr, false, e2), Ci(i2, e2);
        } else {
          if (Mi(i2, n2)) return;
          Ei.set(n2), t2.uniformMatrix4fv(this.addr, false, Ei), Ci(i2, n2);
        }
      }
      function Bi(t2, e2) {
        const i2 = this.cache;
        i2[0] !== e2 && (t2.uniform1i(this.addr, e2), i2[0] = e2);
      }
      function Ui(t2, e2) {
        const i2 = this.cache;
        Mi(i2, e2) || (t2.uniform2iv(this.addr, e2), Ci(i2, e2));
      }
      function ki(t2, e2) {
        const i2 = this.cache;
        Mi(i2, e2) || (t2.uniform3iv(this.addr, e2), Ci(i2, e2));
      }
      function Gi(t2, e2) {
        const i2 = this.cache;
        Mi(i2, e2) || (t2.uniform4iv(this.addr, e2), Ci(i2, e2));
      }
      function Hi(t2, e2) {
        const i2 = this.cache;
        i2[0] !== e2 && (t2.uniform1ui(this.addr, e2), i2[0] = e2);
      }
      function ji(t2, e2) {
        const i2 = this.cache;
        Mi(i2, e2) || (t2.uniform2uiv(this.addr, e2), Ci(i2, e2));
      }
      function zi(t2, e2) {
        const i2 = this.cache;
        Mi(i2, e2) || (t2.uniform3uiv(this.addr, e2), Ci(i2, e2));
      }
      function Vi(t2, e2) {
        const i2 = this.cache;
        Mi(i2, e2) || (t2.uniform4uiv(this.addr, e2), Ci(i2, e2));
      }
      function Xi(t2, e2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.safeSetTexture2D(e2 || vi, r2);
      }
      function Wi(t2, e2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture3D(e2 || yi, r2);
      }
      function Yi(t2, e2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.safeSetTextureCube(e2 || xi, r2);
      }
      function qi(t2, e2, i2) {
        const n2 = this.cache, r2 = i2.allocateTextureUnit();
        n2[0] !== r2 && (t2.uniform1i(this.addr, r2), n2[0] = r2), i2.setTexture2DArray(e2 || _i, r2);
      }
      function Zi(t2, e2) {
        t2.uniform1fv(this.addr, e2);
      }
      function Ji(t2, e2) {
        const i2 = Ai(e2, this.size, 2);
        t2.uniform2fv(this.addr, i2);
      }
      function Ki(t2, e2) {
        const i2 = Ai(e2, this.size, 3);
        t2.uniform3fv(this.addr, i2);
      }
      function Qi(t2, e2) {
        const i2 = Ai(e2, this.size, 4);
        t2.uniform4fv(this.addr, i2);
      }
      function $i(t2, e2) {
        const i2 = Ai(e2, this.size, 4);
        t2.uniformMatrix2fv(this.addr, false, i2);
      }
      function tn(t2, e2) {
        const i2 = Ai(e2, this.size, 9);
        t2.uniformMatrix3fv(this.addr, false, i2);
      }
      function en(t2, e2) {
        const i2 = Ai(e2, this.size, 16);
        t2.uniformMatrix4fv(this.addr, false, i2);
      }
      function nn(t2, e2) {
        t2.uniform1iv(this.addr, e2);
      }
      function rn(t2, e2) {
        t2.uniform2iv(this.addr, e2);
      }
      function on(t2, e2) {
        t2.uniform3iv(this.addr, e2);
      }
      function sn(t2, e2) {
        t2.uniform4iv(this.addr, e2);
      }
      function an(t2, e2) {
        t2.uniform1uiv(this.addr, e2);
      }
      function ln(t2, e2) {
        t2.uniform2uiv(this.addr, e2);
      }
      function hn(t2, e2) {
        t2.uniform3uiv(this.addr, e2);
      }
      function un(t2, e2) {
        t2.uniform4uiv(this.addr, e2);
      }
      function cn(t2, e2, i2) {
        const n2 = e2.length, r2 = Ri(i2, n2);
        t2.uniform1iv(this.addr, r2);
        for (let t3 = 0; t3 !== n2; ++t3) i2.safeSetTexture2D(e2[t3] || vi, r2[t3]);
      }
      function dn(t2, e2, i2) {
        const n2 = e2.length, r2 = Ri(i2, n2);
        t2.uniform1iv(this.addr, r2);
        for (let t3 = 0; t3 !== n2; ++t3) i2.safeSetTextureCube(e2[t3] || xi, r2[t3]);
      }
      function pn(t2, e2, i2) {
        this.id = t2, this.addr = i2, this.cache = [], this.setValue = function(t3) {
          switch (t3) {
            case 5126:
              return Ii;
            case 35664:
              return Pi;
            case 35665:
              return Oi;
            case 35666:
              return Ni;
            case 35674:
              return Li;
            case 35675:
              return Di;
            case 35676:
              return Fi;
            case 5124:
            case 35670:
              return Bi;
            case 35667:
            case 35671:
              return Ui;
            case 35668:
            case 35672:
              return ki;
            case 35669:
            case 35673:
              return Gi;
            case 5125:
              return Hi;
            case 36294:
              return ji;
            case 36295:
              return zi;
            case 36296:
              return Vi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Xi;
            case 35679:
            case 36299:
            case 36307:
              return Wi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Yi;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return qi;
          }
        }(e2.type);
      }
      function fn(t2, e2, i2) {
        this.id = t2, this.addr = i2, this.cache = [], this.size = e2.size, this.setValue = function(t3) {
          switch (t3) {
            case 5126:
              return Zi;
            case 35664:
              return Ji;
            case 35665:
              return Ki;
            case 35666:
              return Qi;
            case 35674:
              return $i;
            case 35675:
              return tn;
            case 35676:
              return en;
            case 5124:
            case 35670:
              return nn;
            case 35667:
            case 35671:
              return rn;
            case 35668:
            case 35672:
              return on;
            case 35669:
            case 35673:
              return sn;
            case 5125:
              return an;
            case 36294:
              return ln;
            case 36295:
              return hn;
            case 36296:
              return un;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return cn;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return dn;
          }
        }(e2.type);
      }
      function mn(t2) {
        this.id = t2, this.seq = [], this.map = {};
      }
      fn.prototype.updateCache = function(t2) {
        const e2 = this.cache;
        t2 instanceof Float32Array && e2.length !== t2.length && (this.cache = new Float32Array(t2.length)), Ci(e2, t2);
      }, mn.prototype.setValue = function(t2, e2, i2) {
        const n2 = this.seq;
        for (let r2 = 0, o2 = n2.length; r2 !== o2; ++r2) {
          const o3 = n2[r2];
          o3.setValue(t2, e2[o3.id], i2);
        }
      };
      const gn = /(\w+)(\])?(\[|\.)?/g;
      function vn(t2, e2) {
        t2.seq.push(e2), t2.map[e2.id] = e2;
      }
      function _n(t2, e2, i2) {
        const n2 = t2.name, r2 = n2.length;
        for (gn.lastIndex = 0; ; ) {
          const o2 = gn.exec(n2), s2 = gn.lastIndex;
          let a2 = o2[1];
          const l2 = "]" === o2[2], h2 = o2[3];
          if (l2 && (a2 |= 0), void 0 === h2 || "[" === h2 && s2 + 2 === r2) {
            vn(i2, void 0 === h2 ? new pn(a2, t2, e2) : new fn(a2, t2, e2));
            break;
          }
          {
            let t3 = i2.map[a2];
            void 0 === t3 && (t3 = new mn(a2), vn(i2, t3)), i2 = t3;
          }
        }
      }
      function yn(t2, e2) {
        this.seq = [], this.map = {};
        const i2 = t2.getProgramParameter(e2, 35718);
        for (let n2 = 0; n2 < i2; ++n2) {
          const i3 = t2.getActiveUniform(e2, n2);
          _n(i3, t2.getUniformLocation(e2, i3.name), this);
        }
      }
      function xn(t2, e2, i2) {
        const n2 = t2.createShader(e2);
        return t2.shaderSource(n2, i2), t2.compileShader(n2), n2;
      }
      yn.prototype.setValue = function(t2, e2, i2, n2) {
        const r2 = this.map[e2];
        void 0 !== r2 && r2.setValue(t2, i2, n2);
      }, yn.prototype.setOptional = function(t2, e2, i2) {
        const n2 = e2[i2];
        void 0 !== n2 && this.setValue(t2, i2, n2);
      }, yn.upload = function(t2, e2, i2, n2) {
        for (let r2 = 0, o2 = e2.length; r2 !== o2; ++r2) {
          const o3 = e2[r2], s2 = i2[o3.id];
          false !== s2.needsUpdate && o3.setValue(t2, s2.value, n2);
        }
      }, yn.seqWithValue = function(t2, e2) {
        const i2 = [];
        for (let n2 = 0, r2 = t2.length; n2 !== r2; ++n2) {
          const r3 = t2[n2];
          r3.id in e2 && i2.push(r3);
        }
        return i2;
      };
      let bn = 0;
      function Tn(t2) {
        switch (t2) {
          case 3e3:
            return ["Linear", "( value )"];
          case 3001:
            return ["sRGB", "( value )"];
          case 3002:
            return ["RGBE", "( value )"];
          case 3004:
            return ["RGBM", "( value, 7.0 )"];
          case 3005:
            return ["RGBM", "( value, 16.0 )"];
          case 3006:
            return ["RGBD", "( value, 256.0 )"];
          case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
          case 3003:
            return ["LogLuv", "( value )"];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", t2), ["Linear", "( value )"];
        }
      }
      function En(t2, e2, i2) {
        const n2 = t2.getShaderParameter(e2, 35713), r2 = t2.getShaderInfoLog(e2).trim();
        if (n2 && "" === r2) return "";
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + i2 + "\n" + r2 + function(t3) {
          const e3 = t3.split("\n");
          for (let t4 = 0; t4 < e3.length; t4++) e3[t4] = t4 + 1 + ": " + e3[t4];
          return e3.join("\n");
        }(t2.getShaderSource(e2));
      }
      function Sn(t2, e2) {
        const i2 = Tn(e2);
        return "vec4 " + t2 + "( vec4 value ) { return " + i2[0] + "ToLinear" + i2[1] + "; }";
      }
      function wn(t2, e2) {
        const i2 = Tn(e2);
        return "vec4 " + t2 + "( vec4 value ) { return LinearTo" + i2[0] + i2[1] + "; }";
      }
      function An(t2, e2) {
        let i2;
        switch (e2) {
          case 1:
            i2 = "Linear";
            break;
          case 2:
            i2 = "Reinhard";
            break;
          case 3:
            i2 = "OptimizedCineon";
            break;
          case 4:
            i2 = "ACESFilmic";
            break;
          case 5:
            i2 = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e2), i2 = "Linear";
        }
        return "vec3 " + t2 + "( vec3 color ) { return " + i2 + "ToneMapping( color ); }";
      }
      function Mn(t2) {
        return "" !== t2;
      }
      function Cn(t2, e2) {
        return t2.replace(/NUM_DIR_LIGHTS/g, e2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e2.numPointLightShadows);
      }
      function Rn(t2, e2) {
        return t2.replace(/NUM_CLIPPING_PLANES/g, e2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e2.numClippingPlanes - e2.numClipIntersection);
      }
      const In = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Pn(t2) {
        return t2.replace(In, On);
      }
      function On(t2, e2) {
        const i2 = Qe[e2];
        if (void 0 === i2) throw new Error("Can not resolve #include <" + e2 + ">");
        return Pn(i2);
      }
      const Nn = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Ln = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Dn(t2) {
        return t2.replace(Ln, Bn).replace(Nn, Fn);
      }
      function Fn(t2, e2, i2, n2) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Bn(t2, e2, i2, n2);
      }
      function Bn(t2, e2, i2, n2) {
        let r2 = "";
        for (let t3 = parseInt(e2); t3 < parseInt(i2); t3++) r2 += n2.replace(/\[\s*i\s*\]/g, "[ " + t3 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t3);
        return r2;
      }
      function Un(t2) {
        let e2 = "precision " + t2.precision + " float;\nprecision " + t2.precision + " int;";
        return "highp" === t2.precision ? e2 += "\n#define HIGH_PRECISION" : "mediump" === t2.precision ? e2 += "\n#define MEDIUM_PRECISION" : "lowp" === t2.precision && (e2 += "\n#define LOW_PRECISION"), e2;
      }
      function kn(t2, e2, i2, n2) {
        const r2 = t2.getContext(), o2 = i2.defines;
        let s2 = i2.vertexShader, a2 = i2.fragmentShader;
        const l2 = function(t3) {
          let e3 = "SHADOWMAP_TYPE_BASIC";
          return 1 === t3.shadowMapType ? e3 = "SHADOWMAP_TYPE_PCF" : 2 === t3.shadowMapType ? e3 = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t3.shadowMapType && (e3 = "SHADOWMAP_TYPE_VSM"), e3;
        }(i2), h2 = function(t3) {
          let e3 = "ENVMAP_TYPE_CUBE";
          if (t3.envMap) switch (t3.envMapMode) {
            case 301:
            case 302:
              e3 = "ENVMAP_TYPE_CUBE";
              break;
            case 306:
            case 307:
              e3 = "ENVMAP_TYPE_CUBE_UV";
          }
          return e3;
        }(i2), u2 = function(t3) {
          let e3 = "ENVMAP_MODE_REFLECTION";
          if (t3.envMap) switch (t3.envMapMode) {
            case 302:
            case 307:
              e3 = "ENVMAP_MODE_REFRACTION";
          }
          return e3;
        }(i2), c2 = function(t3) {
          let e3 = "ENVMAP_BLENDING_NONE";
          if (t3.envMap) switch (t3.combine) {
            case 0:
              e3 = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case 1:
              e3 = "ENVMAP_BLENDING_MIX";
              break;
            case 2:
              e3 = "ENVMAP_BLENDING_ADD";
          }
          return e3;
        }(i2), d2 = t2.gammaFactor > 0 ? t2.gammaFactor : 1, p2 = i2.isWebGL2 ? "" : function(t3) {
          return [t3.extensionDerivatives || t3.envMapCubeUV || t3.bumpMap || t3.tangentSpaceNormalMap || t3.clearcoatNormalMap || t3.flatShading || "physical" === t3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t3.extensionFragDepth || t3.logarithmicDepthBuffer) && t3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t3.extensionDrawBuffers && t3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t3.extensionShaderTextureLOD || t3.envMap || t3.transmission > 0) && t3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Mn).join("\n");
        }(i2), f2 = function(t3) {
          const e3 = [];
          for (const i3 in t3) {
            const n3 = t3[i3];
            false !== n3 && e3.push("#define " + i3 + " " + n3);
          }
          return e3.join("\n");
        }(o2), m2 = r2.createProgram();
        let g2, v2, _2 = i2.glslVersion ? "#version " + i2.glslVersion + "\n" : "";
        i2.isRawShaderMaterial ? (g2 = [f2].filter(Mn).join("\n"), g2.length > 0 && (g2 += "\n"), v2 = [p2, f2].filter(Mn).join("\n"), v2.length > 0 && (v2 += "\n")) : (g2 = [Un(i2), "#define SHADER_NAME " + i2.shaderName, f2, i2.instancing ? "#define USE_INSTANCING" : "", i2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d2, "#define MAX_BONES " + i2.maxBones, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + u2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.displacementMap && i2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.skinning ? "#define USE_SKINNING" : "", i2.useVertexTexture ? "#define BONE_TEXTURE" : "", i2.morphTargets ? "#define USE_MORPHTARGETS" : "", i2.morphNormals && false === i2.flatShading ? "#define USE_MORPHNORMALS" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(Mn).join("\n"), v2 = [p2, Un(i2), "#define SHADER_NAME " + i2.shaderName, f2, i2.alphaTest ? "#define ALPHATEST " + i2.alphaTest + (i2.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d2, i2.useFog && i2.fog ? "#define USE_FOG" : "", i2.useFog && i2.fogExp2 ? "#define FOG_EXP2" : "", i2.map ? "#define USE_MAP" : "", i2.matcap ? "#define USE_MATCAP" : "", i2.envMap ? "#define USE_ENVMAP" : "", i2.envMap ? "#define " + h2 : "", i2.envMap ? "#define " + u2 : "", i2.envMap ? "#define " + c2 : "", i2.lightMap ? "#define USE_LIGHTMAP" : "", i2.aoMap ? "#define USE_AOMAP" : "", i2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i2.bumpMap ? "#define USE_BUMPMAP" : "", i2.normalMap ? "#define USE_NORMALMAP" : "", i2.normalMap && i2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i2.normalMap && i2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i2.specularMap ? "#define USE_SPECULARMAP" : "", i2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i2.metalnessMap ? "#define USE_METALNESSMAP" : "", i2.alphaMap ? "#define USE_ALPHAMAP" : "", i2.sheen ? "#define USE_SHEEN" : "", i2.transmission ? "#define USE_TRANSMISSION" : "", i2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i2.thicknessMap ? "#define USE_THICKNESSMAP" : "", i2.vertexTangents ? "#define USE_TANGENT" : "", i2.vertexColors || i2.instancingColor ? "#define USE_COLOR" : "", i2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i2.vertexUvs ? "#define USE_UV" : "", i2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i2.gradientMap ? "#define USE_GRADIENTMAP" : "", i2.flatShading ? "#define FLAT_SHADED" : "", i2.doubleSided ? "#define DOUBLE_SIDED" : "", i2.flipSided ? "#define FLIP_SIDED" : "", i2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i2.shadowMapEnabled ? "#define " + l2 : "", i2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i2.logarithmicDepthBuffer && i2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (i2.extensionShaderTextureLOD || i2.envMap) && i2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== i2.toneMapping ? "#define TONE_MAPPING" : "", 0 !== i2.toneMapping ? Qe.tonemapping_pars_fragment : "", 0 !== i2.toneMapping ? An("toneMapping", i2.toneMapping) : "", i2.dithering ? "#define DITHERING" : "", Qe.encodings_pars_fragment, i2.map ? Sn("mapTexelToLinear", i2.mapEncoding) : "", i2.matcap ? Sn("matcapTexelToLinear", i2.matcapEncoding) : "", i2.envMap ? Sn("envMapTexelToLinear", i2.envMapEncoding) : "", i2.emissiveMap ? Sn("emissiveMapTexelToLinear", i2.emissiveMapEncoding) : "", i2.lightMap ? Sn("lightMapTexelToLinear", i2.lightMapEncoding) : "", wn("linearToOutputTexel", i2.outputEncoding), i2.depthPacking ? "#define DEPTH_PACKING " + i2.depthPacking : "", "\n"].filter(Mn).join("\n")), s2 = Pn(s2), s2 = Cn(s2, i2), s2 = Rn(s2, i2), a2 = Pn(a2), a2 = Cn(a2, i2), a2 = Rn(a2, i2), s2 = Dn(s2), a2 = Dn(a2), i2.isWebGL2 && true !== i2.isRawShaderMaterial && (_2 = "#version 300 es\n", g2 = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g2, v2 = ["#define varying in", "300 es" === i2.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === i2.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v2);
        const y2 = _2 + v2 + a2, x2 = xn(r2, 35633, _2 + g2 + s2), b2 = xn(r2, 35632, y2);
        if (r2.attachShader(m2, x2), r2.attachShader(m2, b2), void 0 !== i2.index0AttributeName ? r2.bindAttribLocation(m2, 0, i2.index0AttributeName) : true === i2.morphTargets && r2.bindAttribLocation(m2, 0, "position"), r2.linkProgram(m2), t2.debug.checkShaderErrors) {
          const t3 = r2.getProgramInfoLog(m2).trim(), e3 = r2.getShaderInfoLog(x2).trim(), i3 = r2.getShaderInfoLog(b2).trim();
          let n3 = true, o3 = true;
          if (false === r2.getProgramParameter(m2, 35714)) {
            n3 = false;
            const e4 = En(r2, x2, "vertex"), i4 = En(r2, b2, "fragment");
            console.error("THREE.WebGLProgram: shader error: ", r2.getError(), "35715", r2.getProgramParameter(m2, 35715), "gl.getProgramInfoLog", t3, e4, i4);
          } else "" !== t3 ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t3) : "" !== e3 && "" !== i3 || (o3 = false);
          o3 && (this.diagnostics = { runnable: n3, programLog: t3, vertexShader: { log: e3, prefix: g2 }, fragmentShader: { log: i3, prefix: v2 } });
        }
        let T2, E2;
        return r2.deleteShader(x2), r2.deleteShader(b2), this.getUniforms = function() {
          return void 0 === T2 && (T2 = new yn(r2, m2)), T2;
        }, this.getAttributes = function() {
          return void 0 === E2 && (E2 = function(t3, e3) {
            const i3 = {}, n3 = t3.getProgramParameter(e3, 35721);
            for (let r3 = 0; r3 < n3; r3++) {
              const n4 = t3.getActiveAttrib(e3, r3).name;
              i3[n4] = t3.getAttribLocation(e3, n4);
            }
            return i3;
          }(r2, m2)), E2;
        }, this.destroy = function() {
          n2.releaseStatesOfProgram(this), r2.deleteProgram(m2), this.program = void 0;
        }, this.name = i2.shaderName, this.id = bn++, this.cacheKey = e2, this.usedTimes = 1, this.program = m2, this.vertexShader = x2, this.fragmentShader = b2, this;
      }
      function Gn(t2, e2, i2, n2, r2, o2) {
        const s2 = [], a2 = n2.isWebGL2, l2 = n2.logarithmicDepthBuffer, h2 = n2.floatVertexTextures, u2 = n2.maxVertexUniforms, c2 = n2.vertexTextures;
        let d2 = n2.precision;
        const p2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];
        function m2(t3) {
          let e3;
          return t3 && t3.isTexture ? e3 = t3.encoding : t3 && t3.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e3 = t3.texture.encoding) : e3 = 3e3, e3;
        }
        return { getParameters: function(r3, s3, f3, g2, v2) {
          const _2 = g2.fog, y2 = r3.isMeshStandardMaterial ? g2.environment : null, x2 = e2.get(r3.envMap || y2), b2 = p2[r3.type], T2 = v2.isSkinnedMesh ? function(t3) {
            const e3 = t3.skeleton.bones;
            if (h2) return 1024;
            {
              const t4 = u2, i3 = Math.floor((t4 - 20) / 4), n3 = Math.min(i3, e3.length);
              return n3 < e3.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e3.length + " bones. This GPU supports " + n3 + "."), 0) : n3;
            }
          }(v2) : 0;
          let E2, S2;
          if (null !== r3.precision && (d2 = n2.getMaxPrecision(r3.precision), d2 !== r3.precision && console.warn("THREE.WebGLProgram.getParameters:", r3.precision, "not supported, using", d2, "instead.")), b2) {
            const t3 = ti[b2];
            E2 = t3.vertexShader, S2 = t3.fragmentShader;
          } else E2 = r3.vertexShader, S2 = r3.fragmentShader;
          const w2 = t2.getRenderTarget();
          return { isWebGL2: a2, shaderID: b2, shaderName: r3.type, vertexShader: E2, fragmentShader: S2, defines: r3.defines, isRawShaderMaterial: true === r3.isRawShaderMaterial, glslVersion: r3.glslVersion, precision: d2, instancing: true === v2.isInstancedMesh, instancingColor: true === v2.isInstancedMesh && null !== v2.instanceColor, supportsVertexTextures: c2, outputEncoding: null !== w2 ? m2(w2.texture) : t2.outputEncoding, map: !!r3.map, mapEncoding: m2(r3.map), matcap: !!r3.matcap, matcapEncoding: m2(r3.matcap), envMap: !!x2, envMapMode: x2 && x2.mapping, envMapEncoding: m2(x2), envMapCubeUV: !!x2 && (306 === x2.mapping || 307 === x2.mapping), lightMap: !!r3.lightMap, lightMapEncoding: m2(r3.lightMap), aoMap: !!r3.aoMap, emissiveMap: !!r3.emissiveMap, emissiveMapEncoding: m2(r3.emissiveMap), bumpMap: !!r3.bumpMap, normalMap: !!r3.normalMap, objectSpaceNormalMap: 1 === r3.normalMapType, tangentSpaceNormalMap: 0 === r3.normalMapType, clearcoatMap: !!r3.clearcoatMap, clearcoatRoughnessMap: !!r3.clearcoatRoughnessMap, clearcoatNormalMap: !!r3.clearcoatNormalMap, displacementMap: !!r3.displacementMap, roughnessMap: !!r3.roughnessMap, metalnessMap: !!r3.metalnessMap, specularMap: !!r3.specularMap, alphaMap: !!r3.alphaMap, gradientMap: !!r3.gradientMap, sheen: !!r3.sheen, transmission: !!r3.transmission, transmissionMap: !!r3.transmissionMap, thicknessMap: !!r3.thicknessMap, combine: r3.combine, vertexTangents: r3.normalMap && r3.vertexTangents, vertexColors: r3.vertexColors, vertexAlphas: true === r3.vertexColors && v2.geometry && v2.geometry.attributes.color && 4 === v2.geometry.attributes.color.itemSize, vertexUvs: !!(r3.map || r3.bumpMap || r3.normalMap || r3.specularMap || r3.alphaMap || r3.emissiveMap || r3.roughnessMap || r3.metalnessMap || r3.clearcoatMap || r3.clearcoatRoughnessMap || r3.clearcoatNormalMap || r3.displacementMap || r3.transmissionMap || r3.thicknessMap), uvsVertexOnly: !(r3.map || r3.bumpMap || r3.normalMap || r3.specularMap || r3.alphaMap || r3.emissiveMap || r3.roughnessMap || r3.metalnessMap || r3.clearcoatNormalMap || r3.transmission || r3.transmissionMap || r3.thicknessMap || !r3.displacementMap), fog: !!_2, useFog: r3.fog, fogExp2: _2 && _2.isFogExp2, flatShading: !!r3.flatShading, sizeAttenuation: r3.sizeAttenuation, logarithmicDepthBuffer: l2, skinning: true === v2.isSkinnedMesh && T2 > 0, maxBones: T2, useVertexTexture: h2, morphTargets: r3.morphTargets, morphNormals: r3.morphNormals, numDirLights: s3.directional.length, numPointLights: s3.point.length, numSpotLights: s3.spot.length, numRectAreaLights: s3.rectArea.length, numHemiLights: s3.hemi.length, numDirLightShadows: s3.directionalShadowMap.length, numPointLightShadows: s3.pointShadowMap.length, numSpotLightShadows: s3.spotShadowMap.length, numClippingPlanes: o2.numPlanes, numClipIntersection: o2.numIntersection, dithering: r3.dithering, shadowMapEnabled: t2.shadowMap.enabled && f3.length > 0, shadowMapType: t2.shadowMap.type, toneMapping: r3.toneMapped ? t2.toneMapping : 0, physicallyCorrectLights: t2.physicallyCorrectLights, premultipliedAlpha: r3.premultipliedAlpha, alphaTest: r3.alphaTest, doubleSided: 2 === r3.side, flipSided: 1 === r3.side, depthPacking: void 0 !== r3.depthPacking && r3.depthPacking, index0AttributeName: r3.index0AttributeName, extensionDerivatives: r3.extensions && r3.extensions.derivatives, extensionFragDepth: r3.extensions && r3.extensions.fragDepth, extensionDrawBuffers: r3.extensions && r3.extensions.drawBuffers, extensionShaderTextureLOD: r3.extensions && r3.extensions.shaderTextureLOD, rendererExtensionFragDepth: a2 || i2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: a2 || i2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: a2 || i2.has("EXT_shader_texture_lod"), customProgramCacheKey: r3.customProgramCacheKey() };
        }, getProgramCacheKey: function(e3) {
          const i3 = [];
          if (e3.shaderID ? i3.push(e3.shaderID) : (i3.push(e3.fragmentShader), i3.push(e3.vertexShader)), void 0 !== e3.defines) for (const t3 in e3.defines) i3.push(t3), i3.push(e3.defines[t3]);
          if (false === e3.isRawShaderMaterial) {
            for (let t3 = 0; t3 < f2.length; t3++) i3.push(e3[f2[t3]]);
            i3.push(t2.outputEncoding), i3.push(t2.gammaFactor);
          }
          return i3.push(e3.customProgramCacheKey), i3.join();
        }, getUniforms: function(t3) {
          const e3 = p2[t3.type];
          let i3;
          if (e3) {
            const t4 = ti[e3];
            i3 = De.clone(t4.uniforms);
          } else i3 = t3.uniforms;
          return i3;
        }, acquireProgram: function(e3, i3) {
          let n3;
          for (let t3 = 0, e4 = s2.length; t3 < e4; t3++) {
            const e5 = s2[t3];
            if (e5.cacheKey === i3) {
              n3 = e5, ++n3.usedTimes;
              break;
            }
          }
          return void 0 === n3 && (n3 = new kn(t2, i3, e3, r2), s2.push(n3)), n3;
        }, releaseProgram: function(t3) {
          if (0 == --t3.usedTimes) {
            const e3 = s2.indexOf(t3);
            s2[e3] = s2[s2.length - 1], s2.pop(), t3.destroy();
          }
        }, programs: s2 };
      }
      function Hn() {
        let t2 = /* @__PURE__ */ new WeakMap();
        return { get: function(e2) {
          let i2 = t2.get(e2);
          return void 0 === i2 && (i2 = {}, t2.set(e2, i2)), i2;
        }, remove: function(e2) {
          t2.delete(e2);
        }, update: function(e2, i2, n2) {
          t2.get(e2)[i2] = n2;
        }, dispose: function() {
          t2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function jn(t2, e2) {
        return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.program !== e2.program ? t2.program.id - e2.program.id : t2.material.id !== e2.material.id ? t2.material.id - e2.material.id : t2.z !== e2.z ? t2.z - e2.z : t2.id - e2.id;
      }
      function zn(t2, e2) {
        return t2.groupOrder !== e2.groupOrder ? t2.groupOrder - e2.groupOrder : t2.renderOrder !== e2.renderOrder ? t2.renderOrder - e2.renderOrder : t2.z !== e2.z ? e2.z - t2.z : t2.id - e2.id;
      }
      function Vn(t2) {
        const e2 = [];
        let i2 = 0;
        const n2 = [], r2 = [], o2 = [], s2 = { id: -1 };
        function a2(n3, r3, o3, a3, l2, h2) {
          let u2 = e2[i2];
          const c2 = t2.get(o3);
          return void 0 === u2 ? (u2 = { id: n3.id, object: n3, geometry: r3, material: o3, program: c2.program || s2, groupOrder: a3, renderOrder: n3.renderOrder, z: l2, group: h2 }, e2[i2] = u2) : (u2.id = n3.id, u2.object = n3, u2.geometry = r3, u2.material = o3, u2.program = c2.program || s2, u2.groupOrder = a3, u2.renderOrder = n3.renderOrder, u2.z = l2, u2.group = h2), i2++, u2;
        }
        return { opaque: n2, transmissive: r2, transparent: o2, init: function() {
          i2 = 0, n2.length = 0, r2.length = 0, o2.length = 0;
        }, push: function(t3, e3, i3, s3, l2, h2) {
          const u2 = a2(t3, e3, i3, s3, l2, h2);
          i3.transmission > 0 ? r2.push(u2) : true === i3.transparent ? o2.push(u2) : n2.push(u2);
        }, unshift: function(t3, e3, i3, s3, l2, h2) {
          const u2 = a2(t3, e3, i3, s3, l2, h2);
          i3.transmission > 0 ? r2.unshift(u2) : true === i3.transparent ? o2.unshift(u2) : n2.unshift(u2);
        }, finish: function() {
          for (let t3 = i2, n3 = e2.length; t3 < n3; t3++) {
            const i3 = e2[t3];
            if (null === i3.id) break;
            i3.id = null, i3.object = null, i3.geometry = null, i3.material = null, i3.program = null, i3.group = null;
          }
        }, sort: function(t3, e3) {
          n2.length > 1 && n2.sort(t3 || jn), r2.length > 1 && r2.sort(e3 || zn), o2.length > 1 && o2.sort(e3 || zn);
        } };
      }
      function Xn(t2) {
        let e2 = /* @__PURE__ */ new WeakMap();
        return { get: function(i2, n2) {
          let r2;
          return false === e2.has(i2) ? (r2 = new Vn(t2), e2.set(i2, [r2])) : n2 >= e2.get(i2).length ? (r2 = new Vn(t2), e2.get(i2).push(r2)) : r2 = e2.get(i2)[n2], r2;
        }, dispose: function() {
          e2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      function Wn() {
        const t2 = {};
        return { get: function(e2) {
          if (void 0 !== t2[e2.id]) return t2[e2.id];
          let i2;
          switch (e2.type) {
            case "DirectionalLight":
              i2 = { direction: new M(), color: new Zt() };
              break;
            case "SpotLight":
              i2 = { position: new M(), direction: new M(), color: new Zt(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
              break;
            case "PointLight":
              i2 = { position: new M(), color: new Zt(), distance: 0, decay: 0 };
              break;
            case "HemisphereLight":
              i2 = { direction: new M(), skyColor: new Zt(), groundColor: new Zt() };
              break;
            case "RectAreaLight":
              i2 = { color: new Zt(), position: new M(), halfWidth: new M(), halfHeight: new M() };
          }
          return t2[e2.id] = i2, i2;
        } };
      }
      let Yn = 0;
      function qn(t2, e2) {
        return (e2.castShadow ? 1 : 0) - (t2.castShadow ? 1 : 0);
      }
      function Zn(t2, e2) {
        const i2 = new Wn(), n2 = /* @__PURE__ */ function() {
          const t3 = {};
          return { get: function(e3) {
            if (void 0 !== t3[e3.id]) return t3[e3.id];
            let i3;
            switch (e3.type) {
              case "DirectionalLight":
              case "SpotLight":
                i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new g() };
                break;
              case "PointLight":
                i3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new g(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
            }
            return t3[e3.id] = i3, i3;
          } };
        }(), r2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
        for (let t3 = 0; t3 < 9; t3++) r2.probe.push(new M());
        const o2 = new M(), s2 = new rt(), a2 = new rt();
        return { setup: function(o3) {
          let s3 = 0, a3 = 0, l2 = 0;
          for (let t3 = 0; t3 < 9; t3++) r2.probe[t3].set(0, 0, 0);
          let h2 = 0, u2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0;
          o3.sort(qn);
          for (let t3 = 0, e3 = o3.length; t3 < e3; t3++) {
            const e4 = o3[t3], v3 = e4.color, _2 = e4.intensity, y2 = e4.distance, x2 = e4.shadow && e4.shadow.map ? e4.shadow.map.texture : null;
            if (e4.isAmbientLight) s3 += v3.r * _2, a3 += v3.g * _2, l2 += v3.b * _2;
            else if (e4.isLightProbe) for (let t4 = 0; t4 < 9; t4++) r2.probe[t4].addScaledVector(e4.sh.coefficients[t4], _2);
            else if (e4.isDirectionalLight) {
              const t4 = i2.get(e4);
              if (t4.color.copy(e4.color).multiplyScalar(e4.intensity), e4.castShadow) {
                const t5 = e4.shadow, i3 = n2.get(e4);
                i3.shadowBias = t5.bias, i3.shadowNormalBias = t5.normalBias, i3.shadowRadius = t5.radius, i3.shadowMapSize = t5.mapSize, r2.directionalShadow[h2] = i3, r2.directionalShadowMap[h2] = x2, r2.directionalShadowMatrix[h2] = e4.shadow.matrix, f2++;
              }
              r2.directional[h2] = t4, h2++;
            } else if (e4.isSpotLight) {
              const t4 = i2.get(e4);
              if (t4.position.setFromMatrixPosition(e4.matrixWorld), t4.color.copy(v3).multiplyScalar(_2), t4.distance = y2, t4.coneCos = Math.cos(e4.angle), t4.penumbraCos = Math.cos(e4.angle * (1 - e4.penumbra)), t4.decay = e4.decay, e4.castShadow) {
                const t5 = e4.shadow, i3 = n2.get(e4);
                i3.shadowBias = t5.bias, i3.shadowNormalBias = t5.normalBias, i3.shadowRadius = t5.radius, i3.shadowMapSize = t5.mapSize, r2.spotShadow[c2] = i3, r2.spotShadowMap[c2] = x2, r2.spotShadowMatrix[c2] = e4.shadow.matrix, g2++;
              }
              r2.spot[c2] = t4, c2++;
            } else if (e4.isRectAreaLight) {
              const t4 = i2.get(e4);
              t4.color.copy(v3).multiplyScalar(_2), t4.halfWidth.set(0.5 * e4.width, 0, 0), t4.halfHeight.set(0, 0.5 * e4.height, 0), r2.rectArea[d2] = t4, d2++;
            } else if (e4.isPointLight) {
              const t4 = i2.get(e4);
              if (t4.color.copy(e4.color).multiplyScalar(e4.intensity), t4.distance = e4.distance, t4.decay = e4.decay, e4.castShadow) {
                const t5 = e4.shadow, i3 = n2.get(e4);
                i3.shadowBias = t5.bias, i3.shadowNormalBias = t5.normalBias, i3.shadowRadius = t5.radius, i3.shadowMapSize = t5.mapSize, i3.shadowCameraNear = t5.camera.near, i3.shadowCameraFar = t5.camera.far, r2.pointShadow[u2] = i3, r2.pointShadowMap[u2] = x2, r2.pointShadowMatrix[u2] = e4.shadow.matrix, m2++;
              }
              r2.point[u2] = t4, u2++;
            } else if (e4.isHemisphereLight) {
              const t4 = i2.get(e4);
              t4.skyColor.copy(e4.color).multiplyScalar(_2), t4.groundColor.copy(e4.groundColor).multiplyScalar(_2), r2.hemi[p2] = t4, p2++;
            }
          }
          d2 > 0 && (e2.isWebGL2 || true === t2.has("OES_texture_float_linear") ? (r2.rectAreaLTC1 = $e.LTC_FLOAT_1, r2.rectAreaLTC2 = $e.LTC_FLOAT_2) : true === t2.has("OES_texture_half_float_linear") ? (r2.rectAreaLTC1 = $e.LTC_HALF_1, r2.rectAreaLTC2 = $e.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r2.ambient[0] = s3, r2.ambient[1] = a3, r2.ambient[2] = l2;
          const v2 = r2.hash;
          v2.directionalLength === h2 && v2.pointLength === u2 && v2.spotLength === c2 && v2.rectAreaLength === d2 && v2.hemiLength === p2 && v2.numDirectionalShadows === f2 && v2.numPointShadows === m2 && v2.numSpotShadows === g2 || (r2.directional.length = h2, r2.spot.length = c2, r2.rectArea.length = d2, r2.point.length = u2, r2.hemi.length = p2, r2.directionalShadow.length = f2, r2.directionalShadowMap.length = f2, r2.pointShadow.length = m2, r2.pointShadowMap.length = m2, r2.spotShadow.length = g2, r2.spotShadowMap.length = g2, r2.directionalShadowMatrix.length = f2, r2.pointShadowMatrix.length = m2, r2.spotShadowMatrix.length = g2, v2.directionalLength = h2, v2.pointLength = u2, v2.spotLength = c2, v2.rectAreaLength = d2, v2.hemiLength = p2, v2.numDirectionalShadows = f2, v2.numPointShadows = m2, v2.numSpotShadows = g2, r2.version = Yn++);
        }, setupView: function(t3, e3) {
          let i3 = 0, n3 = 0, l2 = 0, h2 = 0, u2 = 0;
          const c2 = e3.matrixWorldInverse;
          for (let e4 = 0, d2 = t3.length; e4 < d2; e4++) {
            const d3 = t3[e4];
            if (d3.isDirectionalLight) {
              const t4 = r2.directional[i3];
              t4.direction.setFromMatrixPosition(d3.matrixWorld), o2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(o2), t4.direction.transformDirection(c2), i3++;
            } else if (d3.isSpotLight) {
              const t4 = r2.spot[l2];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(c2), t4.direction.setFromMatrixPosition(d3.matrixWorld), o2.setFromMatrixPosition(d3.target.matrixWorld), t4.direction.sub(o2), t4.direction.transformDirection(c2), l2++;
            } else if (d3.isRectAreaLight) {
              const t4 = r2.rectArea[h2];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(c2), a2.identity(), s2.copy(d3.matrixWorld), s2.premultiply(c2), a2.extractRotation(s2), t4.halfWidth.set(0.5 * d3.width, 0, 0), t4.halfHeight.set(0, 0.5 * d3.height, 0), t4.halfWidth.applyMatrix4(a2), t4.halfHeight.applyMatrix4(a2), h2++;
            } else if (d3.isPointLight) {
              const t4 = r2.point[n3];
              t4.position.setFromMatrixPosition(d3.matrixWorld), t4.position.applyMatrix4(c2), n3++;
            } else if (d3.isHemisphereLight) {
              const t4 = r2.hemi[u2];
              t4.direction.setFromMatrixPosition(d3.matrixWorld), t4.direction.transformDirection(c2), t4.direction.normalize(), u2++;
            }
          }
        }, state: r2 };
      }
      function Jn(t2, e2) {
        const i2 = new Zn(t2, e2), n2 = [], r2 = [];
        return { init: function() {
          n2.length = 0, r2.length = 0;
        }, state: { lightsArray: n2, shadowsArray: r2, lights: i2 }, setupLights: function() {
          i2.setup(n2);
        }, setupLightsView: function(t3) {
          i2.setupView(n2, t3);
        }, pushLight: function(t3) {
          n2.push(t3);
        }, pushShadow: function(t3) {
          r2.push(t3);
        } };
      }
      function Kn(t2, e2) {
        let i2 = /* @__PURE__ */ new WeakMap();
        return { get: function(n2, r2 = 0) {
          let o2;
          return false === i2.has(n2) ? (o2 = new Jn(t2, e2), i2.set(n2, [o2])) : r2 >= i2.get(n2).length ? (o2 = new Jn(t2, e2), i2.get(n2).push(o2)) : o2 = i2.get(n2)[r2], o2;
        }, dispose: function() {
          i2 = /* @__PURE__ */ new WeakMap();
        } };
      }
      class Qn extends jt {
        constructor(t2) {
          super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.depthPacking = t2.depthPacking, this.morphTargets = t2.morphTargets, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this;
        }
      }
      Qn.prototype.isMeshDepthMaterial = true;
      class $n extends jt {
        constructor(t2) {
          super(), this.type = "MeshDistanceMaterial", this.referencePosition = new M(), this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.referencePosition.copy(t2.referencePosition), this.nearDistance = t2.nearDistance, this.farDistance = t2.farDistance, this.morphTargets = t2.morphTargets, this.map = t2.map, this.alphaMap = t2.alphaMap, this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this;
        }
      }
      $n.prototype.isMeshDistanceMaterial = true;
      function tr(t2, e2, i2) {
        let n2 = new qe();
        const r2 = new g(), o2 = new g(), s2 = new E(), a2 = [], l2 = [], h2 = {}, u2 = i2.maxTextureSize, c2 = { 0: 1, 1: 0, 2: 2 }, d2 = new Fe({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new g() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), p2 = d2.clone();
        p2.defines.HORIZONTAL_PASS = 1;
        const f2 = new de();
        f2.setAttribute("position", new $t(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const m2 = new Ie(f2, d2), v2 = this;
        function _2(i3, n3) {
          const r3 = e2.update(m2);
          d2.uniforms.shadow_pass.value = i3.map.texture, d2.uniforms.resolution.value = i3.mapSize, d2.uniforms.radius.value = i3.radius, t2.setRenderTarget(i3.mapPass), t2.clear(), t2.renderBufferDirect(n3, null, r3, d2, m2, null), p2.uniforms.shadow_pass.value = i3.mapPass.texture, p2.uniforms.resolution.value = i3.mapSize, p2.uniforms.radius.value = i3.radius, t2.setRenderTarget(i3.map), t2.clear(), t2.renderBufferDirect(n3, null, r3, p2, m2, null);
        }
        function y2(t3) {
          const e3 = t3 << 0;
          let i3 = a2[e3];
          return void 0 === i3 && (i3 = new Qn({ depthPacking: 3201, morphTargets: t3 }), a2[e3] = i3), i3;
        }
        function x2(t3) {
          const e3 = t3 << 0;
          let i3 = l2[e3];
          return void 0 === i3 && (i3 = new $n({ morphTargets: t3 }), l2[e3] = i3), i3;
        }
        function b2(e3, i3, n3, r3, o3, s3, a3) {
          let l3 = null, u3 = y2, d3 = e3.customDepthMaterial;
          if (true === r3.isPointLight && (u3 = x2, d3 = e3.customDistanceMaterial), void 0 === d3) {
            let t3 = false;
            true === n3.morphTargets && (t3 = i3.morphAttributes && i3.morphAttributes.position && i3.morphAttributes.position.length > 0), l3 = u3(t3);
          } else l3 = d3;
          if (t2.localClippingEnabled && true === n3.clipShadows && 0 !== n3.clippingPlanes.length) {
            const t3 = l3.uuid, e4 = n3.uuid;
            let i4 = h2[t3];
            void 0 === i4 && (i4 = {}, h2[t3] = i4);
            let r4 = i4[e4];
            void 0 === r4 && (r4 = l3.clone(), i4[e4] = r4), l3 = r4;
          }
          return l3.visible = n3.visible, l3.wireframe = n3.wireframe, l3.side = 3 === a3 ? null !== n3.shadowSide ? n3.shadowSide : n3.side : null !== n3.shadowSide ? n3.shadowSide : c2[n3.side], l3.clipShadows = n3.clipShadows, l3.clippingPlanes = n3.clippingPlanes, l3.clipIntersection = n3.clipIntersection, l3.wireframeLinewidth = n3.wireframeLinewidth, l3.linewidth = n3.linewidth, true === r3.isPointLight && true === l3.isMeshDistanceMaterial && (l3.referencePosition.setFromMatrixPosition(r3.matrixWorld), l3.nearDistance = o3, l3.farDistance = s3), l3;
        }
        function T2(i3, r3, o3, s3, a3) {
          if (false === i3.visible) return;
          if (i3.layers.test(r3.layers) && (i3.isMesh || i3.isLine || i3.isPoints) && (i3.castShadow || i3.receiveShadow && 3 === a3) && (!i3.frustumCulled || n2.intersectsObject(i3))) {
            i3.modelViewMatrix.multiplyMatrices(o3.matrixWorldInverse, i3.matrixWorld);
            const n3 = e2.update(i3), r4 = i3.material;
            if (Array.isArray(r4)) {
              const e3 = n3.groups;
              for (let l4 = 0, h3 = e3.length; l4 < h3; l4++) {
                const h4 = e3[l4], u3 = r4[h4.materialIndex];
                if (u3 && u3.visible) {
                  const e4 = b2(i3, n3, u3, s3, o3.near, o3.far, a3);
                  t2.renderBufferDirect(o3, null, n3, e4, i3, h4);
                }
              }
            } else if (r4.visible) {
              const e3 = b2(i3, n3, r4, s3, o3.near, o3.far, a3);
              t2.renderBufferDirect(o3, null, n3, e3, i3, null);
            }
          }
          const l3 = i3.children;
          for (let t3 = 0, e3 = l3.length; t3 < e3; t3++) T2(l3[t3], r3, o3, s3, a3);
        }
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(e3, i3, a3) {
          if (false === v2.enabled) return;
          if (false === v2.autoUpdate && false === v2.needsUpdate) return;
          if (0 === e3.length) return;
          const l3 = t2.getRenderTarget(), h3 = t2.getActiveCubeFace(), c3 = t2.getActiveMipmapLevel(), d3 = t2.state;
          d3.setBlending(0), d3.buffers.color.setClear(1, 1, 1, 1), d3.buffers.depth.setTest(true), d3.setScissorTest(false);
          for (let l4 = 0, h4 = e3.length; l4 < h4; l4++) {
            const h5 = e3[l4], c4 = h5.shadow;
            if (void 0 === c4) {
              console.warn("THREE.WebGLShadowMap:", h5, "has no shadow.");
              continue;
            }
            if (false === c4.autoUpdate && false === c4.needsUpdate) continue;
            r2.copy(c4.mapSize);
            const p3 = c4.getFrameExtents();
            if (r2.multiply(p3), o2.copy(c4.mapSize), (r2.x > u2 || r2.y > u2) && (r2.x > u2 && (o2.x = Math.floor(u2 / p3.x), r2.x = o2.x * p3.x, c4.mapSize.x = o2.x), r2.y > u2 && (o2.y = Math.floor(u2 / p3.y), r2.y = o2.y * p3.y, c4.mapSize.y = o2.y)), null === c4.map && !c4.isPointLightShadow && 3 === this.type) {
              const t3 = { minFilter: 1006, magFilter: 1006, format: 1023 };
              c4.map = new S(r2.x, r2.y, t3), c4.map.texture.name = h5.name + ".shadowMap", c4.mapPass = new S(r2.x, r2.y, t3), c4.camera.updateProjectionMatrix();
            }
            if (null === c4.map) {
              const t3 = { minFilter: 1003, magFilter: 1003, format: 1023 };
              c4.map = new S(r2.x, r2.y, t3), c4.map.texture.name = h5.name + ".shadowMap", c4.camera.updateProjectionMatrix();
            }
            t2.setRenderTarget(c4.map), t2.clear();
            const f3 = c4.getViewportCount();
            for (let t3 = 0; t3 < f3; t3++) {
              const e4 = c4.getViewport(t3);
              s2.set(o2.x * e4.x, o2.y * e4.y, o2.x * e4.z, o2.y * e4.w), d3.viewport(s2), c4.updateMatrices(h5, t3), n2 = c4.getFrustum(), T2(i3, a3, c4.camera, h5, this.type);
            }
            c4.isPointLightShadow || 3 !== this.type || _2(c4, a3), c4.needsUpdate = false;
          }
          v2.needsUpdate = false, t2.setRenderTarget(l3, h3, c3);
        };
      }
      function er(t2, e2, i2) {
        const n2 = i2.isWebGL2;
        const r2 = new function() {
          let e3 = false;
          const i3 = new E();
          let n3 = null;
          const r3 = new E(0, 0, 0, 0);
          return { setMask: function(i4) {
            n3 === i4 || e3 || (t2.colorMask(i4, i4, i4, i4), n3 = i4);
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4, n4, o3, s3, a3) {
            true === a3 && (e4 *= s3, n4 *= s3, o3 *= s3), i3.set(e4, n4, o3, s3), false === r3.equals(i3) && (t2.clearColor(e4, n4, o3, s3), r3.copy(i3));
          }, reset: function() {
            e3 = false, n3 = null, r3.set(-1, 0, 0, 0);
          } };
        }(), o2 = new function() {
          let e3 = false, i3 = null, n3 = null, r3 = null;
          return { setTest: function(t3) {
            t3 ? U2(2929) : k2(2929);
          }, setMask: function(n4) {
            i3 === n4 || e3 || (t2.depthMask(n4), i3 = n4);
          }, setFunc: function(e4) {
            if (n3 !== e4) {
              if (e4) switch (e4) {
                case 0:
                  t2.depthFunc(512);
                  break;
                case 1:
                  t2.depthFunc(519);
                  break;
                case 2:
                  t2.depthFunc(513);
                  break;
                case 3:
                  t2.depthFunc(515);
                  break;
                case 4:
                  t2.depthFunc(514);
                  break;
                case 5:
                  t2.depthFunc(518);
                  break;
                case 6:
                  t2.depthFunc(516);
                  break;
                case 7:
                  t2.depthFunc(517);
                  break;
                default:
                  t2.depthFunc(515);
              }
              else t2.depthFunc(515);
              n3 = e4;
            }
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4) {
            r3 !== e4 && (t2.clearDepth(e4), r3 = e4);
          }, reset: function() {
            e3 = false, i3 = null, n3 = null, r3 = null;
          } };
        }(), s2 = new function() {
          let e3 = false, i3 = null, n3 = null, r3 = null, o3 = null, s3 = null, a3 = null, l3 = null, h3 = null;
          return { setTest: function(t3) {
            e3 || (t3 ? U2(2960) : k2(2960));
          }, setMask: function(n4) {
            i3 === n4 || e3 || (t2.stencilMask(n4), i3 = n4);
          }, setFunc: function(e4, i4, s4) {
            n3 === e4 && r3 === i4 && o3 === s4 || (t2.stencilFunc(e4, i4, s4), n3 = e4, r3 = i4, o3 = s4);
          }, setOp: function(e4, i4, n4) {
            s3 === e4 && a3 === i4 && l3 === n4 || (t2.stencilOp(e4, i4, n4), s3 = e4, a3 = i4, l3 = n4);
          }, setLocked: function(t3) {
            e3 = t3;
          }, setClear: function(e4) {
            h3 !== e4 && (t2.clearStencil(e4), h3 = e4);
          }, reset: function() {
            e3 = false, i3 = null, n3 = null, r3 = null, o3 = null, s3 = null, a3 = null, l3 = null, h3 = null;
          } };
        }();
        let a2 = {}, l2 = null, h2 = {}, u2 = null, c2 = false, d2 = null, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, _2 = null, y2 = false, x2 = null, b2 = null, T2 = null, S2 = null, w2 = null;
        const A2 = t2.getParameter(35661);
        let M2 = false, C2 = 0;
        const R2 = t2.getParameter(7938);
        -1 !== R2.indexOf("WebGL") ? (C2 = parseFloat(/^WebGL (\d)/.exec(R2)[1]), M2 = C2 >= 1) : -1 !== R2.indexOf("OpenGL ES") && (C2 = parseFloat(/^OpenGL ES (\d)/.exec(R2)[1]), M2 = C2 >= 2);
        let I2 = null, P2 = {};
        const O2 = t2.getParameter(3088), N2 = t2.getParameter(2978), L2 = new E().fromArray(O2), D2 = new E().fromArray(N2);
        function F2(e3, i3, n3) {
          const r3 = new Uint8Array(4), o3 = t2.createTexture();
          t2.bindTexture(e3, o3), t2.texParameteri(e3, 10241, 9728), t2.texParameteri(e3, 10240, 9728);
          for (let e4 = 0; e4 < n3; e4++) t2.texImage2D(i3 + e4, 0, 6408, 1, 1, 0, 6408, 5121, r3);
          return o3;
        }
        const B2 = {};
        function U2(e3) {
          true !== a2[e3] && (t2.enable(e3), a2[e3] = true);
        }
        function k2(e3) {
          false !== a2[e3] && (t2.disable(e3), a2[e3] = false);
        }
        B2[3553] = F2(3553, 3553, 1), B2[34067] = F2(34067, 34069, 6), r2.setClear(0, 0, 0, 1), o2.setClear(1), s2.setClear(0), U2(2929), o2.setFunc(3), z2(false), V2(1), U2(2884), j2(0);
        const G2 = { 100: 32774, 101: 32778, 102: 32779 };
        if (n2) G2[103] = 32775, G2[104] = 32776;
        else {
          const t3 = e2.get("EXT_blend_minmax");
          null !== t3 && (G2[103] = t3.MIN_EXT, G2[104] = t3.MAX_EXT);
        }
        const H2 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
        function j2(e3, i3, n3, r3, o3, s3, a3, l3) {
          if (0 !== e3) {
            if (false === c2 && (U2(3042), c2 = true), 5 === e3) o3 = o3 || i3, s3 = s3 || n3, a3 = a3 || r3, i3 === p2 && o3 === g2 || (t2.blendEquationSeparate(G2[i3], G2[o3]), p2 = i3, g2 = o3), n3 === f2 && r3 === m2 && s3 === v2 && a3 === _2 || (t2.blendFuncSeparate(H2[n3], H2[r3], H2[s3], H2[a3]), f2 = n3, m2 = r3, v2 = s3, _2 = a3), d2 = e3, y2 = null;
            else if (e3 !== d2 || l3 !== y2) {
              if (100 === p2 && 100 === g2 || (t2.blendEquation(32774), p2 = 100, g2 = 100), l3) switch (e3) {
                case 1:
                  t2.blendFuncSeparate(1, 771, 1, 771);
                  break;
                case 2:
                  t2.blendFunc(1, 1);
                  break;
                case 3:
                  t2.blendFuncSeparate(0, 0, 769, 771);
                  break;
                case 4:
                  t2.blendFuncSeparate(0, 768, 0, 770);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e3);
              }
              else switch (e3) {
                case 1:
                  t2.blendFuncSeparate(770, 771, 1, 771);
                  break;
                case 2:
                  t2.blendFunc(770, 1);
                  break;
                case 3:
                  t2.blendFunc(0, 769);
                  break;
                case 4:
                  t2.blendFunc(0, 768);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e3);
              }
              f2 = null, m2 = null, v2 = null, _2 = null, d2 = e3, y2 = l3;
            }
          } else true === c2 && (k2(3042), c2 = false);
        }
        function z2(e3) {
          x2 !== e3 && (e3 ? t2.frontFace(2304) : t2.frontFace(2305), x2 = e3);
        }
        function V2(e3) {
          0 !== e3 ? (U2(2884), e3 !== b2 && (1 === e3 ? t2.cullFace(1029) : 2 === e3 ? t2.cullFace(1028) : t2.cullFace(1032))) : k2(2884), b2 = e3;
        }
        function X2(e3, i3, n3) {
          e3 ? (U2(32823), S2 === i3 && w2 === n3 || (t2.polygonOffset(i3, n3), S2 = i3, w2 = n3)) : k2(32823);
        }
        function W2(e3) {
          void 0 === e3 && (e3 = 33984 + A2 - 1), I2 !== e3 && (t2.activeTexture(e3), I2 = e3);
        }
        return { buffers: { color: r2, depth: o2, stencil: s2 }, enable: U2, disable: k2, bindFramebuffer: function(e3, i3) {
          return null === i3 && null !== l2 && (i3 = l2), h2[e3] !== i3 && (t2.bindFramebuffer(e3, i3), h2[e3] = i3, n2 && (36009 === e3 && (h2[36160] = i3), 36160 === e3 && (h2[36009] = i3)), true);
        }, bindXRFramebuffer: function(e3) {
          e3 !== l2 && (t2.bindFramebuffer(36160, e3), l2 = e3);
        }, useProgram: function(e3) {
          return u2 !== e3 && (t2.useProgram(e3), u2 = e3, true);
        }, setBlending: j2, setMaterial: function(t3, e3) {
          2 === t3.side ? k2(2884) : U2(2884);
          let i3 = 1 === t3.side;
          e3 && (i3 = !i3), z2(i3), 1 === t3.blending && false === t3.transparent ? j2(0) : j2(t3.blending, t3.blendEquation, t3.blendSrc, t3.blendDst, t3.blendEquationAlpha, t3.blendSrcAlpha, t3.blendDstAlpha, t3.premultipliedAlpha), o2.setFunc(t3.depthFunc), o2.setTest(t3.depthTest), o2.setMask(t3.depthWrite), r2.setMask(t3.colorWrite);
          const n3 = t3.stencilWrite;
          s2.setTest(n3), n3 && (s2.setMask(t3.stencilWriteMask), s2.setFunc(t3.stencilFunc, t3.stencilRef, t3.stencilFuncMask), s2.setOp(t3.stencilFail, t3.stencilZFail, t3.stencilZPass)), X2(t3.polygonOffset, t3.polygonOffsetFactor, t3.polygonOffsetUnits), true === t3.alphaToCoverage ? U2(32926) : k2(32926);
        }, setFlipSided: z2, setCullFace: V2, setLineWidth: function(e3) {
          e3 !== T2 && (M2 && t2.lineWidth(e3), T2 = e3);
        }, setPolygonOffset: X2, setScissorTest: function(t3) {
          t3 ? U2(3089) : k2(3089);
        }, activeTexture: W2, bindTexture: function(e3, i3) {
          null === I2 && W2();
          let n3 = P2[I2];
          void 0 === n3 && (n3 = { type: void 0, texture: void 0 }, P2[I2] = n3), n3.type === e3 && n3.texture === i3 || (t2.bindTexture(e3, i3 || B2[e3]), n3.type = e3, n3.texture = i3);
        }, unbindTexture: function() {
          const e3 = P2[I2];
          void 0 !== e3 && void 0 !== e3.type && (t2.bindTexture(e3.type, null), e3.type = void 0, e3.texture = void 0);
        }, compressedTexImage2D: function() {
          try {
            t2.compressedTexImage2D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage2D: function() {
          try {
            t2.texImage2D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, texImage3D: function() {
          try {
            t2.texImage3D.apply(t2, arguments);
          } catch (t3) {
            console.error("THREE.WebGLState:", t3);
          }
        }, scissor: function(e3) {
          false === L2.equals(e3) && (t2.scissor(e3.x, e3.y, e3.z, e3.w), L2.copy(e3));
        }, viewport: function(e3) {
          false === D2.equals(e3) && (t2.viewport(e3.x, e3.y, e3.z, e3.w), D2.copy(e3));
        }, reset: function() {
          t2.disable(3042), t2.disable(2884), t2.disable(2929), t2.disable(32823), t2.disable(3089), t2.disable(2960), t2.disable(32926), t2.blendEquation(32774), t2.blendFunc(1, 0), t2.blendFuncSeparate(1, 0, 1, 0), t2.colorMask(true, true, true, true), t2.clearColor(0, 0, 0, 0), t2.depthMask(true), t2.depthFunc(513), t2.clearDepth(1), t2.stencilMask(4294967295), t2.stencilFunc(519, 0, 4294967295), t2.stencilOp(7680, 7680, 7680), t2.clearStencil(0), t2.cullFace(1029), t2.frontFace(2305), t2.polygonOffset(0, 0), t2.activeTexture(33984), t2.bindFramebuffer(36160, null), true === n2 && (t2.bindFramebuffer(36009, null), t2.bindFramebuffer(36008, null)), t2.useProgram(null), t2.lineWidth(1), t2.scissor(0, 0, t2.canvas.width, t2.canvas.height), t2.viewport(0, 0, t2.canvas.width, t2.canvas.height), a2 = {}, I2 = null, P2 = {}, l2 = null, h2 = {}, u2 = null, c2 = false, d2 = null, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, _2 = null, y2 = false, x2 = null, b2 = null, T2 = null, S2 = null, w2 = null, L2.set(0, 0, t2.canvas.width, t2.canvas.height), D2.set(0, 0, t2.canvas.width, t2.canvas.height), r2.reset(), o2.reset(), s2.reset();
        } };
      }
      function ir(t2, e2, i2, n2, r2, o2, s2) {
        const a2 = r2.isWebGL2, l2 = r2.maxTextures, h2 = r2.maxCubemapSize, u2 = r2.maxTextureSize, c2 = r2.maxSamples, d2 = /* @__PURE__ */ new WeakMap();
        let p2, g2 = false;
        try {
          g2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (t3) {
        }
        function v2(t3, e3) {
          return g2 ? new OffscreenCanvas(t3, e3) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        }
        function _2(t3, e3, i3, n3) {
          let r3 = 1;
          if ((t3.width > n3 || t3.height > n3) && (r3 = n3 / Math.max(t3.width, t3.height)), r3 < 1 || true === e3) {
            if ("undefined" != typeof HTMLImageElement && t3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap) {
              const n4 = e3 ? m : Math.floor, o3 = n4(r3 * t3.width), s3 = n4(r3 * t3.height);
              void 0 === p2 && (p2 = v2(o3, s3));
              const a3 = i3 ? v2(o3, s3) : p2;
              a3.width = o3, a3.height = s3;
              return a3.getContext("2d").drawImage(t3, 0, 0, o3, s3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t3.width + "x" + t3.height + ") to (" + o3 + "x" + s3 + ")."), a3;
            }
            return "data" in t3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t3.width + "x" + t3.height + ")."), t3;
          }
          return t3;
        }
        function y2(t3) {
          return f(t3.width) && f(t3.height);
        }
        function x2(t3, e3) {
          return t3.generateMipmaps && e3 && 1003 !== t3.minFilter && 1006 !== t3.minFilter;
        }
        function b2(e3, i3, r3, o3, s3 = 1) {
          t2.generateMipmap(e3);
          n2.get(i3).__maxMipLevel = Math.log2(Math.max(r3, o3, s3));
        }
        function T2(i3, n3, r3) {
          if (false === a2) return n3;
          if (null !== i3) {
            if (void 0 !== t2[i3]) return t2[i3];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i3 + "'");
          }
          let o3 = n3;
          return 6403 === n3 && (5126 === r3 && (o3 = 33326), 5131 === r3 && (o3 = 33325), 5121 === r3 && (o3 = 33321)), 6407 === n3 && (5126 === r3 && (o3 = 34837), 5131 === r3 && (o3 = 34843), 5121 === r3 && (o3 = 32849)), 6408 === n3 && (5126 === r3 && (o3 = 34836), 5131 === r3 && (o3 = 34842), 5121 === r3 && (o3 = 32856)), 33325 !== o3 && 33326 !== o3 && 34842 !== o3 && 34836 !== o3 || e2.get("EXT_color_buffer_float"), o3;
        }
        function E2(t3) {
          return 1003 === t3 || 1004 === t3 || 1005 === t3 ? 9728 : 9729;
        }
        function S2(e3) {
          const i3 = e3.target;
          i3.removeEventListener("dispose", S2), function(e4) {
            const i4 = n2.get(e4);
            if (void 0 === i4.__webglInit) return;
            t2.deleteTexture(i4.__webglTexture), n2.remove(e4);
          }(i3), i3.isVideoTexture && d2.delete(i3), s2.memory.textures--;
        }
        function w2(e3) {
          const i3 = e3.target;
          i3.removeEventListener("dispose", w2), function(e4) {
            const i4 = e4.texture, r3 = n2.get(e4), o3 = n2.get(i4);
            if (!e4) return;
            void 0 !== o3.__webglTexture && (t2.deleteTexture(o3.__webglTexture), s2.memory.textures--);
            e4.depthTexture && e4.depthTexture.dispose();
            if (e4.isWebGLCubeRenderTarget) for (let e5 = 0; e5 < 6; e5++) t2.deleteFramebuffer(r3.__webglFramebuffer[e5]), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer[e5]);
            else t2.deleteFramebuffer(r3.__webglFramebuffer), r3.__webglDepthbuffer && t2.deleteRenderbuffer(r3.__webglDepthbuffer), r3.__webglMultisampledFramebuffer && t2.deleteFramebuffer(r3.__webglMultisampledFramebuffer), r3.__webglColorRenderbuffer && t2.deleteRenderbuffer(r3.__webglColorRenderbuffer), r3.__webglDepthRenderbuffer && t2.deleteRenderbuffer(r3.__webglDepthRenderbuffer);
            if (e4.isWebGLMultipleRenderTargets) for (let e5 = 0, r4 = i4.length; e5 < r4; e5++) {
              const r5 = n2.get(i4[e5]);
              r5.__webglTexture && (t2.deleteTexture(r5.__webglTexture), s2.memory.textures--), n2.remove(i4[e5]);
            }
            n2.remove(i4), n2.remove(e4);
          }(i3);
        }
        let A2 = 0;
        function M2(t3, e3) {
          const r3 = n2.get(t3);
          if (t3.isVideoTexture && function(t4) {
            const e4 = s2.render.frame;
            d2.get(t4) !== e4 && (d2.set(t4, e4), t4.update());
          }(t3), t3.version > 0 && r3.__version !== t3.version) {
            const i3 = t3.image;
            if (void 0 === i3) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
            else {
              if (false !== i3.complete) return void N2(r3, t3, e3);
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          i2.activeTexture(33984 + e3), i2.bindTexture(3553, r3.__webglTexture);
        }
        function C2(e3, r3) {
          const s3 = n2.get(e3);
          e3.version > 0 && s3.__version !== e3.version ? function(e4, n3, r4) {
            if (6 !== n3.image.length) return;
            O2(e4, n3), i2.activeTexture(33984 + r4), i2.bindTexture(34067, e4.__webglTexture), t2.pixelStorei(37440, n3.flipY), t2.pixelStorei(37441, n3.premultiplyAlpha), t2.pixelStorei(3317, n3.unpackAlignment), t2.pixelStorei(37443, 0);
            const s4 = n3 && (n3.isCompressedTexture || n3.image[0].isCompressedTexture), l3 = n3.image[0] && n3.image[0].isDataTexture, u3 = [];
            for (let t3 = 0; t3 < 6; t3++) u3[t3] = s4 || l3 ? l3 ? n3.image[t3].image : n3.image[t3] : _2(n3.image[t3], false, true, h2);
            const c3 = u3[0], d3 = y2(c3) || a2, p3 = o2.convert(n3.format), f2 = o2.convert(n3.type), m2 = T2(n3.internalFormat, p3, f2);
            let g3;
            if (P2(34067, n3, d3), s4) {
              for (let t3 = 0; t3 < 6; t3++) {
                g3 = u3[t3].mipmaps;
                for (let e5 = 0; e5 < g3.length; e5++) {
                  const r5 = g3[e5];
                  1023 !== n3.format && 1022 !== n3.format ? null !== p3 ? i2.compressedTexImage2D(34069 + t3, e5, m2, r5.width, r5.height, 0, r5.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i2.texImage2D(34069 + t3, e5, m2, r5.width, r5.height, 0, p3, f2, r5.data);
                }
              }
              e4.__maxMipLevel = g3.length - 1;
            } else {
              g3 = n3.mipmaps;
              for (let t3 = 0; t3 < 6; t3++) if (l3) {
                i2.texImage2D(34069 + t3, 0, m2, u3[t3].width, u3[t3].height, 0, p3, f2, u3[t3].data);
                for (let e5 = 0; e5 < g3.length; e5++) {
                  const n4 = g3[e5].image[t3].image;
                  i2.texImage2D(34069 + t3, e5 + 1, m2, n4.width, n4.height, 0, p3, f2, n4.data);
                }
              } else {
                i2.texImage2D(34069 + t3, 0, m2, p3, f2, u3[t3]);
                for (let e5 = 0; e5 < g3.length; e5++) {
                  const n4 = g3[e5];
                  i2.texImage2D(34069 + t3, e5 + 1, m2, p3, f2, n4.image[t3]);
                }
              }
              e4.__maxMipLevel = g3.length;
            }
            x2(n3, d3) && b2(34067, n3, c3.width, c3.height);
            e4.__version = n3.version, n3.onUpdate && n3.onUpdate(n3);
          }(s3, e3, r3) : (i2.activeTexture(33984 + r3), i2.bindTexture(34067, s3.__webglTexture));
        }
        const R2 = { 1e3: 10497, 1001: 33071, 1002: 33648 }, I2 = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
        function P2(i3, o3, s3) {
          if (s3 ? (t2.texParameteri(i3, 10242, R2[o3.wrapS]), t2.texParameteri(i3, 10243, R2[o3.wrapT]), 32879 !== i3 && 35866 !== i3 || t2.texParameteri(i3, 32882, R2[o3.wrapR]), t2.texParameteri(i3, 10240, I2[o3.magFilter]), t2.texParameteri(i3, 10241, I2[o3.minFilter])) : (t2.texParameteri(i3, 10242, 33071), t2.texParameteri(i3, 10243, 33071), 32879 !== i3 && 35866 !== i3 || t2.texParameteri(i3, 32882, 33071), 1001 === o3.wrapS && 1001 === o3.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t2.texParameteri(i3, 10240, E2(o3.magFilter)), t2.texParameteri(i3, 10241, E2(o3.minFilter)), 1003 !== o3.minFilter && 1006 !== o3.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === e2.has("EXT_texture_filter_anisotropic")) {
            const s4 = e2.get("EXT_texture_filter_anisotropic");
            if (1015 === o3.type && false === e2.has("OES_texture_float_linear")) return;
            if (false === a2 && 1016 === o3.type && false === e2.has("OES_texture_half_float_linear")) return;
            (o3.anisotropy > 1 || n2.get(o3).__currentAnisotropy) && (t2.texParameterf(i3, s4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o3.anisotropy, r2.getMaxAnisotropy())), n2.get(o3).__currentAnisotropy = o3.anisotropy);
          }
        }
        function O2(e3, i3) {
          void 0 === e3.__webglInit && (e3.__webglInit = true, i3.addEventListener("dispose", S2), e3.__webglTexture = t2.createTexture(), s2.memory.textures++);
        }
        function N2(e3, n3, r3) {
          let s3 = 3553;
          n3.isDataTexture2DArray && (s3 = 35866), n3.isDataTexture3D && (s3 = 32879), O2(e3, n3), i2.activeTexture(33984 + r3), i2.bindTexture(s3, e3.__webglTexture), t2.pixelStorei(37440, n3.flipY), t2.pixelStorei(37441, n3.premultiplyAlpha), t2.pixelStorei(3317, n3.unpackAlignment), t2.pixelStorei(37443, 0);
          const l3 = function(t3) {
            return !a2 && (1001 !== t3.wrapS || 1001 !== t3.wrapT || 1003 !== t3.minFilter && 1006 !== t3.minFilter);
          }(n3) && false === y2(n3.image), h3 = _2(n3.image, l3, false, u2), c3 = y2(h3) || a2, d3 = o2.convert(n3.format);
          let p3, f2 = o2.convert(n3.type), m2 = T2(n3.internalFormat, d3, f2);
          P2(s3, n3, c3);
          const g3 = n3.mipmaps;
          if (n3.isDepthTexture) m2 = 6402, a2 ? m2 = 1015 === n3.type ? 36012 : 1014 === n3.type ? 33190 : 1020 === n3.type ? 35056 : 33189 : 1015 === n3.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === n3.format && 6402 === m2 && 1012 !== n3.type && 1014 !== n3.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n3.type = 1012, f2 = o2.convert(n3.type)), 1027 === n3.format && 6402 === m2 && (m2 = 34041, 1020 !== n3.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n3.type = 1020, f2 = o2.convert(n3.type))), i2.texImage2D(3553, 0, m2, h3.width, h3.height, 0, d3, f2, null);
          else if (n3.isDataTexture) if (g3.length > 0 && c3) {
            for (let t3 = 0, e4 = g3.length; t3 < e4; t3++) p3 = g3[t3], i2.texImage2D(3553, t3, m2, p3.width, p3.height, 0, d3, f2, p3.data);
            n3.generateMipmaps = false, e3.__maxMipLevel = g3.length - 1;
          } else i2.texImage2D(3553, 0, m2, h3.width, h3.height, 0, d3, f2, h3.data), e3.__maxMipLevel = 0;
          else if (n3.isCompressedTexture) {
            for (let t3 = 0, e4 = g3.length; t3 < e4; t3++) p3 = g3[t3], 1023 !== n3.format && 1022 !== n3.format ? null !== d3 ? i2.compressedTexImage2D(3553, t3, m2, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i2.texImage2D(3553, t3, m2, p3.width, p3.height, 0, d3, f2, p3.data);
            e3.__maxMipLevel = g3.length - 1;
          } else if (n3.isDataTexture2DArray) i2.texImage3D(35866, 0, m2, h3.width, h3.height, h3.depth, 0, d3, f2, h3.data), e3.__maxMipLevel = 0;
          else if (n3.isDataTexture3D) i2.texImage3D(32879, 0, m2, h3.width, h3.height, h3.depth, 0, d3, f2, h3.data), e3.__maxMipLevel = 0;
          else if (g3.length > 0 && c3) {
            for (let t3 = 0, e4 = g3.length; t3 < e4; t3++) p3 = g3[t3], i2.texImage2D(3553, t3, m2, d3, f2, p3);
            n3.generateMipmaps = false, e3.__maxMipLevel = g3.length - 1;
          } else i2.texImage2D(3553, 0, m2, d3, f2, h3), e3.__maxMipLevel = 0;
          x2(n3, c3) && b2(s3, n3, h3.width, h3.height), e3.__version = n3.version, n3.onUpdate && n3.onUpdate(n3);
        }
        function L2(e3, r3, s3, a3, l3) {
          const h3 = o2.convert(s3.format), u3 = o2.convert(s3.type), c3 = T2(s3.internalFormat, h3, u3);
          32879 === l3 || 35866 === l3 ? i2.texImage3D(l3, 0, c3, r3.width, r3.height, r3.depth, 0, h3, u3, null) : i2.texImage2D(l3, 0, c3, r3.width, r3.height, 0, h3, u3, null), i2.bindFramebuffer(36160, e3), t2.framebufferTexture2D(36160, a3, l3, n2.get(s3).__webglTexture, 0), i2.bindFramebuffer(36160, null);
        }
        function D2(e3, i3, n3) {
          if (t2.bindRenderbuffer(36161, e3), i3.depthBuffer && !i3.stencilBuffer) {
            let r3 = 33189;
            if (n3) {
              const e4 = i3.depthTexture;
              e4 && e4.isDepthTexture && (1015 === e4.type ? r3 = 36012 : 1014 === e4.type && (r3 = 33190));
              const n4 = B2(i3);
              t2.renderbufferStorageMultisample(36161, n4, r3, i3.width, i3.height);
            } else t2.renderbufferStorage(36161, r3, i3.width, i3.height);
            t2.framebufferRenderbuffer(36160, 36096, 36161, e3);
          } else if (i3.depthBuffer && i3.stencilBuffer) {
            if (n3) {
              const e4 = B2(i3);
              t2.renderbufferStorageMultisample(36161, e4, 35056, i3.width, i3.height);
            } else t2.renderbufferStorage(36161, 34041, i3.width, i3.height);
            t2.framebufferRenderbuffer(36160, 33306, 36161, e3);
          } else {
            const e4 = true === i3.isWebGLMultipleRenderTargets ? i3.texture[0] : i3.texture, r3 = o2.convert(e4.format), s3 = o2.convert(e4.type), a3 = T2(e4.internalFormat, r3, s3);
            if (n3) {
              const e5 = B2(i3);
              t2.renderbufferStorageMultisample(36161, e5, a3, i3.width, i3.height);
            } else t2.renderbufferStorage(36161, a3, i3.width, i3.height);
          }
          t2.bindRenderbuffer(36161, null);
        }
        function F2(e3) {
          const r3 = n2.get(e3), o3 = true === e3.isWebGLCubeRenderTarget;
          if (e3.depthTexture) {
            if (o3) throw new Error("target.depthTexture not supported in Cube render targets");
            !function(e4, r4) {
              if (r4 && r4.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
              if (i2.bindFramebuffer(36160, e4), !r4.depthTexture || !r4.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              n2.get(r4.depthTexture).__webglTexture && r4.depthTexture.image.width === r4.width && r4.depthTexture.image.height === r4.height || (r4.depthTexture.image.width = r4.width, r4.depthTexture.image.height = r4.height, r4.depthTexture.needsUpdate = true), M2(r4.depthTexture, 0);
              const o4 = n2.get(r4.depthTexture).__webglTexture;
              if (1026 === r4.depthTexture.format) t2.framebufferTexture2D(36160, 36096, 3553, o4, 0);
              else {
                if (1027 !== r4.depthTexture.format) throw new Error("Unknown depthTexture format");
                t2.framebufferTexture2D(36160, 33306, 3553, o4, 0);
              }
            }(r3.__webglFramebuffer, e3);
          } else if (o3) {
            r3.__webglDepthbuffer = [];
            for (let n3 = 0; n3 < 6; n3++) i2.bindFramebuffer(36160, r3.__webglFramebuffer[n3]), r3.__webglDepthbuffer[n3] = t2.createRenderbuffer(), D2(r3.__webglDepthbuffer[n3], e3, false);
          } else i2.bindFramebuffer(36160, r3.__webglFramebuffer), r3.__webglDepthbuffer = t2.createRenderbuffer(), D2(r3.__webglDepthbuffer, e3, false);
          i2.bindFramebuffer(36160, null);
        }
        function B2(t3) {
          return a2 && t3.isWebGLMultisampleRenderTarget ? Math.min(c2, t3.samples) : 0;
        }
        let U2 = false, k2 = false;
        this.allocateTextureUnit = function() {
          const t3 = A2;
          return t3 >= l2 && console.warn("THREE.WebGLTextures: Trying to use " + t3 + " texture units while this GPU supports only " + l2), A2 += 1, t3;
        }, this.resetTextureUnits = function() {
          A2 = 0;
        }, this.setTexture2D = M2, this.setTexture2DArray = function(t3, e3) {
          const r3 = n2.get(t3);
          t3.version > 0 && r3.__version !== t3.version ? N2(r3, t3, e3) : (i2.activeTexture(33984 + e3), i2.bindTexture(35866, r3.__webglTexture));
        }, this.setTexture3D = function(t3, e3) {
          const r3 = n2.get(t3);
          t3.version > 0 && r3.__version !== t3.version ? N2(r3, t3, e3) : (i2.activeTexture(33984 + e3), i2.bindTexture(32879, r3.__webglTexture));
        }, this.setTextureCube = C2, this.setupRenderTarget = function(e3) {
          const l3 = e3.texture, h3 = n2.get(e3), u3 = n2.get(l3);
          e3.addEventListener("dispose", w2), true !== e3.isWebGLMultipleRenderTargets && (u3.__webglTexture = t2.createTexture(), u3.__version = l3.version, s2.memory.textures++);
          const c3 = true === e3.isWebGLCubeRenderTarget, d3 = true === e3.isWebGLMultipleRenderTargets, p3 = true === e3.isWebGLMultisampleRenderTarget, f2 = l3.isDataTexture3D || l3.isDataTexture2DArray, m2 = y2(e3) || a2;
          if (!a2 || 1022 !== l3.format || 1015 !== l3.type && 1016 !== l3.type || (l3.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), c3) {
            h3.__webglFramebuffer = [];
            for (let e4 = 0; e4 < 6; e4++) h3.__webglFramebuffer[e4] = t2.createFramebuffer();
          } else if (h3.__webglFramebuffer = t2.createFramebuffer(), d3) if (r2.drawBuffers) {
            const i3 = e3.texture;
            for (let e4 = 0, r3 = i3.length; e4 < r3; e4++) {
              const r4 = n2.get(i3[e4]);
              void 0 === r4.__webglTexture && (r4.__webglTexture = t2.createTexture(), s2.memory.textures++);
            }
          } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          else if (p3) if (a2) {
            h3.__webglMultisampledFramebuffer = t2.createFramebuffer(), h3.__webglColorRenderbuffer = t2.createRenderbuffer(), t2.bindRenderbuffer(36161, h3.__webglColorRenderbuffer);
            const n3 = o2.convert(l3.format), r3 = o2.convert(l3.type), s3 = T2(l3.internalFormat, n3, r3), a3 = B2(e3);
            t2.renderbufferStorageMultisample(36161, a3, s3, e3.width, e3.height), i2.bindFramebuffer(36160, h3.__webglMultisampledFramebuffer), t2.framebufferRenderbuffer(36160, 36064, 36161, h3.__webglColorRenderbuffer), t2.bindRenderbuffer(36161, null), e3.depthBuffer && (h3.__webglDepthRenderbuffer = t2.createRenderbuffer(), D2(h3.__webglDepthRenderbuffer, e3, true)), i2.bindFramebuffer(36160, null);
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          if (c3) {
            i2.bindTexture(34067, u3.__webglTexture), P2(34067, l3, m2);
            for (let t3 = 0; t3 < 6; t3++) L2(h3.__webglFramebuffer[t3], e3, l3, 36064, 34069 + t3);
            x2(l3, m2) && b2(34067, l3, e3.width, e3.height), i2.bindTexture(34067, null);
          } else if (d3) {
            const t3 = e3.texture;
            for (let r3 = 0, o3 = t3.length; r3 < o3; r3++) {
              const o4 = t3[r3], s3 = n2.get(o4);
              i2.bindTexture(3553, s3.__webglTexture), P2(3553, o4, m2), L2(h3.__webglFramebuffer, e3, o4, 36064 + r3, 3553), x2(o4, m2) && b2(3553, o4, e3.width, e3.height);
            }
            i2.bindTexture(3553, null);
          } else {
            let t3 = 3553;
            if (f2) if (a2) {
              t3 = l3.isDataTexture3D ? 32879 : 35866;
            } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
            i2.bindTexture(t3, u3.__webglTexture), P2(t3, l3, m2), L2(h3.__webglFramebuffer, e3, l3, 36064, t3), x2(l3, m2) && b2(t3, l3, e3.width, e3.height, e3.depth), i2.bindTexture(t3, null);
          }
          e3.depthBuffer && F2(e3);
        }, this.updateRenderTargetMipmap = function(t3) {
          const e3 = y2(t3) || a2, r3 = true === t3.isWebGLMultipleRenderTargets ? t3.texture : [t3.texture];
          for (let o3 = 0, s3 = r3.length; o3 < s3; o3++) {
            const s4 = r3[o3];
            if (x2(s4, e3)) {
              const e4 = t3.isWebGLCubeRenderTarget ? 34067 : 3553, r4 = n2.get(s4).__webglTexture;
              i2.bindTexture(e4, r4), b2(e4, s4, t3.width, t3.height), i2.bindTexture(e4, null);
            }
          }
        }, this.updateMultisampleRenderTarget = function(e3) {
          if (e3.isWebGLMultisampleRenderTarget) if (a2) {
            const r3 = e3.width, o3 = e3.height;
            let s3 = 16384;
            e3.depthBuffer && (s3 |= 256), e3.stencilBuffer && (s3 |= 1024);
            const a3 = n2.get(e3);
            i2.bindFramebuffer(36008, a3.__webglMultisampledFramebuffer), i2.bindFramebuffer(36009, a3.__webglFramebuffer), t2.blitFramebuffer(0, 0, r3, o3, 0, 0, r3, o3, s3, 9728), i2.bindFramebuffer(36008, null), i2.bindFramebuffer(36009, a3.__webglMultisampledFramebuffer);
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }, this.safeSetTexture2D = function(t3, e3) {
          t3 && t3.isWebGLRenderTarget && (false === U2 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), U2 = true), t3 = t3.texture), M2(t3, e3);
        }, this.safeSetTextureCube = function(t3, e3) {
          t3 && t3.isWebGLCubeRenderTarget && (false === k2 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), k2 = true), t3 = t3.texture), C2(t3, e3);
        };
      }
      function nr(t2, e2, i2) {
        const n2 = i2.isWebGL2;
        return { convert: function(t3) {
          let i3;
          if (1009 === t3) return 5121;
          if (1017 === t3) return 32819;
          if (1018 === t3) return 32820;
          if (1019 === t3) return 33635;
          if (1010 === t3) return 5120;
          if (1011 === t3) return 5122;
          if (1012 === t3) return 5123;
          if (1013 === t3) return 5124;
          if (1014 === t3) return 5125;
          if (1015 === t3) return 5126;
          if (1016 === t3) return n2 ? 5131 : (i3 = e2.get("OES_texture_half_float"), null !== i3 ? i3.HALF_FLOAT_OES : null);
          if (1021 === t3) return 6406;
          if (1022 === t3) return 6407;
          if (1023 === t3) return 6408;
          if (1024 === t3) return 6409;
          if (1025 === t3) return 6410;
          if (1026 === t3) return 6402;
          if (1027 === t3) return 34041;
          if (1028 === t3) return 6403;
          if (1029 === t3) return 36244;
          if (1030 === t3) return 33319;
          if (1031 === t3) return 33320;
          if (1032 === t3) return 36248;
          if (1033 === t3) return 36249;
          if (33776 === t3 || 33777 === t3 || 33778 === t3 || 33779 === t3) {
            if (i3 = e2.get("WEBGL_compressed_texture_s3tc"), null === i3) return null;
            if (33776 === t3) return i3.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (33777 === t3) return i3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (33778 === t3) return i3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (33779 === t3) return i3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
          if (35840 === t3 || 35841 === t3 || 35842 === t3 || 35843 === t3) {
            if (i3 = e2.get("WEBGL_compressed_texture_pvrtc"), null === i3) return null;
            if (35840 === t3) return i3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === t3) return i3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === t3) return i3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === t3) return i3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === t3) return i3 = e2.get("WEBGL_compressed_texture_etc1"), null !== i3 ? i3.COMPRESSED_RGB_ETC1_WEBGL : null;
          if ((37492 === t3 || 37496 === t3) && (i3 = e2.get("WEBGL_compressed_texture_etc"), null !== i3)) {
            if (37492 === t3) return i3.COMPRESSED_RGB8_ETC2;
            if (37496 === t3) return i3.COMPRESSED_RGBA8_ETC2_EAC;
          }
          return 37808 === t3 || 37809 === t3 || 37810 === t3 || 37811 === t3 || 37812 === t3 || 37813 === t3 || 37814 === t3 || 37815 === t3 || 37816 === t3 || 37817 === t3 || 37818 === t3 || 37819 === t3 || 37820 === t3 || 37821 === t3 || 37840 === t3 || 37841 === t3 || 37842 === t3 || 37843 === t3 || 37844 === t3 || 37845 === t3 || 37846 === t3 || 37847 === t3 || 37848 === t3 || 37849 === t3 || 37850 === t3 || 37851 === t3 || 37852 === t3 || 37853 === t3 ? (i3 = e2.get("WEBGL_compressed_texture_astc"), null !== i3 ? t3 : null) : 36492 === t3 ? (i3 = e2.get("EXT_texture_compression_bptc"), null !== i3 ? t3 : null) : 1020 === t3 ? n2 ? 34042 : (i3 = e2.get("WEBGL_depth_texture"), null !== i3 ? i3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
        } };
      }
      class rr extends Ue {
        constructor(t2 = []) {
          super(), this.cameras = t2;
        }
      }
      rr.prototype.isArrayCamera = true;
      class or extends Rt {
        constructor() {
          super(), this.type = "Group";
        }
      }
      or.prototype.isGroup = true;
      const sr = { type: "move" };
      class ar {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return null === this._hand && (this._hand = new or(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
        }
        getTargetRaySpace() {
          return null === this._targetRay && (this._targetRay = new or(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new M(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new M()), this._targetRay;
        }
        getGripSpace() {
          return null === this._grip && (this._grip = new or(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new M(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new M()), this._grip;
        }
        dispatchEvent(t2) {
          return null !== this._targetRay && this._targetRay.dispatchEvent(t2), null !== this._grip && this._grip.dispatchEvent(t2), null !== this._hand && this._hand.dispatchEvent(t2), this;
        }
        disconnect(t2) {
          return this.dispatchEvent({ type: "disconnected", data: t2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
        }
        update(t2, e2, i2) {
          let n2 = null, r2 = null, o2 = null;
          const s2 = this._targetRay, a2 = this._grip, l2 = this._hand;
          if (t2 && "visible-blurred" !== e2.session.visibilityState) if (null !== s2 && (n2 = e2.getPose(t2.targetRaySpace, i2), null !== n2 && (s2.matrix.fromArray(n2.transform.matrix), s2.matrix.decompose(s2.position, s2.rotation, s2.scale), n2.linearVelocity ? (s2.hasLinearVelocity = true, s2.linearVelocity.copy(n2.linearVelocity)) : s2.hasLinearVelocity = false, n2.angularVelocity ? (s2.hasAngularVelocity = true, s2.angularVelocity.copy(n2.angularVelocity)) : s2.hasAngularVelocity = false, this.dispatchEvent(sr))), l2 && t2.hand) {
            o2 = true;
            for (const n4 of t2.hand.values()) {
              const t3 = e2.getJointPose(n4, i2);
              if (void 0 === l2.joints[n4.jointName]) {
                const t4 = new or();
                t4.matrixAutoUpdate = false, t4.visible = false, l2.joints[n4.jointName] = t4, l2.add(t4);
              }
              const r4 = l2.joints[n4.jointName];
              null !== t3 && (r4.matrix.fromArray(t3.transform.matrix), r4.matrix.decompose(r4.position, r4.rotation, r4.scale), r4.jointRadius = t3.radius), r4.visible = null !== t3;
            }
            const n3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], s3 = n3.position.distanceTo(r3.position), a3 = 0.02, h2 = 5e-3;
            l2.inputState.pinching && s3 > a3 + h2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t2.handedness, target: this })) : !l2.inputState.pinching && s3 <= a3 - h2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t2.handedness, target: this }));
          } else null !== a2 && t2.gripSpace && (r2 = e2.getPose(t2.gripSpace, i2), null !== r2 && (a2.matrix.fromArray(r2.transform.matrix), a2.matrix.decompose(a2.position, a2.rotation, a2.scale), r2.linearVelocity ? (a2.hasLinearVelocity = true, a2.linearVelocity.copy(r2.linearVelocity)) : a2.hasLinearVelocity = false, r2.angularVelocity ? (a2.hasAngularVelocity = true, a2.angularVelocity.copy(r2.angularVelocity)) : a2.hasAngularVelocity = false));
          return null !== s2 && (s2.visible = null !== n2), null !== a2 && (a2.visible = null !== r2), null !== l2 && (l2.visible = null !== o2), this;
        }
      }
      class lr extends s {
        constructor(t2, e2) {
          super();
          const i2 = this, n2 = t2.state;
          let r2 = null, o2 = 1, s2 = null, a2 = "local-floor", l2 = null, h2 = null, u2 = null, c2 = null;
          const d2 = [], p2 = /* @__PURE__ */ new Map(), f2 = new Ue();
          f2.layers.enable(1), f2.viewport = new E();
          const m2 = new Ue();
          m2.layers.enable(2), m2.viewport = new E();
          const g2 = [f2, m2], v2 = new rr();
          v2.layers.enable(1), v2.layers.enable(2);
          let _2 = null, y2 = null;
          function x2(t3) {
            const e3 = p2.get(t3.inputSource);
            e3 && e3.dispatchEvent({ type: t3.type, data: t3.inputSource });
          }
          function b2() {
            p2.forEach(function(t3, e3) {
              t3.disconnect(e3);
            }), p2.clear(), _2 = null, y2 = null, n2.bindXRFramebuffer(null), t2.setRenderTarget(t2.getRenderTarget()), R2.stop(), i2.isPresenting = false, i2.dispatchEvent({ type: "sessionend" });
          }
          function T2(t3) {
            const e3 = r2.inputSources;
            for (let t4 = 0; t4 < d2.length; t4++) p2.set(e3[t4], d2[t4]);
            for (let e4 = 0; e4 < t3.removed.length; e4++) {
              const i3 = t3.removed[e4], n3 = p2.get(i3);
              n3 && (n3.dispatchEvent({ type: "disconnected", data: i3 }), p2.delete(i3));
            }
            for (let e4 = 0; e4 < t3.added.length; e4++) {
              const i3 = t3.added[e4], n3 = p2.get(i3);
              n3 && n3.dispatchEvent({ type: "connected", data: i3 });
            }
          }
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(t3) {
            let e3 = d2[t3];
            return void 0 === e3 && (e3 = new ar(), d2[t3] = e3), e3.getTargetRaySpace();
          }, this.getControllerGrip = function(t3) {
            let e3 = d2[t3];
            return void 0 === e3 && (e3 = new ar(), d2[t3] = e3), e3.getGripSpace();
          }, this.getHand = function(t3) {
            let e3 = d2[t3];
            return void 0 === e3 && (e3 = new ar(), d2[t3] = e3), e3.getHandSpace();
          }, this.setFramebufferScaleFactor = function(t3) {
            o2 = t3, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(t3) {
            a2 = t3, true === i2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return s2;
          }, this.getSession = function() {
            return r2;
          }, this.setSession = async function(t3) {
            if (r2 = t3, null !== r2) {
              r2.addEventListener("select", x2), r2.addEventListener("selectstart", x2), r2.addEventListener("selectend", x2), r2.addEventListener("squeeze", x2), r2.addEventListener("squeezestart", x2), r2.addEventListener("squeezeend", x2), r2.addEventListener("end", b2), r2.addEventListener("inputsourceschange", T2);
              const t4 = e2.getContextAttributes();
              if (true !== t4.xrCompatible && await e2.makeXRCompatible(), void 0 === r2.renderState.layers) {
                const i3 = { antialias: t4.antialias, alpha: t4.alpha, depth: t4.depth, stencil: t4.stencil, framebufferScaleFactor: o2 }, n3 = new XRWebGLLayer(r2, e2, i3);
                r2.updateRenderState({ baseLayer: n3 });
              } else {
                let i3 = 0;
                t4.depth && (i3 = t4.stencil ? 34041 : 6402);
                const n3 = { colorFormat: t4.alpha ? 6408 : 6407, depthFormat: i3, scaleFactor: o2 };
                h2 = new XRWebGLBinding(r2, e2), c2 = h2.createProjectionLayer(n3), u2 = e2.createFramebuffer(), r2.updateRenderState({ layers: [c2] });
              }
              s2 = await r2.requestReferenceSpace(a2), R2.setContext(r2), R2.start(), i2.isPresenting = true, i2.dispatchEvent({ type: "sessionstart" });
            }
          };
          const S2 = new M(), w2 = new M();
          function A2(t3, e3) {
            null === e3 ? t3.matrixWorld.copy(t3.matrix) : t3.matrixWorld.multiplyMatrices(e3.matrixWorld, t3.matrix), t3.matrixWorldInverse.copy(t3.matrixWorld).invert();
          }
          this.updateCamera = function(t3) {
            if (null === r2) return;
            v2.near = m2.near = f2.near = t3.near, v2.far = m2.far = f2.far = t3.far, _2 === v2.near && y2 === v2.far || (r2.updateRenderState({ depthNear: v2.near, depthFar: v2.far }), _2 = v2.near, y2 = v2.far);
            const e3 = t3.parent, i3 = v2.cameras;
            A2(v2, e3);
            for (let t4 = 0; t4 < i3.length; t4++) A2(i3[t4], e3);
            v2.matrixWorld.decompose(v2.position, v2.quaternion, v2.scale), t3.position.copy(v2.position), t3.quaternion.copy(v2.quaternion), t3.scale.copy(v2.scale), t3.matrix.copy(v2.matrix), t3.matrixWorld.copy(v2.matrixWorld);
            const n3 = t3.children;
            for (let t4 = 0, e4 = n3.length; t4 < e4; t4++) n3[t4].updateMatrixWorld(true);
            2 === i3.length ? function(t4, e4, i4) {
              S2.setFromMatrixPosition(e4.matrixWorld), w2.setFromMatrixPosition(i4.matrixWorld);
              const n4 = S2.distanceTo(w2), r3 = e4.projectionMatrix.elements, o3 = i4.projectionMatrix.elements, s3 = r3[14] / (r3[10] - 1), a3 = r3[14] / (r3[10] + 1), l3 = (r3[9] + 1) / r3[5], h3 = (r3[9] - 1) / r3[5], u3 = (r3[8] - 1) / r3[0], c3 = (o3[8] + 1) / o3[0], d3 = s3 * u3, p3 = s3 * c3, f3 = n4 / (-u3 + c3), m3 = f3 * -u3;
              e4.matrixWorld.decompose(t4.position, t4.quaternion, t4.scale), t4.translateX(m3), t4.translateZ(f3), t4.matrixWorld.compose(t4.position, t4.quaternion, t4.scale), t4.matrixWorldInverse.copy(t4.matrixWorld).invert();
              const g3 = s3 + f3, v3 = a3 + f3, _3 = d3 - m3, y3 = p3 + (n4 - m3), x3 = l3 * a3 / v3 * g3, b3 = h3 * a3 / v3 * g3;
              t4.projectionMatrix.makePerspective(_3, y3, x3, b3, g3, v3);
            }(v2, f2, m2) : v2.projectionMatrix.copy(f2.projectionMatrix);
          }, this.getCamera = function() {
            return v2;
          };
          let C2 = null;
          const R2 = new Ze();
          R2.setAnimationLoop(function(t3, i3) {
            if (l2 = i3.getViewerPose(s2), null !== l2) {
              const t4 = l2.views, i4 = r2.renderState.baseLayer;
              void 0 === r2.renderState.layers && n2.bindXRFramebuffer(i4.framebuffer);
              let o4 = false;
              t4.length !== v2.cameras.length && (v2.cameras.length = 0, o4 = true);
              for (let s3 = 0; s3 < t4.length; s3++) {
                const a3 = t4[s3];
                let l3 = null;
                if (void 0 === r2.renderState.layers) l3 = i4.getViewport(a3);
                else {
                  const t5 = h2.getViewSubImage(c2, a3);
                  n2.bindXRFramebuffer(u2), e2.framebufferTexture2D(36160, 36064, 3553, t5.colorTexture, 0), void 0 !== t5.depthStencilTexture && e2.framebufferTexture2D(36160, 36096, 3553, t5.depthStencilTexture, 0), l3 = t5.viewport;
                }
                const d3 = g2[s3];
                d3.matrix.fromArray(a3.transform.matrix), d3.projectionMatrix.fromArray(a3.projectionMatrix), d3.viewport.set(l3.x, l3.y, l3.width, l3.height), 0 === s3 && v2.matrix.copy(d3.matrix), true === o4 && v2.cameras.push(d3);
              }
            }
            const o3 = r2.inputSources;
            for (let t4 = 0; t4 < d2.length; t4++) {
              const e3 = d2[t4], n3 = o3[t4];
              e3.update(n3, i3, s2);
            }
            C2 && C2(t3, i3);
          }), this.setAnimationLoop = function(t3) {
            C2 = t3;
          }, this.dispose = function() {
          };
        }
      }
      function hr(t2) {
        function e2(e3, i3) {
          e3.opacity.value = i3.opacity, i3.color && e3.diffuse.value.copy(i3.color), i3.emissive && e3.emissive.value.copy(i3.emissive).multiplyScalar(i3.emissiveIntensity), i3.map && (e3.map.value = i3.map), i3.alphaMap && (e3.alphaMap.value = i3.alphaMap), i3.specularMap && (e3.specularMap.value = i3.specularMap);
          const n2 = t2.get(i3).envMap;
          if (n2) {
            e3.envMap.value = n2, e3.flipEnvMap.value = n2.isCubeTexture && n2._needsFlipEnvMap ? -1 : 1, e3.reflectivity.value = i3.reflectivity, e3.refractionRatio.value = i3.refractionRatio;
            const r3 = t2.get(n2).__maxMipLevel;
            void 0 !== r3 && (e3.maxMipLevel.value = r3);
          }
          let r2, o2;
          i3.lightMap && (e3.lightMap.value = i3.lightMap, e3.lightMapIntensity.value = i3.lightMapIntensity), i3.aoMap && (e3.aoMap.value = i3.aoMap, e3.aoMapIntensity.value = i3.aoMapIntensity), i3.map ? r2 = i3.map : i3.specularMap ? r2 = i3.specularMap : i3.displacementMap ? r2 = i3.displacementMap : i3.normalMap ? r2 = i3.normalMap : i3.bumpMap ? r2 = i3.bumpMap : i3.roughnessMap ? r2 = i3.roughnessMap : i3.metalnessMap ? r2 = i3.metalnessMap : i3.alphaMap ? r2 = i3.alphaMap : i3.emissiveMap ? r2 = i3.emissiveMap : i3.clearcoatMap ? r2 = i3.clearcoatMap : i3.clearcoatNormalMap ? r2 = i3.clearcoatNormalMap : i3.clearcoatRoughnessMap && (r2 = i3.clearcoatRoughnessMap), void 0 !== r2 && (r2.isWebGLRenderTarget && (r2 = r2.texture), true === r2.matrixAutoUpdate && r2.updateMatrix(), e3.uvTransform.value.copy(r2.matrix)), i3.aoMap ? o2 = i3.aoMap : i3.lightMap && (o2 = i3.lightMap), void 0 !== o2 && (o2.isWebGLRenderTarget && (o2 = o2.texture), true === o2.matrixAutoUpdate && o2.updateMatrix(), e3.uv2Transform.value.copy(o2.matrix));
        }
        function i2(e3, i3) {
          e3.roughness.value = i3.roughness, e3.metalness.value = i3.metalness, i3.roughnessMap && (e3.roughnessMap.value = i3.roughnessMap), i3.metalnessMap && (e3.metalnessMap.value = i3.metalnessMap), i3.emissiveMap && (e3.emissiveMap.value = i3.emissiveMap), i3.bumpMap && (e3.bumpMap.value = i3.bumpMap, e3.bumpScale.value = i3.bumpScale, 1 === i3.side && (e3.bumpScale.value *= -1)), i3.normalMap && (e3.normalMap.value = i3.normalMap, e3.normalScale.value.copy(i3.normalScale), 1 === i3.side && e3.normalScale.value.negate()), i3.displacementMap && (e3.displacementMap.value = i3.displacementMap, e3.displacementScale.value = i3.displacementScale, e3.displacementBias.value = i3.displacementBias);
          t2.get(i3).envMap && (e3.envMapIntensity.value = i3.envMapIntensity);
        }
        return { refreshFogUniforms: function(t3, e3) {
          t3.fogColor.value.copy(e3.color), e3.isFog ? (t3.fogNear.value = e3.near, t3.fogFar.value = e3.far) : e3.isFogExp2 && (t3.fogDensity.value = e3.density);
        }, refreshMaterialUniforms: function(t3, n2, r2, o2, s2) {
          n2.isMeshBasicMaterial ? e2(t3, n2) : n2.isMeshLambertMaterial ? (e2(t3, n2), function(t4, e3) {
            e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
          }(t3, n2)) : n2.isMeshToonMaterial ? (e2(t3, n2), function(t4, e3) {
            e3.gradientMap && (t4.gradientMap.value = e3.gradientMap);
            e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, n2)) : n2.isMeshPhongMaterial ? (e2(t3, n2), function(t4, e3) {
            t4.specular.value.copy(e3.specular), t4.shininess.value = Math.max(e3.shininess, 1e-4), e3.emissiveMap && (t4.emissiveMap.value = e3.emissiveMap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, n2)) : n2.isMeshStandardMaterial ? (e2(t3, n2), n2.isMeshPhysicalMaterial ? function(t4, e3, n3) {
            i2(t4, e3), t4.reflectivity.value = e3.reflectivity, t4.clearcoat.value = e3.clearcoat, t4.clearcoatRoughness.value = e3.clearcoatRoughness, e3.sheen && t4.sheen.value.copy(e3.sheen);
            e3.clearcoatMap && (t4.clearcoatMap.value = e3.clearcoatMap);
            e3.clearcoatRoughnessMap && (t4.clearcoatRoughnessMap.value = e3.clearcoatRoughnessMap);
            e3.clearcoatNormalMap && (t4.clearcoatNormalScale.value.copy(e3.clearcoatNormalScale), t4.clearcoatNormalMap.value = e3.clearcoatNormalMap, 1 === e3.side && t4.clearcoatNormalScale.value.negate());
            t4.transmission.value = e3.transmission, e3.transmissionMap && (t4.transmissionMap.value = e3.transmissionMap);
            e3.transmission > 0 && (t4.transmissionSamplerMap.value = n3.texture, t4.transmissionSamplerSize.value.set(n3.width, n3.height));
            t4.thickness.value = e3.thickness, e3.thicknessMap && (t4.thicknessMap.value = e3.thicknessMap);
            t4.attenuationDistance.value = e3.attenuationDistance, t4.attenuationColor.value.copy(e3.attenuationColor);
          }(t3, n2, s2) : i2(t3, n2)) : n2.isMeshMatcapMaterial ? (e2(t3, n2), function(t4, e3) {
            e3.matcap && (t4.matcap.value = e3.matcap);
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, n2)) : n2.isMeshDepthMaterial ? (e2(t3, n2), function(t4, e3) {
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, n2)) : n2.isMeshDistanceMaterial ? (e2(t3, n2), function(t4, e3) {
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
            t4.referencePosition.value.copy(e3.referencePosition), t4.nearDistance.value = e3.nearDistance, t4.farDistance.value = e3.farDistance;
          }(t3, n2)) : n2.isMeshNormalMaterial ? (e2(t3, n2), function(t4, e3) {
            e3.bumpMap && (t4.bumpMap.value = e3.bumpMap, t4.bumpScale.value = e3.bumpScale, 1 === e3.side && (t4.bumpScale.value *= -1));
            e3.normalMap && (t4.normalMap.value = e3.normalMap, t4.normalScale.value.copy(e3.normalScale), 1 === e3.side && t4.normalScale.value.negate());
            e3.displacementMap && (t4.displacementMap.value = e3.displacementMap, t4.displacementScale.value = e3.displacementScale, t4.displacementBias.value = e3.displacementBias);
          }(t3, n2)) : n2.isLineBasicMaterial ? (function(t4, e3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity;
          }(t3, n2), n2.isLineDashedMaterial && function(t4, e3) {
            t4.dashSize.value = e3.dashSize, t4.totalSize.value = e3.dashSize + e3.gapSize, t4.scale.value = e3.scale;
          }(t3, n2)) : n2.isPointsMaterial ? function(t4, e3, i3, n3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.size.value = e3.size * i3, t4.scale.value = 0.5 * n3, e3.map && (t4.map.value = e3.map);
            e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
            let r3;
            e3.map ? r3 = e3.map : e3.alphaMap && (r3 = e3.alphaMap);
            void 0 !== r3 && (true === r3.matrixAutoUpdate && r3.updateMatrix(), t4.uvTransform.value.copy(r3.matrix));
          }(t3, n2, r2, o2) : n2.isSpriteMaterial ? function(t4, e3) {
            t4.diffuse.value.copy(e3.color), t4.opacity.value = e3.opacity, t4.rotation.value = e3.rotation, e3.map && (t4.map.value = e3.map);
            e3.alphaMap && (t4.alphaMap.value = e3.alphaMap);
            let i3;
            e3.map ? i3 = e3.map : e3.alphaMap && (i3 = e3.alphaMap);
            void 0 !== i3 && (true === i3.matrixAutoUpdate && i3.updateMatrix(), t4.uvTransform.value.copy(i3.matrix));
          }(t3, n2) : n2.isShadowMaterial ? (t3.color.value.copy(n2.color), t3.opacity.value = n2.opacity) : n2.isShaderMaterial && (n2.uniformsNeedUpdate = false);
        } };
      }
      function ur(t2 = {}) {
        const e2 = void 0 !== t2.canvas ? t2.canvas : function() {
          const t3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
          return t3.style.display = "block", t3;
        }(), i2 = void 0 !== t2.context ? t2.context : null, n2 = void 0 !== t2.alpha && t2.alpha, r2 = void 0 === t2.depth || t2.depth, o2 = void 0 === t2.stencil || t2.stencil, s2 = void 0 !== t2.antialias && t2.antialias, a2 = void 0 === t2.premultipliedAlpha || t2.premultipliedAlpha, l2 = void 0 !== t2.preserveDrawingBuffer && t2.preserveDrawingBuffer, h2 = void 0 !== t2.powerPreference ? t2.powerPreference : "default", u2 = void 0 !== t2.failIfMajorPerformanceCaveat && t2.failIfMajorPerformanceCaveat;
        let c2 = null, d2 = null;
        const p2 = [], f2 = [];
        this.domElement = e2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
        const m2 = this;
        let g2 = false, v2 = 0, _2 = 0, y2 = null, x2 = -1, b2 = null;
        const T2 = new E(), A2 = new E();
        let C2 = null, R2 = e2.width, I2 = e2.height, P2 = 1, O2 = null, N2 = null;
        const L2 = new E(0, 0, R2, I2), D2 = new E(0, 0, R2, I2);
        let F2 = false;
        const B2 = [], U2 = new qe();
        let k2 = false, G2 = false, H2 = null;
        const j2 = new rt(), z2 = new M(), V2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
        function X2() {
          return null === y2 ? P2 : 1;
        }
        let W2, Y2, q2, Z2, J2, K2, Q2, $2, tt2, et2, it2, nt2, ot2, st2, at2, lt2, ht2, ut2, ct2, dt2, pt2, ft2, mt2 = i2;
        function gt2(t3, i3) {
          for (let n3 = 0; n3 < t3.length; n3++) {
            const r3 = t3[n3], o3 = e2.getContext(r3, i3);
            if (null !== o3) return o3;
          }
          return null;
        }
        try {
          const t3 = { alpha: n2, depth: r2, stencil: o2, antialias: s2, premultipliedAlpha: a2, preserveDrawingBuffer: l2, powerPreference: h2, failIfMajorPerformanceCaveat: u2 };
          if (e2.addEventListener("webglcontextlost", yt2, false), e2.addEventListener("webglcontextrestored", xt2, false), null === mt2) {
            const e3 = ["webgl2", "webgl", "experimental-webgl"];
            if (true === m2.isWebGL1Renderer && e3.shift(), mt2 = gt2(e3, t3), null === mt2) throw gt2(e3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          }
          void 0 === mt2.getShaderPrecisionFormat && (mt2.getShaderPrecisionFormat = function() {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
        } catch (t3) {
          throw console.error("THREE.WebGLRenderer: " + t3.message), t3;
        }
        function vt2() {
          W2 = new ai(mt2), Y2 = new ri(mt2, W2, t2), W2.init(Y2), pt2 = new nr(mt2, W2, Y2), q2 = new er(mt2, W2, Y2), B2[0] = 1029, Z2 = new ui(mt2), J2 = new Hn(), K2 = new ir(mt2, W2, q2, J2, Y2, pt2, Z2), Q2 = new si(m2), $2 = new Je(mt2, Y2), ft2 = new ii(mt2, W2, $2, Y2), tt2 = new li(mt2, $2, Z2, ft2), et2 = new fi(mt2, tt2, $2, Z2), ut2 = new pi(mt2), at2 = new oi(J2), it2 = new Gn(m2, Q2, W2, Y2, ft2, at2), nt2 = new hr(J2), ot2 = new Xn(J2), st2 = new Kn(W2, Y2), ht2 = new ei(m2, Q2, q2, et2, a2), lt2 = new tr(m2, et2, Y2), ct2 = new ni(mt2, W2, Z2, Y2), dt2 = new hi(mt2, W2, Z2, Y2), Z2.programs = it2.programs, m2.capabilities = Y2, m2.extensions = W2, m2.properties = J2, m2.renderLists = ot2, m2.shadowMap = lt2, m2.state = q2, m2.info = Z2;
        }
        vt2();
        const _t2 = new lr(m2, mt2);
        function yt2(t3) {
          t3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g2 = true;
        }
        function xt2() {
          console.log("THREE.WebGLRenderer: Context Restored."), g2 = false;
          const t3 = Z2.autoReset, e3 = lt2.enabled, i3 = lt2.autoUpdate, n3 = lt2.needsUpdate, r3 = lt2.type;
          vt2(), Z2.autoReset = t3, lt2.enabled = e3, lt2.autoUpdate = i3, lt2.needsUpdate = n3, lt2.type = r3;
        }
        function bt2(t3) {
          const e3 = t3.target;
          e3.removeEventListener("dispose", bt2), function(t4) {
            (function(t5) {
              const e4 = J2.get(t5).programs;
              void 0 !== e4 && e4.forEach(function(t6) {
                it2.releaseProgram(t6);
              });
            })(t4), J2.remove(t4);
          }(e3);
        }
        this.xr = _t2, this.getContext = function() {
          return mt2;
        }, this.getContextAttributes = function() {
          return mt2.getContextAttributes();
        }, this.forceContextLoss = function() {
          const t3 = W2.get("WEBGL_lose_context");
          t3 && t3.loseContext();
        }, this.forceContextRestore = function() {
          const t3 = W2.get("WEBGL_lose_context");
          t3 && t3.restoreContext();
        }, this.getPixelRatio = function() {
          return P2;
        }, this.setPixelRatio = function(t3) {
          void 0 !== t3 && (P2 = t3, this.setSize(R2, I2, false));
        }, this.getSize = function(t3) {
          return t3.set(R2, I2);
        }, this.setSize = function(t3, i3, n3) {
          _t2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R2 = t3, I2 = i3, e2.width = Math.floor(t3 * P2), e2.height = Math.floor(i3 * P2), false !== n3 && (e2.style.width = t3 + "px", e2.style.height = i3 + "px"), this.setViewport(0, 0, t3, i3));
        }, this.getDrawingBufferSize = function(t3) {
          return t3.set(R2 * P2, I2 * P2).floor();
        }, this.setDrawingBufferSize = function(t3, i3, n3) {
          R2 = t3, I2 = i3, P2 = n3, e2.width = Math.floor(t3 * n3), e2.height = Math.floor(i3 * n3), this.setViewport(0, 0, t3, i3);
        }, this.getCurrentViewport = function(t3) {
          return t3.copy(T2);
        }, this.getViewport = function(t3) {
          return t3.copy(L2);
        }, this.setViewport = function(t3, e3, i3, n3) {
          t3.isVector4 ? L2.set(t3.x, t3.y, t3.z, t3.w) : L2.set(t3, e3, i3, n3), q2.viewport(T2.copy(L2).multiplyScalar(P2).floor());
        }, this.getScissor = function(t3) {
          return t3.copy(D2);
        }, this.setScissor = function(t3, e3, i3, n3) {
          t3.isVector4 ? D2.set(t3.x, t3.y, t3.z, t3.w) : D2.set(t3, e3, i3, n3), q2.scissor(A2.copy(D2).multiplyScalar(P2).floor());
        }, this.getScissorTest = function() {
          return F2;
        }, this.setScissorTest = function(t3) {
          q2.setScissorTest(F2 = t3);
        }, this.setOpaqueSort = function(t3) {
          O2 = t3;
        }, this.setTransparentSort = function(t3) {
          N2 = t3;
        }, this.getClearColor = function(t3) {
          return t3.copy(ht2.getClearColor());
        }, this.setClearColor = function() {
          ht2.setClearColor.apply(ht2, arguments);
        }, this.getClearAlpha = function() {
          return ht2.getClearAlpha();
        }, this.setClearAlpha = function() {
          ht2.setClearAlpha.apply(ht2, arguments);
        }, this.clear = function(t3, e3, i3) {
          let n3 = 0;
          (void 0 === t3 || t3) && (n3 |= 16384), (void 0 === e3 || e3) && (n3 |= 256), (void 0 === i3 || i3) && (n3 |= 1024), mt2.clear(n3);
        }, this.clearColor = function() {
          this.clear(true, false, false);
        }, this.clearDepth = function() {
          this.clear(false, true, false);
        }, this.clearStencil = function() {
          this.clear(false, false, true);
        }, this.dispose = function() {
          e2.removeEventListener("webglcontextlost", yt2, false), e2.removeEventListener("webglcontextrestored", xt2, false), ot2.dispose(), st2.dispose(), J2.dispose(), Q2.dispose(), et2.dispose(), ft2.dispose(), _t2.dispose(), _t2.removeEventListener("sessionstart", Et2), _t2.removeEventListener("sessionend", St2), H2 && (H2.dispose(), H2 = null), wt2.stop();
        }, this.renderBufferImmediate = function(t3, e3) {
          ft2.initAttributes();
          const i3 = J2.get(t3);
          t3.hasPositions && !i3.position && (i3.position = mt2.createBuffer()), t3.hasNormals && !i3.normal && (i3.normal = mt2.createBuffer()), t3.hasUvs && !i3.uv && (i3.uv = mt2.createBuffer()), t3.hasColors && !i3.color && (i3.color = mt2.createBuffer());
          const n3 = e3.getAttributes();
          t3.hasPositions && (mt2.bindBuffer(34962, i3.position), mt2.bufferData(34962, t3.positionArray, 35048), ft2.enableAttribute(n3.position), mt2.vertexAttribPointer(n3.position, 3, 5126, false, 0, 0)), t3.hasNormals && (mt2.bindBuffer(34962, i3.normal), mt2.bufferData(34962, t3.normalArray, 35048), ft2.enableAttribute(n3.normal), mt2.vertexAttribPointer(n3.normal, 3, 5126, false, 0, 0)), t3.hasUvs && (mt2.bindBuffer(34962, i3.uv), mt2.bufferData(34962, t3.uvArray, 35048), ft2.enableAttribute(n3.uv), mt2.vertexAttribPointer(n3.uv, 2, 5126, false, 0, 0)), t3.hasColors && (mt2.bindBuffer(34962, i3.color), mt2.bufferData(34962, t3.colorArray, 35048), ft2.enableAttribute(n3.color), mt2.vertexAttribPointer(n3.color, 3, 5126, false, 0, 0)), ft2.disableUnusedAttributes(), mt2.drawArrays(4, 0, t3.count), t3.count = 0;
        }, this.renderBufferDirect = function(t3, e3, i3, n3, r3, o3) {
          null === e3 && (e3 = V2);
          const s3 = r3.isMesh && r3.matrixWorld.determinant() < 0, a3 = It2(t3, e3, n3, r3);
          q2.setMaterial(n3, s3);
          let l3 = i3.index;
          const h3 = i3.attributes.position;
          if (null === l3) {
            if (void 0 === h3 || 0 === h3.count) return;
          } else if (0 === l3.count) return;
          let u3, c3 = 1;
          true === n3.wireframe && (l3 = tt2.getWireframeAttribute(i3), c3 = 2), (n3.morphTargets || n3.morphNormals) && ut2.update(r3, i3, n3, a3), ft2.setup(r3, n3, a3, i3, l3);
          let d3 = ct2;
          null !== l3 && (u3 = $2.get(l3), d3 = dt2, d3.setIndex(u3));
          const p3 = null !== l3 ? l3.count : h3.count, f3 = i3.drawRange.start * c3, m3 = i3.drawRange.count * c3, g3 = null !== o3 ? o3.start * c3 : 0, v3 = null !== o3 ? o3.count * c3 : 1 / 0, _3 = Math.max(f3, g3), y3 = Math.min(p3, f3 + m3, g3 + v3) - 1, x3 = Math.max(0, y3 - _3 + 1);
          if (0 !== x3) {
            if (r3.isMesh) true === n3.wireframe ? (q2.setLineWidth(n3.wireframeLinewidth * X2()), d3.setMode(1)) : d3.setMode(4);
            else if (r3.isLine) {
              let t4 = n3.linewidth;
              void 0 === t4 && (t4 = 1), q2.setLineWidth(t4 * X2()), r3.isLineSegments ? d3.setMode(1) : r3.isLineLoop ? d3.setMode(2) : d3.setMode(3);
            } else r3.isPoints ? d3.setMode(0) : r3.isSprite && d3.setMode(4);
            if (r3.isInstancedMesh) d3.renderInstances(_3, x3, r3.count);
            else if (i3.isInstancedBufferGeometry) {
              const t4 = Math.min(i3.instanceCount, i3._maxInstanceCount);
              d3.renderInstances(_3, x3, t4);
            } else d3.render(_3, x3);
          }
        }, this.compile = function(t3, e3) {
          d2 = st2.get(t3), d2.init(), t3.traverseVisible(function(t4) {
            t4.isLight && t4.layers.test(e3.layers) && (d2.pushLight(t4), t4.castShadow && d2.pushShadow(t4));
          }), d2.setupLights(), t3.traverse(function(e4) {
            const i3 = e4.material;
            if (i3) if (Array.isArray(i3)) for (let n3 = 0; n3 < i3.length; n3++) {
              Ct2(i3[n3], t3, e4);
            }
            else Ct2(i3, t3, e4);
          });
        };
        let Tt2 = null;
        function Et2() {
          wt2.stop();
        }
        function St2() {
          wt2.start();
        }
        const wt2 = new Ze();
        function At2(t3, e3, i3) {
          const n3 = true === e3.isScene ? e3.overrideMaterial : null;
          for (let r3 = 0, o3 = t3.length; r3 < o3; r3++) {
            const o4 = t3[r3], s3 = o4.object, a3 = o4.geometry, l3 = null === n3 ? o4.material : n3, h3 = o4.group;
            if (i3.isArrayCamera) {
              const t4 = i3.cameras;
              for (let i4 = 0, n4 = t4.length; i4 < n4; i4++) {
                const n5 = t4[i4];
                s3.layers.test(n5.layers) && (q2.viewport(T2.copy(n5.viewport)), d2.setupLightsView(n5), Mt2(s3, e3, n5, a3, l3, h3));
              }
            } else Mt2(s3, e3, i3, a3, l3, h3);
          }
        }
        function Mt2(t3, e3, i3, n3, r3, o3) {
          if (t3.onBeforeRender(m2, e3, i3, n3, r3, o3), t3.modelViewMatrix.multiplyMatrices(i3.matrixWorldInverse, t3.matrixWorld), t3.normalMatrix.getNormalMatrix(t3.modelViewMatrix), t3.isImmediateRenderObject) {
            const n4 = It2(i3, e3, r3, t3);
            q2.setMaterial(r3), ft2.reset(), function(t4, e4) {
              t4.render(function(t5) {
                m2.renderBufferImmediate(t5, e4);
              });
            }(t3, n4);
          } else true === r3.transparent && 2 === r3.side ? (r3.side = 1, r3.needsUpdate = true, m2.renderBufferDirect(i3, e3, n3, r3, t3, o3), r3.side = 0, r3.needsUpdate = true, m2.renderBufferDirect(i3, e3, n3, r3, t3, o3), r3.side = 2) : m2.renderBufferDirect(i3, e3, n3, r3, t3, o3);
          t3.onAfterRender(m2, e3, i3, n3, r3, o3);
        }
        function Ct2(t3, e3, i3) {
          true !== e3.isScene && (e3 = V2);
          const n3 = J2.get(t3), r3 = d2.state.lights, o3 = d2.state.shadowsArray, s3 = r3.state.version, a3 = it2.getParameters(t3, r3.state, o3, e3, i3), l3 = it2.getProgramCacheKey(a3);
          let h3 = n3.programs;
          n3.environment = t3.isMeshStandardMaterial ? e3.environment : null, n3.fog = e3.fog, n3.envMap = Q2.get(t3.envMap || n3.environment), void 0 === h3 && (t3.addEventListener("dispose", bt2), h3 = /* @__PURE__ */ new Map(), n3.programs = h3);
          let u3 = h3.get(l3);
          if (void 0 !== u3) {
            if (n3.currentProgram === u3 && n3.lightsStateVersion === s3) return Rt2(t3, a3), u3;
          } else a3.uniforms = it2.getUniforms(t3), t3.onBuild(a3, m2), t3.onBeforeCompile(a3, m2), u3 = it2.acquireProgram(a3, l3), h3.set(l3, u3), n3.uniforms = a3.uniforms;
          const c3 = n3.uniforms;
          (t3.isShaderMaterial || t3.isRawShaderMaterial) && true !== t3.clipping || (c3.clippingPlanes = at2.uniform), Rt2(t3, a3), n3.needsLights = function(t4) {
            return t4.isMeshLambertMaterial || t4.isMeshToonMaterial || t4.isMeshPhongMaterial || t4.isMeshStandardMaterial || t4.isShadowMaterial || t4.isShaderMaterial && true === t4.lights;
          }(t3), n3.lightsStateVersion = s3, n3.needsLights && (c3.ambientLightColor.value = r3.state.ambient, c3.lightProbe.value = r3.state.probe, c3.directionalLights.value = r3.state.directional, c3.directionalLightShadows.value = r3.state.directionalShadow, c3.spotLights.value = r3.state.spot, c3.spotLightShadows.value = r3.state.spotShadow, c3.rectAreaLights.value = r3.state.rectArea, c3.ltc_1.value = r3.state.rectAreaLTC1, c3.ltc_2.value = r3.state.rectAreaLTC2, c3.pointLights.value = r3.state.point, c3.pointLightShadows.value = r3.state.pointShadow, c3.hemisphereLights.value = r3.state.hemi, c3.directionalShadowMap.value = r3.state.directionalShadowMap, c3.directionalShadowMatrix.value = r3.state.directionalShadowMatrix, c3.spotShadowMap.value = r3.state.spotShadowMap, c3.spotShadowMatrix.value = r3.state.spotShadowMatrix, c3.pointShadowMap.value = r3.state.pointShadowMap, c3.pointShadowMatrix.value = r3.state.pointShadowMatrix);
          const p3 = u3.getUniforms(), f3 = yn.seqWithValue(p3.seq, c3);
          return n3.currentProgram = u3, n3.uniformsList = f3, u3;
        }
        function Rt2(t3, e3) {
          const i3 = J2.get(t3);
          i3.outputEncoding = e3.outputEncoding, i3.instancing = e3.instancing, i3.skinning = e3.skinning, i3.numClippingPlanes = e3.numClippingPlanes, i3.numIntersection = e3.numClipIntersection, i3.vertexAlphas = e3.vertexAlphas;
        }
        function It2(t3, e3, i3, n3) {
          true !== e3.isScene && (e3 = V2), K2.resetTextureUnits();
          const r3 = e3.fog, o3 = i3.isMeshStandardMaterial ? e3.environment : null, s3 = null === y2 ? m2.outputEncoding : y2.texture.encoding, a3 = Q2.get(i3.envMap || o3), l3 = true === i3.vertexColors && n3.geometry && n3.geometry.attributes.color && 4 === n3.geometry.attributes.color.itemSize, h3 = J2.get(i3), u3 = d2.state.lights;
          if (true === k2 && (true === G2 || t3 !== b2)) {
            const e4 = t3 === b2 && i3.id === x2;
            at2.setState(i3, t3, e4);
          }
          let c3 = false;
          i3.version === h3.__version ? h3.needsLights && h3.lightsStateVersion !== u3.state.version || h3.outputEncoding !== s3 || n3.isInstancedMesh && false === h3.instancing ? c3 = true : n3.isInstancedMesh || true !== h3.instancing ? n3.isSkinnedMesh && false === h3.skinning ? c3 = true : n3.isSkinnedMesh || true !== h3.skinning ? h3.envMap !== a3 || i3.fog && h3.fog !== r3 ? c3 = true : void 0 === h3.numClippingPlanes || h3.numClippingPlanes === at2.numPlanes && h3.numIntersection === at2.numIntersection ? h3.vertexAlphas !== l3 && (c3 = true) : c3 = true : c3 = true : c3 = true : (c3 = true, h3.__version = i3.version);
          let p3 = h3.currentProgram;
          true === c3 && (p3 = Ct2(i3, e3, n3));
          let f3 = false, g3 = false, v3 = false;
          const _3 = p3.getUniforms(), T3 = h3.uniforms;
          if (q2.useProgram(p3.program) && (f3 = true, g3 = true, v3 = true), i3.id !== x2 && (x2 = i3.id, g3 = true), f3 || b2 !== t3) {
            if (_3.setValue(mt2, "projectionMatrix", t3.projectionMatrix), Y2.logarithmicDepthBuffer && _3.setValue(mt2, "logDepthBufFC", 2 / (Math.log(t3.far + 1) / Math.LN2)), b2 !== t3 && (b2 = t3, g3 = true, v3 = true), i3.isShaderMaterial || i3.isMeshPhongMaterial || i3.isMeshToonMaterial || i3.isMeshStandardMaterial || i3.envMap) {
              const e4 = _3.map.cameraPosition;
              void 0 !== e4 && e4.setValue(mt2, z2.setFromMatrixPosition(t3.matrixWorld));
            }
            (i3.isMeshPhongMaterial || i3.isMeshToonMaterial || i3.isMeshLambertMaterial || i3.isMeshBasicMaterial || i3.isMeshStandardMaterial || i3.isShaderMaterial) && _3.setValue(mt2, "isOrthographic", true === t3.isOrthographicCamera), (i3.isMeshPhongMaterial || i3.isMeshToonMaterial || i3.isMeshLambertMaterial || i3.isMeshBasicMaterial || i3.isMeshStandardMaterial || i3.isShaderMaterial || i3.isShadowMaterial || n3.isSkinnedMesh) && _3.setValue(mt2, "viewMatrix", t3.matrixWorldInverse);
          }
          if (n3.isSkinnedMesh) {
            _3.setOptional(mt2, n3, "bindMatrix"), _3.setOptional(mt2, n3, "bindMatrixInverse");
            const t4 = n3.skeleton;
            t4 && (Y2.floatVertexTextures ? (null === t4.boneTexture && t4.computeBoneTexture(), _3.setValue(mt2, "boneTexture", t4.boneTexture, K2), _3.setValue(mt2, "boneTextureSize", t4.boneTextureSize)) : _3.setOptional(mt2, t4, "boneMatrices"));
          }
          var E2, S2;
          return (g3 || h3.receiveShadow !== n3.receiveShadow) && (h3.receiveShadow = n3.receiveShadow, _3.setValue(mt2, "receiveShadow", n3.receiveShadow)), g3 && (_3.setValue(mt2, "toneMappingExposure", m2.toneMappingExposure), h3.needsLights && (S2 = v3, (E2 = T3).ambientLightColor.needsUpdate = S2, E2.lightProbe.needsUpdate = S2, E2.directionalLights.needsUpdate = S2, E2.directionalLightShadows.needsUpdate = S2, E2.pointLights.needsUpdate = S2, E2.pointLightShadows.needsUpdate = S2, E2.spotLights.needsUpdate = S2, E2.spotLightShadows.needsUpdate = S2, E2.rectAreaLights.needsUpdate = S2, E2.hemisphereLights.needsUpdate = S2), r3 && i3.fog && nt2.refreshFogUniforms(T3, r3), nt2.refreshMaterialUniforms(T3, i3, P2, I2, H2), yn.upload(mt2, h3.uniformsList, T3, K2)), i3.isShaderMaterial && true === i3.uniformsNeedUpdate && (yn.upload(mt2, h3.uniformsList, T3, K2), i3.uniformsNeedUpdate = false), i3.isSpriteMaterial && _3.setValue(mt2, "center", n3.center), _3.setValue(mt2, "modelViewMatrix", n3.modelViewMatrix), _3.setValue(mt2, "normalMatrix", n3.normalMatrix), _3.setValue(mt2, "modelMatrix", n3.matrixWorld), p3;
        }
        wt2.setAnimationLoop(function(t3) {
          Tt2 && Tt2(t3);
        }), "undefined" != typeof window && wt2.setContext(window), this.setAnimationLoop = function(t3) {
          Tt2 = t3, _t2.setAnimationLoop(t3), null === t3 ? wt2.stop() : wt2.start();
        }, _t2.addEventListener("sessionstart", Et2), _t2.addEventListener("sessionend", St2), this.render = function(t3, e3) {
          if (void 0 !== e3 && true !== e3.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
          if (true === g2) return;
          true === t3.autoUpdate && t3.updateMatrixWorld(), null === e3.parent && e3.updateMatrixWorld(), true === _t2.enabled && true === _t2.isPresenting && (true === _t2.cameraAutoUpdate && _t2.updateCamera(e3), e3 = _t2.getCamera()), true === t3.isScene && t3.onBeforeRender(m2, t3, e3, y2), d2 = st2.get(t3, f2.length), d2.init(), f2.push(d2), j2.multiplyMatrices(e3.projectionMatrix, e3.matrixWorldInverse), U2.setFromProjectionMatrix(j2), G2 = this.localClippingEnabled, k2 = at2.init(this.clippingPlanes, G2, e3), c2 = ot2.get(t3, p2.length), c2.init(), p2.push(c2), function t4(e4, i4, n4, r4) {
            if (false === e4.visible) return;
            if (e4.layers.test(i4.layers)) {
              if (e4.isGroup) n4 = e4.renderOrder;
              else if (e4.isLOD) true === e4.autoUpdate && e4.update(i4);
              else if (e4.isLight) d2.pushLight(e4), e4.castShadow && d2.pushShadow(e4);
              else if (e4.isSprite) {
                if (!e4.frustumCulled || U2.intersectsSprite(e4)) {
                  r4 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(j2);
                  const t5 = et2.update(e4), i5 = e4.material;
                  i5.visible && c2.push(e4, t5, i5, n4, z2.z, null);
                }
              } else if (e4.isImmediateRenderObject) r4 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(j2), c2.push(e4, null, e4.material, n4, z2.z, null);
              else if ((e4.isMesh || e4.isLine || e4.isPoints) && (e4.isSkinnedMesh && e4.skeleton.frame !== Z2.render.frame && (e4.skeleton.update(), e4.skeleton.frame = Z2.render.frame), !e4.frustumCulled || U2.intersectsObject(e4))) {
                r4 && z2.setFromMatrixPosition(e4.matrixWorld).applyMatrix4(j2);
                const t5 = et2.update(e4), i5 = e4.material;
                if (Array.isArray(i5)) {
                  const r5 = t5.groups;
                  for (let o5 = 0, s3 = r5.length; o5 < s3; o5++) {
                    const s4 = r5[o5], a3 = i5[s4.materialIndex];
                    a3 && a3.visible && c2.push(e4, t5, a3, n4, z2.z, s4);
                  }
                } else i5.visible && c2.push(e4, t5, i5, n4, z2.z, null);
              }
            }
            const o4 = e4.children;
            for (let e5 = 0, s3 = o4.length; e5 < s3; e5++) t4(o4[e5], i4, n4, r4);
          }(t3, e3, 0, m2.sortObjects), c2.finish(), true === m2.sortObjects && c2.sort(O2, N2), true === k2 && at2.beginShadows();
          const i3 = d2.state.shadowsArray;
          lt2.render(i3, t3, e3), d2.setupLights(), d2.setupLightsView(e3), true === k2 && at2.endShadows(), true === this.info.autoReset && this.info.reset(), ht2.render(c2, t3);
          const n3 = c2.opaque, r3 = c2.transmissive, o3 = c2.transparent;
          n3.length > 0 && At2(n3, t3, e3), r3.length > 0 && function(t4, e4, i4, n4) {
            if (null === H2) {
              const t5 = true === s2 && true === Y2.isWebGL2;
              H2 = new (t5 ? w : S)(1024, 1024, { generateMipmaps: true, type: null !== pt2.convert(1016) ? 1016 : 1009, minFilter: 1008, magFilter: 1003, wrapS: 1001, wrapT: 1001 });
            }
            const r4 = m2.getRenderTarget();
            m2.setRenderTarget(H2), m2.clear();
            const o4 = m2.toneMapping;
            m2.toneMapping = 0, At2(t4, i4, n4), m2.toneMapping = o4, K2.updateMultisampleRenderTarget(H2), K2.updateRenderTargetMipmap(H2), m2.setRenderTarget(r4), At2(e4, i4, n4);
          }(n3, r3, t3, e3), o3.length > 0 && At2(o3, t3, e3), null !== y2 && (K2.updateMultisampleRenderTarget(y2), K2.updateRenderTargetMipmap(y2)), true === t3.isScene && t3.onAfterRender(m2, t3, e3), q2.buffers.depth.setTest(true), q2.buffers.depth.setMask(true), q2.buffers.color.setMask(true), q2.setPolygonOffset(false), ft2.resetDefaultState(), x2 = -1, b2 = null, f2.pop(), d2 = f2.length > 0 ? f2[f2.length - 1] : null, p2.pop(), c2 = p2.length > 0 ? p2[p2.length - 1] : null;
        }, this.getActiveCubeFace = function() {
          return v2;
        }, this.getActiveMipmapLevel = function() {
          return _2;
        }, this.getRenderTarget = function() {
          return y2;
        }, this.setRenderTarget = function(t3, e3 = 0, i3 = 0) {
          y2 = t3, v2 = e3, _2 = i3, t3 && void 0 === J2.get(t3).__webglFramebuffer && K2.setupRenderTarget(t3);
          let n3 = null, r3 = false, o3 = false;
          if (t3) {
            const i4 = t3.texture;
            (i4.isDataTexture3D || i4.isDataTexture2DArray) && (o3 = true);
            const s3 = J2.get(t3).__webglFramebuffer;
            t3.isWebGLCubeRenderTarget ? (n3 = s3[e3], r3 = true) : n3 = t3.isWebGLMultisampleRenderTarget ? J2.get(t3).__webglMultisampledFramebuffer : s3, T2.copy(t3.viewport), A2.copy(t3.scissor), C2 = t3.scissorTest;
          } else T2.copy(L2).multiplyScalar(P2).floor(), A2.copy(D2).multiplyScalar(P2).floor(), C2 = F2;
          if (q2.bindFramebuffer(36160, n3) && Y2.drawBuffers) {
            let e4 = false;
            if (t3) if (t3.isWebGLMultipleRenderTargets) {
              const i4 = t3.texture;
              if (B2.length !== i4.length || 36064 !== B2[0]) {
                for (let t4 = 0, e5 = i4.length; t4 < e5; t4++) B2[t4] = 36064 + t4;
                B2.length = i4.length, e4 = true;
              }
            } else 1 === B2.length && 36064 === B2[0] || (B2[0] = 36064, B2.length = 1, e4 = true);
            else 1 === B2.length && 1029 === B2[0] || (B2[0] = 1029, B2.length = 1, e4 = true);
            e4 && (Y2.isWebGL2 ? mt2.drawBuffers(B2) : W2.get("WEBGL_draw_buffers").drawBuffersWEBGL(B2));
          }
          if (q2.viewport(T2), q2.scissor(A2), q2.setScissorTest(C2), r3) {
            const n4 = J2.get(t3.texture);
            mt2.framebufferTexture2D(36160, 36064, 34069 + e3, n4.__webglTexture, i3);
          } else if (o3) {
            const n4 = J2.get(t3.texture), r4 = e3 || 0;
            mt2.framebufferTextureLayer(36160, 36064, n4.__webglTexture, i3 || 0, r4);
          }
        }, this.readRenderTargetPixels = function(t3, e3, i3, n3, r3, o3, s3) {
          if (!t3 || !t3.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          let a3 = J2.get(t3).__webglFramebuffer;
          if (t3.isWebGLCubeRenderTarget && void 0 !== s3 && (a3 = a3[s3]), a3) {
            q2.bindFramebuffer(36160, a3);
            try {
              const s4 = t3.texture, a4 = s4.format, l3 = s4.type;
              if (1023 !== a4 && pt2.convert(a4) !== mt2.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
              const h3 = 1016 === l3 && (W2.has("EXT_color_buffer_half_float") || Y2.isWebGL2 && W2.has("EXT_color_buffer_float"));
              if (!(1009 === l3 || pt2.convert(l3) === mt2.getParameter(35738) || 1015 === l3 && (Y2.isWebGL2 || W2.has("OES_texture_float") || W2.has("WEBGL_color_buffer_float")) || h3)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
              36053 === mt2.checkFramebufferStatus(36160) ? e3 >= 0 && e3 <= t3.width - n3 && i3 >= 0 && i3 <= t3.height - r3 && mt2.readPixels(e3, i3, n3, r3, pt2.convert(a4), pt2.convert(l3), o3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
            } finally {
              const t4 = null !== y2 ? J2.get(y2).__webglFramebuffer : null;
              q2.bindFramebuffer(36160, t4);
            }
          }
        }, this.copyFramebufferToTexture = function(t3, e3, i3 = 0) {
          const n3 = Math.pow(2, -i3), r3 = Math.floor(e3.image.width * n3), o3 = Math.floor(e3.image.height * n3);
          let s3 = pt2.convert(e3.format);
          Y2.isWebGL2 && (6407 === s3 && (s3 = 32849), 6408 === s3 && (s3 = 32856)), K2.setTexture2D(e3, 0), mt2.copyTexImage2D(3553, i3, s3, t3.x, t3.y, r3, o3, 0), q2.unbindTexture();
        }, this.copyTextureToTexture = function(t3, e3, i3, n3 = 0) {
          const r3 = e3.image.width, o3 = e3.image.height, s3 = pt2.convert(i3.format), a3 = pt2.convert(i3.type);
          K2.setTexture2D(i3, 0), mt2.pixelStorei(37440, i3.flipY), mt2.pixelStorei(37441, i3.premultiplyAlpha), mt2.pixelStorei(3317, i3.unpackAlignment), e3.isDataTexture ? mt2.texSubImage2D(3553, n3, t3.x, t3.y, r3, o3, s3, a3, e3.image.data) : e3.isCompressedTexture ? mt2.compressedTexSubImage2D(3553, n3, t3.x, t3.y, e3.mipmaps[0].width, e3.mipmaps[0].height, s3, e3.mipmaps[0].data) : mt2.texSubImage2D(3553, n3, t3.x, t3.y, s3, a3, e3.image), 0 === n3 && i3.generateMipmaps && mt2.generateMipmap(3553), q2.unbindTexture();
        }, this.copyTextureToTexture3D = function(t3, e3, i3, n3, r3 = 0) {
          if (m2.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
          const o3 = t3.max.x - t3.min.x + 1, s3 = t3.max.y - t3.min.y + 1, a3 = t3.max.z - t3.min.z + 1, l3 = pt2.convert(n3.format), h3 = pt2.convert(n3.type);
          let u3;
          if (n3.isDataTexture3D) K2.setTexture3D(n3, 0), u3 = 32879;
          else {
            if (!n3.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            K2.setTexture2DArray(n3, 0), u3 = 35866;
          }
          mt2.pixelStorei(37440, n3.flipY), mt2.pixelStorei(37441, n3.premultiplyAlpha), mt2.pixelStorei(3317, n3.unpackAlignment);
          const c3 = mt2.getParameter(3314), d3 = mt2.getParameter(32878), p3 = mt2.getParameter(3316), f3 = mt2.getParameter(3315), g3 = mt2.getParameter(32877), v3 = i3.isCompressedTexture ? i3.mipmaps[0] : i3.image;
          mt2.pixelStorei(3314, v3.width), mt2.pixelStorei(32878, v3.height), mt2.pixelStorei(3316, t3.min.x), mt2.pixelStorei(3315, t3.min.y), mt2.pixelStorei(32877, t3.min.z), i3.isDataTexture || i3.isDataTexture3D ? mt2.texSubImage3D(u3, r3, e3.x, e3.y, e3.z, o3, s3, a3, l3, h3, v3.data) : i3.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), mt2.compressedTexSubImage3D(u3, r3, e3.x, e3.y, e3.z, o3, s3, a3, l3, v3.data)) : mt2.texSubImage3D(u3, r3, e3.x, e3.y, e3.z, o3, s3, a3, l3, h3, v3), mt2.pixelStorei(3314, c3), mt2.pixelStorei(32878, d3), mt2.pixelStorei(3316, p3), mt2.pixelStorei(3315, f3), mt2.pixelStorei(32877, g3), 0 === r3 && n3.generateMipmaps && mt2.generateMipmap(u3), q2.unbindTexture();
        }, this.initTexture = function(t3) {
          K2.setTexture2D(t3, 0), q2.unbindTexture();
        }, this.resetState = function() {
          v2 = 0, _2 = 0, y2 = null, q2.reset(), ft2.reset();
        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
      (class extends ur {
      }).prototype.isWebGL1Renderer = true;
      class cr {
        constructor(t2, e2 = 25e-5) {
          this.name = "", this.color = new Zt(t2), this.density = e2;
        }
        clone() {
          return new cr(this.color, this.density);
        }
        toJSON() {
          return { type: "FogExp2", color: this.color.getHex(), density: this.density };
        }
      }
      cr.prototype.isFogExp2 = true;
      class dr {
        constructor(t2, e2 = 1, i2 = 1e3) {
          this.name = "", this.color = new Zt(t2), this.near = e2, this.far = i2;
        }
        clone() {
          return new dr(this.color, this.near, this.far);
        }
        toJSON() {
          return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
        }
      }
      dr.prototype.isFog = true;
      class pr extends Rt {
        constructor() {
          super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
        copy(t2, e2) {
          return super.copy(t2, e2), null !== t2.background && (this.background = t2.background.clone()), null !== t2.environment && (this.environment = t2.environment.clone()), null !== t2.fog && (this.fog = t2.fog.clone()), null !== t2.overrideMaterial && (this.overrideMaterial = t2.overrideMaterial.clone()), this.autoUpdate = t2.autoUpdate, this.matrixAutoUpdate = t2.matrixAutoUpdate, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return null !== this.fog && (e2.object.fog = this.fog.toJSON()), e2;
        }
      }
      pr.prototype.isScene = true;
      class fr {
        constructor(t2, e2) {
          this.array = t2, this.stride = e2, this.count = void 0 !== t2 ? t2.length / e2 : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = u();
        }
        onUploadCallback() {
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
        setUsage(t2) {
          return this.usage = t2, this;
        }
        copy(t2) {
          return this.array = new t2.array.constructor(t2.array), this.count = t2.count, this.stride = t2.stride, this.usage = t2.usage, this;
        }
        copyAt(t2, e2, i2) {
          t2 *= this.stride, i2 *= e2.stride;
          for (let n2 = 0, r2 = this.stride; n2 < r2; n2++) this.array[t2 + n2] = e2.array[i2 + n2];
          return this;
        }
        set(t2, e2 = 0) {
          return this.array.set(t2, e2), this;
        }
        clone(t2) {
          void 0 === t2.arrayBuffers && (t2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = u()), void 0 === t2.arrayBuffers[this.array.buffer._uuid] && (t2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const e2 = new this.array.constructor(t2.arrayBuffers[this.array.buffer._uuid]), i2 = new this.constructor(e2, this.stride);
          return i2.setUsage(this.usage), i2;
        }
        onUpload(t2) {
          return this.onUploadCallback = t2, this;
        }
        toJSON(t2) {
          return void 0 === t2.arrayBuffers && (t2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = u()), void 0 === t2.arrayBuffers[this.array.buffer._uuid] && (t2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
        }
      }
      fr.prototype.isInterleavedBuffer = true;
      const mr = new M();
      class gr {
        constructor(t2, e2, i2, n2 = false) {
          this.name = "", this.data = t2, this.itemSize = e2, this.offset = i2, this.normalized = true === n2;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(t2) {
          this.data.needsUpdate = t2;
        }
        applyMatrix4(t2) {
          for (let e2 = 0, i2 = this.data.count; e2 < i2; e2++) mr.x = this.getX(e2), mr.y = this.getY(e2), mr.z = this.getZ(e2), mr.applyMatrix4(t2), this.setXYZ(e2, mr.x, mr.y, mr.z);
          return this;
        }
        applyNormalMatrix(t2) {
          for (let e2 = 0, i2 = this.count; e2 < i2; e2++) mr.x = this.getX(e2), mr.y = this.getY(e2), mr.z = this.getZ(e2), mr.applyNormalMatrix(t2), this.setXYZ(e2, mr.x, mr.y, mr.z);
          return this;
        }
        transformDirection(t2) {
          for (let e2 = 0, i2 = this.count; e2 < i2; e2++) mr.x = this.getX(e2), mr.y = this.getY(e2), mr.z = this.getZ(e2), mr.transformDirection(t2), this.setXYZ(e2, mr.x, mr.y, mr.z);
          return this;
        }
        setX(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset] = e2, this;
        }
        setY(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset + 1] = e2, this;
        }
        setZ(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset + 2] = e2, this;
        }
        setW(t2, e2) {
          return this.data.array[t2 * this.data.stride + this.offset + 3] = e2, this;
        }
        getX(t2) {
          return this.data.array[t2 * this.data.stride + this.offset];
        }
        getY(t2) {
          return this.data.array[t2 * this.data.stride + this.offset + 1];
        }
        getZ(t2) {
          return this.data.array[t2 * this.data.stride + this.offset + 2];
        }
        getW(t2) {
          return this.data.array[t2 * this.data.stride + this.offset + 3];
        }
        setXY(t2, e2, i2) {
          return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = i2, this;
        }
        setXYZ(t2, e2, i2, n2) {
          return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = i2, this.data.array[t2 + 2] = n2, this;
        }
        setXYZW(t2, e2, i2, n2, r2) {
          return t2 = t2 * this.data.stride + this.offset, this.data.array[t2 + 0] = e2, this.data.array[t2 + 1] = i2, this.data.array[t2 + 2] = n2, this.data.array[t2 + 3] = r2, this;
        }
        clone(t2) {
          if (void 0 === t2) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const t3 = [];
            for (let e2 = 0; e2 < this.count; e2++) {
              const i2 = e2 * this.data.stride + this.offset;
              for (let e3 = 0; e3 < this.itemSize; e3++) t3.push(this.data.array[i2 + e3]);
            }
            return new $t(new this.array.constructor(t3), this.itemSize, this.normalized);
          }
          return void 0 === t2.interleavedBuffers && (t2.interleavedBuffers = {}), void 0 === t2.interleavedBuffers[this.data.uuid] && (t2.interleavedBuffers[this.data.uuid] = this.data.clone(t2)), new gr(t2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(t2) {
          if (void 0 === t2) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const t3 = [];
            for (let e2 = 0; e2 < this.count; e2++) {
              const i2 = e2 * this.data.stride + this.offset;
              for (let e3 = 0; e3 < this.itemSize; e3++) t3.push(this.data.array[i2 + e3]);
            }
            return { itemSize: this.itemSize, type: this.array.constructor.name, array: t3, normalized: this.normalized };
          }
          return void 0 === t2.interleavedBuffers && (t2.interleavedBuffers = {}), void 0 === t2.interleavedBuffers[this.data.uuid] && (t2.interleavedBuffers[this.data.uuid] = this.data.toJSON(t2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
        }
      }
      gr.prototype.isInterleavedBufferAttribute = true;
      class vr extends jt {
        constructor(t2) {
          super(), this.type = "SpriteMaterial", this.color = new Zt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.rotation = t2.rotation, this.sizeAttenuation = t2.sizeAttenuation, this;
        }
      }
      let _r;
      vr.prototype.isSpriteMaterial = true;
      const yr = new M(), xr = new M(), br = new M(), Tr = new g(), Er = new g(), Sr = new rt(), wr = new M(), Ar = new M(), Mr = new M(), Cr = new g(), Rr = new g(), Ir = new g();
      class Pr extends Rt {
        constructor(t2) {
          if (super(), this.type = "Sprite", void 0 === _r) {
            _r = new de();
            const t3 = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), e2 = new fr(t3, 5);
            _r.setIndex([0, 1, 2, 0, 2, 3]), _r.setAttribute("position", new gr(e2, 3, 0, false)), _r.setAttribute("uv", new gr(e2, 2, 3, false));
          }
          this.geometry = _r, this.material = void 0 !== t2 ? t2 : new vr(), this.center = new g(0.5, 0.5);
        }
        raycast(t2, e2) {
          null === t2.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), xr.setFromMatrixScale(this.matrixWorld), Sr.copy(t2.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t2.camera.matrixWorldInverse, this.matrixWorld), br.setFromMatrixPosition(this.modelViewMatrix), t2.camera.isPerspectiveCamera && false === this.material.sizeAttenuation && xr.multiplyScalar(-br.z);
          const i2 = this.material.rotation;
          let n2, r2;
          0 !== i2 && (r2 = Math.cos(i2), n2 = Math.sin(i2));
          const o2 = this.center;
          Or(wr.set(-0.5, -0.5, 0), br, o2, xr, n2, r2), Or(Ar.set(0.5, -0.5, 0), br, o2, xr, n2, r2), Or(Mr.set(0.5, 0.5, 0), br, o2, xr, n2, r2), Cr.set(0, 0), Rr.set(1, 0), Ir.set(1, 1);
          let s2 = t2.ray.intersectTriangle(wr, Ar, Mr, false, yr);
          if (null === s2 && (Or(Ar.set(-0.5, 0.5, 0), br, o2, xr, n2, r2), Rr.set(0, 1), s2 = t2.ray.intersectTriangle(wr, Mr, Ar, false, yr), null === s2)) return;
          const a2 = t2.ray.origin.distanceTo(yr);
          a2 < t2.near || a2 > t2.far || e2.push({ distance: a2, point: yr.clone(), uv: Gt.getUV(yr, wr, Ar, Mr, Cr, Rr, Ir, new g()), face: null, object: this });
        }
        copy(t2) {
          return super.copy(t2), void 0 !== t2.center && this.center.copy(t2.center), this.material = t2.material, this;
        }
      }
      function Or(t2, e2, i2, n2, r2, o2) {
        Tr.subVectors(t2, i2).addScalar(0.5).multiply(n2), void 0 !== r2 ? (Er.x = o2 * Tr.x - r2 * Tr.y, Er.y = r2 * Tr.x + o2 * Tr.y) : Er.copy(Tr), t2.copy(e2), t2.x += Er.x, t2.y += Er.y, t2.applyMatrix4(Sr);
      }
      Pr.prototype.isSprite = true;
      const Nr = new M(), Lr = new E(), Dr = new E(), Fr = new M(), Br = new rt();
      class Ur extends Ie {
        constructor(t2, e2) {
          super(t2, e2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new rt(), this.bindMatrixInverse = new rt();
        }
        copy(t2) {
          return super.copy(t2), this.bindMode = t2.bindMode, this.bindMatrix.copy(t2.bindMatrix), this.bindMatrixInverse.copy(t2.bindMatrixInverse), this.skeleton = t2.skeleton, this;
        }
        bind(t2, e2) {
          this.skeleton = t2, void 0 === e2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e2 = this.matrixWorld), this.bindMatrix.copy(e2), this.bindMatrixInverse.copy(e2).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const t2 = new E(), e2 = this.geometry.attributes.skinWeight;
          for (let i2 = 0, n2 = e2.count; i2 < n2; i2++) {
            t2.x = e2.getX(i2), t2.y = e2.getY(i2), t2.z = e2.getZ(i2), t2.w = e2.getW(i2);
            const n3 = 1 / t2.manhattanLength();
            n3 !== 1 / 0 ? t2.multiplyScalar(n3) : t2.set(1, 0, 0, 0), e2.setXYZW(i2, t2.x, t2.y, t2.z, t2.w);
          }
        }
        updateMatrixWorld(t2) {
          super.updateMatrixWorld(t2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        boneTransform(t2, e2) {
          const i2 = this.skeleton, n2 = this.geometry;
          Lr.fromBufferAttribute(n2.attributes.skinIndex, t2), Dr.fromBufferAttribute(n2.attributes.skinWeight, t2), Nr.fromBufferAttribute(n2.attributes.position, t2).applyMatrix4(this.bindMatrix), e2.set(0, 0, 0);
          for (let t3 = 0; t3 < 4; t3++) {
            const n3 = Dr.getComponent(t3);
            if (0 !== n3) {
              const r2 = Lr.getComponent(t3);
              Br.multiplyMatrices(i2.bones[r2].matrixWorld, i2.boneInverses[r2]), e2.addScaledVector(Fr.copy(Nr).applyMatrix4(Br), n3);
            }
          }
          return e2.applyMatrix4(this.bindMatrixInverse);
        }
      }
      Ur.prototype.isSkinnedMesh = true;
      class kr extends Rt {
        constructor() {
          super(), this.type = "Bone";
        }
      }
      kr.prototype.isBone = true;
      class Gr extends b {
        constructor(t2 = null, e2 = 1, i2 = 1, n2, r2, o2, s2, a2, l2 = 1003, h2 = 1003, u2, c2) {
          super(null, o2, s2, a2, l2, h2, n2, r2, u2, c2), this.image = { data: t2, width: e2, height: i2 }, this.magFilter = l2, this.minFilter = h2, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
        }
      }
      Gr.prototype.isDataTexture = true;
      const Hr = new rt(), jr = new rt(), zr = [], Vr = new Ie();
      class Xr extends Ie {
        constructor(t2, e2, i2) {
          super(t2, e2), this.instanceMatrix = new $t(new Float32Array(16 * i2), 16), this.instanceColor = null, this.count = i2, this.frustumCulled = false;
        }
        copy(t2) {
          return super.copy(t2), this.instanceMatrix.copy(t2.instanceMatrix), null !== t2.instanceColor && (this.instanceColor = t2.instanceColor.clone()), this.count = t2.count, this;
        }
        getColorAt(t2, e2) {
          e2.fromArray(this.instanceColor.array, 3 * t2);
        }
        getMatrixAt(t2, e2) {
          e2.fromArray(this.instanceMatrix.array, 16 * t2);
        }
        raycast(t2, e2) {
          const i2 = this.matrixWorld, n2 = this.count;
          if (Vr.geometry = this.geometry, Vr.material = this.material, void 0 !== Vr.material) for (let r2 = 0; r2 < n2; r2++) {
            this.getMatrixAt(r2, Hr), jr.multiplyMatrices(i2, Hr), Vr.matrixWorld = jr, Vr.raycast(t2, zr);
            for (let t3 = 0, i3 = zr.length; t3 < i3; t3++) {
              const i4 = zr[t3];
              i4.instanceId = r2, i4.object = this, e2.push(i4);
            }
            zr.length = 0;
          }
        }
        setColorAt(t2, e2) {
          null === this.instanceColor && (this.instanceColor = new $t(new Float32Array(3 * this.count), 3)), e2.toArray(this.instanceColor.array, 3 * t2);
        }
        setMatrixAt(t2, e2) {
          e2.toArray(this.instanceMatrix.array, 16 * t2);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      Xr.prototype.isInstancedMesh = true;
      class Wr extends jt {
        constructor(t2) {
          super(), this.type = "LineBasicMaterial", this.color = new Zt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.linewidth = t2.linewidth, this.linecap = t2.linecap, this.linejoin = t2.linejoin, this.morphTargets = t2.morphTargets, this;
        }
      }
      Wr.prototype.isLineBasicMaterial = true;
      const Yr = new M(), qr = new M(), Zr = new rt(), Jr = new nt(), Kr = new Z();
      class Qr extends Rt {
        constructor(t2 = new de(), e2 = new Wr()) {
          super(), this.type = "Line", this.geometry = t2, this.material = e2, this.updateMorphTargets();
        }
        copy(t2) {
          return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
        }
        computeLineDistances() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) if (null === t2.index) {
            const e2 = t2.attributes.position, i2 = [0];
            for (let t3 = 1, n2 = e2.count; t3 < n2; t3++) Yr.fromBufferAttribute(e2, t3 - 1), qr.fromBufferAttribute(e2, t3), i2[t3] = i2[t3 - 1], i2[t3] += Yr.distanceTo(qr);
            t2.setAttribute("lineDistance", new ne(i2, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else t2.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          return this;
        }
        raycast(t2, e2) {
          const i2 = this.geometry, n2 = this.matrixWorld, r2 = t2.params.Line.threshold, o2 = i2.drawRange;
          if (null === i2.boundingSphere && i2.computeBoundingSphere(), Kr.copy(i2.boundingSphere), Kr.applyMatrix4(n2), Kr.radius += r2, false === t2.ray.intersectsSphere(Kr)) return;
          Zr.copy(n2).invert(), Jr.copy(t2.ray).applyMatrix4(Zr);
          const s2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s2 * s2, l2 = new M(), h2 = new M(), u2 = new M(), c2 = new M(), d2 = this.isLineSegments ? 2 : 1;
          if (i2.isBufferGeometry) {
            const n3 = i2.index, r3 = i2.attributes.position;
            if (null !== n3) {
              for (let i3 = Math.max(0, o2.start), s3 = Math.min(n3.count, o2.start + o2.count) - 1; i3 < s3; i3 += d2) {
                const o3 = n3.getX(i3), s4 = n3.getX(i3 + 1);
                l2.fromBufferAttribute(r3, o3), h2.fromBufferAttribute(r3, s4);
                if (Jr.distanceSqToSegment(l2, h2, c2, u2) > a2) continue;
                c2.applyMatrix4(this.matrixWorld);
                const d3 = t2.ray.origin.distanceTo(c2);
                d3 < t2.near || d3 > t2.far || e2.push({ distance: d3, point: u2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
              }
            } else {
              for (let i3 = Math.max(0, o2.start), n4 = Math.min(r3.count, o2.start + o2.count) - 1; i3 < n4; i3 += d2) {
                l2.fromBufferAttribute(r3, i3), h2.fromBufferAttribute(r3, i3 + 1);
                if (Jr.distanceSqToSegment(l2, h2, c2, u2) > a2) continue;
                c2.applyMatrix4(this.matrixWorld);
                const n5 = t2.ray.origin.distanceTo(c2);
                n5 < t2.near || n5 > t2.far || e2.push({ distance: n5, point: u2.clone().applyMatrix4(this.matrixWorld), index: i3, face: null, faceIndex: null, object: this });
              }
            }
          } else i2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        updateMorphTargets() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) {
            const e2 = t2.morphAttributes, i2 = Object.keys(e2);
            if (i2.length > 0) {
              const t3 = e2[i2[0]];
              if (void 0 !== t3) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) {
                  const i4 = t3[e3].name || String(e3);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[i4] = e3;
                }
              }
            }
          } else {
            const e2 = t2.morphTargets;
            void 0 !== e2 && e2.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      Qr.prototype.isLine = true;
      const $r = new M(), to = new M();
      class eo extends Qr {
        constructor(t2, e2) {
          super(t2, e2), this.type = "LineSegments";
        }
        computeLineDistances() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) if (null === t2.index) {
            const e2 = t2.attributes.position, i2 = [];
            for (let t3 = 0, n2 = e2.count; t3 < n2; t3 += 2) $r.fromBufferAttribute(e2, t3), to.fromBufferAttribute(e2, t3 + 1), i2[t3] = 0 === t3 ? 0 : i2[t3 - 1], i2[t3 + 1] = i2[t3] + $r.distanceTo(to);
            t2.setAttribute("lineDistance", new ne(i2, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          else t2.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          return this;
        }
      }
      eo.prototype.isLineSegments = true;
      class io extends Qr {
        constructor(t2, e2) {
          super(t2, e2), this.type = "LineLoop";
        }
      }
      io.prototype.isLineLoop = true;
      class no extends jt {
        constructor(t2) {
          super(), this.type = "PointsMaterial", this.color = new Zt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.alphaMap = t2.alphaMap, this.size = t2.size, this.sizeAttenuation = t2.sizeAttenuation, this.morphTargets = t2.morphTargets, this;
        }
      }
      no.prototype.isPointsMaterial = true;
      const ro = new rt(), oo = new nt(), so = new Z(), ao = new M();
      class lo extends Rt {
        constructor(t2 = new de(), e2 = new no()) {
          super(), this.type = "Points", this.geometry = t2, this.material = e2, this.updateMorphTargets();
        }
        copy(t2) {
          return super.copy(t2), this.material = t2.material, this.geometry = t2.geometry, this;
        }
        raycast(t2, e2) {
          const i2 = this.geometry, n2 = this.matrixWorld, r2 = t2.params.Points.threshold, o2 = i2.drawRange;
          if (null === i2.boundingSphere && i2.computeBoundingSphere(), so.copy(i2.boundingSphere), so.applyMatrix4(n2), so.radius += r2, false === t2.ray.intersectsSphere(so)) return;
          ro.copy(n2).invert(), oo.copy(t2.ray).applyMatrix4(ro);
          const s2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), a2 = s2 * s2;
          if (i2.isBufferGeometry) {
            const r3 = i2.index, s3 = i2.attributes.position;
            if (null !== r3) {
              for (let i3 = Math.max(0, o2.start), l2 = Math.min(r3.count, o2.start + o2.count); i3 < l2; i3++) {
                const o3 = r3.getX(i3);
                ao.fromBufferAttribute(s3, o3), ho(ao, o3, a2, n2, t2, e2, this);
              }
            } else {
              for (let i3 = Math.max(0, o2.start), r4 = Math.min(s3.count, o2.start + o2.count); i3 < r4; i3++) ao.fromBufferAttribute(s3, i3), ho(ao, i3, a2, n2, t2, e2, this);
            }
          } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        updateMorphTargets() {
          const t2 = this.geometry;
          if (t2.isBufferGeometry) {
            const e2 = t2.morphAttributes, i2 = Object.keys(e2);
            if (i2.length > 0) {
              const t3 = e2[i2[0]];
              if (void 0 !== t3) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let e3 = 0, i3 = t3.length; e3 < i3; e3++) {
                  const i4 = t3[e3].name || String(e3);
                  this.morphTargetInfluences.push(0), this.morphTargetDictionary[i4] = e3;
                }
              }
            }
          } else {
            const e2 = t2.morphTargets;
            void 0 !== e2 && e2.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      function ho(t2, e2, i2, n2, r2, o2, s2) {
        const a2 = oo.distanceSqToPoint(t2);
        if (a2 < i2) {
          const i3 = new M();
          oo.closestPointToPoint(t2, i3), i3.applyMatrix4(n2);
          const l2 = r2.ray.origin.distanceTo(i3);
          if (l2 < r2.near || l2 > r2.far) return;
          o2.push({ distance: l2, distanceToRay: Math.sqrt(a2), point: i3, index: e2, face: null, object: s2 });
        }
      }
      lo.prototype.isPoints = true;
      (class extends b {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2) {
          super(t2, e2, i2, n2, r2, o2, s2, a2, l2), this.format = void 0 !== s2 ? s2 : 1022, this.minFilter = void 0 !== o2 ? o2 : 1006, this.magFilter = void 0 !== r2 ? r2 : 1006, this.generateMipmaps = false;
          const h2 = this;
          "requestVideoFrameCallback" in t2 && t2.requestVideoFrameCallback(function e3() {
            h2.needsUpdate = true, t2.requestVideoFrameCallback(e3);
          });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const t2 = this.image;
          false === "requestVideoFrameCallback" in t2 && t2.readyState >= t2.HAVE_CURRENT_DATA && (this.needsUpdate = true);
        }
      }).prototype.isVideoTexture = true;
      class uo extends b {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2) {
          super(null, o2, s2, a2, l2, h2, n2, r2, u2, c2), this.image = { width: e2, height: i2 }, this.mipmaps = t2, this.flipY = false, this.generateMipmaps = false;
        }
      }
      uo.prototype.isCompressedTexture = true;
      (class extends b {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2) {
          super(t2, e2, i2, n2, r2, o2, s2, a2, l2), this.needsUpdate = true;
        }
      }).prototype.isCanvasTexture = true;
      (class extends b {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2) {
          if (1026 !== (h2 = void 0 !== h2 ? h2 : 1026) && 1027 !== h2) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          void 0 === i2 && 1026 === h2 && (i2 = 1012), void 0 === i2 && 1027 === h2 && (i2 = 1020), super(null, n2, r2, o2, s2, a2, h2, i2, l2), this.image = { width: t2, height: e2 }, this.magFilter = void 0 !== s2 ? s2 : 1003, this.minFilter = void 0 !== a2 ? a2 : 1003, this.flipY = false, this.generateMipmaps = false;
        }
      }).prototype.isDepthTexture = true;
      new M(), new M(), new M(), new Gt();
      class co {
        constructor() {
          this.type = "Curve", this.arcLengthDivisions = 200;
        }
        getPoint() {
          return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        }
        getPointAt(t2, e2) {
          const i2 = this.getUtoTmapping(t2);
          return this.getPoint(i2, e2);
        }
        getPoints(t2 = 5) {
          const e2 = [];
          for (let i2 = 0; i2 <= t2; i2++) e2.push(this.getPoint(i2 / t2));
          return e2;
        }
        getSpacedPoints(t2 = 5) {
          const e2 = [];
          for (let i2 = 0; i2 <= t2; i2++) e2.push(this.getPointAt(i2 / t2));
          return e2;
        }
        getLength() {
          const t2 = this.getLengths();
          return t2[t2.length - 1];
        }
        getLengths(t2 = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === t2 + 1 && !this.needsUpdate) return this.cacheArcLengths;
          this.needsUpdate = false;
          const e2 = [];
          let i2, n2 = this.getPoint(0), r2 = 0;
          e2.push(0);
          for (let o2 = 1; o2 <= t2; o2++) i2 = this.getPoint(o2 / t2), r2 += i2.distanceTo(n2), e2.push(r2), n2 = i2;
          return this.cacheArcLengths = e2, e2;
        }
        updateArcLengths() {
          this.needsUpdate = true, this.getLengths();
        }
        getUtoTmapping(t2, e2) {
          const i2 = this.getLengths();
          let n2 = 0;
          const r2 = i2.length;
          let o2;
          o2 = e2 || t2 * i2[r2 - 1];
          let s2, a2 = 0, l2 = r2 - 1;
          for (; a2 <= l2; ) if (n2 = Math.floor(a2 + (l2 - a2) / 2), s2 = i2[n2] - o2, s2 < 0) a2 = n2 + 1;
          else {
            if (!(s2 > 0)) {
              l2 = n2;
              break;
            }
            l2 = n2 - 1;
          }
          if (n2 = l2, i2[n2] === o2) return n2 / (r2 - 1);
          const h2 = i2[n2];
          return (n2 + (o2 - h2) / (i2[n2 + 1] - h2)) / (r2 - 1);
        }
        getTangent(t2, e2) {
          let i2 = t2 - 1e-4, n2 = t2 + 1e-4;
          i2 < 0 && (i2 = 0), n2 > 1 && (n2 = 1);
          const r2 = this.getPoint(i2), o2 = this.getPoint(n2), s2 = e2 || (r2.isVector2 ? new g() : new M());
          return s2.copy(o2).sub(r2).normalize(), s2;
        }
        getTangentAt(t2, e2) {
          const i2 = this.getUtoTmapping(t2);
          return this.getTangent(i2, e2);
        }
        computeFrenetFrames(t2, e2) {
          const i2 = new M(), n2 = [], r2 = [], o2 = [], s2 = new M(), a2 = new rt();
          for (let e3 = 0; e3 <= t2; e3++) {
            const i3 = e3 / t2;
            n2[e3] = this.getTangentAt(i3, new M()), n2[e3].normalize();
          }
          r2[0] = new M(), o2[0] = new M();
          let l2 = Number.MAX_VALUE;
          const h2 = Math.abs(n2[0].x), u2 = Math.abs(n2[0].y), d2 = Math.abs(n2[0].z);
          h2 <= l2 && (l2 = h2, i2.set(1, 0, 0)), u2 <= l2 && (l2 = u2, i2.set(0, 1, 0)), d2 <= l2 && i2.set(0, 0, 1), s2.crossVectors(n2[0], i2).normalize(), r2[0].crossVectors(n2[0], s2), o2[0].crossVectors(n2[0], r2[0]);
          for (let e3 = 1; e3 <= t2; e3++) {
            if (r2[e3] = r2[e3 - 1].clone(), o2[e3] = o2[e3 - 1].clone(), s2.crossVectors(n2[e3 - 1], n2[e3]), s2.length() > Number.EPSILON) {
              s2.normalize();
              const t3 = Math.acos(c(n2[e3 - 1].dot(n2[e3]), -1, 1));
              r2[e3].applyMatrix4(a2.makeRotationAxis(s2, t3));
            }
            o2[e3].crossVectors(n2[e3], r2[e3]);
          }
          if (true === e2) {
            let e3 = Math.acos(c(r2[0].dot(r2[t2]), -1, 1));
            e3 /= t2, n2[0].dot(s2.crossVectors(r2[0], r2[t2])) > 0 && (e3 = -e3);
            for (let i3 = 1; i3 <= t2; i3++) r2[i3].applyMatrix4(a2.makeRotationAxis(n2[i3], e3 * i3)), o2[i3].crossVectors(n2[i3], r2[i3]);
          }
          return { tangents: n2, normals: r2, binormals: o2 };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.arcLengthDivisions = t2.arcLengthDivisions, this;
        }
        toJSON() {
          const t2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
          return t2.arcLengthDivisions = this.arcLengthDivisions, t2.type = this.type, t2;
        }
        fromJSON(t2) {
          return this.arcLengthDivisions = t2.arcLengthDivisions, this;
        }
      }
      class po extends co {
        constructor(t2 = 0, e2 = 0, i2 = 1, n2 = 1, r2 = 0, o2 = 2 * Math.PI, s2 = false, a2 = 0) {
          super(), this.type = "EllipseCurve", this.aX = t2, this.aY = e2, this.xRadius = i2, this.yRadius = n2, this.aStartAngle = r2, this.aEndAngle = o2, this.aClockwise = s2, this.aRotation = a2;
        }
        getPoint(t2, e2) {
          const i2 = e2 || new g(), n2 = 2 * Math.PI;
          let r2 = this.aEndAngle - this.aStartAngle;
          const o2 = Math.abs(r2) < Number.EPSILON;
          for (; r2 < 0; ) r2 += n2;
          for (; r2 > n2; ) r2 -= n2;
          r2 < Number.EPSILON && (r2 = o2 ? 0 : n2), true !== this.aClockwise || o2 || (r2 === n2 ? r2 = -n2 : r2 -= n2);
          const s2 = this.aStartAngle + t2 * r2;
          let a2 = this.aX + this.xRadius * Math.cos(s2), l2 = this.aY + this.yRadius * Math.sin(s2);
          if (0 !== this.aRotation) {
            const t3 = Math.cos(this.aRotation), e3 = Math.sin(this.aRotation), i3 = a2 - this.aX, n3 = l2 - this.aY;
            a2 = i3 * t3 - n3 * e3 + this.aX, l2 = i3 * e3 + n3 * t3 + this.aY;
          }
          return i2.set(a2, l2);
        }
        copy(t2) {
          return super.copy(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.aX = this.aX, t2.aY = this.aY, t2.xRadius = this.xRadius, t2.yRadius = this.yRadius, t2.aStartAngle = this.aStartAngle, t2.aEndAngle = this.aEndAngle, t2.aClockwise = this.aClockwise, t2.aRotation = this.aRotation, t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.aX = t2.aX, this.aY = t2.aY, this.xRadius = t2.xRadius, this.yRadius = t2.yRadius, this.aStartAngle = t2.aStartAngle, this.aEndAngle = t2.aEndAngle, this.aClockwise = t2.aClockwise, this.aRotation = t2.aRotation, this;
        }
      }
      po.prototype.isEllipseCurve = true;
      class fo extends po {
        constructor(t2, e2, i2, n2, r2, o2) {
          super(t2, e2, i2, i2, n2, r2, o2), this.type = "ArcCurve";
        }
      }
      function mo() {
        let t2 = 0, e2 = 0, i2 = 0, n2 = 0;
        function r2(r3, o2, s2, a2) {
          t2 = r3, e2 = s2, i2 = -3 * r3 + 3 * o2 - 2 * s2 - a2, n2 = 2 * r3 - 2 * o2 + s2 + a2;
        }
        return { initCatmullRom: function(t3, e3, i3, n3, o2) {
          r2(e3, i3, o2 * (i3 - t3), o2 * (n3 - e3));
        }, initNonuniformCatmullRom: function(t3, e3, i3, n3, o2, s2, a2) {
          let l2 = (e3 - t3) / o2 - (i3 - t3) / (o2 + s2) + (i3 - e3) / s2, h2 = (i3 - e3) / s2 - (n3 - e3) / (s2 + a2) + (n3 - i3) / a2;
          l2 *= s2, h2 *= s2, r2(e3, i3, l2, h2);
        }, calc: function(r3) {
          const o2 = r3 * r3;
          return t2 + e2 * r3 + i2 * o2 + n2 * (o2 * r3);
        } };
      }
      fo.prototype.isArcCurve = true;
      const go = new M(), vo = new mo(), _o = new mo(), yo = new mo();
      class xo extends co {
        constructor(t2 = [], e2 = false, i2 = "centripetal", n2 = 0.5) {
          super(), this.type = "CatmullRomCurve3", this.points = t2, this.closed = e2, this.curveType = i2, this.tension = n2;
        }
        getPoint(t2, e2 = new M()) {
          const i2 = e2, n2 = this.points, r2 = n2.length, o2 = (r2 - (this.closed ? 0 : 1)) * t2;
          let s2, a2, l2 = Math.floor(o2), h2 = o2 - l2;
          this.closed ? l2 += l2 > 0 ? 0 : (Math.floor(Math.abs(l2) / r2) + 1) * r2 : 0 === h2 && l2 === r2 - 1 && (l2 = r2 - 2, h2 = 1), this.closed || l2 > 0 ? s2 = n2[(l2 - 1) % r2] : (go.subVectors(n2[0], n2[1]).add(n2[0]), s2 = go);
          const u2 = n2[l2 % r2], c2 = n2[(l2 + 1) % r2];
          if (this.closed || l2 + 2 < r2 ? a2 = n2[(l2 + 2) % r2] : (go.subVectors(n2[r2 - 1], n2[r2 - 2]).add(n2[r2 - 1]), a2 = go), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t3 = "chordal" === this.curveType ? 0.5 : 0.25;
            let e3 = Math.pow(s2.distanceToSquared(u2), t3), i3 = Math.pow(u2.distanceToSquared(c2), t3), n3 = Math.pow(c2.distanceToSquared(a2), t3);
            i3 < 1e-4 && (i3 = 1), e3 < 1e-4 && (e3 = i3), n3 < 1e-4 && (n3 = i3), vo.initNonuniformCatmullRom(s2.x, u2.x, c2.x, a2.x, e3, i3, n3), _o.initNonuniformCatmullRom(s2.y, u2.y, c2.y, a2.y, e3, i3, n3), yo.initNonuniformCatmullRom(s2.z, u2.z, c2.z, a2.z, e3, i3, n3);
          } else "catmullrom" === this.curveType && (vo.initCatmullRom(s2.x, u2.x, c2.x, a2.x, this.tension), _o.initCatmullRom(s2.y, u2.y, c2.y, a2.y, this.tension), yo.initCatmullRom(s2.z, u2.z, c2.z, a2.z, this.tension));
          return i2.set(vo.calc(h2), _o.calc(h2), yo.calc(h2)), i2;
        }
        copy(t2) {
          super.copy(t2), this.points = [];
          for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
            const i3 = t2.points[e2];
            this.points.push(i3.clone());
          }
          return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.points = [];
          for (let e2 = 0, i2 = this.points.length; e2 < i2; e2++) {
            const i3 = this.points[e2];
            t2.points.push(i3.toArray());
          }
          return t2.closed = this.closed, t2.curveType = this.curveType, t2.tension = this.tension, t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.points = [];
          for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
            const i3 = t2.points[e2];
            this.points.push(new M().fromArray(i3));
          }
          return this.closed = t2.closed, this.curveType = t2.curveType, this.tension = t2.tension, this;
        }
      }
      function bo(t2, e2, i2, n2, r2) {
        const o2 = 0.5 * (n2 - e2), s2 = 0.5 * (r2 - i2), a2 = t2 * t2;
        return (2 * i2 - 2 * n2 + o2 + s2) * (t2 * a2) + (-3 * i2 + 3 * n2 - 2 * o2 - s2) * a2 + o2 * t2 + i2;
      }
      function To(t2, e2, i2, n2) {
        return function(t3, e3) {
          const i3 = 1 - t3;
          return i3 * i3 * e3;
        }(t2, e2) + function(t3, e3) {
          return 2 * (1 - t3) * t3 * e3;
        }(t2, i2) + function(t3, e3) {
          return t3 * t3 * e3;
        }(t2, n2);
      }
      function Eo(t2, e2, i2, n2, r2) {
        return function(t3, e3) {
          const i3 = 1 - t3;
          return i3 * i3 * i3 * e3;
        }(t2, e2) + function(t3, e3) {
          const i3 = 1 - t3;
          return 3 * i3 * i3 * t3 * e3;
        }(t2, i2) + function(t3, e3) {
          return 3 * (1 - t3) * t3 * t3 * e3;
        }(t2, n2) + function(t3, e3) {
          return t3 * t3 * t3 * e3;
        }(t2, r2);
      }
      xo.prototype.isCatmullRomCurve3 = true;
      class So extends co {
        constructor(t2 = new g(), e2 = new g(), i2 = new g(), n2 = new g()) {
          super(), this.type = "CubicBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = i2, this.v3 = n2;
        }
        getPoint(t2, e2 = new g()) {
          const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2, s2 = this.v3;
          return i2.set(Eo(t2, n2.x, r2.x, o2.x, s2.x), Eo(t2, n2.y, r2.y, o2.y, s2.y)), i2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
        }
      }
      So.prototype.isCubicBezierCurve = true;
      class wo extends co {
        constructor(t2 = new M(), e2 = new M(), i2 = new M(), n2 = new M()) {
          super(), this.type = "CubicBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = i2, this.v3 = n2;
        }
        getPoint(t2, e2 = new M()) {
          const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2, s2 = this.v3;
          return i2.set(Eo(t2, n2.x, r2.x, o2.x, s2.x), Eo(t2, n2.y, r2.y, o2.y, s2.y), Eo(t2, n2.z, r2.z, o2.z, s2.z)), i2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this.v3.copy(t2.v3), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2.v3 = this.v3.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this.v3.fromArray(t2.v3), this;
        }
      }
      wo.prototype.isCubicBezierCurve3 = true;
      class Ao extends co {
        constructor(t2 = new g(), e2 = new g()) {
          super(), this.type = "LineCurve", this.v1 = t2, this.v2 = e2;
        }
        getPoint(t2, e2 = new g()) {
          const i2 = e2;
          return 1 === t2 ? i2.copy(this.v2) : (i2.copy(this.v2).sub(this.v1), i2.multiplyScalar(t2).add(this.v1)), i2;
        }
        getPointAt(t2, e2) {
          return this.getPoint(t2, e2);
        }
        getTangent(t2, e2) {
          const i2 = e2 || new g();
          return i2.copy(this.v2).sub(this.v1).normalize(), i2;
        }
        copy(t2) {
          return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      Ao.prototype.isLineCurve = true;
      class Mo extends co {
        constructor(t2 = new g(), e2 = new g(), i2 = new g()) {
          super(), this.type = "QuadraticBezierCurve", this.v0 = t2, this.v1 = e2, this.v2 = i2;
        }
        getPoint(t2, e2 = new g()) {
          const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2;
          return i2.set(To(t2, n2.x, r2.x, o2.x), To(t2, n2.y, r2.y, o2.y)), i2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      Mo.prototype.isQuadraticBezierCurve = true;
      class Co extends co {
        constructor(t2 = new M(), e2 = new M(), i2 = new M()) {
          super(), this.type = "QuadraticBezierCurve3", this.v0 = t2, this.v1 = e2, this.v2 = i2;
        }
        getPoint(t2, e2 = new M()) {
          const i2 = e2, n2 = this.v0, r2 = this.v1, o2 = this.v2;
          return i2.set(To(t2, n2.x, r2.x, o2.x), To(t2, n2.y, r2.y, o2.y), To(t2, n2.z, r2.z, o2.z)), i2;
        }
        copy(t2) {
          return super.copy(t2), this.v0.copy(t2.v0), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v0 = this.v0.toArray(), t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v0.fromArray(t2.v0), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }
      Co.prototype.isQuadraticBezierCurve3 = true;
      class Ro extends co {
        constructor(t2 = []) {
          super(), this.type = "SplineCurve", this.points = t2;
        }
        getPoint(t2, e2 = new g()) {
          const i2 = e2, n2 = this.points, r2 = (n2.length - 1) * t2, o2 = Math.floor(r2), s2 = r2 - o2, a2 = n2[0 === o2 ? o2 : o2 - 1], l2 = n2[o2], h2 = n2[o2 > n2.length - 2 ? n2.length - 1 : o2 + 1], u2 = n2[o2 > n2.length - 3 ? n2.length - 1 : o2 + 2];
          return i2.set(bo(s2, a2.x, l2.x, h2.x, u2.x), bo(s2, a2.y, l2.y, h2.y, u2.y)), i2;
        }
        copy(t2) {
          super.copy(t2), this.points = [];
          for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
            const i3 = t2.points[e2];
            this.points.push(i3.clone());
          }
          return this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.points = [];
          for (let e2 = 0, i2 = this.points.length; e2 < i2; e2++) {
            const i3 = this.points[e2];
            t2.points.push(i3.toArray());
          }
          return t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.points = [];
          for (let e2 = 0, i2 = t2.points.length; e2 < i2; e2++) {
            const i3 = t2.points[e2];
            this.points.push(new g().fromArray(i3));
          }
          return this;
        }
      }
      Ro.prototype.isSplineCurve = true;
      var Io = Object.freeze({ __proto__: null, ArcCurve: fo, CatmullRomCurve3: xo, CubicBezierCurve: So, CubicBezierCurve3: wo, EllipseCurve: po, LineCurve: Ao, LineCurve3: class extends co {
        constructor(t2 = new M(), e2 = new M()) {
          super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t2, this.v2 = e2;
        }
        getPoint(t2, e2 = new M()) {
          const i2 = e2;
          return 1 === t2 ? i2.copy(this.v2) : (i2.copy(this.v2).sub(this.v1), i2.multiplyScalar(t2).add(this.v1)), i2;
        }
        getPointAt(t2, e2) {
          return this.getPoint(t2, e2);
        }
        copy(t2) {
          return super.copy(t2), this.v1.copy(t2.v1), this.v2.copy(t2.v2), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.v1 = this.v1.toArray(), t2.v2 = this.v2.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.v1.fromArray(t2.v1), this.v2.fromArray(t2.v2), this;
        }
      }, QuadraticBezierCurve: Mo, QuadraticBezierCurve3: Co, SplineCurve: Ro });
      const Po = function(t2, e2, i2 = 2) {
        const n2 = e2 && e2.length, r2 = n2 ? e2[0] * i2 : t2.length;
        let o2 = Oo(t2, 0, r2, i2, true);
        const s2 = [];
        if (!o2 || o2.next === o2.prev) return s2;
        let a2, l2, h2, u2, c2, d2, p2;
        if (n2 && (o2 = function(t3, e3, i3, n3) {
          const r3 = [];
          let o3, s3, a3, l3, h3;
          for (o3 = 0, s3 = e3.length; o3 < s3; o3++) a3 = e3[o3] * n3, l3 = o3 < s3 - 1 ? e3[o3 + 1] * n3 : t3.length, h3 = Oo(t3, a3, l3, n3, false), h3 === h3.next && (h3.steiner = true), r3.push(zo(h3));
          for (r3.sort(ko), o3 = 0; o3 < r3.length; o3++) Go(r3[o3], i3), i3 = No(i3, i3.next);
          return i3;
        }(t2, e2, o2, i2)), t2.length > 80 * i2) {
          a2 = h2 = t2[0], l2 = u2 = t2[1];
          for (let e3 = i2; e3 < r2; e3 += i2) c2 = t2[e3], d2 = t2[e3 + 1], c2 < a2 && (a2 = c2), d2 < l2 && (l2 = d2), c2 > h2 && (h2 = c2), d2 > u2 && (u2 = d2);
          p2 = Math.max(h2 - a2, u2 - l2), p2 = 0 !== p2 ? 1 / p2 : 0;
        }
        return Lo(o2, s2, i2, a2, l2, p2), s2;
      };
      function Oo(t2, e2, i2, n2, r2) {
        let o2, s2;
        if (r2 === function(t3, e3, i3, n3) {
          let r3 = 0;
          for (let o3 = e3, s3 = i3 - n3; o3 < i3; o3 += n3) r3 += (t3[s3] - t3[o3]) * (t3[o3 + 1] + t3[s3 + 1]), s3 = o3;
          return r3;
        }(t2, e2, i2, n2) > 0) for (o2 = e2; o2 < i2; o2 += n2) s2 = $o(o2, t2[o2], t2[o2 + 1], s2);
        else for (o2 = i2 - n2; o2 >= e2; o2 -= n2) s2 = $o(o2, t2[o2], t2[o2 + 1], s2);
        return s2 && Yo(s2, s2.next) && (ts(s2), s2 = s2.next), s2;
      }
      function No(t2, e2) {
        if (!t2) return t2;
        e2 || (e2 = t2);
        let i2, n2 = t2;
        do {
          if (i2 = false, n2.steiner || !Yo(n2, n2.next) && 0 !== Wo(n2.prev, n2, n2.next)) n2 = n2.next;
          else {
            if (ts(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
            i2 = true;
          }
        } while (i2 || n2 !== e2);
        return e2;
      }
      function Lo(t2, e2, i2, n2, r2, o2, s2) {
        if (!t2) return;
        !s2 && o2 && function(t3, e3, i3, n3) {
          let r3 = t3;
          do {
            null === r3.z && (r3.z = jo(r3.x, r3.y, e3, i3, n3)), r3.prevZ = r3.prev, r3.nextZ = r3.next, r3 = r3.next;
          } while (r3 !== t3);
          r3.prevZ.nextZ = null, r3.prevZ = null, function(t4) {
            let e4, i4, n4, r4, o3, s3, a3, l3, h3 = 1;
            do {
              for (i4 = t4, t4 = null, o3 = null, s3 = 0; i4; ) {
                for (s3++, n4 = i4, a3 = 0, e4 = 0; e4 < h3 && (a3++, n4 = n4.nextZ, n4); e4++) ;
                for (l3 = h3; a3 > 0 || l3 > 0 && n4; ) 0 !== a3 && (0 === l3 || !n4 || i4.z <= n4.z) ? (r4 = i4, i4 = i4.nextZ, a3--) : (r4 = n4, n4 = n4.nextZ, l3--), o3 ? o3.nextZ = r4 : t4 = r4, r4.prevZ = o3, o3 = r4;
                i4 = n4;
              }
              o3.nextZ = null, h3 *= 2;
            } while (s3 > 1);
          }(r3);
        }(t2, n2, r2, o2);
        let a2, l2, h2 = t2;
        for (; t2.prev !== t2.next; ) if (a2 = t2.prev, l2 = t2.next, o2 ? Fo(t2, n2, r2, o2) : Do(t2)) e2.push(a2.i / i2), e2.push(t2.i / i2), e2.push(l2.i / i2), ts(t2), t2 = l2.next, h2 = l2.next;
        else if ((t2 = l2) === h2) {
          s2 ? 1 === s2 ? Lo(t2 = Bo(No(t2), e2, i2), e2, i2, n2, r2, o2, 2) : 2 === s2 && Uo(t2, e2, i2, n2, r2, o2) : Lo(No(t2), e2, i2, n2, r2, o2, 1);
          break;
        }
      }
      function Do(t2) {
        const e2 = t2.prev, i2 = t2, n2 = t2.next;
        if (Wo(e2, i2, n2) >= 0) return false;
        let r2 = t2.next.next;
        for (; r2 !== t2.prev; ) {
          if (Vo(e2.x, e2.y, i2.x, i2.y, n2.x, n2.y, r2.x, r2.y) && Wo(r2.prev, r2, r2.next) >= 0) return false;
          r2 = r2.next;
        }
        return true;
      }
      function Fo(t2, e2, i2, n2) {
        const r2 = t2.prev, o2 = t2, s2 = t2.next;
        if (Wo(r2, o2, s2) >= 0) return false;
        const a2 = r2.x < o2.x ? r2.x < s2.x ? r2.x : s2.x : o2.x < s2.x ? o2.x : s2.x, l2 = r2.y < o2.y ? r2.y < s2.y ? r2.y : s2.y : o2.y < s2.y ? o2.y : s2.y, h2 = r2.x > o2.x ? r2.x > s2.x ? r2.x : s2.x : o2.x > s2.x ? o2.x : s2.x, u2 = r2.y > o2.y ? r2.y > s2.y ? r2.y : s2.y : o2.y > s2.y ? o2.y : s2.y, c2 = jo(a2, l2, e2, i2, n2), d2 = jo(h2, u2, e2, i2, n2);
        let p2 = t2.prevZ, f2 = t2.nextZ;
        for (; p2 && p2.z >= c2 && f2 && f2.z <= d2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, p2.x, p2.y) && Wo(p2.prev, p2, p2.next) >= 0) return false;
          if (p2 = p2.prevZ, f2 !== t2.prev && f2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, f2.x, f2.y) && Wo(f2.prev, f2, f2.next) >= 0) return false;
          f2 = f2.nextZ;
        }
        for (; p2 && p2.z >= c2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, p2.x, p2.y) && Wo(p2.prev, p2, p2.next) >= 0) return false;
          p2 = p2.prevZ;
        }
        for (; f2 && f2.z <= d2; ) {
          if (f2 !== t2.prev && f2 !== t2.next && Vo(r2.x, r2.y, o2.x, o2.y, s2.x, s2.y, f2.x, f2.y) && Wo(f2.prev, f2, f2.next) >= 0) return false;
          f2 = f2.nextZ;
        }
        return true;
      }
      function Bo(t2, e2, i2) {
        let n2 = t2;
        do {
          const r2 = n2.prev, o2 = n2.next.next;
          !Yo(r2, o2) && qo(r2, n2, n2.next, o2) && Ko(r2, o2) && Ko(o2, r2) && (e2.push(r2.i / i2), e2.push(n2.i / i2), e2.push(o2.i / i2), ts(n2), ts(n2.next), n2 = t2 = o2), n2 = n2.next;
        } while (n2 !== t2);
        return No(n2);
      }
      function Uo(t2, e2, i2, n2, r2, o2) {
        let s2 = t2;
        do {
          let t3 = s2.next.next;
          for (; t3 !== s2.prev; ) {
            if (s2.i !== t3.i && Xo(s2, t3)) {
              let a2 = Qo(s2, t3);
              return s2 = No(s2, s2.next), a2 = No(a2, a2.next), Lo(s2, e2, i2, n2, r2, o2), void Lo(a2, e2, i2, n2, r2, o2);
            }
            t3 = t3.next;
          }
          s2 = s2.next;
        } while (s2 !== t2);
      }
      function ko(t2, e2) {
        return t2.x - e2.x;
      }
      function Go(t2, e2) {
        if (e2 = function(t3, e3) {
          let i2 = e3;
          const n2 = t3.x, r2 = t3.y;
          let o2, s2 = -1 / 0;
          do {
            if (r2 <= i2.y && r2 >= i2.next.y && i2.next.y !== i2.y) {
              const t4 = i2.x + (r2 - i2.y) * (i2.next.x - i2.x) / (i2.next.y - i2.y);
              if (t4 <= n2 && t4 > s2) {
                if (s2 = t4, t4 === n2) {
                  if (r2 === i2.y) return i2;
                  if (r2 === i2.next.y) return i2.next;
                }
                o2 = i2.x < i2.next.x ? i2 : i2.next;
              }
            }
            i2 = i2.next;
          } while (i2 !== e3);
          if (!o2) return null;
          if (n2 === s2) return o2;
          const a2 = o2, l2 = o2.x, h2 = o2.y;
          let u2, c2 = 1 / 0;
          i2 = o2;
          do {
            n2 >= i2.x && i2.x >= l2 && n2 !== i2.x && Vo(r2 < h2 ? n2 : s2, r2, l2, h2, r2 < h2 ? s2 : n2, r2, i2.x, i2.y) && (u2 = Math.abs(r2 - i2.y) / (n2 - i2.x), Ko(i2, t3) && (u2 < c2 || u2 === c2 && (i2.x > o2.x || i2.x === o2.x && Ho(o2, i2))) && (o2 = i2, c2 = u2)), i2 = i2.next;
          } while (i2 !== a2);
          return o2;
        }(t2, e2)) {
          const i2 = Qo(e2, t2);
          No(e2, e2.next), No(i2, i2.next);
        }
      }
      function Ho(t2, e2) {
        return Wo(t2.prev, t2, e2.prev) < 0 && Wo(e2.next, t2, t2.next) < 0;
      }
      function jo(t2, e2, i2, n2, r2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - i2) * r2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * r2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function zo(t2) {
        let e2 = t2, i2 = t2;
        do {
          (e2.x < i2.x || e2.x === i2.x && e2.y < i2.y) && (i2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return i2;
      }
      function Vo(t2, e2, i2, n2, r2, o2, s2, a2) {
        return (r2 - s2) * (e2 - a2) - (t2 - s2) * (o2 - a2) >= 0 && (t2 - s2) * (n2 - a2) - (i2 - s2) * (e2 - a2) >= 0 && (i2 - s2) * (o2 - a2) - (r2 - s2) * (n2 - a2) >= 0;
      }
      function Xo(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          let i2 = t3;
          do {
            if (i2.i !== t3.i && i2.next.i !== t3.i && i2.i !== e3.i && i2.next.i !== e3.i && qo(i2, i2.next, t3, e3)) return true;
            i2 = i2.next;
          } while (i2 !== t3);
          return false;
        }(t2, e2) && (Ko(t2, e2) && Ko(e2, t2) && function(t3, e3) {
          let i2 = t3, n2 = false;
          const r2 = (t3.x + e3.x) / 2, o2 = (t3.y + e3.y) / 2;
          do {
            i2.y > o2 != i2.next.y > o2 && i2.next.y !== i2.y && r2 < (i2.next.x - i2.x) * (o2 - i2.y) / (i2.next.y - i2.y) + i2.x && (n2 = !n2), i2 = i2.next;
          } while (i2 !== t3);
          return n2;
        }(t2, e2) && (Wo(t2.prev, t2, e2.prev) || Wo(t2, e2.prev, e2)) || Yo(t2, e2) && Wo(t2.prev, t2, t2.next) > 0 && Wo(e2.prev, e2, e2.next) > 0);
      }
      function Wo(t2, e2, i2) {
        return (e2.y - t2.y) * (i2.x - e2.x) - (e2.x - t2.x) * (i2.y - e2.y);
      }
      function Yo(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function qo(t2, e2, i2, n2) {
        const r2 = Jo(Wo(t2, e2, i2)), o2 = Jo(Wo(t2, e2, n2)), s2 = Jo(Wo(i2, n2, t2)), a2 = Jo(Wo(i2, n2, e2));
        return r2 !== o2 && s2 !== a2 || (!(0 !== r2 || !Zo(t2, i2, e2)) || (!(0 !== o2 || !Zo(t2, n2, e2)) || (!(0 !== s2 || !Zo(i2, t2, n2)) || !(0 !== a2 || !Zo(i2, e2, n2)))));
      }
      function Zo(t2, e2, i2) {
        return e2.x <= Math.max(t2.x, i2.x) && e2.x >= Math.min(t2.x, i2.x) && e2.y <= Math.max(t2.y, i2.y) && e2.y >= Math.min(t2.y, i2.y);
      }
      function Jo(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Ko(t2, e2) {
        return Wo(t2.prev, t2, t2.next) < 0 ? Wo(t2, e2, t2.next) >= 0 && Wo(t2, t2.prev, e2) >= 0 : Wo(t2, e2, t2.prev) < 0 || Wo(t2, t2.next, e2) < 0;
      }
      function Qo(t2, e2) {
        const i2 = new es(t2.i, t2.x, t2.y), n2 = new es(e2.i, e2.x, e2.y), r2 = t2.next, o2 = e2.prev;
        return t2.next = e2, e2.prev = t2, i2.next = r2, r2.prev = i2, n2.next = i2, i2.prev = n2, o2.next = n2, n2.prev = o2, n2;
      }
      function $o(t2, e2, i2, n2) {
        const r2 = new es(t2, e2, i2);
        return n2 ? (r2.next = n2.next, r2.prev = n2, n2.next.prev = r2, n2.next = r2) : (r2.prev = r2, r2.next = r2), r2;
      }
      function ts(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function es(t2, e2, i2) {
        this.i = t2, this.x = e2, this.y = i2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      class is {
        static area(t2) {
          const e2 = t2.length;
          let i2 = 0;
          for (let n2 = e2 - 1, r2 = 0; r2 < e2; n2 = r2++) i2 += t2[n2].x * t2[r2].y - t2[r2].x * t2[n2].y;
          return 0.5 * i2;
        }
        static isClockWise(t2) {
          return is.area(t2) < 0;
        }
        static triangulateShape(t2, e2) {
          const i2 = [], n2 = [], r2 = [];
          ns(t2), rs(i2, t2);
          let o2 = t2.length;
          e2.forEach(ns);
          for (let t3 = 0; t3 < e2.length; t3++) n2.push(o2), o2 += e2[t3].length, rs(i2, e2[t3]);
          const s2 = Po(i2, n2);
          for (let t3 = 0; t3 < s2.length; t3 += 3) r2.push(s2.slice(t3, t3 + 3));
          return r2;
        }
      }
      function ns(t2) {
        const e2 = t2.length;
        e2 > 2 && t2[e2 - 1].equals(t2[0]) && t2.pop();
      }
      function rs(t2, e2) {
        for (let i2 = 0; i2 < e2.length; i2++) t2.push(e2[i2].x), t2.push(e2[i2].y);
      }
      class os extends de {
        constructor(t2, e2) {
          super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t2, options: e2 }, t2 = Array.isArray(t2) ? t2 : [t2];
          const i2 = this, n2 = [], r2 = [];
          for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) {
            o2(t2[e3]);
          }
          function o2(t3) {
            const o3 = [], s2 = void 0 !== e2.curveSegments ? e2.curveSegments : 12, a2 = void 0 !== e2.steps ? e2.steps : 1;
            let l2 = void 0 !== e2.depth ? e2.depth : 100, h2 = void 0 === e2.bevelEnabled || e2.bevelEnabled, u2 = void 0 !== e2.bevelThickness ? e2.bevelThickness : 6, c2 = void 0 !== e2.bevelSize ? e2.bevelSize : u2 - 2, d2 = void 0 !== e2.bevelOffset ? e2.bevelOffset : 0, p2 = void 0 !== e2.bevelSegments ? e2.bevelSegments : 3;
            const f2 = e2.extrudePath, m2 = void 0 !== e2.UVGenerator ? e2.UVGenerator : ss;
            void 0 !== e2.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l2 = e2.amount);
            let v2, _2, y2, x2, b2, T2 = false;
            f2 && (v2 = f2.getSpacedPoints(a2), T2 = true, h2 = false, _2 = f2.computeFrenetFrames(a2, false), y2 = new M(), x2 = new M(), b2 = new M()), h2 || (p2 = 0, u2 = 0, c2 = 0, d2 = 0);
            const E2 = t3.extractPoints(s2);
            let S2 = E2.shape;
            const w2 = E2.holes;
            if (!is.isClockWise(S2)) {
              S2 = S2.reverse();
              for (let t4 = 0, e3 = w2.length; t4 < e3; t4++) {
                const e4 = w2[t4];
                is.isClockWise(e4) && (w2[t4] = e4.reverse());
              }
            }
            const A2 = is.triangulateShape(S2, w2), C2 = S2;
            for (let t4 = 0, e3 = w2.length; t4 < e3; t4++) {
              const e4 = w2[t4];
              S2 = S2.concat(e4);
            }
            function R2(t4, e3, i3) {
              return e3 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e3.clone().multiplyScalar(i3).add(t4);
            }
            const I2 = S2.length, P2 = A2.length;
            function O2(t4, e3, i3) {
              let n3, r3, o4;
              const s3 = t4.x - e3.x, a3 = t4.y - e3.y, l3 = i3.x - t4.x, h3 = i3.y - t4.y, u3 = s3 * s3 + a3 * a3, c3 = s3 * h3 - a3 * l3;
              if (Math.abs(c3) > Number.EPSILON) {
                const c4 = Math.sqrt(u3), d3 = Math.sqrt(l3 * l3 + h3 * h3), p3 = e3.x - a3 / c4, f3 = e3.y + s3 / c4, m3 = ((i3.x - h3 / d3 - p3) * h3 - (i3.y + l3 / d3 - f3) * l3) / (s3 * h3 - a3 * l3);
                n3 = p3 + s3 * m3 - t4.x, r3 = f3 + a3 * m3 - t4.y;
                const v3 = n3 * n3 + r3 * r3;
                if (v3 <= 2) return new g(n3, r3);
                o4 = Math.sqrt(v3 / 2);
              } else {
                let t5 = false;
                s3 > Number.EPSILON ? l3 > Number.EPSILON && (t5 = true) : s3 < -Number.EPSILON ? l3 < -Number.EPSILON && (t5 = true) : Math.sign(a3) === Math.sign(h3) && (t5 = true), t5 ? (n3 = -a3, r3 = s3, o4 = Math.sqrt(u3)) : (n3 = s3, r3 = a3, o4 = Math.sqrt(u3 / 2));
              }
              return new g(n3 / o4, r3 / o4);
            }
            const N2 = [];
            for (let t4 = 0, e3 = C2.length, i3 = e3 - 1, n3 = t4 + 1; t4 < e3; t4++, i3++, n3++) i3 === e3 && (i3 = 0), n3 === e3 && (n3 = 0), N2[t4] = O2(C2[t4], C2[i3], C2[n3]);
            const L2 = [];
            let D2, F2 = N2.concat();
            for (let t4 = 0, e3 = w2.length; t4 < e3; t4++) {
              const e4 = w2[t4];
              D2 = [];
              for (let t5 = 0, i3 = e4.length, n3 = i3 - 1, r3 = t5 + 1; t5 < i3; t5++, n3++, r3++) n3 === i3 && (n3 = 0), r3 === i3 && (r3 = 0), D2[t5] = O2(e4[t5], e4[n3], e4[r3]);
              L2.push(D2), F2 = F2.concat(D2);
            }
            for (let t4 = 0; t4 < p2; t4++) {
              const e3 = t4 / p2, i3 = u2 * Math.cos(e3 * Math.PI / 2), n3 = c2 * Math.sin(e3 * Math.PI / 2) + d2;
              for (let t5 = 0, e4 = C2.length; t5 < e4; t5++) {
                const e5 = R2(C2[t5], N2[t5], n3);
                k2(e5.x, e5.y, -i3);
              }
              for (let t5 = 0, e4 = w2.length; t5 < e4; t5++) {
                const e5 = w2[t5];
                D2 = L2[t5];
                for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
                  const r4 = R2(e5[t6], D2[t6], n3);
                  k2(r4.x, r4.y, -i3);
                }
              }
            }
            const B2 = c2 + d2;
            for (let t4 = 0; t4 < I2; t4++) {
              const e3 = h2 ? R2(S2[t4], F2[t4], B2) : S2[t4];
              T2 ? (x2.copy(_2.normals[0]).multiplyScalar(e3.x), y2.copy(_2.binormals[0]).multiplyScalar(e3.y), b2.copy(v2[0]).add(x2).add(y2), k2(b2.x, b2.y, b2.z)) : k2(e3.x, e3.y, 0);
            }
            for (let t4 = 1; t4 <= a2; t4++) for (let e3 = 0; e3 < I2; e3++) {
              const i3 = h2 ? R2(S2[e3], F2[e3], B2) : S2[e3];
              T2 ? (x2.copy(_2.normals[t4]).multiplyScalar(i3.x), y2.copy(_2.binormals[t4]).multiplyScalar(i3.y), b2.copy(v2[t4]).add(x2).add(y2), k2(b2.x, b2.y, b2.z)) : k2(i3.x, i3.y, l2 / a2 * t4);
            }
            for (let t4 = p2 - 1; t4 >= 0; t4--) {
              const e3 = t4 / p2, i3 = u2 * Math.cos(e3 * Math.PI / 2), n3 = c2 * Math.sin(e3 * Math.PI / 2) + d2;
              for (let t5 = 0, e4 = C2.length; t5 < e4; t5++) {
                const e5 = R2(C2[t5], N2[t5], n3);
                k2(e5.x, e5.y, l2 + i3);
              }
              for (let t5 = 0, e4 = w2.length; t5 < e4; t5++) {
                const e5 = w2[t5];
                D2 = L2[t5];
                for (let t6 = 0, r3 = e5.length; t6 < r3; t6++) {
                  const r4 = R2(e5[t6], D2[t6], n3);
                  T2 ? k2(r4.x, r4.y + v2[a2 - 1].y, v2[a2 - 1].x + i3) : k2(r4.x, r4.y, l2 + i3);
                }
              }
            }
            function U2(t4, e3) {
              let i3 = t4.length;
              for (; --i3 >= 0; ) {
                const n3 = i3;
                let r3 = i3 - 1;
                r3 < 0 && (r3 = t4.length - 1);
                for (let t5 = 0, i4 = a2 + 2 * p2; t5 < i4; t5++) {
                  const i5 = I2 * t5, o4 = I2 * (t5 + 1);
                  H2(e3 + n3 + i5, e3 + r3 + i5, e3 + r3 + o4, e3 + n3 + o4);
                }
              }
            }
            function k2(t4, e3, i3) {
              o3.push(t4), o3.push(e3), o3.push(i3);
            }
            function G2(t4, e3, r3) {
              j2(t4), j2(e3), j2(r3);
              const o4 = n2.length / 3, s3 = m2.generateTopUV(i2, n2, o4 - 3, o4 - 2, o4 - 1);
              z2(s3[0]), z2(s3[1]), z2(s3[2]);
            }
            function H2(t4, e3, r3, o4) {
              j2(t4), j2(e3), j2(o4), j2(e3), j2(r3), j2(o4);
              const s3 = n2.length / 3, a3 = m2.generateSideWallUV(i2, n2, s3 - 6, s3 - 3, s3 - 2, s3 - 1);
              z2(a3[0]), z2(a3[1]), z2(a3[3]), z2(a3[1]), z2(a3[2]), z2(a3[3]);
            }
            function j2(t4) {
              n2.push(o3[3 * t4 + 0]), n2.push(o3[3 * t4 + 1]), n2.push(o3[3 * t4 + 2]);
            }
            function z2(t4) {
              r2.push(t4.x), r2.push(t4.y);
            }
            !function() {
              const t4 = n2.length / 3;
              if (h2) {
                let t5 = 0, e3 = I2 * t5;
                for (let t6 = 0; t6 < P2; t6++) {
                  const i3 = A2[t6];
                  G2(i3[2] + e3, i3[1] + e3, i3[0] + e3);
                }
                t5 = a2 + 2 * p2, e3 = I2 * t5;
                for (let t6 = 0; t6 < P2; t6++) {
                  const i3 = A2[t6];
                  G2(i3[0] + e3, i3[1] + e3, i3[2] + e3);
                }
              } else {
                for (let t5 = 0; t5 < P2; t5++) {
                  const e3 = A2[t5];
                  G2(e3[2], e3[1], e3[0]);
                }
                for (let t5 = 0; t5 < P2; t5++) {
                  const e3 = A2[t5];
                  G2(e3[0] + I2 * a2, e3[1] + I2 * a2, e3[2] + I2 * a2);
                }
              }
              i2.addGroup(t4, n2.length / 3 - t4, 0);
            }(), function() {
              const t4 = n2.length / 3;
              let e3 = 0;
              U2(C2, e3), e3 += C2.length;
              for (let t5 = 0, i3 = w2.length; t5 < i3; t5++) {
                const i4 = w2[t5];
                U2(i4, e3), e3 += i4.length;
              }
              i2.addGroup(t4, n2.length / 3 - t4, 1);
            }();
          }
          this.setAttribute("position", new ne(n2, 3)), this.setAttribute("uv", new ne(r2, 2)), this.computeVertexNormals();
        }
        toJSON() {
          const t2 = super.toJSON();
          return function(t3, e2, i2) {
            if (i2.shapes = [], Array.isArray(t3)) for (let e3 = 0, n2 = t3.length; e3 < n2; e3++) {
              const n3 = t3[e3];
              i2.shapes.push(n3.uuid);
            }
            else i2.shapes.push(t3.uuid);
            void 0 !== e2.extrudePath && (i2.options.extrudePath = e2.extrudePath.toJSON());
            return i2;
          }(this.parameters.shapes, this.parameters.options, t2);
        }
        static fromJSON(t2, e2) {
          const i2 = [];
          for (let n3 = 0, r2 = t2.shapes.length; n3 < r2; n3++) {
            const r3 = e2[t2.shapes[n3]];
            i2.push(r3);
          }
          const n2 = t2.options.extrudePath;
          return void 0 !== n2 && (t2.options.extrudePath = new Io[n2.type]().fromJSON(n2)), new os(i2, t2.options);
        }
      }
      const ss = { generateTopUV: function(t2, e2, i2, n2, r2) {
        const o2 = e2[3 * i2], s2 = e2[3 * i2 + 1], a2 = e2[3 * n2], l2 = e2[3 * n2 + 1], h2 = e2[3 * r2], u2 = e2[3 * r2 + 1];
        return [new g(o2, s2), new g(a2, l2), new g(h2, u2)];
      }, generateSideWallUV: function(t2, e2, i2, n2, r2, o2) {
        const s2 = e2[3 * i2], a2 = e2[3 * i2 + 1], l2 = e2[3 * i2 + 2], h2 = e2[3 * n2], u2 = e2[3 * n2 + 1], c2 = e2[3 * n2 + 2], d2 = e2[3 * r2], p2 = e2[3 * r2 + 1], f2 = e2[3 * r2 + 2], m2 = e2[3 * o2], v2 = e2[3 * o2 + 1], _2 = e2[3 * o2 + 2];
        return Math.abs(a2 - u2) < Math.abs(s2 - h2) ? [new g(s2, 1 - l2), new g(h2, 1 - c2), new g(d2, 1 - f2), new g(m2, 1 - _2)] : [new g(a2, 1 - l2), new g(u2, 1 - c2), new g(p2, 1 - f2), new g(v2, 1 - _2)];
      } };
      class as extends de {
        constructor(t2, e2 = 12) {
          super(), this.type = "ShapeGeometry", this.parameters = { shapes: t2, curveSegments: e2 };
          const i2 = [], n2 = [], r2 = [], o2 = [];
          let s2 = 0, a2 = 0;
          if (false === Array.isArray(t2)) l2(t2);
          else for (let e3 = 0; e3 < t2.length; e3++) l2(t2[e3]), this.addGroup(s2, a2, e3), s2 += a2, a2 = 0;
          function l2(t3) {
            const s3 = n2.length / 3, l3 = t3.extractPoints(e2);
            let h2 = l3.shape;
            const u2 = l3.holes;
            false === is.isClockWise(h2) && (h2 = h2.reverse());
            for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
              const e4 = u2[t4];
              true === is.isClockWise(e4) && (u2[t4] = e4.reverse());
            }
            const c2 = is.triangulateShape(h2, u2);
            for (let t4 = 0, e3 = u2.length; t4 < e3; t4++) {
              const e4 = u2[t4];
              h2 = h2.concat(e4);
            }
            for (let t4 = 0, e3 = h2.length; t4 < e3; t4++) {
              const e4 = h2[t4];
              n2.push(e4.x, e4.y, 0), r2.push(0, 0, 1), o2.push(e4.x, e4.y);
            }
            for (let t4 = 0, e3 = c2.length; t4 < e3; t4++) {
              const e4 = c2[t4], n3 = e4[0] + s3, r3 = e4[1] + s3, o3 = e4[2] + s3;
              i2.push(n3, r3, o3), a2 += 3;
            }
          }
          this.setIndex(i2), this.setAttribute("position", new ne(n2, 3)), this.setAttribute("normal", new ne(r2, 3)), this.setAttribute("uv", new ne(o2, 2));
        }
        toJSON() {
          const t2 = super.toJSON();
          return function(t3, e2) {
            if (e2.shapes = [], Array.isArray(t3)) for (let i2 = 0, n2 = t3.length; i2 < n2; i2++) {
              const n3 = t3[i2];
              e2.shapes.push(n3.uuid);
            }
            else e2.shapes.push(t3.uuid);
            return e2;
          }(this.parameters.shapes, t2);
        }
        static fromJSON(t2, e2) {
          const i2 = [];
          for (let n2 = 0, r2 = t2.shapes.length; n2 < r2; n2++) {
            const r3 = e2[t2.shapes[n2]];
            i2.push(r3);
          }
          return new as(i2, t2.curveSegments);
        }
      }
      class ls extends jt {
        constructor(t2) {
          super(), this.type = "ShadowMaterial", this.color = new Zt(0), this.transparent = true, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this;
        }
      }
      ls.prototype.isShadowMaterial = true;
      class hs extends Fe {
        constructor(t2) {
          super(t2), this.type = "RawShaderMaterial";
        }
      }
      hs.prototype.isRawShaderMaterial = true;
      class us extends jt {
        constructor(t2) {
          super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Zt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.vertexTangents = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.defines = { STANDARD: "" }, this.color.copy(t2.color), this.roughness = t2.roughness, this.metalness = t2.metalness, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.roughnessMap = t2.roughnessMap, this.metalnessMap = t2.metalnessMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.envMapIntensity = t2.envMapIntensity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this.vertexTangents = t2.vertexTangents, this;
        }
      }
      us.prototype.isMeshStandardMaterial = true;
      class cs extends us {
        constructor(t2) {
          super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new g(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", { get: function() {
            return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
          }, set: function(t3) {
            this.reflectivity = c(2.5 * (t3 - 1) / (t3 + 1), 0, 1);
          } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Zt(1, 1, 1), this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t2.clearcoat, this.clearcoatMap = t2.clearcoatMap, this.clearcoatRoughness = t2.clearcoatRoughness, this.clearcoatRoughnessMap = t2.clearcoatRoughnessMap, this.clearcoatNormalMap = t2.clearcoatNormalMap, this.clearcoatNormalScale.copy(t2.clearcoatNormalScale), this.reflectivity = t2.reflectivity, t2.sheen ? this.sheen = (this.sheen || new Zt()).copy(t2.sheen) : this.sheen = null, this.transmission = t2.transmission, this.transmissionMap = t2.transmissionMap, this.thickness = t2.thickness, this.thicknessMap = t2.thicknessMap, this.attenuationDistance = t2.attenuationDistance, this.attenuationColor.copy(t2.attenuationColor), this;
        }
      }
      cs.prototype.isMeshPhysicalMaterial = true;
      class ds extends jt {
        constructor(t2) {
          super(), this.type = "MeshPhongMaterial", this.color = new Zt(16777215), this.specular = new Zt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.specular.copy(t2.specular), this.shininess = t2.shininess, this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this;
        }
      }
      ds.prototype.isMeshPhongMaterial = true;
      class ps extends jt {
        constructor(t2) {
          super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Zt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.gradientMap = t2.gradientMap, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
        }
      }
      ps.prototype.isMeshToonMaterial = true;
      class fs extends jt {
        constructor(t2) {
          super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this;
        }
      }
      fs.prototype.isMeshNormalMaterial = true;
      class ms extends jt {
        constructor(t2) {
          super(), this.type = "MeshLambertMaterial", this.color = new Zt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Zt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.morphTargets = false, this.morphNormals = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.map = t2.map, this.lightMap = t2.lightMap, this.lightMapIntensity = t2.lightMapIntensity, this.aoMap = t2.aoMap, this.aoMapIntensity = t2.aoMapIntensity, this.emissive.copy(t2.emissive), this.emissiveMap = t2.emissiveMap, this.emissiveIntensity = t2.emissiveIntensity, this.specularMap = t2.specularMap, this.alphaMap = t2.alphaMap, this.envMap = t2.envMap, this.combine = t2.combine, this.reflectivity = t2.reflectivity, this.refractionRatio = t2.refractionRatio, this.wireframe = t2.wireframe, this.wireframeLinewidth = t2.wireframeLinewidth, this.wireframeLinecap = t2.wireframeLinecap, this.wireframeLinejoin = t2.wireframeLinejoin, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this;
        }
      }
      ms.prototype.isMeshLambertMaterial = true;
      class gs extends jt {
        constructor(t2) {
          super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Zt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.defines = { MATCAP: "" }, this.color.copy(t2.color), this.matcap = t2.matcap, this.map = t2.map, this.bumpMap = t2.bumpMap, this.bumpScale = t2.bumpScale, this.normalMap = t2.normalMap, this.normalMapType = t2.normalMapType, this.normalScale.copy(t2.normalScale), this.displacementMap = t2.displacementMap, this.displacementScale = t2.displacementScale, this.displacementBias = t2.displacementBias, this.alphaMap = t2.alphaMap, this.morphTargets = t2.morphTargets, this.morphNormals = t2.morphNormals, this.flatShading = t2.flatShading, this;
        }
      }
      gs.prototype.isMeshMatcapMaterial = true;
      class vs extends Wr {
        constructor(t2) {
          super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t2);
        }
        copy(t2) {
          return super.copy(t2), this.scale = t2.scale, this.dashSize = t2.dashSize, this.gapSize = t2.gapSize, this;
        }
      }
      vs.prototype.isLineDashedMaterial = true;
      const _s = { arraySlice: function(t2, e2, i2) {
        return _s.isTypedArray(t2) ? new t2.constructor(t2.subarray(e2, void 0 !== i2 ? i2 : t2.length)) : t2.slice(e2, i2);
      }, convertArray: function(t2, e2, i2) {
        return !t2 || !i2 && t2.constructor === e2 ? t2 : "number" == typeof e2.BYTES_PER_ELEMENT ? new e2(t2) : Array.prototype.slice.call(t2);
      }, isTypedArray: function(t2) {
        return ArrayBuffer.isView(t2) && !(t2 instanceof DataView);
      }, getKeyframeOrder: function(t2) {
        const e2 = t2.length, i2 = new Array(e2);
        for (let t3 = 0; t3 !== e2; ++t3) i2[t3] = t3;
        return i2.sort(function(e3, i3) {
          return t2[e3] - t2[i3];
        }), i2;
      }, sortedArray: function(t2, e2, i2) {
        const n2 = t2.length, r2 = new t2.constructor(n2);
        for (let o2 = 0, s2 = 0; s2 !== n2; ++o2) {
          const n3 = i2[o2] * e2;
          for (let i3 = 0; i3 !== e2; ++i3) r2[s2++] = t2[n3 + i3];
        }
        return r2;
      }, flattenJSON: function(t2, e2, i2, n2) {
        let r2 = 1, o2 = t2[0];
        for (; void 0 !== o2 && void 0 === o2[n2]; ) o2 = t2[r2++];
        if (void 0 === o2) return;
        let s2 = o2[n2];
        if (void 0 !== s2) if (Array.isArray(s2)) do {
          s2 = o2[n2], void 0 !== s2 && (e2.push(o2.time), i2.push.apply(i2, s2)), o2 = t2[r2++];
        } while (void 0 !== o2);
        else if (void 0 !== s2.toArray) do {
          s2 = o2[n2], void 0 !== s2 && (e2.push(o2.time), s2.toArray(i2, i2.length)), o2 = t2[r2++];
        } while (void 0 !== o2);
        else do {
          s2 = o2[n2], void 0 !== s2 && (e2.push(o2.time), i2.push(s2)), o2 = t2[r2++];
        } while (void 0 !== o2);
      }, subclip: function(t2, e2, i2, n2, r2 = 30) {
        const o2 = t2.clone();
        o2.name = e2;
        const s2 = [];
        for (let t3 = 0; t3 < o2.tracks.length; ++t3) {
          const e3 = o2.tracks[t3], a3 = e3.getValueSize(), l2 = [], h2 = [];
          for (let t4 = 0; t4 < e3.times.length; ++t4) {
            const o3 = e3.times[t4] * r2;
            if (!(o3 < i2 || o3 >= n2)) {
              l2.push(e3.times[t4]);
              for (let i3 = 0; i3 < a3; ++i3) h2.push(e3.values[t4 * a3 + i3]);
            }
          }
          0 !== l2.length && (e3.times = _s.convertArray(l2, e3.times.constructor), e3.values = _s.convertArray(h2, e3.values.constructor), s2.push(e3));
        }
        o2.tracks = s2;
        let a2 = 1 / 0;
        for (let t3 = 0; t3 < o2.tracks.length; ++t3) a2 > o2.tracks[t3].times[0] && (a2 = o2.tracks[t3].times[0]);
        for (let t3 = 0; t3 < o2.tracks.length; ++t3) o2.tracks[t3].shift(-1 * a2);
        return o2.resetDuration(), o2;
      }, makeClipAdditive: function(t2, e2 = 0, i2 = t2, n2 = 30) {
        n2 <= 0 && (n2 = 30);
        const r2 = i2.tracks.length, o2 = e2 / n2;
        for (let e3 = 0; e3 < r2; ++e3) {
          const n3 = i2.tracks[e3], r3 = n3.ValueTypeName;
          if ("bool" === r3 || "string" === r3) continue;
          const s2 = t2.tracks.find(function(t3) {
            return t3.name === n3.name && t3.ValueTypeName === r3;
          });
          if (void 0 === s2) continue;
          let a2 = 0;
          const l2 = n3.getValueSize();
          n3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a2 = l2 / 3);
          let h2 = 0;
          const u2 = s2.getValueSize();
          s2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h2 = u2 / 3);
          const c2 = n3.times.length - 1;
          let d2;
          if (o2 <= n3.times[0]) {
            const t3 = a2, e4 = l2 - a2;
            d2 = _s.arraySlice(n3.values, t3, e4);
          } else if (o2 >= n3.times[c2]) {
            const t3 = c2 * l2 + a2, e4 = t3 + l2 - a2;
            d2 = _s.arraySlice(n3.values, t3, e4);
          } else {
            const t3 = n3.createInterpolant(), e4 = a2, i3 = l2 - a2;
            t3.evaluate(o2), d2 = _s.arraySlice(t3.resultBuffer, e4, i3);
          }
          if ("quaternion" === r3) {
            new A().fromArray(d2).normalize().conjugate().toArray(d2);
          }
          const p2 = s2.times.length;
          for (let t3 = 0; t3 < p2; ++t3) {
            const e4 = t3 * u2 + h2;
            if ("quaternion" === r3) A.multiplyQuaternionsFlat(s2.values, e4, d2, 0, s2.values, e4);
            else {
              const t4 = u2 - 2 * h2;
              for (let i3 = 0; i3 < t4; ++i3) s2.values[e4 + i3] -= d2[i3];
            }
          }
        }
        return t2.blendMode = 2501, t2;
      } };
      class ys {
        constructor(t2, e2, i2, n2) {
          this.parameterPositions = t2, this._cachedIndex = 0, this.resultBuffer = void 0 !== n2 ? n2 : new e2.constructor(i2), this.sampleValues = e2, this.valueSize = i2, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(t2) {
          const e2 = this.parameterPositions;
          let i2 = this._cachedIndex, n2 = e2[i2], r2 = e2[i2 - 1];
          t: {
            e: {
              let o2;
              i: {
                n: if (!(t2 < n2)) {
                  for (let o3 = i2 + 2; ; ) {
                    if (void 0 === n2) {
                      if (t2 < r2) break n;
                      return i2 = e2.length, this._cachedIndex = i2, this.afterEnd_(i2 - 1, t2, r2);
                    }
                    if (i2 === o3) break;
                    if (r2 = n2, n2 = e2[++i2], t2 < n2) break e;
                  }
                  o2 = e2.length;
                  break i;
                }
                if (t2 >= r2) break t;
                {
                  const s2 = e2[1];
                  t2 < s2 && (i2 = 2, r2 = s2);
                  for (let o3 = i2 - 2; ; ) {
                    if (void 0 === r2) return this._cachedIndex = 0, this.beforeStart_(0, t2, n2);
                    if (i2 === o3) break;
                    if (n2 = r2, r2 = e2[--i2 - 1], t2 >= r2) break e;
                  }
                  o2 = i2, i2 = 0;
                }
              }
              for (; i2 < o2; ) {
                const n3 = i2 + o2 >>> 1;
                t2 < e2[n3] ? o2 = n3 : i2 = n3 + 1;
              }
              if (n2 = e2[i2], r2 = e2[i2 - 1], void 0 === r2) return this._cachedIndex = 0, this.beforeStart_(0, t2, n2);
              if (void 0 === n2) return i2 = e2.length, this._cachedIndex = i2, this.afterEnd_(i2 - 1, r2, t2);
            }
            this._cachedIndex = i2, this.intervalChanged_(i2, r2, n2);
          }
          return this.interpolate_(i2, r2, t2, n2);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t2) {
          const e2 = this.resultBuffer, i2 = this.sampleValues, n2 = this.valueSize, r2 = t2 * n2;
          for (let t3 = 0; t3 !== n2; ++t3) e2[t3] = i2[r2 + t3];
          return e2;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      ys.prototype.beforeStart_ = ys.prototype.copySampleValue_, ys.prototype.afterEnd_ = ys.prototype.copySampleValue_;
      class xs extends ys {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 };
        }
        intervalChanged_(t2, e2, i2) {
          const n2 = this.parameterPositions;
          let r2 = t2 - 2, o2 = t2 + 1, s2 = n2[r2], a2 = n2[o2];
          if (void 0 === s2) switch (this.getSettings_().endingStart) {
            case 2401:
              r2 = t2, s2 = 2 * e2 - i2;
              break;
            case 2402:
              r2 = n2.length - 2, s2 = e2 + n2[r2] - n2[r2 + 1];
              break;
            default:
              r2 = t2, s2 = i2;
          }
          if (void 0 === a2) switch (this.getSettings_().endingEnd) {
            case 2401:
              o2 = t2, a2 = 2 * i2 - e2;
              break;
            case 2402:
              o2 = 1, a2 = i2 + n2[1] - n2[0];
              break;
            default:
              o2 = t2 - 1, a2 = e2;
          }
          const l2 = 0.5 * (i2 - e2), h2 = this.valueSize;
          this._weightPrev = l2 / (e2 - s2), this._weightNext = l2 / (a2 - i2), this._offsetPrev = r2 * h2, this._offsetNext = o2 * h2;
        }
        interpolate_(t2, e2, i2, n2) {
          const r2 = this.resultBuffer, o2 = this.sampleValues, s2 = this.valueSize, a2 = t2 * s2, l2 = a2 - s2, h2 = this._offsetPrev, u2 = this._offsetNext, c2 = this._weightPrev, d2 = this._weightNext, p2 = (i2 - e2) / (n2 - e2), f2 = p2 * p2, m2 = f2 * p2, g2 = -c2 * m2 + 2 * c2 * f2 - c2 * p2, v2 = (1 + c2) * m2 + (-1.5 - 2 * c2) * f2 + (-0.5 + c2) * p2 + 1, _2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, y2 = d2 * m2 - d2 * f2;
          for (let t3 = 0; t3 !== s2; ++t3) r2[t3] = g2 * o2[h2 + t3] + v2 * o2[l2 + t3] + _2 * o2[a2 + t3] + y2 * o2[u2 + t3];
          return r2;
        }
      }
      class bs extends ys {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2);
        }
        interpolate_(t2, e2, i2, n2) {
          const r2 = this.resultBuffer, o2 = this.sampleValues, s2 = this.valueSize, a2 = t2 * s2, l2 = a2 - s2, h2 = (i2 - e2) / (n2 - e2), u2 = 1 - h2;
          for (let t3 = 0; t3 !== s2; ++t3) r2[t3] = o2[l2 + t3] * u2 + o2[a2 + t3] * h2;
          return r2;
        }
      }
      class Ts extends ys {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2);
        }
        interpolate_(t2) {
          return this.copySampleValue_(t2 - 1);
        }
      }
      class Es {
        constructor(t2, e2, i2, n2) {
          if (void 0 === t2) throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e2 || 0 === e2.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t2);
          this.name = t2, this.times = _s.convertArray(e2, this.TimeBufferType), this.values = _s.convertArray(i2, this.ValueBufferType), this.setInterpolation(n2 || this.DefaultInterpolation);
        }
        static toJSON(t2) {
          const e2 = t2.constructor;
          let i2;
          if (e2.toJSON !== this.toJSON) i2 = e2.toJSON(t2);
          else {
            i2 = { name: t2.name, times: _s.convertArray(t2.times, Array), values: _s.convertArray(t2.values, Array) };
            const e3 = t2.getInterpolation();
            e3 !== t2.DefaultInterpolation && (i2.interpolation = e3);
          }
          return i2.type = t2.ValueTypeName, i2;
        }
        InterpolantFactoryMethodDiscrete(t2) {
          return new Ts(this.times, this.values, this.getValueSize(), t2);
        }
        InterpolantFactoryMethodLinear(t2) {
          return new bs(this.times, this.values, this.getValueSize(), t2);
        }
        InterpolantFactoryMethodSmooth(t2) {
          return new xs(this.times, this.values, this.getValueSize(), t2);
        }
        setInterpolation(t2) {
          let e2;
          switch (t2) {
            case 2300:
              e2 = this.InterpolantFactoryMethodDiscrete;
              break;
            case 2301:
              e2 = this.InterpolantFactoryMethodLinear;
              break;
            case 2302:
              e2 = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e2) {
            const e3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
              if (t2 === this.DefaultInterpolation) throw new Error(e3);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e3), this;
          }
          return this.createInterpolant = e2, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return 2300;
            case this.InterpolantFactoryMethodLinear:
              return 2301;
            case this.InterpolantFactoryMethodSmooth:
              return 2302;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t2) {
          if (0 !== t2) {
            const e2 = this.times;
            for (let i2 = 0, n2 = e2.length; i2 !== n2; ++i2) e2[i2] += t2;
          }
          return this;
        }
        scale(t2) {
          if (1 !== t2) {
            const e2 = this.times;
            for (let i2 = 0, n2 = e2.length; i2 !== n2; ++i2) e2[i2] *= t2;
          }
          return this;
        }
        trim(t2, e2) {
          const i2 = this.times, n2 = i2.length;
          let r2 = 0, o2 = n2 - 1;
          for (; r2 !== n2 && i2[r2] < t2; ) ++r2;
          for (; -1 !== o2 && i2[o2] > e2; ) --o2;
          if (++o2, 0 !== r2 || o2 !== n2) {
            r2 >= o2 && (o2 = Math.max(o2, 1), r2 = o2 - 1);
            const t3 = this.getValueSize();
            this.times = _s.arraySlice(i2, r2, o2), this.values = _s.arraySlice(this.values, r2 * t3, o2 * t3);
          }
          return this;
        }
        validate() {
          let t2 = true;
          const e2 = this.getValueSize();
          e2 - Math.floor(e2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t2 = false);
          const i2 = this.times, n2 = this.values, r2 = i2.length;
          0 === r2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t2 = false);
          let o2 = null;
          for (let e3 = 0; e3 !== r2; e3++) {
            const n3 = i2[e3];
            if ("number" == typeof n3 && isNaN(n3)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e3, n3), t2 = false;
              break;
            }
            if (null !== o2 && o2 > n3) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, e3, n3, o2), t2 = false;
              break;
            }
            o2 = n3;
          }
          if (void 0 !== n2 && _s.isTypedArray(n2)) for (let e3 = 0, i3 = n2.length; e3 !== i3; ++e3) {
            const i4 = n2[e3];
            if (isNaN(i4)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e3, i4), t2 = false;
              break;
            }
          }
          return t2;
        }
        optimize() {
          const t2 = _s.arraySlice(this.times), e2 = _s.arraySlice(this.values), i2 = this.getValueSize(), n2 = 2302 === this.getInterpolation(), r2 = t2.length - 1;
          let o2 = 1;
          for (let s2 = 1; s2 < r2; ++s2) {
            let r3 = false;
            const a2 = t2[s2];
            if (a2 !== t2[s2 + 1] && (1 !== s2 || a2 !== t2[0])) if (n2) r3 = true;
            else {
              const t3 = s2 * i2, n3 = t3 - i2, o3 = t3 + i2;
              for (let s3 = 0; s3 !== i2; ++s3) {
                const i3 = e2[t3 + s3];
                if (i3 !== e2[n3 + s3] || i3 !== e2[o3 + s3]) {
                  r3 = true;
                  break;
                }
              }
            }
            if (r3) {
              if (s2 !== o2) {
                t2[o2] = t2[s2];
                const n3 = s2 * i2, r4 = o2 * i2;
                for (let t3 = 0; t3 !== i2; ++t3) e2[r4 + t3] = e2[n3 + t3];
              }
              ++o2;
            }
          }
          if (r2 > 0) {
            t2[o2] = t2[r2];
            for (let t3 = r2 * i2, n3 = o2 * i2, s2 = 0; s2 !== i2; ++s2) e2[n3 + s2] = e2[t3 + s2];
            ++o2;
          }
          return o2 !== t2.length ? (this.times = _s.arraySlice(t2, 0, o2), this.values = _s.arraySlice(e2, 0, o2 * i2)) : (this.times = t2, this.values = e2), this;
        }
        clone() {
          const t2 = _s.arraySlice(this.times, 0), e2 = _s.arraySlice(this.values, 0), i2 = new (0, this.constructor)(this.name, t2, e2);
          return i2.createInterpolant = this.createInterpolant, i2;
        }
      }
      Es.prototype.TimeBufferType = Float32Array, Es.prototype.ValueBufferType = Float32Array, Es.prototype.DefaultInterpolation = 2301;
      class Ss extends Es {
      }
      Ss.prototype.ValueTypeName = "bool", Ss.prototype.ValueBufferType = Array, Ss.prototype.DefaultInterpolation = 2300, Ss.prototype.InterpolantFactoryMethodLinear = void 0, Ss.prototype.InterpolantFactoryMethodSmooth = void 0;
      class ws extends Es {
      }
      ws.prototype.ValueTypeName = "color";
      class As extends Es {
      }
      As.prototype.ValueTypeName = "number";
      class Ms extends ys {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2, n2);
        }
        interpolate_(t2, e2, i2, n2) {
          const r2 = this.resultBuffer, o2 = this.sampleValues, s2 = this.valueSize, a2 = (i2 - e2) / (n2 - e2);
          let l2 = t2 * s2;
          for (let t3 = l2 + s2; l2 !== t3; l2 += 4) A.slerpFlat(r2, 0, o2, l2 - s2, o2, l2, a2);
          return r2;
        }
      }
      class Cs extends Es {
        InterpolantFactoryMethodLinear(t2) {
          return new Ms(this.times, this.values, this.getValueSize(), t2);
        }
      }
      Cs.prototype.ValueTypeName = "quaternion", Cs.prototype.DefaultInterpolation = 2301, Cs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Rs extends Es {
      }
      Rs.prototype.ValueTypeName = "string", Rs.prototype.ValueBufferType = Array, Rs.prototype.DefaultInterpolation = 2300, Rs.prototype.InterpolantFactoryMethodLinear = void 0, Rs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class Is extends Es {
      }
      Is.prototype.ValueTypeName = "vector";
      class Ps {
        constructor(t2, e2 = -1, i2, n2 = 2500) {
          this.name = t2, this.tracks = i2, this.duration = e2, this.blendMode = n2, this.uuid = u(), this.duration < 0 && this.resetDuration();
        }
        static parse(t2) {
          const e2 = [], i2 = t2.tracks, n2 = 1 / (t2.fps || 1);
          for (let t3 = 0, r3 = i2.length; t3 !== r3; ++t3) e2.push(Os(i2[t3]).scale(n2));
          const r2 = new this(t2.name, t2.duration, e2, t2.blendMode);
          return r2.uuid = t2.uuid, r2;
        }
        static toJSON(t2) {
          const e2 = [], i2 = t2.tracks, n2 = { name: t2.name, duration: t2.duration, tracks: e2, uuid: t2.uuid, blendMode: t2.blendMode };
          for (let t3 = 0, n3 = i2.length; t3 !== n3; ++t3) e2.push(Es.toJSON(i2[t3]));
          return n2;
        }
        static CreateFromMorphTargetSequence(t2, e2, i2, n2) {
          const r2 = e2.length, o2 = [];
          for (let t3 = 0; t3 < r2; t3++) {
            let s2 = [], a2 = [];
            s2.push((t3 + r2 - 1) % r2, t3, (t3 + 1) % r2), a2.push(0, 1, 0);
            const l2 = _s.getKeyframeOrder(s2);
            s2 = _s.sortedArray(s2, 1, l2), a2 = _s.sortedArray(a2, 1, l2), n2 || 0 !== s2[0] || (s2.push(r2), a2.push(a2[0])), o2.push(new As(".morphTargetInfluences[" + e2[t3].name + "]", s2, a2).scale(1 / i2));
          }
          return new this(t2, -1, o2);
        }
        static findByName(t2, e2) {
          let i2 = t2;
          if (!Array.isArray(t2)) {
            const e3 = t2;
            i2 = e3.geometry && e3.geometry.animations || e3.animations;
          }
          for (let t3 = 0; t3 < i2.length; t3++) if (i2[t3].name === e2) return i2[t3];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(t2, e2, i2) {
          const n2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
          for (let e3 = 0, i3 = t2.length; e3 < i3; e3++) {
            const i4 = t2[e3], o3 = i4.name.match(r2);
            if (o3 && o3.length > 1) {
              const t3 = o3[1];
              let e4 = n2[t3];
              e4 || (n2[t3] = e4 = []), e4.push(i4);
            }
          }
          const o2 = [];
          for (const t3 in n2) o2.push(this.CreateFromMorphTargetSequence(t3, n2[t3], e2, i2));
          return o2;
        }
        static parseAnimation(t2, e2) {
          if (!t2) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const i2 = function(t3, e3, i3, n3, r3) {
            if (0 !== i3.length) {
              const o3 = [], s3 = [];
              _s.flattenJSON(i3, o3, s3, n3), 0 !== o3.length && r3.push(new t3(e3, o3, s3));
            }
          }, n2 = [], r2 = t2.name || "default", o2 = t2.fps || 30, s2 = t2.blendMode;
          let a2 = t2.length || -1;
          const l2 = t2.hierarchy || [];
          for (let t3 = 0; t3 < l2.length; t3++) {
            const r3 = l2[t3].keys;
            if (r3 && 0 !== r3.length) if (r3[0].morphTargets) {
              const t4 = {};
              let e3;
              for (e3 = 0; e3 < r3.length; e3++) if (r3[e3].morphTargets) for (let i3 = 0; i3 < r3[e3].morphTargets.length; i3++) t4[r3[e3].morphTargets[i3]] = -1;
              for (const i3 in t4) {
                const t5 = [], o3 = [];
                for (let n3 = 0; n3 !== r3[e3].morphTargets.length; ++n3) {
                  const n4 = r3[e3];
                  t5.push(n4.time), o3.push(n4.morphTarget === i3 ? 1 : 0);
                }
                n2.push(new As(".morphTargetInfluence[" + i3 + "]", t5, o3));
              }
              a2 = t4.length * (o2 || 1);
            } else {
              const o3 = ".bones[" + e2[t3].name + "]";
              i2(Is, o3 + ".position", r3, "pos", n2), i2(Cs, o3 + ".quaternion", r3, "rot", n2), i2(Is, o3 + ".scale", r3, "scl", n2);
            }
          }
          if (0 === n2.length) return null;
          return new this(r2, a2, n2, s2);
        }
        resetDuration() {
          let t2 = 0;
          for (let e2 = 0, i2 = this.tracks.length; e2 !== i2; ++e2) {
            const i3 = this.tracks[e2];
            t2 = Math.max(t2, i3.times[i3.times.length - 1]);
          }
          return this.duration = t2, this;
        }
        trim() {
          for (let t2 = 0; t2 < this.tracks.length; t2++) this.tracks[t2].trim(0, this.duration);
          return this;
        }
        validate() {
          let t2 = true;
          for (let e2 = 0; e2 < this.tracks.length; e2++) t2 = t2 && this.tracks[e2].validate();
          return t2;
        }
        optimize() {
          for (let t2 = 0; t2 < this.tracks.length; t2++) this.tracks[t2].optimize();
          return this;
        }
        clone() {
          const t2 = [];
          for (let e2 = 0; e2 < this.tracks.length; e2++) t2.push(this.tracks[e2].clone());
          return new this.constructor(this.name, this.duration, t2, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Os(t2) {
        if (void 0 === t2.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e2 = function(t3) {
          switch (t3.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return As;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Is;
            case "color":
              return ws;
            case "quaternion":
              return Cs;
            case "bool":
            case "boolean":
              return Ss;
            case "string":
              return Rs;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t3);
        }(t2.type);
        if (void 0 === t2.times) {
          const e3 = [], i2 = [];
          _s.flattenJSON(t2.keys, e3, i2, "value"), t2.times = e3, t2.values = i2;
        }
        return void 0 !== e2.parse ? e2.parse(t2) : new e2(t2.name, t2.times, t2.values, t2.interpolation);
      }
      const Ns = { enabled: false, files: {}, add: function(t2, e2) {
        false !== this.enabled && (this.files[t2] = e2);
      }, get: function(t2) {
        if (false !== this.enabled) return this.files[t2];
      }, remove: function(t2) {
        delete this.files[t2];
      }, clear: function() {
        this.files = {};
      } };
      class Ls {
        constructor(t2, e2, i2) {
          const n2 = this;
          let r2 = false, o2 = 0, s2 = 0, a2 = void 0;
          const l2 = [];
          this.onStart = void 0, this.onLoad = t2, this.onProgress = e2, this.onError = i2, this.itemStart = function(t3) {
            s2++, false === r2 && void 0 !== n2.onStart && n2.onStart(t3, o2, s2), r2 = true;
          }, this.itemEnd = function(t3) {
            o2++, void 0 !== n2.onProgress && n2.onProgress(t3, o2, s2), o2 === s2 && (r2 = false, void 0 !== n2.onLoad && n2.onLoad());
          }, this.itemError = function(t3) {
            void 0 !== n2.onError && n2.onError(t3);
          }, this.resolveURL = function(t3) {
            return a2 ? a2(t3) : t3;
          }, this.setURLModifier = function(t3) {
            return a2 = t3, this;
          }, this.addHandler = function(t3, e3) {
            return l2.push(t3, e3), this;
          }, this.removeHandler = function(t3) {
            const e3 = l2.indexOf(t3);
            return -1 !== e3 && l2.splice(e3, 2), this;
          }, this.getHandler = function(t3) {
            for (let e3 = 0, i3 = l2.length; e3 < i3; e3 += 2) {
              const i4 = l2[e3], n3 = l2[e3 + 1];
              if (i4.global && (i4.lastIndex = 0), i4.test(t3)) return n3;
            }
            return null;
          };
        }
      }
      const Ds = new Ls();
      class Fs {
        constructor(t2) {
          this.manager = void 0 !== t2 ? t2 : Ds, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {
        }
        loadAsync(t2, e2) {
          const i2 = this;
          return new Promise(function(n2, r2) {
            i2.load(t2, n2, e2, r2);
          });
        }
        parse() {
        }
        setCrossOrigin(t2) {
          return this.crossOrigin = t2, this;
        }
        setWithCredentials(t2) {
          return this.withCredentials = t2, this;
        }
        setPath(t2) {
          return this.path = t2, this;
        }
        setResourcePath(t2) {
          return this.resourcePath = t2, this;
        }
        setRequestHeader(t2) {
          return this.requestHeader = t2, this;
        }
      }
      const Bs = {};
      class Us extends Fs {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, i2, n2) {
          void 0 === t2 && (t2 = ""), void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
          const r2 = this, o2 = Ns.get(t2);
          if (void 0 !== o2) return r2.manager.itemStart(t2), setTimeout(function() {
            e2 && e2(o2), r2.manager.itemEnd(t2);
          }, 0), o2;
          if (void 0 !== Bs[t2]) return void Bs[t2].push({ onLoad: e2, onProgress: i2, onError: n2 });
          const s2 = t2.match(/^data:(.*?)(;base64)?,(.*)$/);
          let a2;
          if (s2) {
            const i3 = s2[1], o3 = !!s2[2];
            let a3 = s2[3];
            a3 = decodeURIComponent(a3), o3 && (a3 = atob(a3));
            try {
              let n3;
              const o4 = (this.responseType || "").toLowerCase();
              switch (o4) {
                case "arraybuffer":
                case "blob":
                  const t3 = new Uint8Array(a3.length);
                  for (let e4 = 0; e4 < a3.length; e4++) t3[e4] = a3.charCodeAt(e4);
                  n3 = "blob" === o4 ? new Blob([t3.buffer], { type: i3 }) : t3.buffer;
                  break;
                case "document":
                  const e3 = new DOMParser();
                  n3 = e3.parseFromString(a3, i3);
                  break;
                case "json":
                  n3 = JSON.parse(a3);
                  break;
                default:
                  n3 = a3;
              }
              setTimeout(function() {
                e2 && e2(n3), r2.manager.itemEnd(t2);
              }, 0);
            } catch (e3) {
              setTimeout(function() {
                n2 && n2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
              }, 0);
            }
          } else {
            Bs[t2] = [], Bs[t2].push({ onLoad: e2, onProgress: i2, onError: n2 }), a2 = new XMLHttpRequest(), a2.open("GET", t2, true), a2.addEventListener("load", function(e3) {
              const i3 = this.response, n3 = Bs[t2];
              if (delete Bs[t2], 200 === this.status || 0 === this.status) {
                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Ns.add(t2, i3);
                for (let t3 = 0, e4 = n3.length; t3 < e4; t3++) {
                  const e5 = n3[t3];
                  e5.onLoad && e5.onLoad(i3);
                }
                r2.manager.itemEnd(t2);
              } else {
                for (let t3 = 0, i4 = n3.length; t3 < i4; t3++) {
                  const i5 = n3[t3];
                  i5.onError && i5.onError(e3);
                }
                r2.manager.itemError(t2), r2.manager.itemEnd(t2);
              }
            }, false), a2.addEventListener("progress", function(e3) {
              const i3 = Bs[t2];
              for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
                const n4 = i3[t3];
                n4.onProgress && n4.onProgress(e3);
              }
            }, false), a2.addEventListener("error", function(e3) {
              const i3 = Bs[t2];
              delete Bs[t2];
              for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
                const n4 = i3[t3];
                n4.onError && n4.onError(e3);
              }
              r2.manager.itemError(t2), r2.manager.itemEnd(t2);
            }, false), a2.addEventListener("abort", function(e3) {
              const i3 = Bs[t2];
              delete Bs[t2];
              for (let t3 = 0, n3 = i3.length; t3 < n3; t3++) {
                const n4 = i3[t3];
                n4.onError && n4.onError(e3);
              }
              r2.manager.itemError(t2), r2.manager.itemEnd(t2);
            }, false), void 0 !== this.responseType && (a2.responseType = this.responseType), void 0 !== this.withCredentials && (a2.withCredentials = this.withCredentials), a2.overrideMimeType && a2.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
            for (const t3 in this.requestHeader) a2.setRequestHeader(t3, this.requestHeader[t3]);
            a2.send(null);
          }
          return r2.manager.itemStart(t2), a2;
        }
        setResponseType(t2) {
          return this.responseType = t2, this;
        }
        setMimeType(t2) {
          return this.mimeType = t2, this;
        }
      }
      class ks extends Fs {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, i2, n2) {
          void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
          const r2 = this, o2 = Ns.get(t2);
          if (void 0 !== o2) return r2.manager.itemStart(t2), setTimeout(function() {
            e2 && e2(o2), r2.manager.itemEnd(t2);
          }, 0), o2;
          const s2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
          function a2() {
            s2.removeEventListener("load", a2, false), s2.removeEventListener("error", l2, false), Ns.add(t2, this), e2 && e2(this), r2.manager.itemEnd(t2);
          }
          function l2(e3) {
            s2.removeEventListener("load", a2, false), s2.removeEventListener("error", l2, false), n2 && n2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
          }
          return s2.addEventListener("load", a2, false), s2.addEventListener("error", l2, false), "data:" !== t2.substr(0, 5) && void 0 !== this.crossOrigin && (s2.crossOrigin = this.crossOrigin), r2.manager.itemStart(t2), s2.src = t2, s2;
        }
      }
      class Gs extends Fs {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, i2, n2) {
          const r2 = new Ge(), o2 = new ks(this.manager);
          o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path);
          let s2 = 0;
          function a2(i3) {
            o2.load(t2[i3], function(t3) {
              r2.images[i3] = t3, s2++, 6 === s2 && (r2.needsUpdate = true, e2 && e2(r2));
            }, void 0, n2);
          }
          for (let e3 = 0; e3 < t2.length; ++e3) a2(e3);
          return r2;
        }
      }
      class Hs extends Fs {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, i2, n2) {
          const r2 = new b(), o2 = new ks(this.manager);
          return o2.setCrossOrigin(this.crossOrigin), o2.setPath(this.path), o2.load(t2, function(i3) {
            r2.image = i3;
            const n3 = t2.search(/\.jpe?g($|\?)/i) > 0 || 0 === t2.search(/^data\:image\/jpeg/);
            r2.format = n3 ? 1022 : 1023, r2.needsUpdate = true, void 0 !== e2 && e2(r2);
          }, i2, n2), r2;
        }
      }
      class js extends co {
        constructor() {
          super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
        }
        add(t2) {
          this.curves.push(t2);
        }
        closePath() {
          const t2 = this.curves[0].getPoint(0), e2 = this.curves[this.curves.length - 1].getPoint(1);
          t2.equals(e2) || this.curves.push(new Ao(e2, t2));
        }
        getPoint(t2) {
          const e2 = t2 * this.getLength(), i2 = this.getCurveLengths();
          let n2 = 0;
          for (; n2 < i2.length; ) {
            if (i2[n2] >= e2) {
              const t3 = i2[n2] - e2, r2 = this.curves[n2], o2 = r2.getLength(), s2 = 0 === o2 ? 0 : 1 - t3 / o2;
              return r2.getPointAt(s2);
            }
            n2++;
          }
          return null;
        }
        getLength() {
          const t2 = this.getCurveLengths();
          return t2[t2.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
          const t2 = [];
          let e2 = 0;
          for (let i2 = 0, n2 = this.curves.length; i2 < n2; i2++) e2 += this.curves[i2].getLength(), t2.push(e2);
          return this.cacheLengths = t2, t2;
        }
        getSpacedPoints(t2 = 40) {
          const e2 = [];
          for (let i2 = 0; i2 <= t2; i2++) e2.push(this.getPoint(i2 / t2));
          return this.autoClose && e2.push(e2[0]), e2;
        }
        getPoints(t2 = 12) {
          const e2 = [];
          let i2;
          for (let n2 = 0, r2 = this.curves; n2 < r2.length; n2++) {
            const o2 = r2[n2], s2 = o2 && o2.isEllipseCurve ? 2 * t2 : o2 && (o2.isLineCurve || o2.isLineCurve3) ? 1 : o2 && o2.isSplineCurve ? t2 * o2.points.length : t2, a2 = o2.getPoints(s2);
            for (let t3 = 0; t3 < a2.length; t3++) {
              const n3 = a2[t3];
              i2 && i2.equals(n3) || (e2.push(n3), i2 = n3);
            }
          }
          return this.autoClose && e2.length > 1 && !e2[e2.length - 1].equals(e2[0]) && e2.push(e2[0]), e2;
        }
        copy(t2) {
          super.copy(t2), this.curves = [];
          for (let e2 = 0, i2 = t2.curves.length; e2 < i2; e2++) {
            const i3 = t2.curves[e2];
            this.curves.push(i3.clone());
          }
          return this.autoClose = t2.autoClose, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.autoClose = this.autoClose, t2.curves = [];
          for (let e2 = 0, i2 = this.curves.length; e2 < i2; e2++) {
            const i3 = this.curves[e2];
            t2.curves.push(i3.toJSON());
          }
          return t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.autoClose = t2.autoClose, this.curves = [];
          for (let e2 = 0, i2 = t2.curves.length; e2 < i2; e2++) {
            const i3 = t2.curves[e2];
            this.curves.push(new Io[i3.type]().fromJSON(i3));
          }
          return this;
        }
      }
      class zs extends js {
        constructor(t2) {
          super(), this.type = "Path", this.currentPoint = new g(), t2 && this.setFromPoints(t2);
        }
        setFromPoints(t2) {
          this.moveTo(t2[0].x, t2[0].y);
          for (let e2 = 1, i2 = t2.length; e2 < i2; e2++) this.lineTo(t2[e2].x, t2[e2].y);
          return this;
        }
        moveTo(t2, e2) {
          return this.currentPoint.set(t2, e2), this;
        }
        lineTo(t2, e2) {
          const i2 = new Ao(this.currentPoint.clone(), new g(t2, e2));
          return this.curves.push(i2), this.currentPoint.set(t2, e2), this;
        }
        quadraticCurveTo(t2, e2, i2, n2) {
          const r2 = new Mo(this.currentPoint.clone(), new g(t2, e2), new g(i2, n2));
          return this.curves.push(r2), this.currentPoint.set(i2, n2), this;
        }
        bezierCurveTo(t2, e2, i2, n2, r2, o2) {
          const s2 = new So(this.currentPoint.clone(), new g(t2, e2), new g(i2, n2), new g(r2, o2));
          return this.curves.push(s2), this.currentPoint.set(r2, o2), this;
        }
        splineThru(t2) {
          const e2 = [this.currentPoint.clone()].concat(t2), i2 = new Ro(e2);
          return this.curves.push(i2), this.currentPoint.copy(t2[t2.length - 1]), this;
        }
        arc(t2, e2, i2, n2, r2, o2) {
          const s2 = this.currentPoint.x, a2 = this.currentPoint.y;
          return this.absarc(t2 + s2, e2 + a2, i2, n2, r2, o2), this;
        }
        absarc(t2, e2, i2, n2, r2, o2) {
          return this.absellipse(t2, e2, i2, i2, n2, r2, o2), this;
        }
        ellipse(t2, e2, i2, n2, r2, o2, s2, a2) {
          const l2 = this.currentPoint.x, h2 = this.currentPoint.y;
          return this.absellipse(t2 + l2, e2 + h2, i2, n2, r2, o2, s2, a2), this;
        }
        absellipse(t2, e2, i2, n2, r2, o2, s2, a2) {
          const l2 = new po(t2, e2, i2, n2, r2, o2, s2, a2);
          if (this.curves.length > 0) {
            const t3 = l2.getPoint(0);
            t3.equals(this.currentPoint) || this.lineTo(t3.x, t3.y);
          }
          this.curves.push(l2);
          const h2 = l2.getPoint(1);
          return this.currentPoint.copy(h2), this;
        }
        copy(t2) {
          return super.copy(t2), this.currentPoint.copy(t2.currentPoint), this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.currentPoint = this.currentPoint.toArray(), t2;
        }
        fromJSON(t2) {
          return super.fromJSON(t2), this.currentPoint.fromArray(t2.currentPoint), this;
        }
      }
      class Vs extends zs {
        constructor(t2) {
          super(t2), this.uuid = u(), this.type = "Shape", this.holes = [];
        }
        getPointsHoles(t2) {
          const e2 = [];
          for (let i2 = 0, n2 = this.holes.length; i2 < n2; i2++) e2[i2] = this.holes[i2].getPoints(t2);
          return e2;
        }
        extractPoints(t2) {
          return { shape: this.getPoints(t2), holes: this.getPointsHoles(t2) };
        }
        copy(t2) {
          super.copy(t2), this.holes = [];
          for (let e2 = 0, i2 = t2.holes.length; e2 < i2; e2++) {
            const i3 = t2.holes[e2];
            this.holes.push(i3.clone());
          }
          return this;
        }
        toJSON() {
          const t2 = super.toJSON();
          t2.uuid = this.uuid, t2.holes = [];
          for (let e2 = 0, i2 = this.holes.length; e2 < i2; e2++) {
            const i3 = this.holes[e2];
            t2.holes.push(i3.toJSON());
          }
          return t2;
        }
        fromJSON(t2) {
          super.fromJSON(t2), this.uuid = t2.uuid, this.holes = [];
          for (let e2 = 0, i2 = t2.holes.length; e2 < i2; e2++) {
            const i3 = t2.holes[e2];
            this.holes.push(new zs().fromJSON(i3));
          }
          return this;
        }
      }
      class Xs extends Rt {
        constructor(t2, e2 = 1) {
          super(), this.type = "Light", this.color = new Zt(t2), this.intensity = e2;
        }
        dispose() {
        }
        copy(t2) {
          return super.copy(t2), this.color.copy(t2.color), this.intensity = t2.intensity, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.color = this.color.getHex(), e2.object.intensity = this.intensity, void 0 !== this.groundColor && (e2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e2.object.distance = this.distance), void 0 !== this.angle && (e2.object.angle = this.angle), void 0 !== this.decay && (e2.object.decay = this.decay), void 0 !== this.penumbra && (e2.object.penumbra = this.penumbra), void 0 !== this.shadow && (e2.object.shadow = this.shadow.toJSON()), e2;
        }
      }
      Xs.prototype.isLight = true;
      class Ws extends Xs {
        constructor(t2, e2, i2) {
          super(t2, i2), this.type = "HemisphereLight", this.position.copy(Rt.DefaultUp), this.updateMatrix(), this.groundColor = new Zt(e2);
        }
        copy(t2) {
          return Xs.prototype.copy.call(this, t2), this.groundColor.copy(t2.groundColor), this;
        }
      }
      Ws.prototype.isHemisphereLight = true;
      const Ys = new rt(), qs = new M(), Zs = new M();
      class Js {
        constructor(t2) {
          this.camera = t2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new g(512, 512), this.map = null, this.mapPass = null, this.matrix = new rt(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new qe(), this._frameExtents = new g(1, 1), this._viewportCount = 1, this._viewports = [new E(0, 0, 1, 1)];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(t2) {
          const e2 = this.camera, i2 = this.matrix;
          qs.setFromMatrixPosition(t2.matrixWorld), e2.position.copy(qs), Zs.setFromMatrixPosition(t2.target.matrixWorld), e2.lookAt(Zs), e2.updateMatrixWorld(), Ys.multiplyMatrices(e2.projectionMatrix, e2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ys), i2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i2.multiply(e2.projectionMatrix), i2.multiply(e2.matrixWorldInverse);
        }
        getViewport(t2) {
          return this._viewports[t2];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(t2) {
          return this.camera = t2.camera.clone(), this.bias = t2.bias, this.radius = t2.radius, this.mapSize.copy(t2.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t2 = {};
          return 0 !== this.bias && (t2.bias = this.bias), 0 !== this.normalBias && (t2.normalBias = this.normalBias), 1 !== this.radius && (t2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t2.mapSize = this.mapSize.toArray()), t2.camera = this.camera.toJSON(false).object, delete t2.camera.matrix, t2;
        }
      }
      class Ks extends Js {
        constructor() {
          super(new Ue(50, 1, 0.5, 500)), this.focus = 1;
        }
        updateMatrices(t2) {
          const e2 = this.camera, i2 = 2 * h * t2.angle * this.focus, n2 = this.mapSize.width / this.mapSize.height, r2 = t2.distance || e2.far;
          i2 === e2.fov && n2 === e2.aspect && r2 === e2.far || (e2.fov = i2, e2.aspect = n2, e2.far = r2, e2.updateProjectionMatrix()), super.updateMatrices(t2);
        }
        copy(t2) {
          return super.copy(t2), this.focus = t2.focus, this;
        }
      }
      Ks.prototype.isSpotLightShadow = true;
      class Qs extends Xs {
        constructor(t2, e2, i2 = 0, n2 = Math.PI / 3, r2 = 0, o2 = 1) {
          super(t2, e2), this.type = "SpotLight", this.position.copy(Rt.DefaultUp), this.updateMatrix(), this.target = new Rt(), this.distance = i2, this.angle = n2, this.penumbra = r2, this.decay = o2, this.shadow = new Ks();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(t2) {
          this.intensity = t2 / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t2) {
          return super.copy(t2), this.distance = t2.distance, this.angle = t2.angle, this.penumbra = t2.penumbra, this.decay = t2.decay, this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
        }
      }
      Qs.prototype.isSpotLight = true;
      const $s = new rt(), ta = new M(), ea = new M();
      class ia extends Js {
        constructor() {
          super(new Ue(90, 1, 0.5, 500)), this._frameExtents = new g(4, 2), this._viewportCount = 6, this._viewports = [new E(2, 1, 1, 1), new E(0, 1, 1, 1), new E(3, 1, 1, 1), new E(1, 1, 1, 1), new E(3, 0, 1, 1), new E(1, 0, 1, 1)], this._cubeDirections = [new M(1, 0, 0), new M(-1, 0, 0), new M(0, 0, 1), new M(0, 0, -1), new M(0, 1, 0), new M(0, -1, 0)], this._cubeUps = [new M(0, 1, 0), new M(0, 1, 0), new M(0, 1, 0), new M(0, 1, 0), new M(0, 0, 1), new M(0, 0, -1)];
        }
        updateMatrices(t2, e2 = 0) {
          const i2 = this.camera, n2 = this.matrix, r2 = t2.distance || i2.far;
          r2 !== i2.far && (i2.far = r2, i2.updateProjectionMatrix()), ta.setFromMatrixPosition(t2.matrixWorld), i2.position.copy(ta), ea.copy(i2.position), ea.add(this._cubeDirections[e2]), i2.up.copy(this._cubeUps[e2]), i2.lookAt(ea), i2.updateMatrixWorld(), n2.makeTranslation(-ta.x, -ta.y, -ta.z), $s.multiplyMatrices(i2.projectionMatrix, i2.matrixWorldInverse), this._frustum.setFromProjectionMatrix($s);
        }
      }
      ia.prototype.isPointLightShadow = true;
      class na extends Xs {
        constructor(t2, e2, i2 = 0, n2 = 1) {
          super(t2, e2), this.type = "PointLight", this.distance = i2, this.decay = n2, this.shadow = new ia();
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(t2) {
          this.intensity = t2 / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t2) {
          return super.copy(t2), this.distance = t2.distance, this.decay = t2.decay, this.shadow = t2.shadow.clone(), this;
        }
      }
      na.prototype.isPointLight = true;
      class ra extends Be {
        constructor(t2 = -1, e2 = 1, i2 = 1, n2 = -1, r2 = 0.1, o2 = 2e3) {
          super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t2, this.right = e2, this.top = i2, this.bottom = n2, this.near = r2, this.far = o2, this.updateProjectionMatrix();
        }
        copy(t2, e2) {
          return super.copy(t2, e2), this.left = t2.left, this.right = t2.right, this.top = t2.top, this.bottom = t2.bottom, this.near = t2.near, this.far = t2.far, this.zoom = t2.zoom, this.view = null === t2.view ? null : Object.assign({}, t2.view), this;
        }
        setViewOffset(t2, e2, i2, n2, r2, o2) {
          null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t2, this.view.fullHeight = e2, this.view.offsetX = i2, this.view.offsetY = n2, this.view.width = r2, this.view.height = o2, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t2 = (this.right - this.left) / (2 * this.zoom), e2 = (this.top - this.bottom) / (2 * this.zoom), i2 = (this.right + this.left) / 2, n2 = (this.top + this.bottom) / 2;
          let r2 = i2 - t2, o2 = i2 + t2, s2 = n2 + e2, a2 = n2 - e2;
          if (null !== this.view && this.view.enabled) {
            const t3 = (this.right - this.left) / this.view.fullWidth / this.zoom, e3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r2 += t3 * this.view.offsetX, o2 = r2 + t3 * this.view.width, s2 -= e3 * this.view.offsetY, a2 = s2 - e3 * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r2, o2, s2, a2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.zoom = this.zoom, e2.object.left = this.left, e2.object.right = this.right, e2.object.top = this.top, e2.object.bottom = this.bottom, e2.object.near = this.near, e2.object.far = this.far, null !== this.view && (e2.object.view = Object.assign({}, this.view)), e2;
        }
      }
      ra.prototype.isOrthographicCamera = true;
      class oa extends Js {
        constructor() {
          super(new ra(-5, 5, 5, -5, 0.5, 500));
        }
      }
      oa.prototype.isDirectionalLightShadow = true;
      class sa extends Xs {
        constructor(t2, e2) {
          super(t2, e2), this.type = "DirectionalLight", this.position.copy(Rt.DefaultUp), this.updateMatrix(), this.target = new Rt(), this.shadow = new oa();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(t2) {
          return super.copy(t2), this.target = t2.target.clone(), this.shadow = t2.shadow.clone(), this;
        }
      }
      sa.prototype.isDirectionalLight = true;
      class aa extends Xs {
        constructor(t2, e2) {
          super(t2, e2), this.type = "AmbientLight";
        }
      }
      aa.prototype.isAmbientLight = true;
      class la extends Xs {
        constructor(t2, e2, i2 = 10, n2 = 10) {
          super(t2, e2), this.type = "RectAreaLight", this.width = i2, this.height = n2;
        }
        copy(t2) {
          return super.copy(t2), this.width = t2.width, this.height = t2.height, this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.width = this.width, e2.object.height = this.height, e2;
        }
      }
      la.prototype.isRectAreaLight = true;
      class ha {
        constructor() {
          this.coefficients = [];
          for (let t2 = 0; t2 < 9; t2++) this.coefficients.push(new M());
        }
        set(t2) {
          for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].copy(t2[e2]);
          return this;
        }
        zero() {
          for (let t2 = 0; t2 < 9; t2++) this.coefficients[t2].set(0, 0, 0);
          return this;
        }
        getAt(t2, e2) {
          const i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = this.coefficients;
          return e2.copy(o2[0]).multiplyScalar(0.282095), e2.addScaledVector(o2[1], 0.488603 * n2), e2.addScaledVector(o2[2], 0.488603 * r2), e2.addScaledVector(o2[3], 0.488603 * i2), e2.addScaledVector(o2[4], i2 * n2 * 1.092548), e2.addScaledVector(o2[5], n2 * r2 * 1.092548), e2.addScaledVector(o2[6], 0.315392 * (3 * r2 * r2 - 1)), e2.addScaledVector(o2[7], i2 * r2 * 1.092548), e2.addScaledVector(o2[8], 0.546274 * (i2 * i2 - n2 * n2)), e2;
        }
        getIrradianceAt(t2, e2) {
          const i2 = t2.x, n2 = t2.y, r2 = t2.z, o2 = this.coefficients;
          return e2.copy(o2[0]).multiplyScalar(0.886227), e2.addScaledVector(o2[1], 1.023328 * n2), e2.addScaledVector(o2[2], 1.023328 * r2), e2.addScaledVector(o2[3], 1.023328 * i2), e2.addScaledVector(o2[4], 0.858086 * i2 * n2), e2.addScaledVector(o2[5], 0.858086 * n2 * r2), e2.addScaledVector(o2[6], 0.743125 * r2 * r2 - 0.247708), e2.addScaledVector(o2[7], 0.858086 * i2 * r2), e2.addScaledVector(o2[8], 0.429043 * (i2 * i2 - n2 * n2)), e2;
        }
        add(t2) {
          for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].add(t2.coefficients[e2]);
          return this;
        }
        addScaledSH(t2, e2) {
          for (let i2 = 0; i2 < 9; i2++) this.coefficients[i2].addScaledVector(t2.coefficients[i2], e2);
          return this;
        }
        scale(t2) {
          for (let e2 = 0; e2 < 9; e2++) this.coefficients[e2].multiplyScalar(t2);
          return this;
        }
        lerp(t2, e2) {
          for (let i2 = 0; i2 < 9; i2++) this.coefficients[i2].lerp(t2.coefficients[i2], e2);
          return this;
        }
        equals(t2) {
          for (let e2 = 0; e2 < 9; e2++) if (!this.coefficients[e2].equals(t2.coefficients[e2])) return false;
          return true;
        }
        copy(t2) {
          return this.set(t2.coefficients);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        fromArray(t2, e2 = 0) {
          const i2 = this.coefficients;
          for (let n2 = 0; n2 < 9; n2++) i2[n2].fromArray(t2, e2 + 3 * n2);
          return this;
        }
        toArray(t2 = [], e2 = 0) {
          const i2 = this.coefficients;
          for (let n2 = 0; n2 < 9; n2++) i2[n2].toArray(t2, e2 + 3 * n2);
          return t2;
        }
        static getBasisAt(t2, e2) {
          const i2 = t2.x, n2 = t2.y, r2 = t2.z;
          e2[0] = 0.282095, e2[1] = 0.488603 * n2, e2[2] = 0.488603 * r2, e2[3] = 0.488603 * i2, e2[4] = 1.092548 * i2 * n2, e2[5] = 1.092548 * n2 * r2, e2[6] = 0.315392 * (3 * r2 * r2 - 1), e2[7] = 1.092548 * i2 * r2, e2[8] = 0.546274 * (i2 * i2 - n2 * n2);
        }
      }
      ha.prototype.isSphericalHarmonics3 = true;
      class ua extends Xs {
        constructor(t2 = new ha(), e2 = 1) {
          super(void 0, e2), this.sh = t2;
        }
        copy(t2) {
          return super.copy(t2), this.sh.copy(t2.sh), this;
        }
        fromJSON(t2) {
          return this.intensity = t2.intensity, this.sh.fromArray(t2.sh), this;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.object.sh = this.sh.toArray(), e2;
        }
      }
      ua.prototype.isLightProbe = true;
      class ca {
        static decodeText(t2) {
          if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t2);
          let e2 = "";
          for (let i2 = 0, n2 = t2.length; i2 < n2; i2++) e2 += String.fromCharCode(t2[i2]);
          try {
            return decodeURIComponent(escape(e2));
          } catch (t3) {
            return e2;
          }
        }
        static extractUrlBase(t2) {
          const e2 = t2.lastIndexOf("/");
          return -1 === e2 ? "./" : t2.substr(0, e2 + 1);
        }
      }
      class da extends de {
        constructor() {
          super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(t2) {
          return super.copy(t2), this.instanceCount = t2.instanceCount, this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const t2 = super.toJSON(this);
          return t2.instanceCount = this.instanceCount, t2.isInstancedBufferGeometry = true, t2;
        }
      }
      da.prototype.isInstancedBufferGeometry = true;
      class pa extends $t {
        constructor(t2, e2, i2, n2 = 1) {
          "number" == typeof i2 && (n2 = i2, i2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t2, e2, i2), this.meshPerAttribute = n2;
        }
        copy(t2) {
          return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
        }
        toJSON() {
          const t2 = super.toJSON();
          return t2.meshPerAttribute = this.meshPerAttribute, t2.isInstancedBufferAttribute = true, t2;
        }
      }
      pa.prototype.isInstancedBufferAttribute = true;
      (class extends Fs {
        constructor(t2) {
          super(t2), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
        }
        setOptions(t2) {
          return this.options = t2, this;
        }
        load(t2, e2, i2, n2) {
          void 0 === t2 && (t2 = ""), void 0 !== this.path && (t2 = this.path + t2), t2 = this.manager.resolveURL(t2);
          const r2 = this, o2 = Ns.get(t2);
          if (void 0 !== o2) return r2.manager.itemStart(t2), setTimeout(function() {
            e2 && e2(o2), r2.manager.itemEnd(t2);
          }, 0), o2;
          const s2 = {};
          s2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s2.headers = this.requestHeader, fetch(t2, s2).then(function(t3) {
            return t3.blob();
          }).then(function(t3) {
            return createImageBitmap(t3, Object.assign(r2.options, { colorSpaceConversion: "none" }));
          }).then(function(i3) {
            Ns.add(t2, i3), e2 && e2(i3), r2.manager.itemEnd(t2);
          }).catch(function(e3) {
            n2 && n2(e3), r2.manager.itemError(t2), r2.manager.itemEnd(t2);
          }), r2.manager.itemStart(t2);
        }
      }).prototype.isImageBitmapLoader = true;
      class fa {
        constructor() {
          this.type = "ShapePath", this.color = new Zt(), this.subPaths = [], this.currentPath = null;
        }
        moveTo(t2, e2) {
          return this.currentPath = new zs(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t2, e2), this;
        }
        lineTo(t2, e2) {
          return this.currentPath.lineTo(t2, e2), this;
        }
        quadraticCurveTo(t2, e2, i2, n2) {
          return this.currentPath.quadraticCurveTo(t2, e2, i2, n2), this;
        }
        bezierCurveTo(t2, e2, i2, n2, r2, o2) {
          return this.currentPath.bezierCurveTo(t2, e2, i2, n2, r2, o2), this;
        }
        splineThru(t2) {
          return this.currentPath.splineThru(t2), this;
        }
        toShapes(t2, e2) {
          function i2(t3) {
            const e3 = [];
            for (let i3 = 0, n3 = t3.length; i3 < n3; i3++) {
              const n4 = t3[i3], r3 = new Vs();
              r3.curves = n4.curves, e3.push(r3);
            }
            return e3;
          }
          function n2(t3, e3) {
            const i3 = e3.length;
            let n3 = false;
            for (let r3 = i3 - 1, o3 = 0; o3 < i3; r3 = o3++) {
              let i4 = e3[r3], s3 = e3[o3], a3 = s3.x - i4.x, l3 = s3.y - i4.y;
              if (Math.abs(l3) > Number.EPSILON) {
                if (l3 < 0 && (i4 = e3[o3], a3 = -a3, s3 = e3[r3], l3 = -l3), t3.y < i4.y || t3.y > s3.y) continue;
                if (t3.y === i4.y) {
                  if (t3.x === i4.x) return true;
                } else {
                  const e4 = l3 * (t3.x - i4.x) - a3 * (t3.y - i4.y);
                  if (0 === e4) return true;
                  if (e4 < 0) continue;
                  n3 = !n3;
                }
              } else {
                if (t3.y !== i4.y) continue;
                if (s3.x <= t3.x && t3.x <= i4.x || i4.x <= t3.x && t3.x <= s3.x) return true;
              }
            }
            return n3;
          }
          const r2 = is.isClockWise, o2 = this.subPaths;
          if (0 === o2.length) return [];
          if (true === e2) return i2(o2);
          let s2, a2, l2;
          const h2 = [];
          if (1 === o2.length) return a2 = o2[0], l2 = new Vs(), l2.curves = a2.curves, h2.push(l2), h2;
          let u2 = !r2(o2[0].getPoints());
          u2 = t2 ? !u2 : u2;
          const c2 = [], d2 = [];
          let p2, f2, m2 = [], g2 = 0;
          d2[g2] = void 0, m2[g2] = [];
          for (let e3 = 0, i3 = o2.length; e3 < i3; e3++) a2 = o2[e3], p2 = a2.getPoints(), s2 = r2(p2), s2 = t2 ? !s2 : s2, s2 ? (!u2 && d2[g2] && g2++, d2[g2] = { s: new Vs(), p: p2 }, d2[g2].s.curves = a2.curves, u2 && g2++, m2[g2] = []) : m2[g2].push({ h: a2, p: p2[0] });
          if (!d2[0]) return i2(o2);
          if (d2.length > 1) {
            let t3 = false;
            const e3 = [];
            for (let t4 = 0, e4 = d2.length; t4 < e4; t4++) c2[t4] = [];
            for (let i3 = 0, r3 = d2.length; i3 < r3; i3++) {
              const r4 = m2[i3];
              for (let o3 = 0; o3 < r4.length; o3++) {
                const s3 = r4[o3];
                let a3 = true;
                for (let r5 = 0; r5 < d2.length; r5++) n2(s3.p, d2[r5].p) && (i3 !== r5 && e3.push({ froms: i3, tos: r5, hole: o3 }), a3 ? (a3 = false, c2[r5].push(s3)) : t3 = true);
                a3 && c2[i3].push(s3);
              }
            }
            e3.length > 0 && (t3 || (m2 = c2));
          }
          for (let t3 = 0, e3 = d2.length; t3 < e3; t3++) {
            l2 = d2[t3].s, h2.push(l2), f2 = m2[t3];
            for (let t4 = 0, e4 = f2.length; t4 < e4; t4++) l2.holes.push(f2[t4].h);
          }
          return h2;
        }
      }
      class ma {
        constructor(t2) {
          this.type = "Font", this.data = t2;
        }
        generateShapes(t2, e2 = 100) {
          const i2 = [], n2 = function(t3, e3, i3) {
            const n3 = Array.from(t3), r2 = e3 / i3.resolution, o2 = (i3.boundingBox.yMax - i3.boundingBox.yMin + i3.underlineThickness) * r2, s2 = [];
            let a2 = 0, l2 = 0;
            for (let t4 = 0; t4 < n3.length; t4++) {
              const e4 = n3[t4];
              if ("\n" === e4) a2 = 0, l2 -= o2;
              else {
                const t5 = ga(e4, r2, a2, l2, i3);
                a2 += t5.offsetX, s2.push(t5.path);
              }
            }
            return s2;
          }(t2, e2, this.data);
          for (let t3 = 0, e3 = n2.length; t3 < e3; t3++) Array.prototype.push.apply(i2, n2[t3].toShapes());
          return i2;
        }
      }
      function ga(t2, e2, i2, n2, r2) {
        const o2 = r2.glyphs[t2] || r2.glyphs["?"];
        if (!o2) return void console.error('THREE.Font: character "' + t2 + '" does not exists in font family ' + r2.familyName + ".");
        const s2 = new fa();
        let a2, l2, h2, u2, c2, d2, p2, f2;
        if (o2.o) {
          const t3 = o2._cachedOutline || (o2._cachedOutline = o2.o.split(" "));
          for (let r3 = 0, o3 = t3.length; r3 < o3; ) {
            switch (t3[r3++]) {
              case "m":
                a2 = t3[r3++] * e2 + i2, l2 = t3[r3++] * e2 + n2, s2.moveTo(a2, l2);
                break;
              case "l":
                a2 = t3[r3++] * e2 + i2, l2 = t3[r3++] * e2 + n2, s2.lineTo(a2, l2);
                break;
              case "q":
                h2 = t3[r3++] * e2 + i2, u2 = t3[r3++] * e2 + n2, c2 = t3[r3++] * e2 + i2, d2 = t3[r3++] * e2 + n2, s2.quadraticCurveTo(c2, d2, h2, u2);
                break;
              case "b":
                h2 = t3[r3++] * e2 + i2, u2 = t3[r3++] * e2 + n2, c2 = t3[r3++] * e2 + i2, d2 = t3[r3++] * e2 + n2, p2 = t3[r3++] * e2 + i2, f2 = t3[r3++] * e2 + n2, s2.bezierCurveTo(c2, d2, p2, f2, h2, u2);
            }
          }
        }
        return { offsetX: o2.ha * e2, path: s2 };
      }
      ma.prototype.isFont = true;
      let va;
      const _a = function() {
        return void 0 === va && (va = new (window.AudioContext || window.webkitAudioContext)()), va;
      };
      class ya extends Fs {
        constructor(t2) {
          super(t2);
        }
        load(t2, e2, i2, n2) {
          const r2 = this, o2 = new Us(this.manager);
          o2.setResponseType("arraybuffer"), o2.setPath(this.path), o2.setRequestHeader(this.requestHeader), o2.setWithCredentials(this.withCredentials), o2.load(t2, function(i3) {
            try {
              const t3 = i3.slice(0);
              _a().decodeAudioData(t3, function(t4) {
                e2(t4);
              });
            } catch (e3) {
              n2 ? n2(e3) : console.error(e3), r2.manager.itemError(t2);
            }
          }, i2, n2);
        }
      }
      (class extends ua {
        constructor(t2, e2, i2 = 1) {
          super(void 0, i2);
          const n2 = new Zt().set(t2), r2 = new Zt().set(e2), o2 = new M(n2.r, n2.g, n2.b), s2 = new M(r2.r, r2.g, r2.b), a2 = Math.sqrt(Math.PI), l2 = a2 * Math.sqrt(0.75);
          this.sh.coefficients[0].copy(o2).add(s2).multiplyScalar(a2), this.sh.coefficients[1].copy(o2).sub(s2).multiplyScalar(l2);
        }
      }).prototype.isHemisphereLightProbe = true;
      (class extends ua {
        constructor(t2, e2 = 1) {
          super(void 0, e2);
          const i2 = new Zt().set(t2);
          this.sh.coefficients[0].set(i2.r, i2.g, i2.b).multiplyScalar(2 * Math.sqrt(Math.PI));
        }
      }).prototype.isAmbientLightProbe = true;
      class xa extends Rt {
        constructor(t2) {
          super(), this.type = "Audio", this.listener = t2, this.context = t2.context, this.gain = this.context.createGain(), this.gain.connect(t2.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t2, this.connect(), this;
        }
        setMediaElementSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t2), this.connect(), this;
        }
        setMediaStreamSource(t2) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t2), this.connect(), this;
        }
        setBuffer(t2) {
          return this.buffer = t2, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(t2 = 0) {
          if (true === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
          if (false === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
          this._startedAt = this.context.currentTime + t2;
          const e2 = this.context.createBufferSource();
          return e2.buffer = this.buffer, e2.loop = this.loop, e2.loopStart = this.loopStart, e2.loopEnd = this.loopEnd, e2.onended = this.onEnded.bind(this), e2.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e2, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
          if (false !== this.hasPlaybackControl) return true === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, true === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        stop() {
          if (false !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++) this.filters[t2 - 1].connect(this.filters[t2]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this._connected = true, this;
        }
        disconnect() {
          if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let t2 = 1, e2 = this.filters.length; t2 < e2; t2++) this.filters[t2 - 1].disconnect(this.filters[t2]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
          } else this.source.disconnect(this.getOutput());
          return this._connected = false, this;
        }
        getFilters() {
          return this.filters;
        }
        setFilters(t2) {
          return t2 || (t2 = []), true === this._connected ? (this.disconnect(), this.filters = t2.slice(), this.connect()) : this.filters = t2.slice(), this;
        }
        setDetune(t2) {
          if (this.detune = t2, void 0 !== this.source.detune) return true === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(t2) {
          return this.setFilters(t2 ? [t2] : []);
        }
        setPlaybackRate(t2) {
          if (false !== this.hasPlaybackControl) return this.playbackRate = t2, true === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false;
        }
        getLoop() {
          return false === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
        }
        setLoop(t2) {
          if (false !== this.hasPlaybackControl) return this.loop = t2, true === this.isPlaying && (this.source.loop = this.loop), this;
          console.warn("THREE.Audio: this Audio has no playback control.");
        }
        setLoopStart(t2) {
          return this.loopStart = t2, this;
        }
        setLoopEnd(t2) {
          return this.loopEnd = t2, this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(t2) {
          return this.gain.gain.setTargetAtTime(t2, this.context.currentTime, 0.01), this;
        }
      }
      class ba {
        constructor(t2, e2, i2) {
          let n2, r2, o2;
          switch (this.binding = t2, this.valueSize = i2, e2) {
            case "quaternion":
              n2 = this._slerp, r2 = this._slerpAdditive, o2 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i2), this._workIndex = 5;
              break;
            case "string":
            case "bool":
              n2 = this._select, r2 = this._select, o2 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i2);
              break;
            default:
              n2 = this._lerp, r2 = this._lerpAdditive, o2 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i2);
          }
          this._mixBufferRegion = n2, this._mixBufferRegionAdditive = r2, this._setIdentity = o2, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(t2, e2) {
          const i2 = this.buffer, n2 = this.valueSize, r2 = t2 * n2 + n2;
          let o2 = this.cumulativeWeight;
          if (0 === o2) {
            for (let t3 = 0; t3 !== n2; ++t3) i2[r2 + t3] = i2[t3];
            o2 = e2;
          } else {
            o2 += e2;
            const t3 = e2 / o2;
            this._mixBufferRegion(i2, r2, 0, t3, n2);
          }
          this.cumulativeWeight = o2;
        }
        accumulateAdditive(t2) {
          const e2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e2, n2, 0, t2, i2), this.cumulativeWeightAdditive += t2;
        }
        apply(t2) {
          const e2 = this.valueSize, i2 = this.buffer, n2 = t2 * e2 + e2, r2 = this.cumulativeWeight, o2 = this.cumulativeWeightAdditive, s2 = this.binding;
          if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r2 < 1) {
            const t3 = e2 * this._origIndex;
            this._mixBufferRegion(i2, n2, t3, 1 - r2, e2);
          }
          o2 > 0 && this._mixBufferRegionAdditive(i2, n2, this._addIndex * e2, 1, e2);
          for (let t3 = e2, r3 = e2 + e2; t3 !== r3; ++t3) if (i2[t3] !== i2[t3 + e2]) {
            s2.setValue(i2, n2);
            break;
          }
        }
        saveOriginalState() {
          const t2 = this.binding, e2 = this.buffer, i2 = this.valueSize, n2 = i2 * this._origIndex;
          t2.getValue(e2, n2);
          for (let t3 = i2, r2 = n2; t3 !== r2; ++t3) e2[t3] = e2[n2 + t3 % i2];
          this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const t2 = 3 * this.valueSize;
          this.binding.setValue(this.buffer, t2);
        }
        _setAdditiveIdentityNumeric() {
          const t2 = this._addIndex * this.valueSize, e2 = t2 + this.valueSize;
          for (let i2 = t2; i2 < e2; i2++) this.buffer[i2] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const t2 = this._origIndex * this.valueSize, e2 = this._addIndex * this.valueSize;
          for (let i2 = 0; i2 < this.valueSize; i2++) this.buffer[e2 + i2] = this.buffer[t2 + i2];
        }
        _select(t2, e2, i2, n2, r2) {
          if (n2 >= 0.5) for (let n3 = 0; n3 !== r2; ++n3) t2[e2 + n3] = t2[i2 + n3];
        }
        _slerp(t2, e2, i2, n2) {
          A.slerpFlat(t2, e2, t2, e2, t2, i2, n2);
        }
        _slerpAdditive(t2, e2, i2, n2, r2) {
          const o2 = this._workIndex * r2;
          A.multiplyQuaternionsFlat(t2, o2, t2, e2, t2, i2), A.slerpFlat(t2, e2, t2, e2, t2, o2, n2);
        }
        _lerp(t2, e2, i2, n2, r2) {
          const o2 = 1 - n2;
          for (let s2 = 0; s2 !== r2; ++s2) {
            const r3 = e2 + s2;
            t2[r3] = t2[r3] * o2 + t2[i2 + s2] * n2;
          }
        }
        _lerpAdditive(t2, e2, i2, n2, r2) {
          for (let o2 = 0; o2 !== r2; ++o2) {
            const r3 = e2 + o2;
            t2[r3] = t2[r3] + t2[i2 + o2] * n2;
          }
        }
      }
      const Ta = new RegExp("[\\[\\]\\.:\\/]", "g"), Ea = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Sa = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), wa = /(WCOD+)?/.source.replace("WCOD", Ea), Aa = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ma = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ca = new RegExp("^" + Sa + wa + Aa + Ma + "$"), Ra = ["material", "materials", "bones"];
      class Ia {
        constructor(t2, e2, i2) {
          this.path = e2, this.parsedPath = i2 || Ia.parseTrackName(e2), this.node = Ia.findNode(t2, this.parsedPath.nodeName) || t2, this.rootNode = t2, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(t2, e2, i2) {
          return t2 && t2.isAnimationObjectGroup ? new Ia.Composite(t2, e2, i2) : new Ia(t2, e2, i2);
        }
        static sanitizeNodeName(t2) {
          return t2.replace(/\s/g, "_").replace(Ta, "");
        }
        static parseTrackName(t2) {
          const e2 = Ca.exec(t2);
          if (!e2) throw new Error("PropertyBinding: Cannot parse trackName: " + t2);
          const i2 = { nodeName: e2[2], objectName: e2[3], objectIndex: e2[4], propertyName: e2[5], propertyIndex: e2[6] }, n2 = i2.nodeName && i2.nodeName.lastIndexOf(".");
          if (void 0 !== n2 && -1 !== n2) {
            const t3 = i2.nodeName.substring(n2 + 1);
            -1 !== Ra.indexOf(t3) && (i2.nodeName = i2.nodeName.substring(0, n2), i2.objectName = t3);
          }
          if (null === i2.propertyName || 0 === i2.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t2);
          return i2;
        }
        static findNode(t2, e2) {
          if (!e2 || "" === e2 || "." === e2 || -1 === e2 || e2 === t2.name || e2 === t2.uuid) return t2;
          if (t2.skeleton) {
            const i2 = t2.skeleton.getBoneByName(e2);
            if (void 0 !== i2) return i2;
          }
          if (t2.children) {
            const i2 = function(t3) {
              for (let n3 = 0; n3 < t3.length; n3++) {
                const r2 = t3[n3];
                if (r2.name === e2 || r2.uuid === e2) return r2;
                const o2 = i2(r2.children);
                if (o2) return o2;
              }
              return null;
            }, n2 = i2(t2.children);
            if (n2) return n2;
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(t2, e2) {
          t2[e2] = this.node[this.propertyName];
        }
        _getValue_array(t2, e2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) t2[e2++] = i2[n2];
        }
        _getValue_arrayElement(t2, e2) {
          t2[e2] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t2, e2) {
          this.resolvedProperty.toArray(t2, e2);
        }
        _setValue_direct(t2, e2) {
          this.targetObject[this.propertyName] = t2[e2];
        }
        _setValue_direct_setNeedsUpdate(t2, e2) {
          this.targetObject[this.propertyName] = t2[e2], this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t2, e2) {
          this.targetObject[this.propertyName] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(t2, e2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) i2[n2] = t2[e2++];
        }
        _setValue_array_setNeedsUpdate(t2, e2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) i2[n2] = t2[e2++];
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t2, e2) {
          const i2 = this.resolvedProperty;
          for (let n2 = 0, r2 = i2.length; n2 !== r2; ++n2) i2[n2] = t2[e2++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(t2, e2) {
          this.resolvedProperty[this.propertyIndex] = t2[e2];
        }
        _setValue_arrayElement_setNeedsUpdate(t2, e2) {
          this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t2, e2) {
          this.resolvedProperty[this.propertyIndex] = t2[e2], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(t2, e2) {
          this.resolvedProperty.fromArray(t2, e2);
        }
        _setValue_fromArray_setNeedsUpdate(t2, e2) {
          this.resolvedProperty.fromArray(t2, e2), this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t2, e2) {
          this.resolvedProperty.fromArray(t2, e2), this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(t2, e2) {
          this.bind(), this.getValue(t2, e2);
        }
        _setValue_unbound(t2, e2) {
          this.bind(), this.setValue(t2, e2);
        }
        bind() {
          let t2 = this.node;
          const e2 = this.parsedPath, i2 = e2.objectName, n2 = e2.propertyName;
          let r2 = e2.propertyIndex;
          if (t2 || (t2 = Ia.findNode(this.rootNode, e2.nodeName) || this.rootNode, this.node = t2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t2) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          if (i2) {
            let n3 = e2.objectIndex;
            switch (i2) {
              case "materials":
                if (!t2.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!t2.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                t2 = t2.material.materials;
                break;
              case "bones":
                if (!t2.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                t2 = t2.skeleton.bones;
                for (let e3 = 0; e3 < t2.length; e3++) if (t2[e3].name === n3) {
                  n3 = e3;
                  break;
                }
                break;
              default:
                if (void 0 === t2[i2]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                t2 = t2[i2];
            }
            if (void 0 !== n3) {
              if (void 0 === t2[n3]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t2);
              t2 = t2[n3];
            }
          }
          const o2 = t2[n2];
          if (void 0 === o2) {
            const i3 = e2.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + i3 + "." + n2 + " but it wasn't found.", t2);
          }
          let s2 = this.Versioning.None;
          this.targetObject = t2, void 0 !== t2.needsUpdate ? s2 = this.Versioning.NeedsUpdate : void 0 !== t2.matrixWorldNeedsUpdate && (s2 = this.Versioning.MatrixWorldNeedsUpdate);
          let a2 = this.BindingType.Direct;
          if (void 0 !== r2) {
            if ("morphTargetInfluences" === n2) {
              if (!t2.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              if (!t2.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              if (!t2.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              void 0 !== t2.morphTargetDictionary[r2] && (r2 = t2.morphTargetDictionary[r2]);
            }
            a2 = this.BindingType.ArrayElement, this.resolvedProperty = o2, this.propertyIndex = r2;
          } else void 0 !== o2.fromArray && void 0 !== o2.toArray ? (a2 = this.BindingType.HasFromToArray, this.resolvedProperty = o2) : Array.isArray(o2) ? (a2 = this.BindingType.EntireArray, this.resolvedProperty = o2) : this.propertyName = n2;
          this.getValue = this.GetterByBindingType[a2], this.setValue = this.SetterByBindingTypeAndVersioning[a2][s2];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      Ia.Composite = class {
        constructor(t2, e2, i2) {
          const n2 = i2 || Ia.parseTrackName(e2);
          this._targetGroup = t2, this._bindings = t2.subscribe_(e2, n2);
        }
        getValue(t2, e2) {
          this.bind();
          const i2 = this._targetGroup.nCachedObjects_, n2 = this._bindings[i2];
          void 0 !== n2 && n2.getValue(t2, e2);
        }
        setValue(t2, e2) {
          const i2 = this._bindings;
          for (let n2 = this._targetGroup.nCachedObjects_, r2 = i2.length; n2 !== r2; ++n2) i2[n2].setValue(t2, e2);
        }
        bind() {
          const t2 = this._bindings;
          for (let e2 = this._targetGroup.nCachedObjects_, i2 = t2.length; e2 !== i2; ++e2) t2[e2].bind();
        }
        unbind() {
          const t2 = this._bindings;
          for (let e2 = this._targetGroup.nCachedObjects_, i2 = t2.length; e2 !== i2; ++e2) t2[e2].unbind();
        }
      }, Ia.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Ia.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, Ia.prototype.GetterByBindingType = [Ia.prototype._getValue_direct, Ia.prototype._getValue_array, Ia.prototype._getValue_arrayElement, Ia.prototype._getValue_toArray], Ia.prototype.SetterByBindingTypeAndVersioning = [[Ia.prototype._setValue_direct, Ia.prototype._setValue_direct_setNeedsUpdate, Ia.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ia.prototype._setValue_array, Ia.prototype._setValue_array_setNeedsUpdate, Ia.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ia.prototype._setValue_arrayElement, Ia.prototype._setValue_arrayElement_setNeedsUpdate, Ia.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ia.prototype._setValue_fromArray, Ia.prototype._setValue_fromArray_setNeedsUpdate, Ia.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
      (class {
        constructor() {
          this.uuid = u(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
          const t2 = {};
          this._indicesByUUID = t2;
          for (let e3 = 0, i2 = arguments.length; e3 !== i2; ++e3) t2[arguments[e3].uuid] = e3;
          this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
          const e2 = this;
          this.stats = { objects: { get total() {
            return e2._objects.length;
          }, get inUse() {
            return this.total - e2.nCachedObjects_;
          } }, get bindingsPerObject() {
            return e2._bindings.length;
          } };
        }
        add() {
          const t2 = this._objects, e2 = this._indicesByUUID, i2 = this._paths, n2 = this._parsedPaths, r2 = this._bindings, o2 = r2.length;
          let s2 = void 0, a2 = t2.length, l2 = this.nCachedObjects_;
          for (let h2 = 0, u2 = arguments.length; h2 !== u2; ++h2) {
            const u3 = arguments[h2], c2 = u3.uuid;
            let d2 = e2[c2];
            if (void 0 === d2) {
              d2 = a2++, e2[c2] = d2, t2.push(u3);
              for (let t3 = 0, e3 = o2; t3 !== e3; ++t3) r2[t3].push(new Ia(u3, i2[t3], n2[t3]));
            } else if (d2 < l2) {
              s2 = t2[d2];
              const a3 = --l2, h3 = t2[a3];
              e2[h3.uuid] = d2, t2[d2] = h3, e2[c2] = a3, t2[a3] = u3;
              for (let t3 = 0, e3 = o2; t3 !== e3; ++t3) {
                const e4 = r2[t3], o3 = e4[a3];
                let s3 = e4[d2];
                e4[d2] = o3, void 0 === s3 && (s3 = new Ia(u3, i2[t3], n2[t3])), e4[a3] = s3;
              }
            } else t2[d2] !== s2 && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
          this.nCachedObjects_ = l2;
        }
        remove() {
          const t2 = this._objects, e2 = this._indicesByUUID, i2 = this._bindings, n2 = i2.length;
          let r2 = this.nCachedObjects_;
          for (let o2 = 0, s2 = arguments.length; o2 !== s2; ++o2) {
            const s3 = arguments[o2], a2 = s3.uuid, l2 = e2[a2];
            if (void 0 !== l2 && l2 >= r2) {
              const o3 = r2++, h2 = t2[o3];
              e2[h2.uuid] = l2, t2[l2] = h2, e2[a2] = o3, t2[o3] = s3;
              for (let t3 = 0, e3 = n2; t3 !== e3; ++t3) {
                const e4 = i2[t3], n3 = e4[o3], r3 = e4[l2];
                e4[l2] = n3, e4[o3] = r3;
              }
            }
          }
          this.nCachedObjects_ = r2;
        }
        uncache() {
          const t2 = this._objects, e2 = this._indicesByUUID, i2 = this._bindings, n2 = i2.length;
          let r2 = this.nCachedObjects_, o2 = t2.length;
          for (let s2 = 0, a2 = arguments.length; s2 !== a2; ++s2) {
            const a3 = arguments[s2].uuid, l2 = e2[a3];
            if (void 0 !== l2) if (delete e2[a3], l2 < r2) {
              const s3 = --r2, a4 = t2[s3], h2 = --o2, u2 = t2[h2];
              e2[a4.uuid] = l2, t2[l2] = a4, e2[u2.uuid] = s3, t2[s3] = u2, t2.pop();
              for (let t3 = 0, e3 = n2; t3 !== e3; ++t3) {
                const e4 = i2[t3], n3 = e4[s3], r3 = e4[h2];
                e4[l2] = n3, e4[s3] = r3, e4.pop();
              }
            } else {
              const r3 = --o2, s3 = t2[r3];
              r3 > 0 && (e2[s3.uuid] = l2), t2[l2] = s3, t2.pop();
              for (let t3 = 0, e3 = n2; t3 !== e3; ++t3) {
                const e4 = i2[t3];
                e4[l2] = e4[r3], e4.pop();
              }
            }
          }
          this.nCachedObjects_ = r2;
        }
        subscribe_(t2, e2) {
          const i2 = this._bindingsIndicesByPath;
          let n2 = i2[t2];
          const r2 = this._bindings;
          if (void 0 !== n2) return r2[n2];
          const o2 = this._paths, s2 = this._parsedPaths, a2 = this._objects, l2 = a2.length, h2 = this.nCachedObjects_, u2 = new Array(l2);
          n2 = r2.length, i2[t2] = n2, o2.push(t2), s2.push(e2), r2.push(u2);
          for (let i3 = h2, n3 = a2.length; i3 !== n3; ++i3) {
            const n4 = a2[i3];
            u2[i3] = new Ia(n4, t2, e2);
          }
          return u2;
        }
        unsubscribe_(t2) {
          const e2 = this._bindingsIndicesByPath, i2 = e2[t2];
          if (void 0 !== i2) {
            const n2 = this._paths, r2 = this._parsedPaths, o2 = this._bindings, s2 = o2.length - 1, a2 = o2[s2];
            e2[t2[s2]] = i2, o2[i2] = a2, o2.pop(), r2[i2] = r2[s2], r2.pop(), n2[i2] = n2[s2], n2.pop();
          }
        }
      }).prototype.isAnimationObjectGroup = true;
      class Pa {
        constructor(t2, e2, i2 = null, n2 = e2.blendMode) {
          this._mixer = t2, this._clip = e2, this._localRoot = i2, this.blendMode = n2;
          const r2 = e2.tracks, o2 = r2.length, s2 = new Array(o2), a2 = { endingStart: 2400, endingEnd: 2400 };
          for (let t3 = 0; t3 !== o2; ++t3) {
            const e3 = r2[t3].createInterpolant(null);
            s2[t3] = e3, e3.settings = a2;
          }
          this._interpolantSettings = a2, this._interpolants = s2, this._propertyBindings = new Array(o2), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(t2) {
          return this._startTime = t2, this;
        }
        setLoop(t2, e2) {
          return this.loop = t2, this.repetitions = e2, this;
        }
        setEffectiveWeight(t2) {
          return this.weight = t2, this._effectiveWeight = this.enabled ? t2 : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(t2) {
          return this._scheduleFading(t2, 0, 1);
        }
        fadeOut(t2) {
          return this._scheduleFading(t2, 1, 0);
        }
        crossFadeFrom(t2, e2, i2) {
          if (t2.fadeOut(e2), this.fadeIn(e2), i2) {
            const i3 = this._clip.duration, n2 = t2._clip.duration, r2 = n2 / i3, o2 = i3 / n2;
            t2.warp(1, r2, e2), this.warp(o2, 1, e2);
          }
          return this;
        }
        crossFadeTo(t2, e2, i2) {
          return t2.crossFadeFrom(this, e2, i2);
        }
        stopFading() {
          const t2 = this._weightInterpolant;
          return null !== t2 && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
        }
        setEffectiveTimeScale(t2) {
          return this.timeScale = t2, this._effectiveTimeScale = this.paused ? 0 : t2, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(t2) {
          return this.timeScale = this._clip.duration / t2, this.stopWarping();
        }
        syncWith(t2) {
          return this.time = t2.time, this.timeScale = t2.timeScale, this.stopWarping();
        }
        halt(t2) {
          return this.warp(this._effectiveTimeScale, 0, t2);
        }
        warp(t2, e2, i2) {
          const n2 = this._mixer, r2 = n2.time, o2 = this.timeScale;
          let s2 = this._timeScaleInterpolant;
          null === s2 && (s2 = n2._lendControlInterpolant(), this._timeScaleInterpolant = s2);
          const a2 = s2.parameterPositions, l2 = s2.sampleValues;
          return a2[0] = r2, a2[1] = r2 + i2, l2[0] = t2 / o2, l2[1] = e2 / o2, this;
        }
        stopWarping() {
          const t2 = this._timeScaleInterpolant;
          return null !== t2 && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t2)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(t2, e2, i2, n2) {
          if (!this.enabled) return void this._updateWeight(t2);
          const r2 = this._startTime;
          if (null !== r2) {
            const n3 = (t2 - r2) * i2;
            if (n3 < 0 || 0 === i2) return;
            this._startTime = null, e2 = i2 * n3;
          }
          e2 *= this._updateTimeScale(t2);
          const o2 = this._updateTime(e2), s2 = this._updateWeight(t2);
          if (s2 > 0) {
            const t3 = this._interpolants, e3 = this._propertyBindings;
            switch (this.blendMode) {
              case 2501:
                for (let i3 = 0, n3 = t3.length; i3 !== n3; ++i3) t3[i3].evaluate(o2), e3[i3].accumulateAdditive(s2);
                break;
              case 2500:
              default:
                for (let i3 = 0, r3 = t3.length; i3 !== r3; ++i3) t3[i3].evaluate(o2), e3[i3].accumulate(n2, s2);
            }
          }
        }
        _updateWeight(t2) {
          let e2 = 0;
          if (this.enabled) {
            e2 = this.weight;
            const i2 = this._weightInterpolant;
            if (null !== i2) {
              const n2 = i2.evaluate(t2)[0];
              e2 *= n2, t2 > i2.parameterPositions[1] && (this.stopFading(), 0 === n2 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = e2, e2;
        }
        _updateTimeScale(t2) {
          let e2 = 0;
          if (!this.paused) {
            e2 = this.timeScale;
            const i2 = this._timeScaleInterpolant;
            if (null !== i2) {
              e2 *= i2.evaluate(t2)[0], t2 > i2.parameterPositions[1] && (this.stopWarping(), 0 === e2 ? this.paused = true : this.timeScale = e2);
            }
          }
          return this._effectiveTimeScale = e2, e2;
        }
        _updateTime(t2) {
          const e2 = this._clip.duration, i2 = this.loop;
          let n2 = this.time + t2, r2 = this._loopCount;
          const o2 = 2202 === i2;
          if (0 === t2) return -1 === r2 ? n2 : o2 && 1 == (1 & r2) ? e2 - n2 : n2;
          if (2200 === i2) {
            -1 === r2 && (this._loopCount = 0, this._setEndings(true, true, false));
            t: {
              if (n2 >= e2) n2 = e2;
              else {
                if (!(n2 < 0)) {
                  this.time = n2;
                  break t;
                }
                n2 = 0;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 < 0 ? -1 : 1 });
            }
          } else {
            if (-1 === r2 && (t2 >= 0 ? (r2 = 0, this._setEndings(true, 0 === this.repetitions, o2)) : this._setEndings(0 === this.repetitions, true, o2)), n2 >= e2 || n2 < 0) {
              const i3 = Math.floor(n2 / e2);
              n2 -= e2 * i3, r2 += Math.abs(i3);
              const s2 = this.repetitions - r2;
              if (s2 <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, n2 = t2 > 0 ? e2 : 0, this.time = n2, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t2 > 0 ? 1 : -1 });
              else {
                if (1 === s2) {
                  const e3 = t2 < 0;
                  this._setEndings(e3, !e3, o2);
                } else this._setEndings(false, false, o2);
                this._loopCount = r2, this.time = n2, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i3 });
              }
            } else this.time = n2;
            if (o2 && 1 == (1 & r2)) return e2 - n2;
          }
          return n2;
        }
        _setEndings(t2, e2, i2) {
          const n2 = this._interpolantSettings;
          i2 ? (n2.endingStart = 2401, n2.endingEnd = 2401) : (n2.endingStart = t2 ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n2.endingEnd = e2 ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
        }
        _scheduleFading(t2, e2, i2) {
          const n2 = this._mixer, r2 = n2.time;
          let o2 = this._weightInterpolant;
          null === o2 && (o2 = n2._lendControlInterpolant(), this._weightInterpolant = o2);
          const s2 = o2.parameterPositions, a2 = o2.sampleValues;
          return s2[0] = r2, a2[0] = e2, s2[1] = r2 + t2, a2[1] = i2, this;
        }
      }
      (class extends s {
        constructor(t2) {
          super(), this._root = t2, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(t2, e2) {
          const i2 = t2._localRoot || this._root, n2 = t2._clip.tracks, r2 = n2.length, o2 = t2._propertyBindings, s2 = t2._interpolants, a2 = i2.uuid, l2 = this._bindingsByRootAndName;
          let h2 = l2[a2];
          void 0 === h2 && (h2 = {}, l2[a2] = h2);
          for (let t3 = 0; t3 !== r2; ++t3) {
            const r3 = n2[t3], l3 = r3.name;
            let u2 = h2[l3];
            if (void 0 !== u2) o2[t3] = u2;
            else {
              if (u2 = o2[t3], void 0 !== u2) {
                null === u2._cacheIndex && (++u2.referenceCount, this._addInactiveBinding(u2, a2, l3));
                continue;
              }
              const n3 = e2 && e2._propertyBindings[t3].binding.parsedPath;
              u2 = new ba(Ia.create(i2, l3, n3), r3.ValueTypeName, r3.getValueSize()), ++u2.referenceCount, this._addInactiveBinding(u2, a2, l3), o2[t3] = u2;
            }
            s2[t3].resultBuffer = u2.buffer;
          }
        }
        _activateAction(t2) {
          if (!this._isActiveAction(t2)) {
            if (null === t2._cacheIndex) {
              const e3 = (t2._localRoot || this._root).uuid, i2 = t2._clip.uuid, n2 = this._actionsByClip[i2];
              this._bindAction(t2, n2 && n2.knownActions[0]), this._addInactiveAction(t2, i2, e3);
            }
            const e2 = t2._propertyBindings;
            for (let t3 = 0, i2 = e2.length; t3 !== i2; ++t3) {
              const i3 = e2[t3];
              0 == i3.useCount++ && (this._lendBinding(i3), i3.saveOriginalState());
            }
            this._lendAction(t2);
          }
        }
        _deactivateAction(t2) {
          if (this._isActiveAction(t2)) {
            const e2 = t2._propertyBindings;
            for (let t3 = 0, i2 = e2.length; t3 !== i2; ++t3) {
              const i3 = e2[t3];
              0 == --i3.useCount && (i3.restoreOriginalState(), this._takeBackBinding(i3));
            }
            this._takeBackAction(t2);
          }
        }
        _initMemoryManager() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          const t2 = this;
          this.stats = { actions: { get total() {
            return t2._actions.length;
          }, get inUse() {
            return t2._nActiveActions;
          } }, bindings: { get total() {
            return t2._bindings.length;
          }, get inUse() {
            return t2._nActiveBindings;
          } }, controlInterpolants: { get total() {
            return t2._controlInterpolants.length;
          }, get inUse() {
            return t2._nActiveControlInterpolants;
          } } };
        }
        _isActiveAction(t2) {
          const e2 = t2._cacheIndex;
          return null !== e2 && e2 < this._nActiveActions;
        }
        _addInactiveAction(t2, e2, i2) {
          const n2 = this._actions, r2 = this._actionsByClip;
          let o2 = r2[e2];
          if (void 0 === o2) o2 = { knownActions: [t2], actionByRoot: {} }, t2._byClipCacheIndex = 0, r2[e2] = o2;
          else {
            const e3 = o2.knownActions;
            t2._byClipCacheIndex = e3.length, e3.push(t2);
          }
          t2._cacheIndex = n2.length, n2.push(t2), o2.actionByRoot[i2] = t2;
        }
        _removeInactiveAction(t2) {
          const e2 = this._actions, i2 = e2[e2.length - 1], n2 = t2._cacheIndex;
          i2._cacheIndex = n2, e2[n2] = i2, e2.pop(), t2._cacheIndex = null;
          const r2 = t2._clip.uuid, o2 = this._actionsByClip, s2 = o2[r2], a2 = s2.knownActions, l2 = a2[a2.length - 1], h2 = t2._byClipCacheIndex;
          l2._byClipCacheIndex = h2, a2[h2] = l2, a2.pop(), t2._byClipCacheIndex = null;
          delete s2.actionByRoot[(t2._localRoot || this._root).uuid], 0 === a2.length && delete o2[r2], this._removeInactiveBindingsForAction(t2);
        }
        _removeInactiveBindingsForAction(t2) {
          const e2 = t2._propertyBindings;
          for (let t3 = 0, i2 = e2.length; t3 !== i2; ++t3) {
            const i3 = e2[t3];
            0 == --i3.referenceCount && this._removeInactiveBinding(i3);
          }
        }
        _lendAction(t2) {
          const e2 = this._actions, i2 = t2._cacheIndex, n2 = this._nActiveActions++, r2 = e2[n2];
          t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
        }
        _takeBackAction(t2) {
          const e2 = this._actions, i2 = t2._cacheIndex, n2 = --this._nActiveActions, r2 = e2[n2];
          t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
        }
        _addInactiveBinding(t2, e2, i2) {
          const n2 = this._bindingsByRootAndName, r2 = this._bindings;
          let o2 = n2[e2];
          void 0 === o2 && (o2 = {}, n2[e2] = o2), o2[i2] = t2, t2._cacheIndex = r2.length, r2.push(t2);
        }
        _removeInactiveBinding(t2) {
          const e2 = this._bindings, i2 = t2.binding, n2 = i2.rootNode.uuid, r2 = i2.path, o2 = this._bindingsByRootAndName, s2 = o2[n2], a2 = e2[e2.length - 1], l2 = t2._cacheIndex;
          a2._cacheIndex = l2, e2[l2] = a2, e2.pop(), delete s2[r2], 0 === Object.keys(s2).length && delete o2[n2];
        }
        _lendBinding(t2) {
          const e2 = this._bindings, i2 = t2._cacheIndex, n2 = this._nActiveBindings++, r2 = e2[n2];
          t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
        }
        _takeBackBinding(t2) {
          const e2 = this._bindings, i2 = t2._cacheIndex, n2 = --this._nActiveBindings, r2 = e2[n2];
          t2._cacheIndex = n2, e2[n2] = t2, r2._cacheIndex = i2, e2[i2] = r2;
        }
        _lendControlInterpolant() {
          const t2 = this._controlInterpolants, e2 = this._nActiveControlInterpolants++;
          let i2 = t2[e2];
          return void 0 === i2 && (i2 = new bs(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i2.__cacheIndex = e2, t2[e2] = i2), i2;
        }
        _takeBackControlInterpolant(t2) {
          const e2 = this._controlInterpolants, i2 = t2.__cacheIndex, n2 = --this._nActiveControlInterpolants, r2 = e2[n2];
          t2.__cacheIndex = n2, e2[n2] = t2, r2.__cacheIndex = i2, e2[i2] = r2;
        }
        clipAction(t2, e2, i2) {
          const n2 = e2 || this._root, r2 = n2.uuid;
          let o2 = "string" == typeof t2 ? Ps.findByName(n2, t2) : t2;
          const s2 = null !== o2 ? o2.uuid : t2, a2 = this._actionsByClip[s2];
          let l2 = null;
          if (void 0 === i2 && (i2 = null !== o2 ? o2.blendMode : 2500), void 0 !== a2) {
            const t3 = a2.actionByRoot[r2];
            if (void 0 !== t3 && t3.blendMode === i2) return t3;
            l2 = a2.knownActions[0], null === o2 && (o2 = l2._clip);
          }
          if (null === o2) return null;
          const h2 = new Pa(this, o2, e2, i2);
          return this._bindAction(h2, l2), this._addInactiveAction(h2, s2, r2), h2;
        }
        existingAction(t2, e2) {
          const i2 = e2 || this._root, n2 = i2.uuid, r2 = "string" == typeof t2 ? Ps.findByName(i2, t2) : t2, o2 = r2 ? r2.uuid : t2, s2 = this._actionsByClip[o2];
          return void 0 !== s2 && s2.actionByRoot[n2] || null;
        }
        stopAllAction() {
          const t2 = this._actions;
          for (let e2 = this._nActiveActions - 1; e2 >= 0; --e2) t2[e2].stop();
          return this;
        }
        update(t2) {
          t2 *= this.timeScale;
          const e2 = this._actions, i2 = this._nActiveActions, n2 = this.time += t2, r2 = Math.sign(t2), o2 = this._accuIndex ^= 1;
          for (let s3 = 0; s3 !== i2; ++s3) {
            e2[s3]._update(n2, t2, r2, o2);
          }
          const s2 = this._bindings, a2 = this._nActiveBindings;
          for (let t3 = 0; t3 !== a2; ++t3) s2[t3].apply(o2);
          return this;
        }
        setTime(t2) {
          this.time = 0;
          for (let t3 = 0; t3 < this._actions.length; t3++) this._actions[t3].time = 0;
          return this.update(t2);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(t2) {
          const e2 = this._actions, i2 = t2.uuid, n2 = this._actionsByClip, r2 = n2[i2];
          if (void 0 !== r2) {
            const t3 = r2.knownActions;
            for (let i3 = 0, n3 = t3.length; i3 !== n3; ++i3) {
              const n4 = t3[i3];
              this._deactivateAction(n4);
              const r3 = n4._cacheIndex, o2 = e2[e2.length - 1];
              n4._cacheIndex = null, n4._byClipCacheIndex = null, o2._cacheIndex = r3, e2[r3] = o2, e2.pop(), this._removeInactiveBindingsForAction(n4);
            }
            delete n2[i2];
          }
        }
        uncacheRoot(t2) {
          const e2 = t2.uuid, i2 = this._actionsByClip;
          for (const t3 in i2) {
            const n3 = i2[t3].actionByRoot[e2];
            void 0 !== n3 && (this._deactivateAction(n3), this._removeInactiveAction(n3));
          }
          const n2 = this._bindingsByRootAndName[e2];
          if (void 0 !== n2) for (const t3 in n2) {
            const e3 = n2[t3];
            e3.restoreOriginalState(), this._removeInactiveBinding(e3);
          }
        }
        uncacheAction(t2, e2) {
          const i2 = this.existingAction(t2, e2);
          null !== i2 && (this._deactivateAction(i2), this._removeInactiveAction(i2));
        }
      }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
      class Oa {
        constructor(t2) {
          "string" == typeof t2 && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t2 = arguments[1]), this.value = t2;
        }
        clone() {
          return new Oa(void 0 === this.value.clone ? this.value : this.value.clone());
        }
      }
      (class extends fr {
        constructor(t2, e2, i2 = 1) {
          super(t2, e2), this.meshPerAttribute = i2;
        }
        copy(t2) {
          return super.copy(t2), this.meshPerAttribute = t2.meshPerAttribute, this;
        }
        clone(t2) {
          const e2 = super.clone(t2);
          return e2.meshPerAttribute = this.meshPerAttribute, e2;
        }
        toJSON(t2) {
          const e2 = super.toJSON(t2);
          return e2.isInstancedInterleavedBuffer = true, e2.meshPerAttribute = this.meshPerAttribute, e2;
        }
      }).prototype.isInstancedInterleavedBuffer = true;
      (class {
        constructor(t2, e2, i2, n2, r2) {
          this.buffer = t2, this.type = e2, this.itemSize = i2, this.elementSize = n2, this.count = r2, this.version = 0;
        }
        set needsUpdate(t2) {
          true === t2 && this.version++;
        }
        setBuffer(t2) {
          return this.buffer = t2, this;
        }
        setType(t2, e2) {
          return this.type = t2, this.elementSize = e2, this;
        }
        setItemSize(t2) {
          return this.itemSize = t2, this;
        }
        setCount(t2) {
          return this.count = t2, this;
        }
      }).prototype.isGLBufferAttribute = true;
      const Na = new g();
      class La {
        constructor(t2 = new g(1 / 0, 1 / 0), e2 = new g(-1 / 0, -1 / 0)) {
          this.min = t2, this.max = e2;
        }
        set(t2, e2) {
          return this.min.copy(t2), this.max.copy(e2), this;
        }
        setFromPoints(t2) {
          this.makeEmpty();
          for (let e2 = 0, i2 = t2.length; e2 < i2; e2++) this.expandByPoint(t2[e2]);
          return this;
        }
        setFromCenterAndSize(t2, e2) {
          const i2 = Na.copy(e2).multiplyScalar(0.5);
          return this.min.copy(t2).sub(i2), this.max.copy(t2).add(i2), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t2) {
          return this.min.copy(t2.min), this.max.copy(t2.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(t2) {
          return this.isEmpty() ? t2.set(0, 0) : t2.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t2) {
          return this.isEmpty() ? t2.set(0, 0) : t2.subVectors(this.max, this.min);
        }
        expandByPoint(t2) {
          return this.min.min(t2), this.max.max(t2), this;
        }
        expandByVector(t2) {
          return this.min.sub(t2), this.max.add(t2), this;
        }
        expandByScalar(t2) {
          return this.min.addScalar(-t2), this.max.addScalar(t2), this;
        }
        containsPoint(t2) {
          return !(t2.x < this.min.x || t2.x > this.max.x || t2.y < this.min.y || t2.y > this.max.y);
        }
        containsBox(t2) {
          return this.min.x <= t2.min.x && t2.max.x <= this.max.x && this.min.y <= t2.min.y && t2.max.y <= this.max.y;
        }
        getParameter(t2, e2) {
          return e2.set((t2.x - this.min.x) / (this.max.x - this.min.x), (t2.y - this.min.y) / (this.max.y - this.min.y));
        }
        intersectsBox(t2) {
          return !(t2.max.x < this.min.x || t2.min.x > this.max.x || t2.max.y < this.min.y || t2.min.y > this.max.y);
        }
        clampPoint(t2, e2) {
          return e2.copy(t2).clamp(this.min, this.max);
        }
        distanceToPoint(t2) {
          return Na.copy(t2).clamp(this.min, this.max).sub(t2).length();
        }
        intersect(t2) {
          return this.min.max(t2.min), this.max.min(t2.max), this;
        }
        union(t2) {
          return this.min.min(t2.min), this.max.max(t2.max), this;
        }
        translate(t2) {
          return this.min.add(t2), this.max.add(t2), this;
        }
        equals(t2) {
          return t2.min.equals(this.min) && t2.max.equals(this.max);
        }
      }
      La.prototype.isBox2 = true;
      const Da = new M(), Fa = new M();
      (class extends Rt {
        constructor(t2) {
          super(), this.material = t2, this.render = function() {
          }, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
        }
      }).prototype.isImmediateRenderObject = true;
      const Ba = new M(), Ua = new rt(), ka = new rt();
      const Ga = new Float32Array(1);
      new Int32Array(Ga.buffer);
      Math.pow(2, 8);
      const Ha = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], ja = 5 + Ha.length, za = new Jt({ side: 1, depthWrite: false, depthTest: false }), { _lodPlanes: Va, _sizeLods: Xa, _sigmas: Wa } = (new Ie(new Oe(), za), Ya());
      Math.sqrt(5);
      function Ya() {
        const t2 = [], e2 = [], i2 = [];
        let n2 = 8;
        for (let r2 = 0; r2 < ja; r2++) {
          const o2 = Math.pow(2, n2);
          e2.push(o2);
          let s2 = 1 / o2;
          r2 > 4 ? s2 = Ha[r2 - 8 + 4 - 1] : 0 == r2 && (s2 = 0), i2.push(s2);
          const a2 = 1 / (o2 - 1), l2 = -a2 / 2, h2 = 1 + a2 / 2, u2 = [l2, l2, h2, l2, h2, h2, l2, l2, h2, h2, l2, h2], c2 = 6, d2 = 6, p2 = 3, f2 = 2, m2 = 1, g2 = new Float32Array(p2 * d2 * c2), v2 = new Float32Array(f2 * d2 * c2), _2 = new Float32Array(m2 * d2 * c2);
          for (let t3 = 0; t3 < c2; t3++) {
            const e3 = t3 % 3 * 2 / 3 - 1, i3 = t3 > 2 ? 0 : -1, n3 = [e3, i3, 0, e3 + 2 / 3, i3, 0, e3 + 2 / 3, i3 + 1, 0, e3, i3, 0, e3 + 2 / 3, i3 + 1, 0, e3, i3 + 1, 0];
            g2.set(n3, p2 * d2 * t3), v2.set(u2, f2 * d2 * t3);
            const r3 = [t3, t3, t3, t3, t3, t3];
            _2.set(r3, m2 * d2 * t3);
          }
          const y2 = new de();
          y2.setAttribute("position", new $t(g2, p2)), y2.setAttribute("uv", new $t(v2, f2)), y2.setAttribute("faceIndex", new $t(_2, m2)), t2.push(y2), n2 > 4 && n2--;
        }
        return { _lodPlanes: t2, _sizeLods: e2, _sigmas: i2 };
      }
      co.create = function(t2, e2) {
        return console.log("THREE.Curve.create() has been deprecated"), t2.prototype = Object.create(co.prototype), t2.prototype.constructor = t2, t2.prototype.getPoint = e2, t2;
      }, zs.prototype.fromPoints = function(t2) {
        return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t2);
      }, class extends eo {
        constructor(t2 = 10, e2 = 10, i2 = 4473924, n2 = 8947848) {
          i2 = new Zt(i2), n2 = new Zt(n2);
          const r2 = e2 / 2, o2 = t2 / e2, s2 = t2 / 2, a2 = [], l2 = [];
          for (let t3 = 0, h3 = 0, u2 = -s2; t3 <= e2; t3++, u2 += o2) {
            a2.push(-s2, 0, u2, s2, 0, u2), a2.push(u2, 0, -s2, u2, 0, s2);
            const e3 = t3 === r2 ? i2 : n2;
            e3.toArray(l2, h3), h3 += 3, e3.toArray(l2, h3), h3 += 3, e3.toArray(l2, h3), h3 += 3, e3.toArray(l2, h3), h3 += 3;
          }
          const h2 = new de();
          h2.setAttribute("position", new ne(a2, 3)), h2.setAttribute("color", new ne(l2, 3));
          super(h2, new Wr({ vertexColors: true, toneMapped: false })), this.type = "GridHelper";
        }
      }.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
      }, class extends eo {
        constructor(t2) {
          const e2 = function t3(e3) {
            const i3 = [];
            e3 && e3.isBone && i3.push(e3);
            for (let n3 = 0; n3 < e3.children.length; n3++) i3.push.apply(i3, t3(e3.children[n3]));
            return i3;
          }(t2), i2 = new de(), n2 = [], r2 = [], o2 = new Zt(0, 0, 1), s2 = new Zt(0, 1, 0);
          for (let t3 = 0; t3 < e2.length; t3++) {
            const i3 = e2[t3];
            i3.parent && i3.parent.isBone && (n2.push(0, 0, 0), n2.push(0, 0, 0), r2.push(o2.r, o2.g, o2.b), r2.push(s2.r, s2.g, s2.b));
          }
          i2.setAttribute("position", new ne(n2, 3)), i2.setAttribute("color", new ne(r2, 3));
          super(i2, new Wr({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true })), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t2, this.bones = e2, this.matrix = t2.matrixWorld, this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(t2) {
          const e2 = this.bones, i2 = this.geometry, n2 = i2.getAttribute("position");
          ka.copy(this.root.matrixWorld).invert();
          for (let t3 = 0, i3 = 0; t3 < e2.length; t3++) {
            const r2 = e2[t3];
            r2.parent && r2.parent.isBone && (Ua.multiplyMatrices(ka, r2.matrixWorld), Ba.setFromMatrixPosition(Ua), n2.setXYZ(i3, Ba.x, Ba.y, Ba.z), Ua.multiplyMatrices(ka, r2.parent.matrixWorld), Ba.setFromMatrixPosition(Ua), n2.setXYZ(i3 + 1, Ba.x, Ba.y, Ba.z), i3 += 2);
          }
          i2.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t2);
        }
      }.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
      }, Fs.prototype.extractUrlBase = function(t2) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ca.extractUrlBase(t2);
      }, Fs.Handlers = { add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      }, get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      } }, La.prototype.center = function(t2) {
        return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, La.prototype.empty = function() {
        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, La.prototype.isIntersectionBox = function(t2) {
        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, La.prototype.size = function(t2) {
        return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t2);
      }, I.prototype.center = function(t2) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, I.prototype.empty = function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, I.prototype.isIntersectionBox = function(t2) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, I.prototype.isIntersectionSphere = function(t2) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
      }, I.prototype.size = function(t2) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t2);
      }, Z.prototype.empty = function() {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
      }, qe.prototype.setFromMatrix = function(t2) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t2);
      }, class {
        constructor(t2 = new M(), e2 = new M()) {
          this.start = t2, this.end = e2;
        }
        set(t2, e2) {
          return this.start.copy(t2), this.end.copy(e2), this;
        }
        copy(t2) {
          return this.start.copy(t2.start), this.end.copy(t2.end), this;
        }
        getCenter(t2) {
          return t2.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(t2) {
          return t2.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(t2, e2) {
          return this.delta(e2).multiplyScalar(t2).add(this.start);
        }
        closestPointToPointParameter(t2, e2) {
          Da.subVectors(t2, this.start), Fa.subVectors(this.end, this.start);
          const i2 = Fa.dot(Fa);
          let n2 = Fa.dot(Da) / i2;
          return e2 && (n2 = c(n2, 0, 1)), n2;
        }
        closestPointToPoint(t2, e2, i2) {
          const n2 = this.closestPointToPointParameter(t2, e2);
          return this.delta(i2).multiplyScalar(n2).add(this.start);
        }
        applyMatrix4(t2) {
          return this.start.applyMatrix4(t2), this.end.applyMatrix4(t2), this;
        }
        equals(t2) {
          return t2.start.equals(this.start) && t2.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }.prototype.center = function(t2) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t2);
      }, v.prototype.flattenToArrayOffset = function(t2, e2) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
      }, v.prototype.multiplyVector3 = function(t2) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
      }, v.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
      }, v.prototype.applyToBufferAttribute = function(t2) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t2.applyMatrix3(this);
      }, v.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
      }, v.prototype.getInverse = function(t2) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
      }, rt.prototype.extractPosition = function(t2) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t2);
      }, rt.prototype.flattenToArrayOffset = function(t2, e2) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t2, e2);
      }, rt.prototype.getPosition = function() {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new M().setFromMatrixColumn(this, 3);
      }, rt.prototype.setRotationFromQuaternion = function(t2) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t2);
      }, rt.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      }, rt.prototype.multiplyVector3 = function(t2) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, rt.prototype.multiplyVector4 = function(t2) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, rt.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
      }, rt.prototype.rotateAxis = function(t2) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t2.transformDirection(this);
      }, rt.prototype.crossVector = function(t2) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, rt.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.");
      }, rt.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      }, rt.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      }, rt.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      }, rt.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      }, rt.prototype.applyToBufferAttribute = function(t2) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t2.applyMatrix4(this);
      }, rt.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
      }, rt.prototype.makeFrustum = function(t2, e2, i2, n2, r2, o2) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t2, e2, n2, i2, r2, o2);
      }, rt.prototype.getInverse = function(t2) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t2).invert();
      }, Xe.prototype.isIntersectionLine = function(t2) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t2);
      }, A.prototype.multiplyVector3 = function(t2) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t2.applyQuaternion(this);
      }, A.prototype.inverse = function() {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
      }, nt.prototype.isIntersectionBox = function(t2) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t2);
      }, nt.prototype.isIntersectionPlane = function(t2) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t2);
      }, nt.prototype.isIntersectionSphere = function(t2) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t2);
      }, Gt.prototype.area = function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
      }, Gt.prototype.barycoordFromPoint = function(t2, e2) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t2, e2);
      }, Gt.prototype.midpoint = function(t2) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t2);
      }, Gt.prototypenormal = function(t2) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t2);
      }, Gt.prototype.plane = function(t2) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t2);
      }, Gt.barycoordFromPoint = function(t2, e2, i2, n2, r2) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Gt.getBarycoord(t2, e2, i2, n2, r2);
      }, Gt.normal = function(t2, e2, i2, n2) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Gt.getNormal(t2, e2, i2, n2);
      }, Vs.prototype.extractAllPoints = function(t2) {
        return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t2);
      }, Vs.prototype.extrude = function(t2) {
        return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new os(this, t2);
      }, Vs.prototype.makeGeometry = function(t2) {
        return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new as(this, t2);
      }, g.prototype.fromAttribute = function(t2, e2, i2) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, i2);
      }, g.prototype.distanceToManhattan = function(t2) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
      }, g.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      }, M.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
      }, M.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
      }, M.prototype.getPositionFromMatrix = function(t2) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t2);
      }, M.prototype.getScaleFromMatrix = function(t2) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t2);
      }, M.prototype.getColumnFromMatrix = function(t2, e2) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e2, t2);
      }, M.prototype.applyProjection = function(t2) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t2);
      }, M.prototype.fromAttribute = function(t2, e2, i2) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, i2);
      }, M.prototype.distanceToManhattan = function(t2) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t2);
      }, M.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      }, E.prototype.fromAttribute = function(t2, e2, i2) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t2, e2, i2);
      }, E.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
      }, Rt.prototype.getChildByName = function(t2) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t2);
      }, Rt.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
      }, Rt.prototype.translate = function(t2, e2) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e2, t2);
      }, Rt.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
      }, Rt.prototype.applyMatrix = function(t2) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      }, Object.defineProperties(Rt.prototype, { eulerOrder: { get: function() {
        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
      }, set: function(t2) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t2;
      } }, useQuaternion: { get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }, set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      } } }), Ie.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }, Object.defineProperties(Ie.prototype, { drawMode: { get: function() {
        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
      }, set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      } } }), Ur.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.");
      }, Ue.prototype.setLens = function(t2, e2) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e2 && (this.filmGauge = e2), this.setFocalLength(t2);
      }, Object.defineProperties(Xs.prototype, { onlyShadow: { set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      } }, shadowCameraFov: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t2;
      } }, shadowCameraLeft: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t2;
      } }, shadowCameraRight: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t2;
      } }, shadowCameraTop: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t2;
      } }, shadowCameraBottom: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t2;
      } }, shadowCameraNear: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t2;
      } }, shadowCameraFar: { set: function(t2) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t2;
      } }, shadowCameraVisible: { set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      } }, shadowBias: { set: function(t2) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t2;
      } }, shadowDarkness: { set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      } }, shadowMapWidth: { set: function(t2) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t2;
      } }, shadowMapHeight: { set: function(t2) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t2;
      } } }), Object.defineProperties($t.prototype, { length: { get: function() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
      } }, dynamic: { get: function() {
        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage;
      }, set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
      } } }), $t.prototype.setDynamic = function(t2) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t2 ? 35048 : 35044), this;
      }, $t.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
      }, $t.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }, de.prototype.addIndex = function(t2) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t2);
      }, de.prototype.addAttribute = function(t2, e2) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e2 && e2.isBufferAttribute || e2 && e2.isInterleavedBufferAttribute ? "index" === t2 ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e2), this) : this.setAttribute(t2, e2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t2, new $t(arguments[1], arguments[2])));
      }, de.prototype.addDrawCall = function(t2, e2, i2) {
        void 0 !== i2 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t2, e2);
      }, de.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
      }, de.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
      }, de.prototype.removeAttribute = function(t2) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t2);
      }, de.prototype.applyMatrix = function(t2) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t2);
      }, Object.defineProperties(de.prototype, { drawcalls: { get: function() {
        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
      } }, offsets: { get: function() {
        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
      } } }), fr.prototype.setDynamic = function(t2) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === t2 ? 35048 : 35044), this;
      }, fr.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
      }, os.prototype.getArrays = function() {
        console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
      }, os.prototype.addShapeList = function() {
        console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
      }, os.prototype.addShape = function() {
        console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
      }, pr.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.");
      }, Oa.prototype.onUpdate = function() {
        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
      }, Object.defineProperties(jt.prototype, { wrapAround: { get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      } }, overdraw: { get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }, set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      } }, wrapRGB: { get: function() {
        return console.warn("THREE.Material: .wrapRGB has been removed."), new Zt();
      } }, shading: { get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      }, set: function(t2) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t2;
      } }, stencilMask: { get: function() {
        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
      }, set: function(t2) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t2;
      } } }), Object.defineProperties(Fe.prototype, { derivatives: { get: function() {
        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
      }, set: function(t2) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t2;
      } } }), ur.prototype.clearTarget = function(t2, e2, i2, n2) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t2), this.clear(e2, i2, n2);
      }, ur.prototype.animate = function(t2) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t2);
      }, ur.prototype.getCurrentRenderTarget = function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
      }, ur.prototype.getMaxAnisotropy = function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
      }, ur.prototype.getPrecision = function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
      }, ur.prototype.resetGLState = function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
      }, ur.prototype.supportsFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
      }, ur.prototype.supportsHalfFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
      }, ur.prototype.supportsStandardDerivatives = function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
      }, ur.prototype.supportsCompressedTextureS3TC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
      }, ur.prototype.supportsCompressedTexturePVRTC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
      }, ur.prototype.supportsBlendMinMax = function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
      }, ur.prototype.supportsVertexTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
      }, ur.prototype.supportsInstancedArrays = function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
      }, ur.prototype.enableScissorTest = function(t2) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t2);
      }, ur.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
      }, ur.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
      }, ur.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
      }, ur.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
      }, ur.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
      }, ur.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
      }, ur.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
      }, ur.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
      }, ur.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
      }, ur.prototype.getActiveMipMapLevel = function() {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
      }, Object.defineProperties(ur.prototype, { shadowMapEnabled: { get: function() {
        return this.shadowMap.enabled;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t2;
      } }, shadowMapType: { get: function() {
        return this.shadowMap.type;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t2;
      } }, shadowMapCullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      } }, context: { get: function() {
        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
      } }, vr: { get: function() {
        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
      } }, gammaInput: { get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      } }, gammaOutput: { get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = true === t2 ? 3001 : 3e3;
      } }, toneMappingWhitePoint: { get: function() {
        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      } } }), Object.defineProperties(tr.prototype, { cullFace: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      } }, renderReverseSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      } }, renderSingleSided: { get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }, set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      } } }), Object.defineProperties(S.prototype, { wrapS: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t2;
      } }, wrapT: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t2;
      } }, magFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t2;
      } }, minFilter: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t2;
      } }, anisotropy: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t2;
      } }, offset: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t2;
      } }, repeat: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t2;
      } }, format: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t2;
      } }, type: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t2;
      } }, generateMipmaps: { get: function() {
        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
      }, set: function(t2) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t2;
      } } }), xa.prototype.load = function(t2) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        const e2 = this;
        return new ya().load(t2, function(t3) {
          e2.setBuffer(t3);
        }), this;
      }, class {
        constructor(t2, e2 = 2048) {
          this.analyser = t2.context.createAnalyser(), this.analyser.fftSize = e2, this.data = new Uint8Array(this.analyser.frequencyBinCount), t2.getOutput().connect(this.analyser);
        }
        getFrequencyData() {
          return this.analyser.getByteFrequencyData(this.data), this.data;
        }
        getAverageFrequency() {
          let t2 = 0;
          const e2 = this.getFrequencyData();
          for (let i2 = 0; i2 < e2.length; i2++) t2 += e2[i2];
          return t2 / e2.length;
        }
      }.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
      }, ke.prototype.updateCubeMap = function(t2, e2) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t2, e2);
      }, ke.prototype.clear = function(t2, e2, i2, n2) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t2, e2, i2, n2);
      }, y.crossOrigin = void 0, y.loadTexture = function(t2, e2, i2, n2) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const r2 = new Hs();
        r2.setCrossOrigin(this.crossOrigin);
        const o2 = r2.load(t2, i2, void 0, n2);
        return e2 && (o2.mapping = e2), o2;
      }, y.loadTextureCube = function(t2, e2, i2, n2) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const r2 = new Gs();
        r2.setCrossOrigin(this.crossOrigin);
        const o2 = r2.load(t2, i2, void 0, n2);
        return e2 && (o2.mapping = e2), o2;
      }, y.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
      }, y.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
      };
      "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "130" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "130");
      var qa = i(6), Za = i.n(qa), Ja = i(33), Ka = i.n(Ja), Qa = i(11), $a = i.n(Qa);
      class tl {
        constructor() {
          this.camera = new ra(10, 10, 10, 10), this.camera.position.z = 100, this.camera.position.x = 0, this.camera.position.y = 0;
        }
        focus(t2, e2) {
          t2.position.z = 50;
        }
        updateAspect(t2, e2) {
          this.camera.left = -1 * t2 / 2, this.camera.right = t2 / 2, this.camera.top = e2 / 2, this.camera.bottom = -1 * e2 / 2, this.camera.updateProjectionMatrix();
        }
      }
      const el = { linear: (t2, e2, i2, n2) => i2 * t2 / n2 + e2, easeIn: (t2, e2, i2, n2) => i2 * (t2 /= n2) * t2 + e2, strongEaseIn: (t2, e2, i2, n2) => i2 * (t2 /= n2) * t2 * t2 * t2 * t2 + e2, strongEaseOut: (t2, e2, i2, n2) => i2 * ((t2 = t2 / n2 - 1) * t2 * t2 * t2 * t2 + 1) + e2, sineaseIn: (t2, e2, i2, n2) => i2 * (t2 /= n2) * t2 * t2 + e2, sineaseOut: (t2, e2, i2, n2) => i2 * ((t2 = t2 / n2 - 1) * t2 * t2 + 1) + e2 }, il = new b();
      class nl {
        constructor() {
          this.camera = new tl(), this.mesh = new Ie(), this.material = null, this.geometry = null;
        }
        applyOptions(t2) {
        }
        addObjects(t2) {
          this.mesh.position.z = 50, t2.add(this.mesh);
        }
        setSize(t2, e2) {
          this.camera.updateAspect(t2, e2), this.geometry = new Ke(t2, e2, 1, 1), this.material = new Fe({ fragmentShader: this.fragmentShader, vertexShader: "\nvarying vec2 vUv;\nvoid main(){\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n" }), this.material.uniforms = { width: { value: t2 }, height: { value: e2 }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.applyOptions(this.options), this.mesh.geometry = this.geometry, this.mesh.material = this.material;
        }
        setPrevTexture(t2) {
          this.material.uniforms.texturePrev.value = t2;
        }
        setNextTexture(t2) {
          this.material.uniforms.textureNext.value = t2;
        }
        updateAnimation(t2) {
          this.material.uniforms.timePercent.value = t2;
        }
        dispose() {
          var t2, e2;
          null === (t2 = this.geometry) || void 0 === t2 || t2.dispose(), null === (e2 = this.material) || void 0 === e2 || e2.dispose();
        }
      }
      var rl = i(72), ol = i.n(rl), sl = i(73), al = i.n(sl);
      var ll = i(74), hl = i.n(ll);
      var ul = i(75), cl = i.n(ul);
      var dl = i(76), pl = i.n(dl);
      var fl = i(77), ml = i.n(fl);
      var gl = i(78), vl = i.n(gl);
      var _l = i(79), yl = i.n(_l);
      var xl = i(80), bl = i.n(xl);
      var Tl = i(81), El = i.n(Tl);
      var Sl = i(82), wl = i.n(Sl);
      var Al = i(83), Ml = i.n(Al);
      var Cl = i(84), Rl = i.n(Cl);
      var Il = i(85), Pl = i.n(Il);
      class Ol {
        constructor() {
          this.camera = new Ue(60, 1, 1, 2e3), this.camera.position.z = 1e3, this.camera.position.x = 0, this.camera.position.y = 0;
        }
        updateAspect(t2, e2) {
          this.camera.aspect = t2 / e2, this.camera.updateProjectionMatrix();
        }
        focus(t2, e2) {
          const i2 = 0.5 * e2 / Math.tan(Math.PI / 6);
          t2.position.z = 1e3 - i2;
        }
      }
      class Nl {
        constructor() {
          this.prevTexture = il, this.nextTexture = il, this.geometry = new de(), this.material = null, this.camera = new Ol(), this.mesh = new Ie(), this.textureWidth = 0, this.textureHeight = 0;
        }
        horizontalSegments() {
          return Math.ceil(this.verticalSegments * this.textureWidth / this.textureHeight);
        }
        applyOptions(t2) {
          this.options = t2;
        }
        initMesh(t2, e2) {
          const i2 = [], n2 = [], r2 = [], o2 = this.verticalSegments, s2 = this.horizontalSegments(), a2 = t2 / 2, l2 = e2 / 2, h2 = t2 / s2, u2 = e2 / o2, c2 = this.extraAttributes(), d2 = Object.keys(c2), p2 = d2.reduce((t3, e3) => (t3[e3] = [], t3), {});
          for (let t3 = 0; t3 < o2; t3++) {
            const e3 = t3 * u2 - l2;
            for (let i3 = 0; i3 < s2; i3++) {
              const l3 = i3 * h2 - a2;
              n2.push(l3, -e3, 0), r2.push(1 * i3 / s2, 1 - 1 * t3 / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3))), n2.push(l3 + h2, -e3, 0), r2.push(1 * (i3 + 1) / s2, 1 - 1 * t3 / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3))), n2.push(l3, -e3 - u2, 0), r2.push(1 * i3 / s2, 1 - 1 * (t3 + 1) / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3))), n2.push(l3 + h2, -e3 - u2, 0), r2.push(1 * (i3 + 1) / s2, 1 - 1 * (t3 + 1) / o2), d2.forEach((e4) => p2[e4].push(...c2[e4].generator(t3, i3)));
            }
          }
          for (let t3 = 0; t3 < o2 * s2; t3++) {
            const e3 = 4 * t3, n3 = e3 + 1, r3 = e3 + 2, o3 = e3 + 3;
            i2.push(n3, e3, o3), i2.push(e3, r3, o3);
          }
          return this.geometry.setIndex(i2), this.geometry.setAttribute("position", new ne(n2, 3)), this.geometry.setAttribute("uv", new ne(new Float32Array(r2), 2)), d2.forEach((t3) => {
            const { threeType: e3, jsType: i3, itemSize: n3 } = c2[t3];
            this.geometry.setAttribute(t3, new e3(new i3(p2[t3]), n3));
          }), { verticalSegments: o2, horizontalSegments: s2, segmentWidth: h2, segmentHeight: u2 };
        }
        setSize(t2, e2) {
          this.textureWidth = t2, this.textureHeight = e2, this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.material = new Fe({ fragmentShader: this.fragmentShader, vertexShader: this.vertexShader, side: 2 }), this.mesh.geometry = this.geometry, this.material.transparent = true, this.mesh.material = this.material;
          const { verticalSegments: i2, horizontalSegments: n2, segmentWidth: r2, segmentHeight: o2 } = this.initMesh(t2, e2);
          this.material.uniforms = { segmentWidth: { value: r2 }, segmentHeight: { value: o2 }, verticalSegments: { value: i2 }, horizontalSegments: { value: n2 }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.applyOptions(this.options);
        }
        setPrevTexture(t2) {
          this.prevTexture = t2, this.material.uniforms.texturePrev.value = t2;
        }
        setNextTexture(t2) {
          this.nextTexture = t2, this.material.uniforms.textureNext.value = t2;
        }
        addObjects(t2) {
          t2.add(this.mesh);
        }
        updateAnimation(t2) {
          this.material.uniforms.timePercent.value = t2;
        }
        dispose() {
          var t2, e2;
          null === (t2 = this.geometry) || void 0 === t2 || t2.dispose(), null === (e2 = this.material) || void 0 === e2 || e2.dispose();
        }
      }
      var Ll = i(86), Dl = i.n(Ll), Fl = i(87), Bl = i.n(Fl);
      var Ul = i(88), kl = i.n(Ul), Gl = i(89), Hl = i.n(Gl);
      var jl = i(90), zl = i.n(jl), Vl = i(91), Xl = i.n(Vl);
      var Wl = i(92), Yl = i.n(Wl), ql = i(93), Zl = i.n(ql);
      var Jl = i(94), Kl = i.n(Jl), Ql = i(95), $l = i.n(Ql);
      var th = i(96), eh = i.n(th), ih = i(97), nh = i.n(ih);
      class rh extends Nl {
        constructor() {
          super(...arguments), this.duration = 1250, this.options = [], this.fragmentShader = nh.a, this.vertexShader = eh.a, this.verticalSegments = 100;
        }
        addObjects(t2) {
          t2.add(this.mesh), t2.background = this.nextTexture;
        }
        extraAttributes() {
          return {};
        }
        applyOptions(t2) {
          super.applyOptions(t2);
          const e2 = this.options.find((t3) => "invX" === t3.name);
          this.material.uniforms.option = { value: (null == e2 ? void 0 : e2.value) ? Number(e2.value) : 0 };
        }
      }
      var oh = i(98), sh = i.n(oh), ah = i(99), lh = i.n(ah);
      var hh = i(100), uh = i.n(hh);
      var ch = i(101), dh = i.n(ch);
      var ph = i(102), fh = i.n(ph);
      var mh = i(103), gh = i.n(mh), vh = i(104), _h = i.n(vh);
      var yh = i(105), xh = i.n(yh);
      var bh = i(46), Th = i.n(bh), Eh = i(47), Sh = i.n(Eh);
      var wh = i(106), Ah = i.n(wh), Mh = i(107), Ch = i.n(Mh);
      const Rh = { RandomLines: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = al.a, this.options = [{ name: "dir", value: "horz" }];
        }
        genRandomLines() {
          let t2 = [1];
          for (let e3 = 20; e3--; ) {
            let e4 = t2.sort((t3, e5) => e5 - t3)[0], i2 = t2.indexOf(e4), n2 = Math.random(), r2 = e4 * n2, o2 = e4 * (1 - n2);
            t2.splice(i2, 1), t2.push(r2, o2);
          }
          let e2 = t2.length;
          for (; e2; ) {
            let i2 = Math.floor(Math.random() * e2--);
            [t2[i2], t2[e2]] = [t2[e2], t2[i2]];
          }
          return t2;
        }
        applyOptions(t2) {
          var e2, i2;
          super.applyOptions(t2), this.material.uniforms.direction = { value: "horz" === (null === (i2 = null === (e2 = this.options) || void 0 === e2 ? void 0 : e2[0]) || void 0 === i2 ? void 0 : i2.value) ? 0 : 1 };
        }
        setSize(t2, e2) {
          super.setSize(t2, e2), this.material.uniforms.lines = { value: this.genRandomLines() }, this.material.vertexShader = ol.a;
        }
      }, Shape: class extends nl {
        constructor() {
          super(...arguments), this.duration = 800, this.fragmentShader = hl.a, this.options = [];
        }
      }, Ripples: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1400, this.fragmentShader = cl.a, this.options = [{ name: "dir", value: "center" }], this.optionsMap = { center: 0, ru: 1, lu: 2, ld: 3, rd: 4 };
        }
        applyOptions(t2) {
          var e2, i2;
          super.applyOptions(t2);
          const n2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: null === (e2 = this.optionsMap) || void 0 === e2 ? void 0 : e2[null !== (i2 = null == n2 ? void 0 : n2.value) && void 0 !== i2 ? i2 : "center"] };
        }
      }, Erase: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = pl.a, this.options = [], this.defaultDir = "right", this.optionsMap = { [this.defaultDir]: 0, d: 1, r: 2, u: 3 };
        }
        applyOptions(t2) {
          var e2, i2;
          super.applyOptions(t2);
          const n2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: null === (e2 = this.optionsMap) || void 0 === e2 ? void 0 : e2[null !== (i2 = null == n2 ? void 0 : n2.value) && void 0 !== i2 ? i2 : this.defaultDir] };
        }
      }, Dissolve: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1200, this.fragmentShader = ml.a, this.options = [], this.dissolveIndices = {};
        }
        random40() {
          return Math.ceil(40 * Math.random());
        }
        setSize(t2, e2) {
          super.setSize(t2, e2);
          for (let t3 = 0; t3 < 1600; t3++) {
            let t4 = this.random40(), e3 = this.random40();
            for (; void 0 !== this.dissolveIndices[`${t4}_${e3}`]; ) t4 = this.random40(), e3 = this.random40();
            this.dissolveIndices[`${t4}_${e3}`] = 0;
          }
          this.material.uniforms.dissolveTexture = { value: this.genDissolveToTexture() };
        }
        genDissolveToTexture() {
          var t2 = new Uint8Array(4800);
          for (let e2 = 0; e2 < 1600; e2++) {
            const i2 = e2 % 40 + 1, n2 = Math.floor(e2 / 40) + 1, r2 = 3 * e2;
            0 === this.dissolveIndices[`${i2}_${n2}`] ? (t2[r2] = 0, t2[r2 + 1] = 0, t2[r2 + 2] = 0) : (t2[r2] = 255, t2[r2 + 1] = 255, t2[r2 + 2] = 255);
          }
          return new Gr(t2, 40, 40, 1022);
        }
        updateAnimation(t2) {
          const e2 = 1600 * t2 - Object.keys(this.dissolveIndices).filter((t3) => 1 === this.dissolveIndices[t3]).length;
          for (let t3 = 0; t3 < e2; t3++) {
            const t4 = Object.keys(this.dissolveIndices).filter((t5) => 0 === this.dissolveIndices[t5]), e3 = Math.ceil(Math.random() * t4.length) - 1;
            this.dissolveIndices[t4[e3]] = 1;
          }
          this.material.uniforms.dissolveTexture.value = this.genDissolveToTexture();
        }
      }, Smooth: class extends nl {
        constructor() {
          super(...arguments), this.duration = 2e3, this.fragmentShader = vl.a, this.options = [];
        }
      }, FadeInOut: class extends nl {
        constructor() {
          super(...arguments), this.duration = 700, this.fragmentShader = yl.a, this.options = [];
        }
        applyOptions(t2) {
          super.applyOptions(t2);
          const e2 = this.options.find((t3) => "thruBlk" === t3.name);
          this.material.uniforms.option = { value: "1" === (null == e2 ? void 0 : e2.value) ? 1 : 0 };
        }
      }, Push: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = bl.a, this.options = [], this.optionsMap = { u: 0, r: 1, d: 2, l: 3 };
        }
        applyOptions(t2) {
          var e2, i2;
          super.applyOptions(t2);
          const n2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: null === (e2 = this.optionsMap) || void 0 === e2 ? void 0 : e2[null !== (i2 = null == n2 ? void 0 : n2.value) && void 0 !== i2 ? i2 : "l"] };
        }
      }, Separation: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1500, this.fragmentShader = El.a, this.options = [];
        }
        applyOptions(t2) {
          super.applyOptions(t2);
          const e2 = this.options.find((t3) => "orient" === t3.name), i2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.orient = { value: "vert" === (null == e2 ? void 0 : e2.value) }, this.material.uniforms.direction = { value: "in" === (null == i2 ? void 0 : i2.value) };
        }
      }, Display: class extends nl {
        constructor() {
          super(...arguments), this.duration = 3400, this.fragmentShader = wl.a, this.options = [];
        }
        applyOptions(t2) {
          const e2 = this.options.find((t3) => "dir" === t3.name), i2 = this.options.find((t3) => "thruBlk" === t3.name);
          this.material.uniforms.direction = { value: "r" === (null == e2 ? void 0 : e2.value) }, this.material.uniforms.thruBlk = { value: "1" === (null == i2 ? void 0 : i2.value) };
        }
      }, Uncover: class extends nl {
        constructor() {
          super(...arguments), this.duration = 750, this.fragmentShader = Ml.a, this.options = [], this.defaultDir = "right", this.optionsMap = { [this.defaultDir]: 0, d: 1, r: 2, u: 3, ld: 4, lu: 5, rd: 6, ru: 7 }, this.selfOptionsList = [{ x: -1, y: 0 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }];
        }
        applyOptions(t2) {
          var e2;
          super.applyOptions(t2);
          const i2 = this.options.find((t3) => "dir" === t3.name), n2 = this.optionsMap[null !== (e2 = null == i2 ? void 0 : i2.value) && void 0 !== e2 ? e2 : this.defaultDir], r2 = this.selfOptionsList[n2];
          this.material.uniforms.optionX = { value: r2.x }, this.material.uniforms.optionY = { value: r2.y };
        }
      }, Cover: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = Rl.a, this.options = [], this.defaultDir = "right", this.optionsMap = { [this.defaultDir]: 0, d: 1, r: 2, u: 3, ld: 4, lu: 5, rd: 6, ru: 7 }, this.selfOptionsList = [{ x: -1, y: 0 }, { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }];
        }
        applyOptions(t2) {
          var e2;
          super.applyOptions(t2);
          const i2 = this.options.find((t3) => "dir" === t3.name), n2 = this.optionsMap[null !== (e2 = null == i2 ? void 0 : i2.value) && void 0 !== e2 ? e2 : this.defaultDir], r2 = this.selfOptionsList[n2];
          this.material.uniforms.optionX = { value: r2.x }, this.material.uniforms.optionY = { value: r2.y };
        }
      }, Flash: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = Pl.a, this.options = [];
        }
      }, Checkerboard: class extends Nl {
        constructor() {
          super(...arguments), this.duration = 2500, this.options = [{ name: "dir", value: "horz" }], this.fragmentShader = Bl.a, this.vertexShader = Dl.a, this.vIndex = "", this.delay = 0, this.verticalSegments = 5;
        }
        extraAttributes() {
          return { times: { threeType: ne, jsType: Float32Array, itemSize: 1, generator: (t2, e2) => (this.vIndex !== `${t2}${e2}` && (this.delay = 0.3 * Math.random(), this.vIndex = `${t2}${e2}`), [this.delay]) }, segment: { threeType: ne, jsType: Float32Array, itemSize: 2, generator: (t2, e2) => [e2, t2] }, option: { threeType: ee, jsType: Int32Array, itemSize: 1, generator: () => [this.options.find((t2) => "dir" === t2.name && "horz" === t2.value) ? 0 : 1] } };
        }
      }, Vortex: class {
        constructor() {
          this.duration = 4e3, this.geometry = new de(), this.material = new Fe({ fragmentShader: Hl.a, vertexShader: kl.a, side: 2 }), this.camera = new Ol(), this.mesh = new Ie();
        }
        initData(t2, e2) {
          const i2 = [], n2 = [], r2 = [], o2 = [], s2 = [], a2 = [], l2 = Math.ceil(124 * t2 / e2), h2 = t2 / 2, u2 = e2 / 2, c2 = t2 / l2, d2 = e2 / 124;
          for (let t3 = 0; t3 < 124; t3++) {
            const e3 = t3 * d2 - u2;
            for (let i3 = 0; i3 < l2; i3++) {
              const u3 = i3 * c2 - h2, p2 = Math.ceil((i3 + 1) / ((l2 + 1) / 12)), f2 = 0.4 / p2, m2 = (p2 - 1) * f2 + Math.random() * f2;
              n2.push(u3, -e3, 0), o2.push(1 * i3 / l2, 1 - 1 * t3 / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2), n2.push(u3 + c2, -e3, 0), o2.push(1 * (i3 + 1) / l2, 1 - 1 * t3 / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2), n2.push(u3, -e3 - d2, 0), o2.push(1 * i3 / l2, 1 - 1 * (t3 + 1) / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2), n2.push(u3 + c2, -e3 - d2, 0), o2.push(1 * (i3 + 1) / l2, 1 - 1 * (t3 + 1) / 124), r2.push(0, 0, 1), s2.push(i3, t3), a2.push(m2);
            }
          }
          for (let t3 = 0; t3 < 124 * l2; t3++) {
            const e3 = 4 * t3, n3 = e3 + 1, r3 = e3 + 2, o3 = e3 + 3;
            i2.push(n3, e3, o3), i2.push(e3, r3, o3);
          }
          return this.geometry.setIndex(i2), this.geometry.setAttribute("position", new ne(n2, 3)), this.geometry.setAttribute("normal", new ne(r2, 3)), this.geometry.setAttribute("uv", new ne(new Float32Array(o2), 2)), this.geometry.setAttribute("segment", new ne(new Float32Array(s2), 2)), this.geometry.setAttribute("times", new ne(new Float32Array(a2), 1)), { verticalSegments: 124, horizontalSegments: l2, segmentWidth: c2, segmentHeight: d2 };
        }
        setSize(t2, e2) {
          const { verticalSegments: i2, horizontalSegments: n2, segmentWidth: r2, segmentHeight: o2 } = this.initData(t2, e2);
          this.material.uniforms = { duration: { value: this.duration }, segmentWidth: { value: r2 }, segmentHeight: { value: o2 }, verticalSegments: { value: i2 }, horizontalSegments: { value: n2 }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.mesh.geometry = this.geometry;
          new ds({ side: 2, vertexColors: true }).wireframe = true, this.material.transparent = true, this.mesh.material = this.material;
        }
        setPrevTexture(t2) {
          this.material.uniforms.texturePrev.value = t2;
        }
        setNextTexture(t2) {
          this.material.uniforms.textureNext.value = t2;
        }
        addObjects(t2) {
          t2.add(this.mesh);
        }
        updateAnimation(t2) {
          let e2 = (t2 - 0.4) / 0.2;
          e2 < 0 ? e2 = 0 : e2 > 1 && (e2 = 1), this.material.uniforms.timePercent.value = t2;
        }
        dispose() {
          var t2, e2;
          null === (t2 = this.geometry) || void 0 === t2 || t2.dispose(), null === (e2 = this.material) || void 0 === e2 || e2.dispose();
        }
      }, WindowShades: class {
        constructor() {
          this.duration = 1600, this.geometry = new de(), this.material = new Fe({ fragmentShader: Xl.a, vertexShader: zl.a, side: 2 }), this.horizontalSegments = 16, this.meshToCameraDistance = 0, this.camera = new Ol(), this.mesh = new Ie();
        }
        initData(t2, e2) {
          const i2 = [], n2 = [], r2 = [], o2 = [], s2 = [], a2 = [], l2 = t2 / 2, h2 = e2 / 2, u2 = t2 / this.horizontalSegments;
          for (let t3 = 0; t3 < this.horizontalSegments; t3++) {
            const e3 = Math.abs(t3 - Math.ceil(this.horizontalSegments / 2)) * (0.3 / Math.ceil(this.horizontalSegments / 2)), i3 = t3 * u2 - l2;
            n2.push(i3, h2, 0), r2.push(0), o2.push(t3 / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3 + u2, h2, 0), r2.push(0), o2.push((t3 + 1) / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3, -1 * h2, 0), r2.push(0), o2.push(t3 / this.horizontalSegments, 0), s2.push(t3), a2.push(e3), n2.push(i3 + u2, -1 * h2, 0), o2.push((t3 + 1) / this.horizontalSegments, 0), r2.push(0), s2.push(t3), a2.push(e3), n2.push(i3 + u2, h2, 0), r2.push(1), o2.push(t3 / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3 + u2, h2, -1 * u2), r2.push(1), o2.push((t3 + 1) / this.horizontalSegments, 1), s2.push(t3), a2.push(e3), n2.push(i3 + u2, -1 * h2, 0), r2.push(1), o2.push(t3 / this.horizontalSegments, 0), s2.push(t3), a2.push(e3), n2.push(i3 + u2, -1 * h2, -1 * u2), o2.push((t3 + 1) / this.horizontalSegments, 0), r2.push(1), s2.push(t3), a2.push(e3);
          }
          for (let t3 = 0; t3 < this.horizontalSegments; t3++) {
            const e3 = 8 * t3, n3 = e3 + 1, r3 = e3 + 2, o3 = e3 + 3, s3 = e3 + 4, a3 = e3 + 5, l3 = e3 + 6, h3 = e3 + 7;
            i2.push(n3, e3, o3), i2.push(e3, r3, o3), i2.push(a3, s3, h3), i2.push(s3, l3, h3);
          }
          this.geometry.setIndex(i2), this.geometry.setAttribute("position", new ne(n2, 3)), this.geometry.setAttribute("uv", new ne(new Float32Array(o2), 2)), this.geometry.setAttribute("index", new ne(new Float32Array(s2), 1)), this.geometry.setAttribute("type", new ne(new Float32Array(r2), 1)), this.geometry.setAttribute("delay", new ne(new Float32Array(a2), 1));
        }
        setPrevTexture(t2) {
          this.material.uniforms.texturePrev.value = t2;
        }
        setNextTexture(t2) {
          this.material.uniforms.textureNext.value = t2;
        }
        setSize(t2, e2) {
          this.initData(t2, e2), this.material.uniforms = { segments: { value: this.horizontalSegments }, segmentWidth: { value: t2 / this.horizontalSegments }, timePercent: { value: 0 }, texturePrev: { value: il }, textureNext: { value: il } }, this.meshToCameraDistance = 0.5 * e2 / Math.tan(Math.PI / 6), this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.mesh.geometry = this.geometry, this.material.transparent = true, this.mesh.material = this.material;
        }
        addObjects(t2) {
          t2.add(this.mesh);
        }
        updateAnimation(t2) {
          this.material.uniforms.timePercent.value = t2;
        }
        dispose() {
          var t2, e2;
          null === (t2 = this.geometry) || void 0 === t2 || t2.dispose(), null === (e2 = this.material) || void 0 === e2 || e2.dispose();
        }
      }, Curtain: class extends Nl {
        constructor() {
          super(...arguments), this.duration = 6e3, this.options = [], this.fragmentShader = Zl.a, this.vertexShader = Yl.a, this.verticalSegments = 100;
        }
        extraAttributes() {
          return { isLeft: { threeType: ne, jsType: Float32Array, itemSize: 1, generator: (t2, e2) => [e2 < this.horizontalSegments() / 2 ? 1 : 0] } };
        }
        addObjects(t2) {
          super.addObjects(t2), this.mesh.position.z += 20, t2.background = this.nextTexture;
        }
      }, Fall: class extends Nl {
        constructor() {
          super(...arguments), this.zCurveLimit = 100, this.duration = 2e3, this.options = [{ name: "invX", value: "0" }], this.verticalSegments = 100, this.fragmentShader = $l.a, this.vertexShader = Kl.a;
        }
        extraAttributes() {
          return {};
        }
        setSize(t2, e2) {
          var i2;
          super.setSize(t2, e2);
          const n2 = this.options.find((t3) => "invX" === t3.name);
          this.material.uniforms.zCurveLimit = { value: this.zCurveLimit }, this.material.uniforms.aCoefficient = { value: this.zCurveLimit / (this.textureHeight / 2 * (this.textureHeight / 2)) }, this.material.uniforms.option = { value: null !== (i2 = null == n2 ? void 0 : n2.value) && void 0 !== i2 ? i2 : 0 };
        }
        addObjects(t2) {
          t2.add(this.mesh), t2.background = this.nextTexture;
        }
        updateAnimation(t2) {
          this.material.uniforms.timePercent.value = t2;
        }
      }, Suspension: class extends rh {
        constructor() {
          super(...arguments), this.duration = 2e3, this.fragmentShader = lh.a, this.vertexShader = sh.a;
        }
        addObjects(t2) {
          t2.add(this.mesh), t2.background = this.prevTexture;
        }
      }, Clock: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = uh.a, this.options = [];
        }
      }, Combing: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = dh.a, this.options = [];
        }
        applyOptions(t2) {
          super.applyOptions(t2);
          const e2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: "vert" === (null == e2 ? void 0 : e2.value) ? 1 : 0 };
        }
      }, Scale: class extends nl {
        constructor() {
          super(...arguments), this.duration = 900, this.fragmentShader = fh.a, this.options = [];
        }
        applyOptions(t2) {
          super.applyOptions(t2);
          const e2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: "in" === (null == e2 ? void 0 : e2.value) ? 0 : 1 };
        }
      }, PeelOff: rh, Flip: class extends Nl {
        constructor() {
          super(...arguments), this.duration = 1250, this.options = [], this.fragmentShader = _h.a, this.vertexShader = gh.a, this.verticalSegments = 1;
        }
        extraAttributes() {
          return {};
        }
        applyOptions(t2) {
          const e2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: "l" === (null == e2 ? void 0 : e2.value) ? 1 : 0 };
        }
      }, Strips: class extends nl {
        constructor() {
          super(...arguments), this.duration = 1e3, this.fragmentShader = xh.a, this.options = [], this.defaultDir = "lu", this.optionsMap = { [this.defaultDir]: 0, ld: 1, rd: 2, ru: 3 };
        }
        applyOptions(t2) {
          var e2, i2;
          super.applyOptions(t2);
          const n2 = this.options.find((t3) => "dir" === t3.name);
          this.material.uniforms.option = { value: null === (e2 = this.optionsMap) || void 0 === e2 ? void 0 : e2[null !== (i2 = null == n2 ? void 0 : n2.value) && void 0 !== i2 ? i2 : this.defaultDir] };
        }
      }, Gallery: class {
        constructor() {
          this.camera = new Ol(), this.duration = 1600, this.options = [], this.gap = 10, this.group = new or(), this.prevMesh = new Ie(), this.nextMesh = new Ie(), this.width = 100, this.height = 100, this.prevMaterial = new Fe({ vertexShader: Th.a, fragmentShader: Sh.a, side: 2, uniforms: { galleryTexture: { value: il }, galleryHeight: { value: 1 } } }), this.nextMaterial = new Fe({ vertexShader: Th.a, fragmentShader: Sh.a, side: 2, uniforms: { galleryTexture: { value: il }, galleryHeight: { value: 1 } } });
        }
        get isRight() {
          const t2 = this.options.find((t3) => "dir" === t3.name);
          return !t2 || "r" === t2.value;
        }
        addObjects(t2) {
          this.group.add(this.prevMesh), this.group.add(this.nextMesh), t2.add(this.group);
        }
        dispose() {
          this.prevMaterial.dispose(), this.nextMaterial.dispose(), this.prevMesh.geometry.dispose(), this.nextMesh.geometry.dispose();
        }
        setNextTexture(t2) {
          this.nextMaterial.uniforms.galleryTexture.value = t2, this.nextMesh.material = this.nextMaterial;
        }
        setPrevTexture(t2) {
          this.prevMaterial.uniforms.galleryTexture.value = t2, this.prevMesh.material = this.prevMaterial;
        }
        setSize(t2, e2) {
          this.camera.updateAspect(t2, e2), this.camera.focus(this.prevMesh, e2), this.width = t2, this.height = e2, this.gap = this.width / 20, this.prevMaterial.uniforms.galleryHeight.value = e2, this.nextMaterial.uniforms.galleryHeight.value = e2;
          const i2 = new Ke(t2, 1.2 * e2 + 8, 1, 1);
          this.prevMesh.geometry = i2;
          const n2 = new Ke(t2, 1.2 * e2 + 8, 1, 1);
          this.nextMesh.geometry = n2, this.nextMesh.position.z = this.prevMesh.position.z, this.isRight ? this.nextMesh.position.x = t2 + this.gap : this.nextMesh.position.x = -1 * (t2 + this.gap);
        }
        updateAnimation(t2) {
          if (t2 < 0.3) {
            const e2 = t2 / 0.3;
            this.isRight ? (this.group.position.z = 0.25 * this.height * -1 * e2, this.group.rotation.y = Math.PI / 12 * -1 * e2) : (this.group.position.z = 0.25 * this.height * -1 * e2, this.group.rotation.y = Math.PI / 12 * e2);
          } else if (t2 >= 0.3 && t2 < 0.7) {
            const e2 = (t2 - 0.3) / 0.4;
            this.isRight ? (this.group.position.z = -1 * (0.25 * this.height + 0.55 * this.height * e2), this.group.position.x = -1 * (this.width + this.gap) * e2) : (this.group.position.z = -1 * (0.25 * this.height + 0.55 * this.height * e2), this.group.position.x = (this.width + this.gap) * e2);
          } else {
            const e2 = (t2 - 0.7) / 0.3;
            this.isRight ? (this.group.position.x = -1 * (this.width + this.gap), this.group.position.z = 0.8 * this.height * -1 * (1 - e2), this.group.rotation.y = Math.PI / 12 * -1 * (1 - e2)) : (this.group.position.x = this.width + this.gap, this.group.position.z = 0.8 * this.height * -1 * (1 - e2), this.group.rotation.y = Math.PI / 12 * (1 - e2));
          }
        }
      }, Switch: class {
        constructor() {
          this.camera = new Ol(), this.duration = 6e3, this.options = [], this.prevMesh = new Ie(), this.nextMesh = new Ie(), this.width = 100, this.height = 100, this.depth = 1, this.prevDepth = 1;
        }
        addObjects(t2) {
          t2.add(this.prevMesh), t2.add(this.nextMesh);
        }
        dispose() {
          Array.isArray(this.prevMesh.material) ? this.prevMesh.material.forEach((t2) => t2.dispose()) : this.prevMesh.material.dispose(), this.prevMesh.geometry.dispose(), Array.isArray(this.nextMesh.material) ? this.nextMesh.material.forEach((t2) => t2.dispose()) : this.nextMesh.material.dispose(), this.nextMesh.geometry.dispose();
        }
        setNextTexture(t2) {
          const e2 = new Jt({ map: t2 });
          this.nextMesh.material = e2;
        }
        setPrevTexture(t2) {
          const e2 = new Jt({ map: t2 });
          this.prevMesh.material = e2;
        }
        setSize(t2, e2) {
          this.camera.updateAspect(t2, e2), this.camera.focus(this.prevMesh, e2), this.width = t2, this.height = e2, this.depth = e2 / 2;
          const i2 = new Ke(t2, e2, 1, 1);
          this.prevMesh.geometry = i2;
          const n2 = new Ke(t2, e2, 1, 1);
          this.nextMesh.geometry = n2, this.prevDepth = this.prevMesh.position.z;
        }
        updateAnimation(t2) {
          const e2 = this.options.find((t3) => "dir" === t3.name);
          if (t2 < 0.5) {
            const e3 = t2 / 0.5;
            this.prevMesh.position.x = this.width / 2 * e3, this.prevMesh.rotation.y = -Math.PI / 10 * e3, this.nextMesh.position.x = -this.width / 2 * e3, this.nextMesh.rotation.y = Math.PI / 10 * e3, this.nextMesh.position.z = this.prevDepth - this.depth * (1 - e3);
          } else {
            const e3 = (t2 - 0.5) / 0.5;
            this.prevMesh.position.x = this.width / 2 * (1 - e3), this.prevMesh.rotation.y = -Math.PI / 10 * (1 - e3), this.prevMesh.position.z = this.prevDepth - this.depth * e3, this.nextMesh.position.x = -this.width / 2 * (1 - e3), this.nextMesh.rotation.y = Math.PI / 10 * (1 - e3);
          }
          if (e2 && "l" === e2.value) if (t2 < 0.5) {
            const e3 = t2 / 0.5;
            this.prevMesh.position.x = -this.width / 2 * e3, this.prevMesh.rotation.y = Math.PI / 10 * e3, this.nextMesh.position.x = this.width / 2 * e3, this.nextMesh.rotation.y = -Math.PI / 10 * e3;
          } else {
            const e3 = (t2 - 0.5) / 0.5;
            this.prevMesh.position.x = -this.width / 2 * (1 - e3), this.prevMesh.rotation.y = Math.PI / 10 * (1 - e3), this.nextMesh.position.x = this.width / 2 * (1 - e3), this.nextMesh.rotation.y = -Math.PI / 10 * (1 - e3);
          }
        }
      }, Prism: class {
        constructor() {
          this.camera = new Ol(), this.duration = 6e3, this.preset = null, this.presetZ = 0, this.mesh = new Ie(), this.width = 100, this.height = 100;
        }
        addObjects(t2) {
          this.mesh.geometry = this.box, t2.add(this.mesh);
        }
        dispose() {
          Array.isArray(this.mesh.material) ? this.mesh.material.forEach((t2) => t2.dispose()) : this.mesh.material.dispose(), this.mesh.geometry.dispose();
        }
        setNextTexture(t2) {
          const e2 = Array.isArray(this.mesh.material) ? this.mesh.material : [];
          e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), this.mesh.material = e2;
        }
        setPrevTexture(t2) {
          const e2 = Array.isArray(this.mesh.material) ? this.mesh.material : [];
          e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), e2.push(new Jt({ map: t2 })), this.mesh.material = e2;
        }
        setSize(t2, e2) {
          this.camera.updateAspect(t2, e2), this.camera.focus(this.mesh, e2), this.mesh.position.z -= t2 / 2, this.width = t2, this.height = e2, this.box = new Oe(t2, e2, t2, 1, 1, 1), this.mesh.geometry = this.box;
        }
        updateAnimation(t2) {
          null === this.preset && (this.preset = t2 > 0 ? 0 : Math.PI / 2, this.presetZ = this.mesh.position.z);
          const e2 = Math.PI / 2 * t2, i2 = (Math.sqrt(2) - 1) * (this.width / 2);
          this.mesh.rotation.y = this.preset + e2, this.mesh.position.z = t2 <= 0.5 ? this.presetZ - t2 / 0.5 * i2 : this.presetZ - (1 - (t2 - 0.5) / 0.5) * i2;
        }
      }, Doors: class {
        constructor() {
          this.camera = new Ol(), this.duration = 1600, this.options = [], this.width = 100, this.preMaterial = new Fe({ fragmentShader: Ch.a, vertexShader: Ah.a, uniforms: { prevTexture: { value: il }, timePercent: { value: 0 }, offset: { value: 0 } } }), this.prevGeometry = new de(), this.prevMesh = new Ie(), this.nextMesh = new Ie();
        }
        addObjects(t2) {
          this.prevMesh.material = this.preMaterial, this.prevMesh.geometry = this.prevGeometry, this.prevMesh.material.transparent = true, t2.add(this.prevMesh), t2.add(this.nextMesh);
        }
        setNextTexture(t2) {
          this.nextMesh.material = new Jt({ map: t2 });
        }
        setPrevTexture(t2) {
          this.preMaterial.uniforms.prevTexture.value = t2;
        }
        setSize(t2, e2) {
          this.width = t2, this.camera.updateAspect(t2, e2), this.camera.focus(this.prevMesh, e2);
          const i2 = t2 / 2, n2 = e2 / 2;
          this.preMaterial.uniforms.offset.value = t2 / 2, this.prevGeometry.setIndex([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);
          const r2 = this.options.find((t3) => "dir" === t3.name), o2 = r2 && "vert" === r2.value ? 0 : 1;
          this.preMaterial.uniforms.option = { value: o2 }, 1 === o2 ? (this.prevGeometry.setAttribute("position", new ne([-i2, n2, 0, -i2, 0, 0, i2, n2, 0, -i2, 0, 0, i2, 0, 0, i2, n2, 0, -i2, 0, 0, -i2, -n2, 0, i2, 0, 0, -i2, -n2, 0, i2, -n2, 0, i2, 0, 0], 3)), this.prevGeometry.setAttribute("uv", new ne([0, 1, 0, 0.5, 1, 1, 0, 0.5, 1, 0.5, 1, 1, 0, 0.5, 0, 0, 1, 0.5, 0, 0, 1, 0, 1, 0.5], 2))) : (this.prevGeometry.setAttribute("position", new ne([-i2, n2, 0, -i2, -n2, 0, 0, n2, 0, -i2, -n2, 0, 0, -n2, 0, 0, n2, 0, 0, n2, 0, 0, -n2, 0, i2, n2, 0, 0, -n2, 0, i2, -n2, 0, i2, n2, 0], 3)), this.prevGeometry.setAttribute("uv", new ne([0, 1, 0, 0, 0.5, 1, 0, 0, 0.5, 0, 0.5, 1, 0.5, 1, 0.5, 0, 1, 1, 0.5, 0, 1, 0, 1, 1], 2))), this.prevGeometry.setAttribute("left", new ne([1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], 1)), this.nextMesh.geometry = new Ke(t2, e2, 1, 1), this.nextMesh.position.z = this.prevMesh.position.z - t2 / 4;
        }
        updateAnimation(t2) {
          this.preMaterial.uniforms.timePercent.value = t2, this.nextMesh.position.z = this.prevMesh.position.z - (1 - t2) * (this.width / 4);
        }
        dispose() {
        }
      } };
      class Ih {
        constructor() {
          this.startTime = 0, this.lastTime = 0, this.lastFPSTime = 0, this.renderingDuration = 16, this.reverse = false, this.scene = new pr(), this.delay = 0, this.easeFn = el.linear, this.preset = null, this.onTransactionEnd = () => {
          }, this.isTransactionStartApplied = false, this.prevTexture = null, this.nextTexture = null, this.animationId = null, this.config = null, this.renderer = new ur({ alpha: true, premultipliedAlpha: true }), this.isPlaying = false, this.animate = (t2 = -1) => {
            var e2, i2, n2;
            if (!this.fps(t2)) return void (this.animationId = window.requestAnimationFrame(this.animate));
            this.renderer.clear(), t2 > this.delay && 0 === this.lastTime && (this.lastTime = t2, this.startTime = t2);
            let r2 = 0;
            this.lastTime > 0 && r2 < 1 && (r2 = this.easeFn(t2 - this.startTime, 0, 1, null !== (i2 = null === (e2 = this.preset) || void 0 === e2 ? void 0 : e2.duration) && void 0 !== i2 ? i2 : 0)), r2 > 1 && (r2 = 1), null === (n2 = this.preset) || void 0 === n2 || n2.updateAnimation(this.reverse ? 1 - r2 : r2), this.rerender(), this.isTransactionStartApplied || (this.isTransactionStartApplied = true), r2 < 1 ? this.animationId = window.requestAnimationFrame(this.animate) : this.onTransactionEnd();
          };
        }
        initPlayer(t2) {
          this.config = t2, this.reverse = t2.reverse, t2.delay && Number.isInteger(t2.delay) && (this.delay = t2.delay), t2.easeFn && (this.easeFn = el[t2.easeFn]), t2.maxFPS && Number.isInteger(t2.maxFPS) && t2.maxFPS > 0 && (this.renderingDuration = Math.ceil(1e3 / t2.maxFPS)), this.startTime = 0, this.lastTime = 0, this.scene.clear(), this.renderer.shadowMap.enabled = true, this.renderer.autoClear = false, this.renderer.setClearColor(t2.clearColor || 0), this.isTransactionStartApplied = false, this.renderer.setSize(t2.stageWidth, t2.stageHeight), this.preset = new Rh[t2.presetType](), t2.options && (this.preset.options = t2.options), t2.duration && Number.isInteger(t2.duration) && (this.preset.duration = t2.duration), this.preset.setSize(t2.stageWidth, t2.stageHeight);
        }
        setPrevTexture(t2) {
          var e2, i2, n2, r2;
          t2.needsUpdate = true, this.reverse ? (this.nextTexture = t2, null === (e2 = this.preset) || void 0 === e2 || e2.setNextTexture(t2)) : (this.prevTexture = t2, null === (i2 = this.preset) || void 0 === i2 || i2.setPrevTexture(t2)), null === (n2 = this.preset) || void 0 === n2 || n2.addObjects(this.scene), null === (r2 = this.preset) || void 0 === r2 || r2.updateAnimation(this.reverse ? 1 : 0), this.rerender();
        }
        setNextTexture(t2) {
          var e2, i2;
          t2.needsUpdate = true, this.reverse ? (this.prevTexture = t2, null === (e2 = this.preset) || void 0 === e2 || e2.setPrevTexture(t2)) : (this.nextTexture = t2, null === (i2 = this.preset) || void 0 === i2 || i2.setNextTexture(t2));
        }
        play() {
          return new Promise((t2) => {
            this.onTransactionEnd = t2, this.animate(), this.isPlaying = true;
          });
        }
        rerender() {
          var t2;
          this.renderer.clear(), (null === (t2 = this.preset) || void 0 === t2 ? void 0 : t2.camera.camera) && this.renderer.render(this.scene, this.preset.camera.camera);
        }
        fps(t2) {
          if (t2 <= 0) return true;
          if (this.lastFPSTime < 0) return this.lastFPSTime = t2, true;
          return t2 - this.lastFPSTime >= this.renderingDuration && (this.lastFPSTime = t2, true);
        }
        skip() {
          var t2;
          null === (t2 = this.preset) || void 0 === t2 || t2.updateAnimation(this.reverse ? 0 : 1), this.rerender(), this.dispose(), this.onTransactionEnd();
        }
        dispose() {
          var t2, e2, i2;
          window.cancelAnimationFrame(this.animationId), this.renderer.clear(), this.isPlaying = false, null === (t2 = this.preset) || void 0 === t2 || t2.dispose(), null === (e2 = this.prevTexture) || void 0 === e2 || e2.dispose(), null === (i2 = this.nextTexture) || void 0 === i2 || i2.dispose();
          for (let t3 = this.scene.children.length - 1; t3 >= 0; t3--) {
            const e3 = this.scene.children[t3];
            this.scene.remove(e3);
          }
          this.scene.background = null;
        }
        destroy() {
          this.dispose(), this.renderer.forceContextLoss(), this.renderer.dispose();
        }
      }
      i(139);
      var Ph = i(3), Oh = i(5);
      Oh.c.mixin({ accessible: false, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: false, _accessibleDiv: null, accessibleType: "button", accessiblePointerEvents: "auto", accessibleChildren: true, renderId: -1 });
      var Nh = function() {
        function t2(t3) {
          this.debug = false, this._isActive = false, this._isMobileAccessibility = false, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Ph.isMobile.tablet || Ph.isMobile.phone) && this.createTouchHook();
          var e2 = document.createElement("div");
          e2.style.width = "100px", e2.style.height = "100px", e2.style.position = "absolute", e2.style.top = "0px", e2.style.left = "0px", e2.style.zIndex = 2 .toString(), this.div = e2, this.renderer = t3, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, false);
        }
        return Object.defineProperty(t2.prototype, "isActive", { get: function() {
          return this._isActive;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isMobileAccessibility", { get: function() {
          return this._isMobileAccessibility;
        }, enumerable: false, configurable: true }), t2.prototype.createTouchHook = function() {
          var t3 = this, e2 = document.createElement("button");
          e2.style.width = "1px", e2.style.height = "1px", e2.style.position = "absolute", e2.style.top = "-1000px", e2.style.left = "-1000px", e2.style.zIndex = 2 .toString(), e2.style.backgroundColor = "#FF0000", e2.title = "select to enable accessibility for this content", e2.addEventListener("focus", function() {
            t3._isMobileAccessibility = true, t3.activate(), t3.destroyTouchHook();
          }), document.body.appendChild(e2), this._hookDiv = e2;
        }, t2.prototype.destroyTouchHook = function() {
          this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
        }, t2.prototype.activate = function() {
          var t3;
          this._isActive || (this._isActive = true, globalThis.document.addEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown, false), this.renderer.on("postrender", this.update, this), null === (t3 = this.renderer.view.parentNode) || void 0 === t3 || t3.appendChild(this.div));
        }, t2.prototype.deactivate = function() {
          var t3;
          this._isActive && !this._isMobileAccessibility && (this._isActive = false, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.addEventListener("keydown", this._onKeyDown, false), this.renderer.off("postrender", this.update), null === (t3 = this.div.parentNode) || void 0 === t3 || t3.removeChild(this.div));
        }, t2.prototype.updateAccessibleObjects = function(t3) {
          if (t3.visible && t3.accessibleChildren) {
            t3.accessible && t3.interactive && (t3._accessibleActive || this.addChild(t3), t3.renderId = this.renderId);
            var e2 = t3.children;
            if (e2) for (var i2 = 0; i2 < e2.length; i2++) this.updateAccessibleObjects(e2[i2]);
          }
        }, t2.prototype.update = function() {
          var t3 = performance.now();
          if (!(Ph.isMobile.android.device && t3 < this.androidUpdateCount) && (this.androidUpdateCount = t3 + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
            this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
            var e2 = this.renderer.view.getBoundingClientRect(), i2 = e2.left, n2 = e2.top, r2 = e2.width, o2 = e2.height, s2 = this.renderer, a2 = s2.width, l2 = s2.height, h2 = s2.resolution, u2 = r2 / a2 * h2, c2 = o2 / l2 * h2, d2 = this.div;
            d2.style.left = i2 + "px", d2.style.top = n2 + "px", d2.style.width = a2 + "px", d2.style.height = l2 + "px";
            for (var p2 = 0; p2 < this.children.length; p2++) {
              var f2 = this.children[p2];
              if (f2.renderId !== this.renderId) f2._accessibleActive = false, Object(Ph.removeItems)(this.children, p2, 1), this.div.removeChild(f2._accessibleDiv), this.pool.push(f2._accessibleDiv), f2._accessibleDiv = null, p2--;
              else {
                d2 = f2._accessibleDiv;
                var m2 = f2.hitArea, g2 = f2.worldTransform;
                f2.hitArea ? (d2.style.left = (g2.tx + m2.x * g2.a) * u2 + "px", d2.style.top = (g2.ty + m2.y * g2.d) * c2 + "px", d2.style.width = m2.width * g2.a * u2 + "px", d2.style.height = m2.height * g2.d * c2 + "px") : (m2 = f2.getBounds(), this.capHitArea(m2), d2.style.left = m2.x * u2 + "px", d2.style.top = m2.y * c2 + "px", d2.style.width = m2.width * u2 + "px", d2.style.height = m2.height * c2 + "px", d2.title !== f2.accessibleTitle && null !== f2.accessibleTitle && (d2.title = f2.accessibleTitle), d2.getAttribute("aria-label") !== f2.accessibleHint && null !== f2.accessibleHint && d2.setAttribute("aria-label", f2.accessibleHint)), f2.accessibleTitle === d2.title && f2.tabIndex === d2.tabIndex || (d2.title = f2.accessibleTitle, d2.tabIndex = f2.tabIndex, this.debug && this.updateDebugHTML(d2));
              }
            }
            this.renderId++;
          }
        }, t2.prototype.updateDebugHTML = function(t3) {
          t3.innerHTML = "type: " + t3.type + "</br> title : " + t3.title + "</br> tabIndex: " + t3.tabIndex;
        }, t2.prototype.capHitArea = function(t3) {
          t3.x < 0 && (t3.width += t3.x, t3.x = 0), t3.y < 0 && (t3.height += t3.y, t3.y = 0);
          var e2 = this.renderer, i2 = e2.width, n2 = e2.height;
          t3.x + t3.width > i2 && (t3.width = i2 - t3.x), t3.y + t3.height > n2 && (t3.height = n2 - t3.y);
        }, t2.prototype.addChild = function(t3) {
          var e2 = this.pool.pop();
          e2 || ((e2 = document.createElement("button")).style.width = "100px", e2.style.height = "100px", e2.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e2.style.position = "absolute", e2.style.zIndex = 2 .toString(), e2.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e2.setAttribute("aria-live", "off") : e2.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e2.setAttribute("aria-relevant", "additions") : e2.setAttribute("aria-relevant", "text"), e2.addEventListener("click", this._onClick.bind(this)), e2.addEventListener("focus", this._onFocus.bind(this)), e2.addEventListener("focusout", this._onFocusOut.bind(this))), e2.style.pointerEvents = t3.accessiblePointerEvents, e2.type = t3.accessibleType, t3.accessibleTitle && null !== t3.accessibleTitle ? e2.title = t3.accessibleTitle : t3.accessibleHint && null !== t3.accessibleHint || (e2.title = "displayObject " + t3.tabIndex), t3.accessibleHint && null !== t3.accessibleHint && e2.setAttribute("aria-label", t3.accessibleHint), this.debug && this.updateDebugHTML(e2), t3._accessibleActive = true, t3._accessibleDiv = e2, e2.displayObject = t3, this.children.push(t3), this.div.appendChild(t3._accessibleDiv), t3._accessibleDiv.tabIndex = t3.tabIndex;
        }, t2.prototype._onClick = function(t3) {
          var e2 = this.renderer.plugins.interaction, i2 = t3.target.displayObject, n2 = e2.eventData;
          e2.dispatchEvent(i2, "click", n2), e2.dispatchEvent(i2, "pointertap", n2), e2.dispatchEvent(i2, "tap", n2);
        }, t2.prototype._onFocus = function(t3) {
          t3.target.getAttribute("aria-live") || t3.target.setAttribute("aria-live", "assertive");
          var e2 = this.renderer.plugins.interaction, i2 = t3.target.displayObject, n2 = e2.eventData;
          e2.dispatchEvent(i2, "mouseover", n2);
        }, t2.prototype._onFocusOut = function(t3) {
          t3.target.getAttribute("aria-live") || t3.target.setAttribute("aria-live", "polite");
          var e2 = this.renderer.plugins.interaction, i2 = t3.target.displayObject, n2 = e2.eventData;
          e2.dispatchEvent(i2, "mouseout", n2);
        }, t2.prototype._onKeyDown = function(t3) {
          9 === t3.keyCode && this.activate();
        }, t2.prototype._onMouseMove = function(t3) {
          0 === t3.movementX && 0 === t3.movementY || this.deactivate();
        }, t2.prototype.destroy = function() {
          this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, true), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
        }, t2;
      }(), Lh = i(1), Dh = i(7), Fh = function() {
        function t2() {
          this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Lh.g(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = false, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
        }
        return Object.defineProperty(t2.prototype, "pointerId", { get: function() {
          return this.identifier;
        }, enumerable: false, configurable: true }), t2.prototype.getLocalPosition = function(t3, e2, i2) {
          return t3.worldTransform.applyInverse(i2 || this.global, e2);
        }, t2.prototype.copyEvent = function(t3) {
          "isPrimary" in t3 && t3.isPrimary && (this.isPrimary = true), this.button = "button" in t3 && t3.button;
          var e2 = "buttons" in t3 && t3.buttons;
          this.buttons = Number.isInteger(e2) ? e2 : "which" in t3 && t3.which, this.width = "width" in t3 && t3.width, this.height = "height" in t3 && t3.height, this.tiltX = "tiltX" in t3 && t3.tiltX, this.tiltY = "tiltY" in t3 && t3.tiltY, this.pointerType = "pointerType" in t3 && t3.pointerType, this.pressure = "pressure" in t3 && t3.pressure, this.rotationAngle = "rotationAngle" in t3 && t3.rotationAngle, this.twist = "twist" in t3 && t3.twist || 0, this.tangentialPressure = "tangentialPressure" in t3 && t3.tangentialPressure || 0;
        }, t2.prototype.reset = function() {
          this.isPrimary = false;
        }, t2;
      }(), Bh = function(t2, e2) {
        return (Bh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Uh = function() {
        function t2() {
          this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
        }
        return t2.prototype.stopPropagation = function() {
          this.stopped = true, this.stopPropagationHint = true, this.stopsPropagatingAt = this.currentTarget;
        }, t2.prototype.reset = function() {
          this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.currentTarget = null, this.target = null;
        }, t2;
      }(), kh = function() {
        function t2(e2) {
          this._pointerId = e2, this._flags = t2.FLAGS.NONE;
        }
        return t2.prototype._doSet = function(t3, e2) {
          this._flags = e2 ? this._flags | t3 : this._flags & ~t3;
        }, Object.defineProperty(t2.prototype, "pointerId", { get: function() {
          return this._pointerId;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "flags", { get: function() {
          return this._flags;
        }, set: function(t3) {
          this._flags = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "none", { get: function() {
          return this._flags === t2.FLAGS.NONE;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "over", { get: function() {
          return 0 != (this._flags & t2.FLAGS.OVER);
        }, set: function(e2) {
          this._doSet(t2.FLAGS.OVER, e2);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "rightDown", { get: function() {
          return 0 != (this._flags & t2.FLAGS.RIGHT_DOWN);
        }, set: function(e2) {
          this._doSet(t2.FLAGS.RIGHT_DOWN, e2);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "leftDown", { get: function() {
          return 0 != (this._flags & t2.FLAGS.LEFT_DOWN);
        }, set: function(e2) {
          this._doSet(t2.FLAGS.LEFT_DOWN, e2);
        }, enumerable: false, configurable: true }), t2.FLAGS = Object.freeze({ NONE: 0, OVER: 1, LEFT_DOWN: 2, RIGHT_DOWN: 4 }), t2;
      }(), Gh = function() {
        function t2() {
          this._tempPoint = new Lh.g();
        }
        return t2.prototype.recursiveFindHit = function(t3, e2, i2, n2, r2) {
          if (!e2 || !e2.visible) return false;
          var o2 = t3.data.global, s2 = false, a2 = r2 = e2.interactive || r2, l2 = true;
          if (e2.hitArea ? (n2 && (e2.worldTransform.applyInverse(o2, this._tempPoint), e2.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s2 = true : (n2 = false, l2 = false)), a2 = false) : e2._mask && n2 && (e2._mask.containsPoint && e2._mask.containsPoint(o2) || (n2 = false)), l2 && e2.interactiveChildren && e2.children) for (var h2 = e2.children, u2 = h2.length - 1; u2 >= 0; u2--) {
            var c2 = h2[u2], d2 = this.recursiveFindHit(t3, c2, i2, n2, a2);
            if (d2) {
              if (!c2.parent) continue;
              a2 = false, d2 && (t3.target && (n2 = false), s2 = true);
            }
          }
          return r2 && (n2 && !t3.target && !e2.hitArea && e2.containsPoint && e2.containsPoint(o2) && (s2 = true), e2.interactive && (s2 && !t3.target && (t3.target = e2), i2 && i2(t3, e2, !!s2))), s2;
        }, t2.prototype.findHit = function(t3, e2, i2, n2) {
          this.recursiveFindHit(t3, e2, i2, n2, false);
        }, t2;
      }(), Hh = { interactive: false, interactiveChildren: true, hitArea: null, get buttonMode() {
        return "pointer" === this.cursor;
      }, set buttonMode(t2) {
        t2 ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null);
      }, cursor: null, get trackedPointers() {
        return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers;
      }, _trackedPointers: void 0 };
      Oh.c.mixin(Hh);
      var jh = { target: null, data: { global: null } }, zh = function(t2) {
        function e2(e3, i2) {
          var n2 = t2.call(this) || this;
          return i2 = i2 || {}, n2.renderer = e3, n2.autoPreventDefault = void 0 === i2.autoPreventDefault || i2.autoPreventDefault, n2.interactionFrequency = i2.interactionFrequency || 10, n2.mouse = new Fh(), n2.mouse.identifier = 1, n2.mouse.global.set(-999999), n2.activeInteractionData = {}, n2.activeInteractionData[1] = n2.mouse, n2.interactionDataPool = [], n2.eventData = new Uh(), n2.interactionDOMElement = null, n2.moveWhenInside = false, n2.eventsAdded = false, n2.tickerAdded = false, n2.mouseOverRenderer = !("PointerEvent" in globalThis), n2.supportsTouchEvents = "ontouchstart" in globalThis, n2.supportsPointerEvents = !!globalThis.PointerEvent, n2.onPointerUp = n2.onPointerUp.bind(n2), n2.processPointerUp = n2.processPointerUp.bind(n2), n2.onPointerCancel = n2.onPointerCancel.bind(n2), n2.processPointerCancel = n2.processPointerCancel.bind(n2), n2.onPointerDown = n2.onPointerDown.bind(n2), n2.processPointerDown = n2.processPointerDown.bind(n2), n2.onPointerMove = n2.onPointerMove.bind(n2), n2.processPointerMove = n2.processPointerMove.bind(n2), n2.onPointerOut = n2.onPointerOut.bind(n2), n2.processPointerOverOut = n2.processPointerOverOut.bind(n2), n2.onPointerOver = n2.onPointerOver.bind(n2), n2.cursorStyles = { default: "inherit", pointer: "pointer" }, n2.currentCursorMode = null, n2.cursor = null, n2.resolution = 1, n2.delayedEvents = [], n2.search = new Gh(), n2._tempDisplayObject = new Oh.d(), n2._eventListenerOptions = { capture: true, passive: false }, n2._useSystemTicker = void 0 === i2.useSystemTicker || i2.useSystemTicker, n2.setTargetElement(n2.renderer.view, n2.renderer.resolution), n2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Bh(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), Object.defineProperty(e2.prototype, "useSystemTicker", { get: function() {
          return this._useSystemTicker;
        }, set: function(t3) {
          this._useSystemTicker = t3, t3 ? this.addTickerListener() : this.removeTickerListener();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "lastObjectRendered", { get: function() {
          return this.renderer._lastObjectRendered || this._tempDisplayObject;
        }, enumerable: false, configurable: true }), e2.prototype.hitTest = function(t3, e3) {
          return jh.target = null, jh.data.global = t3, e3 || (e3 = this.lastObjectRendered), this.processInteractive(jh, e3, null, true), jh.target;
        }, e2.prototype.setTargetElement = function(t3, e3) {
          void 0 === e3 && (e3 = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t3, this.resolution = e3, this.addEvents(), this.addTickerListener();
        }, e2.prototype.addTickerListener = function() {
          !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (Dh.a.system.add(this.tickerUpdate, this, Dh.c.INTERACTION), this.tickerAdded = true);
        }, e2.prototype.removeTickerListener = function() {
          this.tickerAdded && (Dh.a.system.remove(this.tickerUpdate, this), this.tickerAdded = false);
        }, e2.prototype.addEvents = function() {
          if (!this.eventsAdded && this.interactionDOMElement) {
            var t3 = this.interactionDOMElement.style;
            globalThis.navigator.msPointerEnabled ? (t3.msContentZooming = "none", t3.msTouchAction = "none") : this.supportsPointerEvents && (t3.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = true;
          }
        }, e2.prototype.removeEvents = function() {
          if (this.eventsAdded && this.interactionDOMElement) {
            var t3 = this.interactionDOMElement.style;
            globalThis.navigator.msPointerEnabled ? (t3.msContentZooming = "", t3.msTouchAction = "") : this.supportsPointerEvents && (t3.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = false;
          }
        }, e2.prototype.tickerUpdate = function(t3) {
          this._deltaTime += t3, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update());
        }, e2.prototype.update = function() {
          if (this.interactionDOMElement) if (this._didMove) this._didMove = false;
          else {
            for (var t3 in this.cursor = null, this.activeInteractionData) if (this.activeInteractionData.hasOwnProperty(t3)) {
              var e3 = this.activeInteractionData[t3];
              if (e3.originalEvent && "touch" !== e3.pointerType) {
                var i2 = this.configureInteractionEventForDOMEvent(this.eventData, e3.originalEvent, e3);
                this.processInteractive(i2, this.lastObjectRendered, this.processPointerOverOut, true);
              }
            }
            this.setCursorMode(this.cursor);
          }
        }, e2.prototype.setCursorMode = function(t3) {
          t3 = t3 || "default";
          var e3 = true;
          if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (e3 = false), this.currentCursorMode !== t3) {
            this.currentCursorMode = t3;
            var i2 = this.cursorStyles[t3];
            if (i2) switch (typeof i2) {
              case "string":
                e3 && (this.interactionDOMElement.style.cursor = i2);
                break;
              case "function":
                i2(t3);
                break;
              case "object":
                e3 && Object.assign(this.interactionDOMElement.style, i2);
            }
            else e3 && "string" == typeof t3 && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t3) && (this.interactionDOMElement.style.cursor = t3);
          }
        }, e2.prototype.dispatchEvent = function(t3, e3, i2) {
          i2.stopPropagationHint && t3 !== i2.stopsPropagatingAt || (i2.currentTarget = t3, i2.type = e3, t3.emit(e3, i2), t3[e3] && t3[e3](i2));
        }, e2.prototype.delayDispatchEvent = function(t3, e3, i2) {
          this.delayedEvents.push({ displayObject: t3, eventString: e3, eventData: i2 });
        }, e2.prototype.mapPositionToPoint = function(t3, e3, i2) {
          var n2;
          n2 = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : { x: 0, y: 0, width: this.interactionDOMElement.width, height: this.interactionDOMElement.height, left: 0, top: 0 };
          var r2 = 1 / this.resolution;
          t3.x = (e3 - n2.left) * (this.interactionDOMElement.width / n2.width) * r2, t3.y = (i2 - n2.top) * (this.interactionDOMElement.height / n2.height) * r2;
        }, e2.prototype.processInteractive = function(t3, e3, i2, n2) {
          var r2 = this.search.findHit(t3, e3, i2, n2), o2 = this.delayedEvents;
          if (!o2.length) return r2;
          t3.stopPropagationHint = false;
          var s2 = o2.length;
          this.delayedEvents = [];
          for (var a2 = 0; a2 < s2; a2++) {
            var l2 = o2[a2], h2 = l2.displayObject, u2 = l2.eventString, c2 = l2.eventData;
            c2.stopsPropagatingAt === h2 && (c2.stopPropagationHint = true), this.dispatchEvent(h2, u2, c2);
          }
          return r2;
        }, e2.prototype.onPointerDown = function(t3) {
          if (!this.supportsTouchEvents || "touch" !== t3.pointerType) {
            var e3 = this.normalizeToPointerData(t3);
            if (this.autoPreventDefault && e3[0].isNormalized) (t3.cancelable || !("cancelable" in t3)) && t3.preventDefault();
            for (var i2 = e3.length, n2 = 0; n2 < i2; n2++) {
              var r2 = e3[n2], o2 = this.getInteractionDataForPointerId(r2), s2 = this.configureInteractionEventForDOMEvent(this.eventData, r2, o2);
              if (s2.data.originalEvent = t3, this.processInteractive(s2, this.lastObjectRendered, this.processPointerDown, true), this.emit("pointerdown", s2), "touch" === r2.pointerType) this.emit("touchstart", s2);
              else if ("mouse" === r2.pointerType || "pen" === r2.pointerType) {
                var a2 = 2 === r2.button;
                this.emit(a2 ? "rightdown" : "mousedown", this.eventData);
              }
            }
          }
        }, e2.prototype.processPointerDown = function(t3, e3, i2) {
          var n2 = t3.data, r2 = t3.data.identifier;
          if (i2) {
            if (e3.trackedPointers[r2] || (e3.trackedPointers[r2] = new kh(r2)), this.dispatchEvent(e3, "pointerdown", t3), "touch" === n2.pointerType) this.dispatchEvent(e3, "touchstart", t3);
            else if ("mouse" === n2.pointerType || "pen" === n2.pointerType) {
              var o2 = 2 === n2.button;
              o2 ? e3.trackedPointers[r2].rightDown = true : e3.trackedPointers[r2].leftDown = true, this.dispatchEvent(e3, o2 ? "rightdown" : "mousedown", t3);
            }
          }
        }, e2.prototype.onPointerComplete = function(t3, e3, i2) {
          for (var n2 = this.normalizeToPointerData(t3), r2 = n2.length, o2 = t3.target !== this.interactionDOMElement ? "outside" : "", s2 = 0; s2 < r2; s2++) {
            var a2 = n2[s2], l2 = this.getInteractionDataForPointerId(a2), h2 = this.configureInteractionEventForDOMEvent(this.eventData, a2, l2);
            if (h2.data.originalEvent = t3, this.processInteractive(h2, this.lastObjectRendered, i2, e3 || !o2), this.emit(e3 ? "pointercancel" : "pointerup" + o2, h2), "mouse" === a2.pointerType || "pen" === a2.pointerType) {
              var u2 = 2 === a2.button;
              this.emit(u2 ? "rightup" + o2 : "mouseup" + o2, h2);
            } else "touch" === a2.pointerType && (this.emit(e3 ? "touchcancel" : "touchend" + o2, h2), this.releaseInteractionDataForPointerId(a2.pointerId));
          }
        }, e2.prototype.onPointerCancel = function(t3) {
          this.supportsTouchEvents && "touch" === t3.pointerType || this.onPointerComplete(t3, true, this.processPointerCancel);
        }, e2.prototype.processPointerCancel = function(t3, e3) {
          var i2 = t3.data, n2 = t3.data.identifier;
          void 0 !== e3.trackedPointers[n2] && (delete e3.trackedPointers[n2], this.dispatchEvent(e3, "pointercancel", t3), "touch" === i2.pointerType && this.dispatchEvent(e3, "touchcancel", t3));
        }, e2.prototype.onPointerUp = function(t3) {
          this.supportsTouchEvents && "touch" === t3.pointerType || this.onPointerComplete(t3, false, this.processPointerUp);
        }, e2.prototype.processPointerUp = function(t3, e3, i2) {
          var n2 = t3.data, r2 = t3.data.identifier, o2 = e3.trackedPointers[r2], s2 = "touch" === n2.pointerType, a2 = "mouse" === n2.pointerType || "pen" === n2.pointerType, l2 = false;
          if (a2) {
            var h2 = 2 === n2.button, u2 = kh.FLAGS, c2 = h2 ? u2.RIGHT_DOWN : u2.LEFT_DOWN, d2 = void 0 !== o2 && o2.flags & c2;
            i2 ? (this.dispatchEvent(e3, h2 ? "rightup" : "mouseup", t3), d2 && (this.dispatchEvent(e3, h2 ? "rightclick" : "click", t3), l2 = true)) : d2 && this.dispatchEvent(e3, h2 ? "rightupoutside" : "mouseupoutside", t3), o2 && (h2 ? o2.rightDown = false : o2.leftDown = false);
          }
          i2 ? (this.dispatchEvent(e3, "pointerup", t3), s2 && this.dispatchEvent(e3, "touchend", t3), o2 && (a2 && !l2 || this.dispatchEvent(e3, "pointertap", t3), s2 && (this.dispatchEvent(e3, "tap", t3), o2.over = false))) : o2 && (this.dispatchEvent(e3, "pointerupoutside", t3), s2 && this.dispatchEvent(e3, "touchendoutside", t3)), o2 && o2.none && delete e3.trackedPointers[r2];
        }, e2.prototype.onPointerMove = function(t3) {
          if (!this.supportsTouchEvents || "touch" !== t3.pointerType) {
            var e3 = this.normalizeToPointerData(t3);
            "mouse" !== e3[0].pointerType && "pen" !== e3[0].pointerType || (this._didMove = true, this.cursor = null);
            for (var i2 = e3.length, n2 = 0; n2 < i2; n2++) {
              var r2 = e3[n2], o2 = this.getInteractionDataForPointerId(r2), s2 = this.configureInteractionEventForDOMEvent(this.eventData, r2, o2);
              s2.data.originalEvent = t3, this.processInteractive(s2, this.lastObjectRendered, this.processPointerMove, true), this.emit("pointermove", s2), "touch" === r2.pointerType && this.emit("touchmove", s2), "mouse" !== r2.pointerType && "pen" !== r2.pointerType || this.emit("mousemove", s2);
            }
            "mouse" === e3[0].pointerType && this.setCursorMode(this.cursor);
          }
        }, e2.prototype.processPointerMove = function(t3, e3, i2) {
          var n2 = t3.data, r2 = "touch" === n2.pointerType, o2 = "mouse" === n2.pointerType || "pen" === n2.pointerType;
          o2 && this.processPointerOverOut(t3, e3, i2), this.moveWhenInside && !i2 || (this.dispatchEvent(e3, "pointermove", t3), r2 && this.dispatchEvent(e3, "touchmove", t3), o2 && this.dispatchEvent(e3, "mousemove", t3));
        }, e2.prototype.onPointerOut = function(t3) {
          if (!this.supportsTouchEvents || "touch" !== t3.pointerType) {
            var e3 = this.normalizeToPointerData(t3)[0];
            "mouse" === e3.pointerType && (this.mouseOverRenderer = false, this.setCursorMode(null));
            var i2 = this.getInteractionDataForPointerId(e3), n2 = this.configureInteractionEventForDOMEvent(this.eventData, e3, i2);
            n2.data.originalEvent = e3, this.processInteractive(n2, this.lastObjectRendered, this.processPointerOverOut, false), this.emit("pointerout", n2), "mouse" === e3.pointerType || "pen" === e3.pointerType ? this.emit("mouseout", n2) : this.releaseInteractionDataForPointerId(i2.identifier);
          }
        }, e2.prototype.processPointerOverOut = function(t3, e3, i2) {
          var n2 = t3.data, r2 = t3.data.identifier, o2 = "mouse" === n2.pointerType || "pen" === n2.pointerType, s2 = e3.trackedPointers[r2];
          i2 && !s2 && (s2 = e3.trackedPointers[r2] = new kh(r2)), void 0 !== s2 && (i2 && this.mouseOverRenderer ? (s2.over || (s2.over = true, this.delayDispatchEvent(e3, "pointerover", t3), o2 && this.delayDispatchEvent(e3, "mouseover", t3)), o2 && null === this.cursor && (this.cursor = e3.cursor)) : s2.over && (s2.over = false, this.dispatchEvent(e3, "pointerout", this.eventData), o2 && this.dispatchEvent(e3, "mouseout", t3), s2.none && delete e3.trackedPointers[r2]));
        }, e2.prototype.onPointerOver = function(t3) {
          var e3 = this.normalizeToPointerData(t3)[0], i2 = this.getInteractionDataForPointerId(e3), n2 = this.configureInteractionEventForDOMEvent(this.eventData, e3, i2);
          n2.data.originalEvent = e3, "mouse" === e3.pointerType && (this.mouseOverRenderer = true), this.emit("pointerover", n2), "mouse" !== e3.pointerType && "pen" !== e3.pointerType || this.emit("mouseover", n2);
        }, e2.prototype.getInteractionDataForPointerId = function(t3) {
          var e3, i2 = t3.pointerId;
          return 1 === i2 || "mouse" === t3.pointerType ? e3 = this.mouse : this.activeInteractionData[i2] ? e3 = this.activeInteractionData[i2] : ((e3 = this.interactionDataPool.pop() || new Fh()).identifier = i2, this.activeInteractionData[i2] = e3), e3.copyEvent(t3), e3;
        }, e2.prototype.releaseInteractionDataForPointerId = function(t3) {
          var e3 = this.activeInteractionData[t3];
          e3 && (delete this.activeInteractionData[t3], e3.reset(), this.interactionDataPool.push(e3));
        }, e2.prototype.configureInteractionEventForDOMEvent = function(t3, e3, i2) {
          return t3.data = i2, this.mapPositionToPoint(i2.global, e3.clientX, e3.clientY), "touch" === e3.pointerType && (e3.globalX = i2.global.x, e3.globalY = i2.global.y), i2.originalEvent = e3, t3.reset(), t3;
        }, e2.prototype.normalizeToPointerData = function(t3) {
          var e3 = [];
          if (this.supportsTouchEvents && t3 instanceof TouchEvent) for (var i2 = 0, n2 = t3.changedTouches.length; i2 < n2; i2++) {
            var r2 = t3.changedTouches[i2];
            void 0 === r2.button && (r2.button = t3.touches.length ? 1 : 0), void 0 === r2.buttons && (r2.buttons = t3.touches.length ? 1 : 0), void 0 === r2.isPrimary && (r2.isPrimary = 1 === t3.touches.length && "touchstart" === t3.type), void 0 === r2.width && (r2.width = r2.radiusX || 1), void 0 === r2.height && (r2.height = r2.radiusY || 1), void 0 === r2.tiltX && (r2.tiltX = 0), void 0 === r2.tiltY && (r2.tiltY = 0), void 0 === r2.pointerType && (r2.pointerType = "touch"), void 0 === r2.pointerId && (r2.pointerId = r2.identifier || 0), void 0 === r2.pressure && (r2.pressure = r2.force || 0.5), void 0 === r2.twist && (r2.twist = 0), void 0 === r2.tangentialPressure && (r2.tangentialPressure = 0), void 0 === r2.layerX && (r2.layerX = r2.offsetX = r2.clientX), void 0 === r2.layerY && (r2.layerY = r2.offsetY = r2.clientY), r2.isNormalized = true, e3.push(r2);
          }
          else if (globalThis.MouseEvent && (!(t3 instanceof MouseEvent) || this.supportsPointerEvents && t3 instanceof globalThis.PointerEvent)) e3.push(t3);
          else {
            var o2 = t3;
            void 0 === o2.isPrimary && (o2.isPrimary = true), void 0 === o2.width && (o2.width = 1), void 0 === o2.height && (o2.height = 1), void 0 === o2.tiltX && (o2.tiltX = 0), void 0 === o2.tiltY && (o2.tiltY = 0), void 0 === o2.pointerType && (o2.pointerType = "mouse"), void 0 === o2.pointerId && (o2.pointerId = 1), void 0 === o2.pressure && (o2.pressure = 0.5), void 0 === o2.twist && (o2.twist = 0), void 0 === o2.tangentialPressure && (o2.tangentialPressure = 0), o2.isNormalized = true, e3.push(o2);
          }
          return e3;
        }, e2.prototype.destroy = function() {
          this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
        }, e2;
      }(Ph.EventEmitter), Vh = i(2), Xh = function() {
        function t2(e2) {
          var i2 = this;
          this.stage = new Oh.b(), e2 = Object.assign({ forceCanvas: false }, e2), this.renderer = Object(Vh.y)(e2), t2._plugins.forEach(function(t3) {
            t3.init.call(i2, e2);
          });
        }
        return t2.registerPlugin = function(e2) {
          t2._plugins.push(e2);
        }, t2.prototype.render = function() {
          this.renderer.render(this.stage);
        }, Object.defineProperty(t2.prototype, "view", { get: function() {
          return this.renderer.view;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "screen", { get: function() {
          return this.renderer.screen;
        }, enumerable: false, configurable: true }), t2.prototype.destroy = function(e2, i2) {
          var n2 = this, r2 = t2._plugins.slice(0);
          r2.reverse(), r2.forEach(function(t3) {
            t3.destroy.call(n2);
          }), this.stage.destroy(i2), this.stage = null, this.renderer.destroy(e2), this.renderer = null;
        }, t2._plugins = [], t2;
      }(), Wh = function() {
        function t2() {
        }
        return t2.init = function(t3) {
          var e2 = this;
          Object.defineProperty(this, "resizeTo", { set: function(t4) {
            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = t4, t4 && (globalThis.addEventListener("resize", this.queueResize), this.resize());
          }, get: function() {
            return this._resizeTo;
          } }), this.queueResize = function() {
            e2._resizeTo && (e2.cancelResize(), e2._resizeId = requestAnimationFrame(function() {
              return e2.resize();
            }));
          }, this.cancelResize = function() {
            e2._resizeId && (cancelAnimationFrame(e2._resizeId), e2._resizeId = null);
          }, this.resize = function() {
            if (e2._resizeTo) {
              var t4, i2;
              if (e2.cancelResize(), e2._resizeTo === globalThis.window) t4 = globalThis.innerWidth, i2 = globalThis.innerHeight;
              else {
                var n2 = e2._resizeTo;
                t4 = n2.clientWidth, i2 = n2.clientHeight;
              }
              e2.renderer.resize(t4, i2);
            }
          }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t3.resizeTo || null;
        }, t2.destroy = function() {
          globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
        }, t2;
      }();
      Xh.registerPlugin(Wh);
      var Yh = /iPhone/i, qh = /iPod/i, Zh = /iPad/i, Jh = /\biOS-universal(?:.+)Mac\b/i, Kh = /\bAndroid(?:.+)Mobile\b/i, Qh = /Android/i, $h = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, tu = /Silk/i, eu = /Windows Phone/i, iu = /\bWindows(?:.+)ARM\b/i, nu = /BlackBerry/i, ru = /BB10/i, ou = /Opera Mini/i, su = /\b(CriOS|Chrome)(?:.+)Mobile/i, au = /Mobile(?:.+)Firefox\b/i, lu = function(t2) {
        return void 0 !== t2 && "MacIntel" === t2.platform && "number" == typeof t2.maxTouchPoints && t2.maxTouchPoints > 1 && "undefined" == typeof MSStream;
      };
      var hu, uu, cu, du, pu, fu, mu, gu, vu, _u, yu, xu, bu, Tu, Eu, Su, wu, Au, Mu, Cu = function(t2) {
        var e2 = { userAgent: "", platform: "", maxTouchPoints: 0 };
        t2 || "undefined" == typeof navigator ? "string" == typeof t2 ? e2.userAgent = t2 : t2 && t2.userAgent && (e2 = { userAgent: t2.userAgent, platform: t2.platform, maxTouchPoints: t2.maxTouchPoints || 0 }) : e2 = { userAgent: navigator.userAgent, platform: navigator.platform, maxTouchPoints: navigator.maxTouchPoints || 0 };
        var i2 = e2.userAgent, n2 = i2.split("[FBAN");
        void 0 !== n2[1] && (i2 = n2[0]), void 0 !== (n2 = i2.split("Twitter"))[1] && (i2 = n2[0]);
        var r2 = /* @__PURE__ */ function(t3) {
          return function(e3) {
            return e3.test(t3);
          };
        }(i2), o2 = { apple: { phone: r2(Yh) && !r2(eu), ipod: r2(qh), tablet: !r2(Yh) && (r2(Zh) || lu(e2)) && !r2(eu), universal: r2(Jh), device: (r2(Yh) || r2(qh) || r2(Zh) || r2(Jh) || lu(e2)) && !r2(eu) }, amazon: { phone: r2($h), tablet: !r2($h) && r2(tu), device: r2($h) || r2(tu) }, android: { phone: !r2(eu) && r2($h) || !r2(eu) && r2(Kh), tablet: !r2(eu) && !r2($h) && !r2(Kh) && (r2(tu) || r2(Qh)), device: !r2(eu) && (r2($h) || r2(tu) || r2(Kh) || r2(Qh)) || r2(/\bokhttp\b/i) }, windows: { phone: r2(eu), tablet: r2(iu), device: r2(eu) || r2(iu) }, other: { blackberry: r2(nu), blackberry10: r2(ru), opera: r2(ou), firefox: r2(au), chrome: r2(su), device: r2(nu) || r2(ru) || r2(ou) || r2(au) || r2(su) }, any: false, phone: false, tablet: false };
        return o2.any = o2.apple.device || o2.android.device || o2.windows.device || o2.other.device, o2.phone = o2.apple.phone || o2.android.phone || o2.windows.phone, o2.tablet = o2.apple.tablet || o2.android.tablet || o2.windows.tablet, o2;
      }(globalThis.navigator);
      !function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(hu || (hu = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(uu || (uu = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(cu || (cu = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(du || (du = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(pu || (pu = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(fu || (fu = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(mu || (mu = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(gu || (gu = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(vu || (vu = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(_u || (_u = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(yu || (yu = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(xu || (xu = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(bu || (bu = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(Tu || (Tu = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(Eu || (Eu = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(Su || (Su = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(wu || (wu = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(Au || (Au = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(Mu || (Mu = {}));
      var Ru = {
        MIPMAP_TEXTURES: xu.POW2,
        ANISOTROPIC_LEVEL: 0,
        RESOLUTION: 1,
        FILTER_RESOLUTION: 1,
        FILTER_MULTISAMPLE: Au.NONE,
        SPRITE_MAX_TEXTURES: function(t2) {
          var e2 = true;
          if (Cu.tablet || Cu.phone) {
            var i2;
            if (Cu.apple.device) {
              if (i2 = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) parseInt(i2[1], 10) < 11 && (e2 = false);
            }
            if (Cu.android.device) {
              if (i2 = navigator.userAgent.match(/Android\s([0-9.]*)/)) parseInt(i2[1], 10) < 7 && (e2 = false);
            }
          }
          return e2 ? t2 : 4;
        }(32),
        SPRITE_BATCH_SIZE: 4096,
        RENDER_OPTIONS: { view: null, antialias: false, autoDensity: false, backgroundColor: 0, backgroundAlpha: 1, useContextAlpha: true, clearBeforeRender: true, preserveDrawingBuffer: false, width: 800, height: 600, legacy: false },
        GC_MODE: Eu.AUTO,
        GC_MAX_IDLE: 3600,
        GC_MAX_CHECK_COUNT: 600,
        WRAP_MODE: yu.CLAMP,
        SCALE_MODE: _u.LINEAR,
        PRECISION_VERTEX: Su.HIGH,
        PRECISION_FRAGMENT: Cu.apple.device ? Su.HIGH : Su.MEDIUM,
        CAN_UPLOAD_SAME_BUFFER: !Cu.apple.device,
        CREATE_IMAGE_BITMAP: false,
        ROUND_PIXELS: false,
        /*!
         * @pixi/display - v6.4.2
         * Compiled Thu, 02 Jun 2022 15:39:26 UTC
         *
         * @pixi/display is licensed under the MIT License.
         * http://www.opensource.org/licenses/mit-license
         */
        SORTABLE_CHILDREN: false
      }, Iu = function() {
        function t2() {
          this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
        }
        return t2.prototype.isEmpty = function() {
          return this.minX > this.maxX || this.minY > this.maxY;
        }, t2.prototype.clear = function() {
          this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
        }, t2.prototype.getRectangle = function(t3) {
          return this.minX > this.maxX || this.minY > this.maxY ? Lh.j.EMPTY : ((t3 = t3 || new Lh.j(0, 0, 1, 1)).x = this.minX, t3.y = this.minY, t3.width = this.maxX - this.minX, t3.height = this.maxY - this.minY, t3);
        }, t2.prototype.addPoint = function(t3) {
          this.minX = Math.min(this.minX, t3.x), this.maxX = Math.max(this.maxX, t3.x), this.minY = Math.min(this.minY, t3.y), this.maxY = Math.max(this.maxY, t3.y);
        }, t2.prototype.addPointMatrix = function(t3, e2) {
          var i2 = t3.a, n2 = t3.b, r2 = t3.c, o2 = t3.d, s2 = t3.tx, a2 = t3.ty, l2 = i2 * e2.x + r2 * e2.y + s2, h2 = n2 * e2.x + o2 * e2.y + a2;
          this.minX = Math.min(this.minX, l2), this.maxX = Math.max(this.maxX, l2), this.minY = Math.min(this.minY, h2), this.maxY = Math.max(this.maxY, h2);
        }, t2.prototype.addQuad = function(t3) {
          var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY, o2 = t3[0], s2 = t3[1];
          e2 = o2 < e2 ? o2 : e2, i2 = s2 < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[2]) < e2 ? o2 : e2, i2 = (s2 = t3[3]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[4]) < e2 ? o2 : e2, i2 = (s2 = t3[5]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, e2 = (o2 = t3[6]) < e2 ? o2 : e2, i2 = (s2 = t3[7]) < i2 ? s2 : i2, n2 = o2 > n2 ? o2 : n2, r2 = s2 > r2 ? s2 : r2, this.minX = e2, this.minY = i2, this.maxX = n2, this.maxY = r2;
        }, t2.prototype.addFrame = function(t3, e2, i2, n2, r2) {
          this.addFrameMatrix(t3.worldTransform, e2, i2, n2, r2);
        }, t2.prototype.addFrameMatrix = function(t3, e2, i2, n2, r2) {
          var o2 = t3.a, s2 = t3.b, a2 = t3.c, l2 = t3.d, h2 = t3.tx, u2 = t3.ty, c2 = this.minX, d2 = this.minY, p2 = this.maxX, f2 = this.maxY, m2 = o2 * e2 + a2 * i2 + h2, g2 = s2 * e2 + l2 * i2 + u2;
          c2 = m2 < c2 ? m2 : c2, d2 = g2 < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * i2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * i2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * e2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * e2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, c2 = (m2 = o2 * n2 + a2 * r2 + h2) < c2 ? m2 : c2, d2 = (g2 = s2 * n2 + l2 * r2 + u2) < d2 ? g2 : d2, p2 = m2 > p2 ? m2 : p2, f2 = g2 > f2 ? g2 : f2, this.minX = c2, this.minY = d2, this.maxX = p2, this.maxY = f2;
        }, t2.prototype.addVertexData = function(t3, e2, i2) {
          for (var n2 = this.minX, r2 = this.minY, o2 = this.maxX, s2 = this.maxY, a2 = e2; a2 < i2; a2 += 2) {
            var l2 = t3[a2], h2 = t3[a2 + 1];
            n2 = l2 < n2 ? l2 : n2, r2 = h2 < r2 ? h2 : r2, o2 = l2 > o2 ? l2 : o2, s2 = h2 > s2 ? h2 : s2;
          }
          this.minX = n2, this.minY = r2, this.maxX = o2, this.maxY = s2;
        }, t2.prototype.addVertices = function(t3, e2, i2, n2) {
          this.addVerticesMatrix(t3.worldTransform, e2, i2, n2);
        }, t2.prototype.addVerticesMatrix = function(t3, e2, i2, n2, r2, o2) {
          void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = r2);
          for (var s2 = t3.a, a2 = t3.b, l2 = t3.c, h2 = t3.d, u2 = t3.tx, c2 = t3.ty, d2 = this.minX, p2 = this.minY, f2 = this.maxX, m2 = this.maxY, g2 = i2; g2 < n2; g2 += 2) {
            var v2 = e2[g2], _2 = e2[g2 + 1], y2 = s2 * v2 + l2 * _2 + u2, x2 = h2 * _2 + a2 * v2 + c2;
            d2 = Math.min(d2, y2 - r2), f2 = Math.max(f2, y2 + r2), p2 = Math.min(p2, x2 - o2), m2 = Math.max(m2, x2 + o2);
          }
          this.minX = d2, this.minY = p2, this.maxX = f2, this.maxY = m2;
        }, t2.prototype.addBounds = function(t3) {
          var e2 = this.minX, i2 = this.minY, n2 = this.maxX, r2 = this.maxY;
          this.minX = t3.minX < e2 ? t3.minX : e2, this.minY = t3.minY < i2 ? t3.minY : i2, this.maxX = t3.maxX > n2 ? t3.maxX : n2, this.maxY = t3.maxY > r2 ? t3.maxY : r2;
        }, t2.prototype.addBoundsMask = function(t3, e2) {
          var i2 = t3.minX > e2.minX ? t3.minX : e2.minX, n2 = t3.minY > e2.minY ? t3.minY : e2.minY, r2 = t3.maxX < e2.maxX ? t3.maxX : e2.maxX, o2 = t3.maxY < e2.maxY ? t3.maxY : e2.maxY;
          if (i2 <= r2 && n2 <= o2) {
            var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
            this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
          }
        }, t2.prototype.addBoundsMatrix = function(t3, e2) {
          this.addFrameMatrix(e2, t3.minX, t3.minY, t3.maxX, t3.maxY);
        }, t2.prototype.addBoundsArea = function(t3, e2) {
          var i2 = t3.minX > e2.x ? t3.minX : e2.x, n2 = t3.minY > e2.y ? t3.minY : e2.y, r2 = t3.maxX < e2.x + e2.width ? t3.maxX : e2.x + e2.width, o2 = t3.maxY < e2.y + e2.height ? t3.maxY : e2.y + e2.height;
          if (i2 <= r2 && n2 <= o2) {
            var s2 = this.minX, a2 = this.minY, l2 = this.maxX, h2 = this.maxY;
            this.minX = i2 < s2 ? i2 : s2, this.minY = n2 < a2 ? n2 : a2, this.maxX = r2 > l2 ? r2 : l2, this.maxY = o2 > h2 ? o2 : h2;
          }
        }, t2.prototype.pad = function(t3, e2) {
          void 0 === t3 && (t3 = 0), void 0 === e2 && (e2 = t3), this.isEmpty() || (this.minX -= t3, this.maxX += t3, this.minY -= e2, this.maxY += e2);
        }, t2.prototype.addFramePad = function(t3, e2, i2, n2, r2, o2) {
          t3 -= r2, e2 -= o2, i2 += r2, n2 += o2, this.minX = this.minX < t3 ? this.minX : t3, this.maxX = this.maxX > i2 ? this.maxX : i2, this.minY = this.minY < e2 ? this.minY : e2, this.maxY = this.maxY > n2 ? this.maxY : n2;
        }, t2;
      }(), Pu = function(t2, e2) {
        return (Pu = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function Ou(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        Pu(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var Nu, Lu, Du, Fu, Bu, Uu, ku, Gu, Hu, ju, zu, Vu, Xu, Wu, Yu, qu, Zu, Ju, Ku, Qu = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.tempDisplayObjectParent = null, e3.transform = new Lh.m(), e3.alpha = 1, e3.visible = true, e3.renderable = true, e3.cullable = false, e3.cullArea = null, e3.parent = null, e3.worldAlpha = 1, e3._lastSortedIndex = 0, e3._zIndex = 0, e3.filterArea = null, e3.filters = null, e3._enabledFilters = null, e3._bounds = new Iu(), e3._localBounds = null, e3._boundsID = 0, e3._boundsRect = null, e3._localBoundsRect = null, e3._mask = null, e3._maskRefCount = 0, e3._destroyed = false, e3.isSprite = false, e3.isMask = false, e3;
        }
        return Ou(e2, t2), e2.mixin = function(t3) {
          for (var i2 = Object.keys(t3), n2 = 0; n2 < i2.length; ++n2) {
            var r2 = i2[n2];
            Object.defineProperty(e2.prototype, r2, Object.getOwnPropertyDescriptor(t3, r2));
          }
        }, Object.defineProperty(e2.prototype, "destroyed", { get: function() {
          return this._destroyed;
        }, enumerable: false, configurable: true }), e2.prototype._recursivePostUpdateTransform = function() {
          this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }, e2.prototype.updateTransform = function() {
          this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
        }, e2.prototype.getBounds = function(t3, e3) {
          return t3 || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e3 || (this._boundsRect || (this._boundsRect = new Lh.j()), e3 = this._boundsRect), this._bounds.getRectangle(e3);
        }, e2.prototype.getLocalBounds = function(t3) {
          t3 || (this._localBoundsRect || (this._localBoundsRect = new Lh.j()), t3 = this._localBoundsRect), this._localBounds || (this._localBounds = new Iu());
          var e3 = this.transform, i2 = this.parent;
          this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
          var n2 = this._bounds, r2 = this._boundsID;
          this._bounds = this._localBounds;
          var o2 = this.getBounds(false, t3);
          return this.parent = i2, this.transform = e3, this._bounds = n2, this._bounds.updateID += this._boundsID - r2, o2;
        }, e2.prototype.toGlobal = function(t3, e3, i2) {
          return void 0 === i2 && (i2 = false), i2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t3, e3);
        }, e2.prototype.toLocal = function(t3, e3, i2, n2) {
          return e3 && (t3 = e3.toGlobal(t3, i2, n2)), n2 || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t3, i2);
        }, e2.prototype.setParent = function(t3) {
          if (!t3 || !t3.addChild) throw new Error("setParent: Argument must be a Container");
          return t3.addChild(this), t3;
        }, e2.prototype.setTransform = function(t3, e3, i2, n2, r2, o2, s2, a2, l2) {
          return void 0 === t3 && (t3 = 0), void 0 === e3 && (e3 = 0), void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = 1), void 0 === r2 && (r2 = 0), void 0 === o2 && (o2 = 0), void 0 === s2 && (s2 = 0), void 0 === a2 && (a2 = 0), void 0 === l2 && (l2 = 0), this.position.x = t3, this.position.y = e3, this.scale.x = i2 || 1, this.scale.y = n2 || 1, this.rotation = r2, this.skew.x = o2, this.skew.y = s2, this.pivot.x = a2, this.pivot.y = l2, this;
        }, e2.prototype.destroy = function(t3) {
          this.parent && this.parent.removeChild(this), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = false, this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
        }, Object.defineProperty(e2.prototype, "_tempDisplayObjectParent", { get: function() {
          return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new $u()), this.tempDisplayObjectParent;
        }, enumerable: false, configurable: true }), e2.prototype.enableTempParent = function() {
          var t3 = this.parent;
          return this.parent = this._tempDisplayObjectParent, t3;
        }, e2.prototype.disableTempParent = function(t3) {
          this.parent = t3;
        }, Object.defineProperty(e2.prototype, "x", { get: function() {
          return this.position.x;
        }, set: function(t3) {
          this.transform.position.x = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "y", { get: function() {
          return this.position.y;
        }, set: function(t3) {
          this.transform.position.y = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldTransform", { get: function() {
          return this.transform.worldTransform;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "localTransform", { get: function() {
          return this.transform.localTransform;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "position", { get: function() {
          return this.transform.position;
        }, set: function(t3) {
          this.transform.position.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "scale", { get: function() {
          return this.transform.scale;
        }, set: function(t3) {
          this.transform.scale.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "pivot", { get: function() {
          return this.transform.pivot;
        }, set: function(t3) {
          this.transform.pivot.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "skew", { get: function() {
          return this.transform.skew;
        }, set: function(t3) {
          this.transform.skew.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "rotation", { get: function() {
          return this.transform.rotation;
        }, set: function(t3) {
          this.transform.rotation = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "angle", { get: function() {
          return this.transform.rotation * Lh.i;
        }, set: function(t3) {
          this.transform.rotation = t3 * Lh.b;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "zIndex", { get: function() {
          return this._zIndex;
        }, set: function(t3) {
          this._zIndex = t3, this.parent && (this.parent.sortDirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "worldVisible", { get: function() {
          var t3 = this;
          do {
            if (!t3.visible) return false;
            t3 = t3.parent;
          } while (t3);
          return true;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mask", { get: function() {
          return this._mask;
        }, set: function(t3) {
          if (this._mask !== t3) {
            var e3;
            if (this._mask) (e3 = this._mask.maskObject || this._mask)._maskRefCount--, 0 === e3._maskRefCount && (e3.renderable = true, e3.isMask = false);
            if (this._mask = t3, this._mask) 0 === (e3 = this._mask.maskObject || this._mask)._maskRefCount && (e3.renderable = false, e3.isMask = true), e3._maskRefCount++;
          }
        }, enumerable: false, configurable: true }), e2;
      }(Ph.EventEmitter), $u = function(t2) {
        function e2() {
          var e3 = null !== t2 && t2.apply(this, arguments) || this;
          return e3.sortDirty = null, e3;
        }
        return Ou(e2, t2), e2;
      }(Qu);
      function tc(t2, e2) {
        return t2.zIndex === e2.zIndex ? t2._lastSortedIndex - e2._lastSortedIndex : t2.zIndex - e2.zIndex;
      }
      Qu.prototype.displayObjectUpdateTransform = Qu.prototype.updateTransform, function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(Nu || (Nu = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(Lu || (Lu = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(Du || (Du = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(Fu || (Fu = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(Bu || (Bu = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(Uu || (Uu = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(ku || (ku = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(Gu || (Gu = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(Hu || (Hu = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(ju || (ju = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(zu || (zu = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(Vu || (Vu = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(Xu || (Xu = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(Wu || (Wu = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(Yu || (Yu = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(qu || (qu = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(Zu || (Zu = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(Ju || (Ju = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(Ku || (Ku = {}));
      var ec = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.children = [], e3.sortableChildren = Ru.SORTABLE_CHILDREN, e3.sortDirty = false, e3;
        }
        return Ou(e2, t2), e2.prototype.onChildrenChange = function(t3) {
        }, e2.prototype.addChild = function() {
          for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++) e3[i2] = t3[i2];
          if (e3.length > 1) for (var n2 = 0; n2 < e3.length; n2++) this.addChild(e3[n2]);
          else {
            var r2 = e3[0];
            r2.parent && r2.parent.removeChild(r2), r2.parent = this, this.sortDirty = true, r2.transform._parentID = -1, this.children.push(r2), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", r2, this, this.children.length - 1), r2.emit("added", this);
          }
          return e3[0];
        }, e2.prototype.addChildAt = function(t3, e3) {
          if (e3 < 0 || e3 > this.children.length) throw new Error(t3 + "addChildAt: The index " + e3 + " supplied is out of bounds " + this.children.length);
          return t3.parent && t3.parent.removeChild(t3), t3.parent = this, this.sortDirty = true, t3.transform._parentID = -1, this.children.splice(e3, 0, t3), this._boundsID++, this.onChildrenChange(e3), t3.emit("added", this), this.emit("childAdded", t3, this, e3), t3;
        }, e2.prototype.swapChildren = function(t3, e3) {
          if (t3 !== e3) {
            var i2 = this.getChildIndex(t3), n2 = this.getChildIndex(e3);
            this.children[i2] = e3, this.children[n2] = t3, this.onChildrenChange(i2 < n2 ? i2 : n2);
          }
        }, e2.prototype.getChildIndex = function(t3) {
          var e3 = this.children.indexOf(t3);
          if (-1 === e3) throw new Error("The supplied DisplayObject must be a child of the caller");
          return e3;
        }, e2.prototype.setChildIndex = function(t3, e3) {
          if (e3 < 0 || e3 >= this.children.length) throw new Error("The index " + e3 + " supplied is out of bounds " + this.children.length);
          var i2 = this.getChildIndex(t3);
          Object(Ph.removeItems)(this.children, i2, 1), this.children.splice(e3, 0, t3), this.onChildrenChange(e3);
        }, e2.prototype.getChildAt = function(t3) {
          if (t3 < 0 || t3 >= this.children.length) throw new Error("getChildAt: Index (" + t3 + ") does not exist.");
          return this.children[t3];
        }, e2.prototype.removeChild = function() {
          for (var t3 = arguments, e3 = [], i2 = 0; i2 < arguments.length; i2++) e3[i2] = t3[i2];
          if (e3.length > 1) for (var n2 = 0; n2 < e3.length; n2++) this.removeChild(e3[n2]);
          else {
            var r2 = e3[0], o2 = this.children.indexOf(r2);
            if (-1 === o2) return null;
            r2.parent = null, r2.transform._parentID = -1, Object(Ph.removeItems)(this.children, o2, 1), this._boundsID++, this.onChildrenChange(o2), r2.emit("removed", this), this.emit("childRemoved", r2, this, o2);
          }
          return e3[0];
        }, e2.prototype.removeChildAt = function(t3) {
          var e3 = this.getChildAt(t3);
          return e3.parent = null, e3.transform._parentID = -1, Object(Ph.removeItems)(this.children, t3, 1), this._boundsID++, this.onChildrenChange(t3), e3.emit("removed", this), this.emit("childRemoved", e3, this, t3), e3;
        }, e2.prototype.removeChildren = function(t3, e3) {
          void 0 === t3 && (t3 = 0), void 0 === e3 && (e3 = this.children.length);
          var i2, n2 = t3, r2 = e3 - n2;
          if (r2 > 0 && r2 <= e3) {
            i2 = this.children.splice(n2, r2);
            for (var o2 = 0; o2 < i2.length; ++o2) i2[o2].parent = null, i2[o2].transform && (i2[o2].transform._parentID = -1);
            this._boundsID++, this.onChildrenChange(t3);
            for (o2 = 0; o2 < i2.length; ++o2) i2[o2].emit("removed", this), this.emit("childRemoved", i2[o2], this, o2);
            return i2;
          }
          if (0 === r2 && 0 === this.children.length) return [];
          throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
        }, e2.prototype.sortChildren = function() {
          for (var t3 = false, e3 = 0, i2 = this.children.length; e3 < i2; ++e3) {
            var n2 = this.children[e3];
            n2._lastSortedIndex = e3, t3 || 0 === n2.zIndex || (t3 = true);
          }
          t3 && this.children.length > 1 && this.children.sort(tc), this.sortDirty = false;
        }, e2.prototype.updateTransform = function() {
          this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
          for (var t3 = 0, e3 = this.children.length; t3 < e3; ++t3) {
            var i2 = this.children[t3];
            i2.visible && i2.updateTransform();
          }
        }, e2.prototype.calculateBounds = function() {
          this._bounds.clear(), this._calculateBounds();
          for (var t3 = 0; t3 < this.children.length; t3++) {
            var e3 = this.children[t3];
            if (e3.visible && e3.renderable) if (e3.calculateBounds(), e3._mask) {
              var i2 = e3._mask.maskObject || e3._mask;
              i2.calculateBounds(), this._bounds.addBoundsMask(e3._bounds, i2._bounds);
            } else e3.filterArea ? this._bounds.addBoundsArea(e3._bounds, e3.filterArea) : this._bounds.addBounds(e3._bounds);
          }
          this._bounds.updateID = this._boundsID;
        }, e2.prototype.getLocalBounds = function(e3, i2) {
          void 0 === i2 && (i2 = false);
          var n2 = t2.prototype.getLocalBounds.call(this, e3);
          if (!i2) for (var r2 = 0, o2 = this.children.length; r2 < o2; ++r2) {
            var s2 = this.children[r2];
            s2.visible && s2.updateTransform();
          }
          return n2;
        }, e2.prototype._calculateBounds = function() {
        }, e2.prototype._renderWithCulling = function(t3) {
          var i2 = t3.renderTexture.sourceFrame;
          if (i2.width > 0 && i2.height > 0) {
            var n2, r2;
            if (this.cullArea ? (n2 = this.cullArea, r2 = this.worldTransform) : this._render !== e2.prototype._render && (n2 = this.getBounds(true)), n2 && i2.intersects(n2, r2)) this._render(t3);
            else if (this.cullArea) return;
            for (var o2 = 0, s2 = this.children.length; o2 < s2; ++o2) {
              var a2 = this.children[o2], l2 = a2.cullable;
              a2.cullable = l2 || !this.cullArea, a2.render(t3), a2.cullable = l2;
            }
          }
        }, e2.prototype.render = function(t3) {
          if (this.visible && !(this.worldAlpha <= 0) && this.renderable) if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t3);
          else if (this.cullable) this._renderWithCulling(t3);
          else {
            this._render(t3);
            for (var e3 = 0, i2 = this.children.length; e3 < i2; ++e3) this.children[e3].render(t3);
          }
        }, e2.prototype.renderAdvanced = function(t3) {
          var e3 = this.filters, i2 = this._mask;
          if (e3) {
            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
            for (var n2 = 0; n2 < e3.length; n2++) e3[n2].enabled && this._enabledFilters.push(e3[n2]);
          }
          var r2 = e3 && this._enabledFilters && this._enabledFilters.length || i2 && (!i2.isMaskData || i2.enabled && (i2.autoDetect || i2.type !== Zu.NONE));
          if (r2 && t3.batch.flush(), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.push(this, this._enabledFilters), i2 && t3.mask.push(this, this._mask), this.cullable) this._renderWithCulling(t3);
          else {
            this._render(t3);
            n2 = 0;
            for (var o2 = this.children.length; n2 < o2; ++n2) this.children[n2].render(t3);
          }
          r2 && t3.batch.flush(), i2 && t3.mask.pop(this), e3 && this._enabledFilters && this._enabledFilters.length && t3.filter.pop();
        }, e2.prototype._render = function(t3) {
        }, e2.prototype.destroy = function(e3) {
          t2.prototype.destroy.call(this), this.sortDirty = false;
          var i2 = "boolean" == typeof e3 ? e3 : e3 && e3.children, n2 = this.removeChildren(0, this.children.length);
          if (i2) for (var r2 = 0; r2 < n2.length; ++r2) n2[r2].destroy(e3);
        }, Object.defineProperty(e2.prototype, "width", { get: function() {
          return this.scale.x * this.getLocalBounds().width;
        }, set: function(t3) {
          var e3 = this.getLocalBounds().width;
          this.scale.x = 0 !== e3 ? t3 / e3 : 1, this._width = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this.scale.y * this.getLocalBounds().height;
        }, set: function(t3) {
          var e3 = this.getLocalBounds().height;
          this.scale.y = 0 !== e3 ? t3 / e3 : 1, this._height = t3;
        }, enumerable: false, configurable: true }), e2;
      }(Qu);
      ec.prototype.containerUpdateTransform = ec.prototype.updateTransform;
      var ic = new Lh.j(), nc = function() {
        function t2(t3) {
          this.renderer = t3;
        }
        return t2.prototype.image = function(t3, e2, i2) {
          var n2 = new Image();
          return n2.src = this.base64(t3, e2, i2), n2;
        }, t2.prototype.base64 = function(t3, e2, i2) {
          return this.canvas(t3).toDataURL(e2, i2);
        }, t2.prototype.canvas = function(e2) {
          var i2, n2, r2, o2 = this.renderer, s2 = false, a2 = false;
          e2 && (e2 instanceof Vh.p ? r2 = e2 : (r2 = this.renderer.generateTexture(e2), a2 = true)), r2 ? (i2 = r2.baseTexture.resolution, n2 = r2.frame, s2 = false, o2.renderTexture.bind(r2)) : (i2 = this.renderer.resolution, s2 = true, (n2 = ic).width = this.renderer.width, n2.height = this.renderer.height, o2.renderTexture.bind(null));
          var l2 = Math.floor(n2.width * i2 + 1e-4), h2 = Math.floor(n2.height * i2 + 1e-4), u2 = new Ph.CanvasRenderTarget(l2, h2, 1), c2 = new Uint8Array(4 * l2 * h2), d2 = o2.gl;
          d2.readPixels(n2.x * i2, n2.y * i2, l2, h2, d2.RGBA, d2.UNSIGNED_BYTE, c2);
          var p2 = u2.context.getImageData(0, 0, l2, h2);
          if (t2.arrayPostDivide(c2, p2.data), u2.context.putImageData(p2, 0, 0), s2) {
            var f2 = new Ph.CanvasRenderTarget(u2.width, u2.height, 1);
            f2.context.scale(1, -1), f2.context.drawImage(u2.canvas, 0, -h2), u2.destroy(), u2 = f2;
          }
          return a2 && r2.destroy(true), u2.canvas;
        }, t2.prototype.pixels = function(e2, i2) {
          var n2, r2, o2, s2 = this.renderer, a2 = false;
          e2 && (e2 instanceof Vh.p ? o2 = e2 : e2 instanceof Qu && (o2 = this.renderer.generateTexture(e2), a2 = true)), o2 ? i2 ? (n2 = i2.resolution, r2 = o2.frame, s2.renderTexture.bind(o2)) : (n2 = o2.baseTexture.resolution, r2 = o2.frame, s2.renderTexture.bind(o2)) : i2 ? (n2 = i2.resolution, (r2 = ic).width = i2.width, r2.height = i2.height, s2.renderTexture.bind(null)) : (n2 = s2.resolution, (r2 = ic).width = s2.width, r2.height = s2.height, s2.renderTexture.bind(null));
          var l2 = r2.width * n2, h2 = r2.height * n2, u2 = new Uint8Array(4 * l2 * h2), c2 = s2.gl;
          return c2.readPixels(r2.x * n2, r2.y * n2, l2, h2, c2.RGBA, c2.UNSIGNED_BYTE, u2), a2 && o2.destroy(true), t2.arrayPostDivide(u2, u2), u2;
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2.arrayPostDivide = function(t3, e2) {
          for (var i2 = 0; i2 < t3.length; i2 += 4) {
            var n2 = e2[i2 + 3] = t3[i2 + 3];
            0 !== n2 ? (e2[i2] = Math.round(Math.min(255 * t3[i2] / n2, 255)), e2[i2 + 1] = Math.round(Math.min(255 * t3[i2 + 1] / n2, 255)), e2[i2 + 2] = Math.round(Math.min(255 * t3[i2 + 2] / n2, 255))) : (e2[i2] = t3[i2], e2[i2 + 1] = t3[i2 + 1], e2[i2 + 2] = t3[i2 + 2]);
          }
        }, t2;
      }(), rc = function() {
        function t2(t3, e2, i2) {
          void 0 === e2 && (e2 = false), this._fn = t3, this._once = e2, this._thisArg = i2, this._next = this._prev = this._owner = null;
        }
        return t2.prototype.detach = function() {
          return null !== this._owner && (this._owner.detach(this), true);
        }, t2;
      }();
      function oc(t2, e2) {
        return t2._head ? (t2._tail._next = e2, e2._prev = t2._tail, t2._tail = e2) : (t2._head = e2, t2._tail = e2), e2._owner = t2, e2;
      }
      var sc, ac = function() {
        function t2() {
          this._head = this._tail = void 0;
        }
        return t2.prototype.handlers = function(t3) {
          void 0 === t3 && (t3 = false);
          var e2 = this._head;
          if (t3) return !!e2;
          for (var i2 = []; e2; ) i2.push(e2), e2 = e2._next;
          return i2;
        }, t2.prototype.has = function(t3) {
          if (!(t3 instanceof rc)) throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
          return t3._owner === this;
        }, t2.prototype.dispatch = function() {
          for (var t3 = arguments, e2 = [], i2 = 0; i2 < arguments.length; i2++) e2[i2] = t3[i2];
          var n2 = this._head;
          if (!n2) return false;
          for (; n2; ) n2._once && this.detach(n2), n2._fn.apply(n2._thisArg, e2), n2 = n2._next;
          return true;
        }, t2.prototype.add = function(t3, e2) {
          if (void 0 === e2 && (e2 = null), "function" != typeof t3) throw new Error("MiniSignal#add(): First arg must be a Function.");
          return oc(this, new rc(t3, false, e2));
        }, t2.prototype.once = function(t3, e2) {
          if (void 0 === e2 && (e2 = null), "function" != typeof t3) throw new Error("MiniSignal#once(): First arg must be a Function.");
          return oc(this, new rc(t3, true, e2));
        }, t2.prototype.detach = function(t3) {
          if (!(t3 instanceof rc)) throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
          return t3._owner !== this || (t3._prev && (t3._prev._next = t3._next), t3._next && (t3._next._prev = t3._prev), t3 === this._head ? (this._head = t3._next, null === t3._next && (this._tail = null)) : t3 === this._tail && (this._tail = t3._prev, this._tail._next = null), t3._owner = null), this;
        }, t2.prototype.detachAll = function() {
          var t3 = this._head;
          if (!t3) return this;
          for (this._head = this._tail = null; t3; ) t3._owner = null, t3 = t3._next;
          return this;
        }, t2;
      }();
      function lc(t2, e2) {
        e2 = e2 || {};
        for (var i2 = { key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], q: { name: "queryKey", parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, n2 = i2.parser[e2.strictMode ? "strict" : "loose"].exec(t2), r2 = {}, o2 = 14; o2--; ) r2[i2.key[o2]] = n2[o2] || "";
        return r2[i2.q.name] = {}, r2[i2.key[12]].replace(i2.q.parser, function(t3, e3, n3) {
          e3 && (r2[i2.q.name][e3] = n3);
        }), r2;
      }
      var hc = null;
      function uc() {
      }
      function cc(t2, e2, i2) {
        e2 && 0 === e2.indexOf(".") && (e2 = e2.substring(1)), e2 && (t2[e2] = i2);
      }
      function dc(t2) {
        return t2.toString().replace("object ", "");
      }
      var pc = function() {
        function t2(e2, i2, n2) {
          if (this._dequeue = uc, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, "string" != typeof e2 || "string" != typeof i2) throw new Error("Both name and url are required for constructing a resource.");
          n2 = n2 || {}, this._flags = 0, this._setFlag(t2.STATUS_FLAGS.DATA_URL, 0 === i2.indexOf("data:")), this.name = e2, this.url = i2, this.extension = this._getExtension(), this.data = null, this.crossOrigin = true === n2.crossOrigin ? "anonymous" : n2.crossOrigin, this.timeout = n2.timeout || 0, this.loadType = n2.loadType || this._determineLoadType(), this.xhrType = n2.xhrType, this.metadata = n2.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t2.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = uc, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new ac(), this.onProgress = new ac(), this.onComplete = new ac(), this.onAfterMiddleware = new ac();
        }
        return t2.setExtensionLoadType = function(e2, i2) {
          cc(t2._loadTypeMap, e2, i2);
        }, t2.setExtensionXhrType = function(e2, i2) {
          cc(t2._xhrTypeMap, e2, i2);
        }, Object.defineProperty(t2.prototype, "isDataUrl", { get: function() {
          return this._hasFlag(t2.STATUS_FLAGS.DATA_URL);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isComplete", { get: function() {
          return this._hasFlag(t2.STATUS_FLAGS.COMPLETE);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "isLoading", { get: function() {
          return this._hasFlag(t2.STATUS_FLAGS.LOADING);
        }, enumerable: false, configurable: true }), t2.prototype.complete = function() {
          this._clearEvents(), this._finish();
        }, t2.prototype.abort = function(e2) {
          if (!this.error) {
            if (this.error = new Error(e2), this._clearEvents(), this.xhr) this.xhr.abort();
            else if (this.xdr) this.xdr.abort();
            else if (this.data) if (this.data.src) this.data.src = t2.EMPTY_GIF;
            else for (; this.data.firstChild; ) this.data.removeChild(this.data.firstChild);
            this._finish();
          }
        }, t2.prototype.load = function(e2) {
          var i2 = this;
          if (!this.isLoading) if (this.isComplete) e2 && setTimeout(function() {
            return e2(i2);
          }, 1);
          else switch (e2 && this.onComplete.once(e2), this._setFlag(t2.STATUS_FLAGS.LOADING, true), this.onStart.dispatch(this), false !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
            case t2.LOAD_TYPE.IMAGE:
              this.type = t2.TYPE.IMAGE, this._loadElement("image");
              break;
            case t2.LOAD_TYPE.AUDIO:
              this.type = t2.TYPE.AUDIO, this._loadSourceElement("audio");
              break;
            case t2.LOAD_TYPE.VIDEO:
              this.type = t2.TYPE.VIDEO, this._loadSourceElement("video");
              break;
            case t2.LOAD_TYPE.XHR:
            default:
              void 0 === sc && (sc = !(!globalThis.XDomainRequest || "withCredentials" in new XMLHttpRequest())), sc && this.crossOrigin ? this._loadXdr() : this._loadXhr();
          }
        }, t2.prototype._hasFlag = function(t3) {
          return 0 != (this._flags & t3);
        }, t2.prototype._setFlag = function(t3, e2) {
          this._flags = e2 ? this._flags | t3 : this._flags & ~t3;
        }, t2.prototype._clearEvents = function() {
          clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, false), this.data.removeEventListener("load", this._boundComplete, false), this.data.removeEventListener("progress", this._boundOnProgress, false), this.data.removeEventListener("canplaythrough", this._boundComplete, false)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, false), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, false), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, false), this.xhr.removeEventListener("progress", this._boundOnProgress, false), this.xhr.removeEventListener("load", this._boundXhrOnLoad, false)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
        }, t2.prototype._finish = function() {
          if (this.isComplete) throw new Error("Complete called again for an already completed resource.");
          this._setFlag(t2.STATUS_FLAGS.COMPLETE, true), this._setFlag(t2.STATUS_FLAGS.LOADING, false), this.onComplete.dispatch(this);
        }, t2.prototype._loadElement = function(t3) {
          this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t3 && void 0 !== globalThis.Image ? this.data = new Image() : this.data = document.createElement(t3), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, false), this.data.addEventListener("load", this._boundComplete, false), this.data.addEventListener("progress", this._boundOnProgress, false), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
        }, t2.prototype._loadSourceElement = function(t3) {
          if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t3 && void 0 !== globalThis.Audio ? this.data = new Audio() : this.data = document.createElement(t3), null !== this.data) {
            if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource) if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
            else if (Array.isArray(this.url)) for (var e2 = this.metadata.mimeType, i2 = 0; i2 < this.url.length; ++i2) this.data.appendChild(this._createSource(t3, this.url[i2], Array.isArray(e2) ? e2[i2] : e2));
            else {
              e2 = this.metadata.mimeType;
              this.data.appendChild(this._createSource(t3, this.url, Array.isArray(e2) ? e2[0] : e2));
            }
            this.data.addEventListener("error", this._boundOnError, false), this.data.addEventListener("load", this._boundComplete, false), this.data.addEventListener("progress", this._boundOnProgress, false), this.data.addEventListener("canplaythrough", this._boundComplete, false), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
          } else this.abort("Unsupported element: " + t3);
        }, t2.prototype._loadXhr = function() {
          "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
          var e2 = this.xhr = new XMLHttpRequest();
          "use-credentials" === this.crossOrigin && (e2.withCredentials = true), e2.open("GET", this.url, true), e2.timeout = this.timeout, this.xhrType === t2.XHR_RESPONSE_TYPE.JSON || this.xhrType === t2.XHR_RESPONSE_TYPE.DOCUMENT ? e2.responseType = t2.XHR_RESPONSE_TYPE.TEXT : e2.responseType = this.xhrType, e2.addEventListener("error", this._boundXhrOnError, false), e2.addEventListener("timeout", this._boundXhrOnTimeout, false), e2.addEventListener("abort", this._boundXhrOnAbort, false), e2.addEventListener("progress", this._boundOnProgress, false), e2.addEventListener("load", this._boundXhrOnLoad, false), e2.send();
        }, t2.prototype._loadXdr = function() {
          "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
          var t3 = this.xhr = new globalThis.XDomainRequest();
          t3.timeout = this.timeout || 5e3, t3.onerror = this._boundXhrOnError, t3.ontimeout = this._boundXhrOnTimeout, t3.onprogress = this._boundOnProgress, t3.onload = this._boundXhrOnLoad, t3.open("GET", this.url, true), setTimeout(function() {
            return t3.send();
          }, 1);
        }, t2.prototype._createSource = function(t3, e2, i2) {
          i2 || (i2 = t3 + "/" + this._getExtension(e2));
          var n2 = document.createElement("source");
          return n2.src = e2, n2.type = i2, n2;
        }, t2.prototype._onError = function(t3) {
          this.abort("Failed to load element using: " + t3.target.nodeName);
        }, t2.prototype._onProgress = function(t3) {
          t3 && t3.lengthComputable && this.onProgress.dispatch(this, t3.loaded / t3.total);
        }, t2.prototype._onTimeout = function() {
          this.abort("Load timed out.");
        }, t2.prototype._xhrOnError = function() {
          var t3 = this.xhr;
          this.abort(dc(t3) + " Request failed. Status: " + t3.status + ', text: "' + t3.statusText + '"');
        }, t2.prototype._xhrOnTimeout = function() {
          var t3 = this.xhr;
          this.abort(dc(t3) + " Request timed out.");
        }, t2.prototype._xhrOnAbort = function() {
          var t3 = this.xhr;
          this.abort(dc(t3) + " Request was aborted by the user.");
        }, t2.prototype._xhrOnLoad = function() {
          var e2 = this.xhr, i2 = "", n2 = void 0 === e2.status ? 200 : e2.status;
          if ("" !== e2.responseType && "text" !== e2.responseType && void 0 !== e2.responseType || (i2 = e2.responseText), 0 === n2 && (i2.length > 0 || e2.responseType === t2.XHR_RESPONSE_TYPE.BUFFER) ? n2 = 200 : 1223 === n2 && (n2 = 204), 2 === (n2 / 100 | 0)) {
            if (this.xhrType === t2.XHR_RESPONSE_TYPE.TEXT) this.data = i2, this.type = t2.TYPE.TEXT;
            else if (this.xhrType === t2.XHR_RESPONSE_TYPE.JSON) try {
              this.data = JSON.parse(i2), this.type = t2.TYPE.JSON;
            } catch (t3) {
              return void this.abort("Error trying to parse loaded json: " + t3);
            }
            else if (this.xhrType === t2.XHR_RESPONSE_TYPE.DOCUMENT) try {
              if (globalThis.DOMParser) {
                var r2 = new DOMParser();
                this.data = r2.parseFromString(i2, "text/xml");
              } else {
                var o2 = document.createElement("div");
                o2.innerHTML = i2, this.data = o2;
              }
              this.type = t2.TYPE.XML;
            } catch (t3) {
              return void this.abort("Error trying to parse loaded xml: " + t3);
            }
            else this.data = e2.response || i2;
            this.complete();
          } else this.abort("[" + e2.status + "] " + e2.statusText + ": " + e2.responseURL);
        }, t2.prototype._determineCrossOrigin = function(t3, e2) {
          if (0 === t3.indexOf("data:")) return "";
          if (globalThis.origin !== globalThis.location.origin) return "anonymous";
          e2 = e2 || globalThis.location, hc || (hc = document.createElement("a")), hc.href = t3;
          var i2 = lc(hc.href, { strictMode: true }), n2 = !i2.port && "" === e2.port || i2.port === e2.port, r2 = i2.protocol ? i2.protocol + ":" : "";
          return i2.host === e2.hostname && n2 && r2 === e2.protocol ? "" : "anonymous";
        }, t2.prototype._determineXhrType = function() {
          return t2._xhrTypeMap[this.extension] || t2.XHR_RESPONSE_TYPE.TEXT;
        }, t2.prototype._determineLoadType = function() {
          return t2._loadTypeMap[this.extension] || t2.LOAD_TYPE.XHR;
        }, t2.prototype._getExtension = function(t3) {
          void 0 === t3 && (t3 = this.url);
          var e2 = "";
          if (this.isDataUrl) {
            var i2 = t3.indexOf("/");
            e2 = t3.substring(i2 + 1, t3.indexOf(";", i2));
          } else {
            var n2 = t3.indexOf("?"), r2 = t3.indexOf("#"), o2 = Math.min(n2 > -1 ? n2 : t3.length, r2 > -1 ? r2 : t3.length);
            e2 = (t3 = t3.substring(0, o2)).substring(t3.lastIndexOf(".") + 1);
          }
          return e2.toLowerCase();
        }, t2.prototype._getMimeFromXhrType = function(e2) {
          switch (e2) {
            case t2.XHR_RESPONSE_TYPE.BUFFER:
              return "application/octet-binary";
            case t2.XHR_RESPONSE_TYPE.BLOB:
              return "application/blob";
            case t2.XHR_RESPONSE_TYPE.DOCUMENT:
              return "application/xml";
            case t2.XHR_RESPONSE_TYPE.JSON:
              return "application/json";
            case t2.XHR_RESPONSE_TYPE.DEFAULT:
            case t2.XHR_RESPONSE_TYPE.TEXT:
            default:
              return "text/plain";
          }
        }, t2;
      }();
      function fc() {
      }
      function mc(t2) {
        return function() {
          for (var e2 = arguments, i2 = [], n2 = 0; n2 < arguments.length; n2++) i2[n2] = e2[n2];
          if (null === t2) throw new Error("Callback was already called.");
          var r2 = t2;
          t2 = null, r2.apply(this, i2);
        };
      }
      !function(t2) {
        var e2, i2, n2, r2;
        (e2 = t2.STATUS_FLAGS || (t2.STATUS_FLAGS = {}))[e2.NONE = 0] = "NONE", e2[e2.DATA_URL = 1] = "DATA_URL", e2[e2.COMPLETE = 2] = "COMPLETE", e2[e2.LOADING = 4] = "LOADING", (i2 = t2.TYPE || (t2.TYPE = {}))[i2.UNKNOWN = 0] = "UNKNOWN", i2[i2.JSON = 1] = "JSON", i2[i2.XML = 2] = "XML", i2[i2.IMAGE = 3] = "IMAGE", i2[i2.AUDIO = 4] = "AUDIO", i2[i2.VIDEO = 5] = "VIDEO", i2[i2.TEXT = 6] = "TEXT", (n2 = t2.LOAD_TYPE || (t2.LOAD_TYPE = {}))[n2.XHR = 1] = "XHR", n2[n2.IMAGE = 2] = "IMAGE", n2[n2.AUDIO = 3] = "AUDIO", n2[n2.VIDEO = 4] = "VIDEO", (r2 = t2.XHR_RESPONSE_TYPE || (t2.XHR_RESPONSE_TYPE = {})).DEFAULT = "text", r2.BUFFER = "arraybuffer", r2.BLOB = "blob", r2.DOCUMENT = "document", r2.JSON = "json", r2.TEXT = "text", t2._loadTypeMap = { gif: t2.LOAD_TYPE.IMAGE, png: t2.LOAD_TYPE.IMAGE, bmp: t2.LOAD_TYPE.IMAGE, jpg: t2.LOAD_TYPE.IMAGE, jpeg: t2.LOAD_TYPE.IMAGE, tif: t2.LOAD_TYPE.IMAGE, tiff: t2.LOAD_TYPE.IMAGE, webp: t2.LOAD_TYPE.IMAGE, tga: t2.LOAD_TYPE.IMAGE, svg: t2.LOAD_TYPE.IMAGE, "svg+xml": t2.LOAD_TYPE.IMAGE, mp3: t2.LOAD_TYPE.AUDIO, ogg: t2.LOAD_TYPE.AUDIO, wav: t2.LOAD_TYPE.AUDIO, mp4: t2.LOAD_TYPE.VIDEO, webm: t2.LOAD_TYPE.VIDEO }, t2._xhrTypeMap = { xhtml: t2.XHR_RESPONSE_TYPE.DOCUMENT, html: t2.XHR_RESPONSE_TYPE.DOCUMENT, htm: t2.XHR_RESPONSE_TYPE.DOCUMENT, xml: t2.XHR_RESPONSE_TYPE.DOCUMENT, tmx: t2.XHR_RESPONSE_TYPE.DOCUMENT, svg: t2.XHR_RESPONSE_TYPE.DOCUMENT, tsx: t2.XHR_RESPONSE_TYPE.DOCUMENT, gif: t2.XHR_RESPONSE_TYPE.BLOB, png: t2.XHR_RESPONSE_TYPE.BLOB, bmp: t2.XHR_RESPONSE_TYPE.BLOB, jpg: t2.XHR_RESPONSE_TYPE.BLOB, jpeg: t2.XHR_RESPONSE_TYPE.BLOB, tif: t2.XHR_RESPONSE_TYPE.BLOB, tiff: t2.XHR_RESPONSE_TYPE.BLOB, webp: t2.XHR_RESPONSE_TYPE.BLOB, tga: t2.XHR_RESPONSE_TYPE.BLOB, json: t2.XHR_RESPONSE_TYPE.JSON, text: t2.XHR_RESPONSE_TYPE.TEXT, txt: t2.XHR_RESPONSE_TYPE.TEXT, ttf: t2.XHR_RESPONSE_TYPE.BUFFER, otf: t2.XHR_RESPONSE_TYPE.BUFFER }, t2.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
      }(pc || (pc = {}));
      var gc = function(t2, e2) {
        this.data = t2, this.callback = e2;
      }, vc = function() {
        function t2(t3, e2) {
          var i2 = this;
          if (void 0 === e2 && (e2 = 1), this.workers = 0, this.saturated = fc, this.unsaturated = fc, this.empty = fc, this.drain = fc, this.error = fc, this.started = false, this.paused = false, this._tasks = [], this._insert = function(t4, e3, n2) {
            if (n2 && "function" != typeof n2) throw new Error("task callback must be a function");
            if (i2.started = true, null == t4 && i2.idle()) setTimeout(function() {
              return i2.drain();
            }, 1);
            else {
              var r2 = new gc(t4, "function" == typeof n2 ? n2 : fc);
              e3 ? i2._tasks.unshift(r2) : i2._tasks.push(r2), setTimeout(i2.process, 1);
            }
          }, this.process = function() {
            for (; !i2.paused && i2.workers < i2.concurrency && i2._tasks.length; ) {
              var t4 = i2._tasks.shift();
              0 === i2._tasks.length && i2.empty(), i2.workers += 1, i2.workers === i2.concurrency && i2.saturated(), i2._worker(t4.data, mc(i2._next(t4)));
            }
          }, this._worker = t3, 0 === e2) throw new Error("Concurrency must not be zero");
          this.concurrency = e2, this.buffer = e2 / 4;
        }
        return t2.prototype._next = function(t3) {
          var e2 = this;
          return function() {
            for (var i2 = arguments, n2 = [], r2 = 0; r2 < arguments.length; r2++) n2[r2] = i2[r2];
            e2.workers -= 1, t3.callback.apply(t3, n2), null != n2[0] && e2.error(n2[0], t3.data), e2.workers <= e2.concurrency - e2.buffer && e2.unsaturated(), e2.idle() && e2.drain(), e2.process();
          };
        }, t2.prototype.push = function(t3, e2) {
          this._insert(t3, false, e2);
        }, t2.prototype.kill = function() {
          this.workers = 0, this.drain = fc, this.started = false, this._tasks = [];
        }, t2.prototype.unshift = function(t3, e2) {
          this._insert(t3, true, e2);
        }, t2.prototype.length = function() {
          return this._tasks.length;
        }, t2.prototype.running = function() {
          return this.workers;
        }, t2.prototype.idle = function() {
          return this._tasks.length + this.workers === 0;
        }, t2.prototype.pause = function() {
          true !== this.paused && (this.paused = true);
        }, t2.prototype.resume = function() {
          if (false !== this.paused) {
            this.paused = false;
            for (var t3 = 1; t3 <= this.concurrency; t3++) this.process();
          }
        }, t2.eachSeries = function(t3, e2, i2, n2) {
          var r2 = 0, o2 = t3.length;
          !function s2(a2) {
            a2 || r2 === o2 ? i2 && i2(a2) : n2 ? setTimeout(function() {
              e2(t3[r2++], s2);
            }, 1) : e2(t3[r2++], s2);
          }();
        }, t2.queue = function(e2, i2) {
          return new t2(e2, i2);
        }, t2;
      }(), _c = /(#[\w-]+)?$/, yc = function() {
        function t2(e2, i2) {
          var n2 = this;
          void 0 === e2 && (e2 = ""), void 0 === i2 && (i2 = 10), this.progress = 0, this.loading = false, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t3, e3) {
            return n2._loadResource(t3, e3);
          }, this.resources = {}, this.baseUrl = e2, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(t3, e3) {
            return n2._loadResource(t3, e3);
          }, this._queue = vc.queue(this._boundLoadResource, i2), this._queue.pause(), this.resources = {}, this.onProgress = new ac(), this.onError = new ac(), this.onLoad = new ac(), this.onStart = new ac(), this.onComplete = new ac();
          for (var r2 = 0; r2 < t2._plugins.length; ++r2) {
            var o2 = t2._plugins[r2], s2 = o2.pre, a2 = o2.use;
            s2 && this.pre(s2), a2 && this.use(a2);
          }
          this._protected = false;
        }
        return t2.prototype._add = function(t3, e2, i2, n2) {
          if (this.loading && (!i2 || !i2.parentResource)) throw new Error("Cannot add resources while the loader is running.");
          if (this.resources[t3]) throw new Error('Resource named "' + t3 + '" already exists.');
          if (e2 = this._prepareUrl(e2), this.resources[t3] = new pc(t3, e2, i2), "function" == typeof n2 && this.resources[t3].onAfterMiddleware.once(n2), this.loading) {
            for (var r2 = i2.parentResource, o2 = [], s2 = 0; s2 < r2.children.length; ++s2) r2.children[s2].isComplete || o2.push(r2.children[s2]);
            var a2 = r2.progressChunk * (o2.length + 1) / (o2.length + 2);
            r2.children.push(this.resources[t3]), r2.progressChunk = a2;
            for (s2 = 0; s2 < o2.length; ++s2) o2[s2].progressChunk = a2;
            this.resources[t3].progressChunk = a2;
          }
          return this._queue.push(this.resources[t3]), this;
        }, t2.prototype.pre = function(t3) {
          return this._beforeMiddleware.push(t3), this;
        }, t2.prototype.use = function(t3) {
          return this._afterMiddleware.push(t3), this;
        }, t2.prototype.reset = function() {
          for (var t3 in this.progress = 0, this.loading = false, this._queue.kill(), this._queue.pause(), this.resources) {
            var e2 = this.resources[t3];
            e2._onLoadBinding && e2._onLoadBinding.detach(), e2.isLoading && e2.abort("loader reset");
          }
          return this.resources = {}, this;
        }, t2.prototype.load = function(t3) {
          if ("function" == typeof t3 && this.onComplete.once(t3), this.loading) return this;
          if (this._queue.idle()) this._onStart(), this._onComplete();
          else {
            for (var e2 = 100 / this._queue._tasks.length, i2 = 0; i2 < this._queue._tasks.length; ++i2) this._queue._tasks[i2].data.progressChunk = e2;
            this._onStart(), this._queue.resume();
          }
          return this;
        }, Object.defineProperty(t2.prototype, "concurrency", { get: function() {
          return this._queue.concurrency;
        }, set: function(t3) {
          this._queue.concurrency = t3;
        }, enumerable: false, configurable: true }), t2.prototype._prepareUrl = function(t3) {
          var e2, i2 = lc(t3, { strictMode: true });
          if (e2 = i2.protocol || !i2.path || 0 === t3.indexOf("//") ? t3 : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t3.charAt(0) ? this.baseUrl + "/" + t3 : this.baseUrl + t3, this.defaultQueryString) {
            var n2 = _c.exec(e2)[0];
            -1 !== (e2 = e2.slice(0, e2.length - n2.length)).indexOf("?") ? e2 += "&" + this.defaultQueryString : e2 += "?" + this.defaultQueryString, e2 += n2;
          }
          return e2;
        }, t2.prototype._loadResource = function(t3, e2) {
          var i2 = this;
          t3._dequeue = e2, vc.eachSeries(this._beforeMiddleware, function(e3, n2) {
            e3.call(i2, t3, function() {
              n2(t3.isComplete ? {} : null);
            });
          }, function() {
            t3.isComplete ? i2._onLoad(t3) : (t3._onLoadBinding = t3.onComplete.once(i2._onLoad, i2), t3.load());
          }, true);
        }, t2.prototype._onStart = function() {
          this.progress = 0, this.loading = true, this.onStart.dispatch(this);
        }, t2.prototype._onComplete = function() {
          this.progress = 100, this.loading = false, this.onComplete.dispatch(this, this.resources);
        }, t2.prototype._onLoad = function(t3) {
          var e2 = this;
          t3._onLoadBinding = null, this._resourcesParsing.push(t3), t3._dequeue(), vc.eachSeries(this._afterMiddleware, function(i2, n2) {
            i2.call(e2, t3, n2);
          }, function() {
            t3.onAfterMiddleware.dispatch(t3), e2.progress = Math.min(100, e2.progress + t3.progressChunk), e2.onProgress.dispatch(e2, t3), t3.error ? e2.onError.dispatch(t3.error, e2, t3) : e2.onLoad.dispatch(e2, t3), e2._resourcesParsing.splice(e2._resourcesParsing.indexOf(t3), 1), e2._queue.idle() && 0 === e2._resourcesParsing.length && e2._onComplete();
          }, true);
        }, t2.prototype.destroy = function() {
          this._protected || this.reset();
        }, Object.defineProperty(t2, "shared", { get: function() {
          var e2 = t2._shared;
          return e2 || ((e2 = new t2())._protected = true, t2._shared = e2), e2;
        }, enumerable: false, configurable: true }), t2.registerPlugin = function(e2) {
          return t2._plugins.push(e2), e2.add && e2.add(), t2;
        }, t2._plugins = [], t2;
      }();
      yc.prototype.add = function(t2, e2, i2, n2) {
        if (Array.isArray(t2)) {
          for (var r2 = 0; r2 < t2.length; ++r2) this.add(t2[r2]);
          return this;
        }
        if ("object" == typeof t2 && (i2 = t2, n2 = e2 || i2.callback || i2.onComplete, e2 = i2.url, t2 = i2.name || i2.key || i2.url), "string" != typeof e2 && (n2 = i2, i2 = e2, e2 = t2), "string" != typeof e2) throw new Error("No url passed to add resource to loader.");
        return "function" == typeof i2 && (n2 = i2, i2 = null), this._add(t2, e2, i2, n2);
      };
      var xc = function() {
        function t2() {
        }
        return t2.init = function(t3) {
          t3 = Object.assign({ sharedLoader: false }, t3), this.loader = t3.sharedLoader ? yc.shared : new yc();
        }, t2.destroy = function() {
          this.loader && (this.loader.destroy(), this.loader = null);
        }, t2;
      }(), bc = function() {
        function t2() {
        }
        return t2.add = function() {
          pc.setExtensionLoadType("svg", pc.LOAD_TYPE.XHR), pc.setExtensionXhrType("svg", pc.XHR_RESPONSE_TYPE.TEXT);
        }, t2.use = function(t3, e2) {
          if (!t3.data || t3.type !== pc.TYPE.IMAGE && "svg" !== t3.extension) e2();
          else {
            var i2 = t3.data, n2 = t3.url, r2 = t3.name, o2 = t3.metadata;
            Vh.t.fromLoader(i2, n2, r2, o2).then(function(i3) {
              t3.texture = i3, e2();
            }).catch(e2);
          }
        }, t2;
      }();
      yc.registerPlugin({ use: function(t2, e2) {
        if (t2.data) {
          if (t2.xhr && t2.xhrType === pc.XHR_RESPONSE_TYPE.BLOB) if (self.Blob && "string" != typeof t2.data) {
            if (0 === t2.data.type.indexOf("image")) {
              var i2 = globalThis.URL || globalThis.webkitURL, n2 = i2.createObjectURL(t2.data);
              return t2.blob = t2.data, t2.data = new Image(), t2.data.src = n2, t2.type = pc.TYPE.IMAGE, void (t2.data.onload = function() {
                i2.revokeObjectURL(n2), t2.data.onload = null, e2();
              });
            }
          } else {
            var r2 = t2.xhr.getResponseHeader("content-type");
            if (r2 && 0 === r2.indexOf("image")) return t2.data = new Image(), t2.data.src = "data:" + r2 + ";base64," + function(t3) {
              for (var e3 = "", i3 = 0; i3 < t3.length; ) {
                for (var n3 = [0, 0, 0], r3 = [0, 0, 0, 0], o2 = 0; o2 < n3.length; ++o2) i3 < t3.length ? n3[o2] = 255 & t3.charCodeAt(i3++) : n3[o2] = 0;
                switch (r3[0] = n3[0] >> 2, r3[1] = (3 & n3[0]) << 4 | n3[1] >> 4, r3[2] = (15 & n3[1]) << 2 | n3[2] >> 6, r3[3] = 63 & n3[2], i3 - (t3.length - 1)) {
                  case 2:
                    r3[3] = 64, r3[2] = 64;
                    break;
                  case 1:
                    r3[3] = 64;
                }
                for (o2 = 0; o2 < r3.length; ++o2) e3 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(r3[o2]);
              }
              return e3;
            }(t2.xhr.responseText), t2.type = pc.TYPE.IMAGE, void (t2.data.onload = function() {
              t2.data.onload = null, e2();
            });
          }
          e2();
        } else e2();
      } }), yc.registerPlugin(bc);
      var Tc, Ec, Sc = i(0);
      !function(t2) {
        t2[t2.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", t2[t2.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", t2[t2.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", t2[t2.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", t2[t2.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", t2[t2.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", t2[t2.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", t2[t2.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", t2[t2.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", t2[t2.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", t2[t2.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", t2[t2.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", t2[t2.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", t2[t2.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", t2[t2.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", t2[t2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", t2[t2.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", t2[t2.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", t2[t2.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", t2[t2.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", t2[t2.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", t2[t2.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", t2[t2.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", t2[t2.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", t2[t2.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", t2[t2.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
      }(Ec || (Ec = {}));
      var wc = ((Tc = {})[Ec.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, Tc[Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, Tc[Ec.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, Tc[Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, Tc[Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, Tc[Ec.COMPRESSED_R11_EAC] = 0.5, Tc[Ec.COMPRESSED_SIGNED_R11_EAC] = 0.5, Tc[Ec.COMPRESSED_RG11_EAC] = 1, Tc[Ec.COMPRESSED_SIGNED_RG11_EAC] = 1, Tc[Ec.COMPRESSED_RGB8_ETC2] = 0.5, Tc[Ec.COMPRESSED_RGBA8_ETC2_EAC] = 1, Tc[Ec.COMPRESSED_SRGB8_ETC2] = 0.5, Tc[Ec.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, Tc[Ec.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, Tc[Ec.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, Tc[Ec.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, Tc[Ec.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, Tc[Ec.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, Tc[Ec.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, Tc[Ec.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, Tc[Ec.COMPRESSED_RGB_ATC_WEBGL] = 0.5, Tc[Ec.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, Tc[Ec.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, Tc), Ac = function(t2, e2) {
        return (Ac = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function Mc(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        Ac(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      function Cc(t2, e2) {
        var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
          if (1 & r2[0]) throw r2[1];
          return r2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (i2) throw new TypeError("Generator is already executing.");
              for (; s2; ) try {
                if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done) return r2;
                switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                  case 0:
                  case 1:
                    r2 = o4;
                    break;
                  case 4:
                    return s2.label++, { value: o4[1], done: false };
                  case 5:
                    s2.label++, n2 = o4[1], o4 = [0];
                    continue;
                  case 7:
                    o4 = s2.ops.pop(), s2.trys.pop();
                    continue;
                  default:
                    if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                      s2 = 0;
                      continue;
                    }
                    if (3 === o4[0] && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                      s2.label = o4[1];
                      break;
                    }
                    if (6 === o4[0] && s2.label < r2[1]) {
                      s2.label = r2[1], r2 = o4;
                      break;
                    }
                    if (r2 && s2.label < r2[2]) {
                      s2.label = r2[2], s2.ops.push(o4);
                      break;
                    }
                    r2[2] && s2.ops.pop(), s2.trys.pop();
                    continue;
                }
                o4 = e2.call(t2, s2);
              } catch (t3) {
                o4 = [6, t3], n2 = 0;
              } finally {
                i2 = r2 = 0;
              }
              if (5 & o4[0]) throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }
      var Rc, Ic, Pc = function(t2) {
        function e2(i2, n2) {
          var r2 = t2.call(this, i2, n2) || this;
          return r2.format = n2.format, r2.levels = n2.levels || 1, r2._width = n2.width, r2._height = n2.height, r2._extension = e2._formatToExtension(r2.format), (n2.levelBuffers || r2.buffer) && (r2._levelBuffers = n2.levelBuffers || e2._createLevelBuffers(i2 instanceof Uint8Array ? i2 : r2.buffer.uint8View, r2.format, r2.levels, 4, 4, r2.width, r2.height)), r2;
        }
        return Mc(e2, t2), e2.prototype.upload = function(t3, e3, i2) {
          var n2 = t3.gl;
          if (!t3.context.extensions[this._extension]) throw new Error(this._extension + " textures are not supported on the current machine");
          if (!this._levelBuffers) return false;
          for (var r2 = 0, o2 = this.levels; r2 < o2; r2++) {
            var s2 = this._levelBuffers[r2], a2 = s2.levelID, l2 = s2.levelWidth, h2 = s2.levelHeight, u2 = s2.levelBuffer;
            n2.compressedTexImage2D(n2.TEXTURE_2D, a2, this.format, l2, h2, 0, u2);
          }
          return true;
        }, e2.prototype.onBlobLoaded = function() {
          this._levelBuffers = e2._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
        }, e2._formatToExtension = function(t3) {
          if (t3 >= 33776 && t3 <= 33779) return "s3tc";
          if (t3 >= 37488 && t3 <= 37497) return "etc";
          if (t3 >= 35840 && t3 <= 35843) return "pvrtc";
          if (t3 >= 36196) return "etc1";
          if (t3 >= 35986 && t3 <= 34798) return "atc";
          throw new Error("Invalid (compressed) texture format given!");
        }, e2._createLevelBuffers = function(t3, e3, i2, n2, r2, o2, s2) {
          for (var a2 = new Array(i2), l2 = t3.byteOffset, h2 = o2, u2 = s2, c2 = h2 + n2 - 1 & ~(n2 - 1), d2 = u2 + r2 - 1 & ~(r2 - 1), p2 = c2 * d2 * wc[e3], f2 = 0; f2 < i2; f2++) a2[f2] = { levelID: f2, levelWidth: i2 > 1 ? h2 : c2, levelHeight: i2 > 1 ? u2 : d2, levelBuffer: new Uint8Array(t3.buffer, l2, p2) }, l2 += p2, p2 = (c2 = (h2 = h2 >> 1 || 1) + n2 - 1 & ~(n2 - 1)) * (d2 = (u2 = u2 >> 1 || 1) + r2 - 1 & ~(r2 - 1)) * wc[e3];
          return a2;
        }, e2;
      }(function(t2) {
        function e2(e3, i2) {
          void 0 === i2 && (i2 = { width: 1, height: 1, autoLoad: true });
          var n2, r2, o2 = this;
          return "string" == typeof e3 ? (n2 = e3, r2 = new Uint8Array()) : (n2 = null, r2 = e3), (o2 = t2.call(this, r2, i2) || this).origin = n2, o2.buffer = r2 ? new Vh.x(r2) : null, o2.origin && false !== i2.autoLoad && o2.load(), r2 && r2.length && (o2.loaded = true, o2.onBlobLoaded(o2.buffer.rawBinaryData)), o2;
        }
        return Mc(e2, t2), e2.prototype.onBlobLoaded = function(t3) {
        }, e2.prototype.load = function() {
          return t3 = this, e3 = void 0, n2 = function() {
            var t4;
            return Cc(this, function(e4) {
              switch (e4.label) {
                case 0:
                  return [4, fetch(this.origin)];
                case 1:
                  return [4, e4.sent().blob()];
                case 2:
                  return [4, e4.sent().arrayBuffer()];
                case 3:
                  return t4 = e4.sent(), this.data = new Uint32Array(t4), this.buffer = new Vh.x(t4), this.loaded = true, this.onBlobLoaded(t4), this.update(), [2, this];
              }
            });
          }, new ((i2 = Promise) || (i2 = Promise))(function(r2, o2) {
            function s2(t4) {
              try {
                l2(n2.next(t4));
              } catch (t5) {
                o2(t5);
              }
            }
            function a2(t4) {
              try {
                l2(n2.throw(t4));
              } catch (t5) {
                o2(t5);
              }
            }
            function l2(t4) {
              t4.done ? r2(t4.value) : new i2(function(e4) {
                e4(t4.value);
              }).then(s2, a2);
            }
            l2((n2 = n2.apply(t3, e3 || [])).next());
          });
          var t3, e3, i2, n2;
        }, e2;
      }(Vh.i)), Oc = function() {
        function t2() {
        }
        return t2.use = function(e2, i2) {
          var n2 = e2.data;
          if (e2.type === pc.TYPE.JSON && n2 && n2.cacheID && n2.textures) {
            for (var r2 = n2.textures, o2 = void 0, s2 = void 0, a2 = 0, l2 = r2.length; a2 < l2; a2++) {
              var h2 = r2[a2], u2 = h2.src, c2 = h2.format;
              if (c2 || (s2 = u2), t2.textureFormats[c2]) {
                o2 = u2;
                break;
              }
            }
            if (!(o2 = o2 || s2)) return void i2(new Error("Cannot load compressed-textures in " + e2.url + ", make sure you provide a fallback"));
            if (o2 === e2.url) return void i2(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
            var d2 = { crossOrigin: e2.crossOrigin, metadata: e2.metadata.imageMetadata, parentResource: e2 }, p2 = Ph.url.resolve(e2.url.replace(this.baseUrl, ""), o2), f2 = n2.cacheID;
            this.add(f2, p2, d2, function(t3) {
              if (t3.error) i2(t3.error);
              else {
                var n3 = t3.texture, r3 = void 0 === n3 ? null : n3, o3 = t3.textures, s3 = void 0 === o3 ? {} : o3;
                Object.assign(e2, { texture: r3, textures: s3 }), i2();
              }
            });
          } else i2();
        }, Object.defineProperty(t2, "textureExtensions", { get: function() {
          if (!t2._textureExtensions) {
            var e2 = document.createElement("canvas").getContext("webgl");
            if (!e2) return console.warn("WebGL not available for compressed textures. Silently failing."), {};
            var i2 = { s3tc: e2.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB: e2.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc: e2.getExtension("WEBGL_compressed_texture_etc"), etc1: e2.getExtension("WEBGL_compressed_texture_etc1"), pvrtc: e2.getExtension("WEBGL_compressed_texture_pvrtc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc: e2.getExtension("WEBGL_compressed_texture_atc"), astc: e2.getExtension("WEBGL_compressed_texture_astc") };
            t2._textureExtensions = i2;
          }
          return t2._textureExtensions;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "textureFormats", { get: function() {
          if (!t2._textureFormats) {
            var e2 = t2.textureExtensions;
            for (var i2 in t2._textureFormats = {}, e2) {
              var n2 = e2[i2];
              n2 && Object.assign(t2._textureFormats, Object.getPrototypeOf(n2));
            }
          }
          return t2._textureFormats;
        }, enumerable: false, configurable: true }), t2;
      }();
      function Nc(t2, e2, i2) {
        var n2 = { textures: {}, texture: null };
        return e2 ? (e2.map(function(t3) {
          return new Vh.t(new Vh.c(t3, Object.assign({ mipmap: Sc.k.OFF, alphaMode: Sc.a.NO_PREMULTIPLIED_ALPHA }, i2)));
        }).forEach(function(e3, i3) {
          var r2 = e3.baseTexture, o2 = t2 + "-" + (i3 + 1);
          Vh.c.addToCache(r2, o2), Vh.t.addToCache(e3, o2), 0 === i3 && (Vh.c.addToCache(r2, t2), Vh.t.addToCache(e3, t2), n2.texture = e3), n2.textures[o2] = e3;
        }), n2) : n2;
      }
      pc.setExtensionXhrType("dds", pc.XHR_RESPONSE_TYPE.BUFFER);
      var Lc, Dc, Fc = 3, Bc = 4, Uc = 7, kc = 19, Gc = 2, Hc = 0, jc = 1, zc = 2, Vc = 3;
      !function(t2) {
        t2[t2.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", t2[t2.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", t2[t2.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", t2[t2.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", t2[t2.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", t2[t2.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", t2[t2.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", t2[t2.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", t2[t2.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", t2[t2.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", t2[t2.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", t2[t2.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", t2[t2.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", t2[t2.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", t2[t2.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", t2[t2.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", t2[t2.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", t2[t2.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", t2[t2.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", t2[t2.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", t2[t2.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", t2[t2.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", t2[t2.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", t2[t2.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", t2[t2.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", t2[t2.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", t2[t2.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", t2[t2.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", t2[t2.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", t2[t2.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", t2[t2.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", t2[t2.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", t2[t2.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", t2[t2.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", t2[t2.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", t2[t2.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", t2[t2.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", t2[t2.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", t2[t2.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", t2[t2.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", t2[t2.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", t2[t2.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", t2[t2.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", t2[t2.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", t2[t2.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", t2[t2.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", t2[t2.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", t2[t2.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", t2[t2.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", t2[t2.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", t2[t2.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", t2[t2.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", t2[t2.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", t2[t2.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", t2[t2.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", t2[t2.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", t2[t2.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", t2[t2.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", t2[t2.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", t2[t2.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", t2[t2.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", t2[t2.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", t2[t2.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", t2[t2.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", t2[t2.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", t2[t2.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", t2[t2.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", t2[t2.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", t2[t2.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", t2[t2.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", t2[t2.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", t2[t2.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", t2[t2.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", t2[t2.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", t2[t2.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", t2[t2.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", t2[t2.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", t2[t2.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", t2[t2.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", t2[t2.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", t2[t2.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", t2[t2.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", t2[t2.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", t2[t2.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", t2[t2.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", t2[t2.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", t2[t2.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", t2[t2.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", t2[t2.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", t2[t2.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", t2[t2.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", t2[t2.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", t2[t2.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", t2[t2.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", t2[t2.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", t2[t2.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", t2[t2.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", t2[t2.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", t2[t2.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", t2[t2.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", t2[t2.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", t2[t2.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", t2[t2.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", t2[t2.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", t2[t2.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", t2[t2.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", t2[t2.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", t2[t2.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", t2[t2.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", t2[t2.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", t2[t2.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", t2[t2.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", t2[t2.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", t2[t2.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", t2[t2.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", t2[t2.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", t2[t2.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", t2[t2.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", t2[t2.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
      }(Lc || (Lc = {})), function(t2) {
        t2[t2.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", t2[t2.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", t2[t2.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
      }(Dc || (Dc = {}));
      var Xc, Wc, Yc, qc = ((Rc = {})[827611204] = Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT, Rc[861165636] = Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT, Rc[894720068] = Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT, Rc), Zc = ((Ic = {})[Lc.DXGI_FORMAT_BC1_TYPELESS] = Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ic[Lc.DXGI_FORMAT_BC1_UNORM] = Ec.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ic[Lc.DXGI_FORMAT_BC2_TYPELESS] = Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ic[Lc.DXGI_FORMAT_BC2_UNORM] = Ec.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ic[Lc.DXGI_FORMAT_BC3_TYPELESS] = Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ic[Lc.DXGI_FORMAT_BC3_UNORM] = Ec.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ic[Lc.DXGI_FORMAT_BC1_UNORM_SRGB] = Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, Ic[Lc.DXGI_FORMAT_BC2_UNORM_SRGB] = Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, Ic[Lc.DXGI_FORMAT_BC3_UNORM_SRGB] = Ec.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, Ic), Jc = function() {
        function t2() {
        }
        return t2.use = function(e2, i2) {
          if ("dds" === e2.extension && e2.data) try {
            Object.assign(e2, Nc(e2.name || e2.url, t2.parse(e2.data), e2.metadata));
          } catch (t3) {
            return void i2(t3);
          }
          i2();
        }, t2.parse = function(t3) {
          var e2 = new Uint32Array(t3);
          if (542327876 !== e2[0]) throw new Error("Invalid DDS file magic word");
          var i2 = new Uint32Array(t3, 0, 124 / Uint32Array.BYTES_PER_ELEMENT), n2 = i2[Fc], r2 = i2[Bc], o2 = i2[Uc], s2 = new Uint32Array(t3, kc * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT), a2 = s2[1];
          if (4 & a2) {
            var l2 = s2[Gc];
            if (808540228 !== l2) {
              var h2 = qc[l2], u2 = new Uint8Array(t3, 128);
              return [new Pc(u2, { format: h2, width: r2, height: n2, levels: o2 })];
            }
            var c2 = new Uint32Array(e2.buffer, 128, 20 / Uint32Array.BYTES_PER_ELEMENT), d2 = c2[Hc], p2 = c2[jc], f2 = c2[zc], m2 = c2[Vc], g2 = Zc[d2];
            if (void 0 === g2) throw new Error("DDSLoader cannot parse texture data with DXGI format " + d2);
            if (4 === f2) throw new Error("DDSLoader does not support cubemap textures");
            if (p2 === Dc.DDS_DIMENSION_TEXTURE3D) throw new Error("DDSLoader does not supported 3D texture data");
            var v2 = new Array();
            if (1 === m2) v2.push(new Uint8Array(t3, 148));
            else {
              for (var _2 = wc[g2], y2 = 0, x2 = r2, b2 = n2, T2 = 0; T2 < o2; T2++) {
                y2 += Math.max(1, x2 + 3 & -4) * Math.max(1, b2 + 3 & -4) * _2, x2 >>>= 1, b2 >>>= 1;
              }
              var E2 = 148;
              for (T2 = 0; T2 < m2; T2++) v2.push(new Uint8Array(t3, E2, y2)), E2 += y2;
            }
            return v2.map(function(t4) {
              return new Pc(t4, { format: g2, width: r2, height: n2, levels: o2 });
            });
          }
          if (64 & a2) throw new Error("DDSLoader does not support uncompressed texture data.");
          if (512 & a2) throw new Error("DDSLoader does not supported YUV uncompressed texture data.");
          if (131072 & a2) throw new Error("DDSLoader does not support single-channel (lumninance) texture data!");
          if (2 & a2) throw new Error("DDSLoader does not support single-channel (alpha) texture data!");
          throw new Error("DDSLoader failed to load a texture file due to an unknown reason!");
        }, t2;
      }();
      pc.setExtensionXhrType("ktx", pc.XHR_RESPONSE_TYPE.BUFFER);
      var Kc = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], Qc = 12, $c = 16, td = 24, ed = 28, id = 36, nd = 40, rd = 44, od = 48, sd = 52, ad = 56, ld = 60, hd = ((Xc = {})[Sc.r.UNSIGNED_BYTE] = 1, Xc[Sc.r.UNSIGNED_SHORT] = 2, Xc[Sc.r.INT] = 4, Xc[Sc.r.UNSIGNED_INT] = 4, Xc[Sc.r.FLOAT] = 4, Xc[Sc.r.HALF_FLOAT] = 8, Xc), ud = ((Wc = {})[Sc.h.RGBA] = 4, Wc[Sc.h.RGB] = 3, Wc[Sc.h.RG] = 2, Wc[Sc.h.RED] = 1, Wc[Sc.h.LUMINANCE] = 1, Wc[Sc.h.LUMINANCE_ALPHA] = 2, Wc[Sc.h.ALPHA] = 1, Wc), cd = ((Yc = {})[Sc.r.UNSIGNED_SHORT_4_4_4_4] = 2, Yc[Sc.r.UNSIGNED_SHORT_5_5_5_1] = 2, Yc[Sc.r.UNSIGNED_SHORT_5_6_5] = 2, Yc), dd = function() {
        function t2() {
        }
        return t2.use = function(e2, i2) {
          if ("ktx" === e2.extension && e2.data) try {
            var n2 = e2.name || e2.url, r2 = t2.parse(n2, e2.data), o2 = r2.compressed, s2 = r2.uncompressed, a2 = r2.kvData;
            if (o2) {
              var l2 = Nc(n2, o2, e2.metadata);
              if (a2 && l2.textures) for (var h2 in l2.textures) l2.textures[h2].baseTexture.ktxKeyValueData = a2;
              Object.assign(e2, l2);
            } else if (s2) {
              var u2 = {};
              s2.forEach(function(t3, e3) {
                var i3 = new Vh.t(new Vh.c(t3.resource, { mipmap: Sc.k.OFF, alphaMode: Sc.a.NO_PREMULTIPLIED_ALPHA, type: t3.type, format: t3.format })), r3 = n2 + "-" + (e3 + 1);
                a2 && (i3.baseTexture.ktxKeyValueData = a2), Vh.c.addToCache(i3.baseTexture, r3), Vh.t.addToCache(i3, r3), 0 === e3 && (u2[n2] = i3, Vh.c.addToCache(i3.baseTexture, n2), Vh.t.addToCache(i3, n2)), u2[r3] = i3;
              }), Object.assign(e2, { textures: u2 });
            }
          } catch (t3) {
            return void i2(t3);
          }
          i2();
        }, t2.parse = function(e2, i2) {
          var n2 = new DataView(i2);
          if (!t2.validate(e2, n2)) return null;
          var r2 = 67305985 === n2.getUint32(Qc, true), o2 = n2.getUint32($c, r2), s2 = n2.getUint32(td, r2), a2 = n2.getUint32(ed, r2), l2 = n2.getUint32(id, r2), h2 = n2.getUint32(nd, r2) || 1, u2 = n2.getUint32(rd, r2) || 1, c2 = n2.getUint32(od, r2) || 1, d2 = n2.getUint32(sd, r2), p2 = n2.getUint32(ad, r2), f2 = n2.getUint32(ld, r2);
          if (0 === h2 || 1 !== u2) throw new Error("Only 2D textures are supported");
          if (1 !== d2) throw new Error("CubeTextures are not supported by KTXLoader yet!");
          if (1 !== c2) throw new Error("WebGL does not support array textures");
          var m2, g2 = l2 + 3 & -4, v2 = h2 + 3 & -4, _2 = new Array(c2), y2 = l2 * h2;
          if (0 === o2 && (y2 = g2 * v2), void 0 === (m2 = 0 !== o2 ? hd[o2] ? hd[o2] * ud[s2] : cd[o2] : wc[a2])) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
          for (var x2 = t2.loadKeyValueData ? t2.parseKvData(n2, f2, r2) : null, b2 = y2 * m2, T2 = l2, E2 = h2, S2 = g2, w2 = v2, A2 = 64 + f2, M2 = 0; M2 < p2; M2++) {
            for (var C2 = n2.getUint32(A2, r2), R2 = A2 + 4, I2 = 0; I2 < c2; I2++) {
              var P2 = _2[I2];
              P2 || (P2 = _2[I2] = new Array(p2)), P2[M2] = { levelID: M2, levelWidth: p2 > 1 || 0 !== o2 ? T2 : S2, levelHeight: p2 > 1 || 0 !== o2 ? E2 : w2, levelBuffer: new Uint8Array(i2, R2, b2) }, R2 += b2;
            }
            A2 = (A2 += C2 + 4) % 4 != 0 ? A2 + 4 - A2 % 4 : A2, b2 = (S2 = (T2 = T2 >> 1 || 1) + 4 - 1 & -4) * (w2 = (E2 = E2 >> 1 || 1) + 4 - 1 & -4) * m2;
          }
          return 0 !== o2 ? { uncompressed: _2.map(function(e3) {
            var i3 = e3[0].levelBuffer, n3 = false;
            return o2 === Sc.r.FLOAT ? i3 = new Float32Array(e3[0].levelBuffer.buffer, e3[0].levelBuffer.byteOffset, e3[0].levelBuffer.byteLength / 4) : o2 === Sc.r.UNSIGNED_INT ? (n3 = true, i3 = new Uint32Array(e3[0].levelBuffer.buffer, e3[0].levelBuffer.byteOffset, e3[0].levelBuffer.byteLength / 4)) : o2 === Sc.r.INT && (n3 = true, i3 = new Int32Array(e3[0].levelBuffer.buffer, e3[0].levelBuffer.byteOffset, e3[0].levelBuffer.byteLength / 4)), { resource: new Vh.i(i3, { width: e3[0].levelWidth, height: e3[0].levelHeight }), type: o2, format: n3 ? t2.convertFormatToInteger(s2) : s2 };
          }), kvData: x2 } : { compressed: _2.map(function(t3) {
            return new Pc(null, { format: a2, width: l2, height: h2, levels: p2, levelBuffers: t3 });
          }), kvData: x2 };
        }, t2.validate = function(t3, e2) {
          for (var i2 = 0; i2 < Kc.length; i2++) if (e2.getUint8(i2) !== Kc[i2]) return console.error(t3 + " is not a valid *.ktx file!"), false;
          return true;
        }, t2.convertFormatToInteger = function(t3) {
          switch (t3) {
            case Sc.h.RGBA:
              return Sc.h.RGBA_INTEGER;
            case Sc.h.RGB:
              return Sc.h.RGB_INTEGER;
            case Sc.h.RG:
              return Sc.h.RG_INTEGER;
            case Sc.h.RED:
              return Sc.h.RED_INTEGER;
            default:
              return t3;
          }
        }, t2.parseKvData = function(t3, e2, i2) {
          for (var n2 = /* @__PURE__ */ new Map(), r2 = 0; r2 < e2; ) {
            var o2 = t3.getUint32(64 + r2, i2), s2 = 64 + r2 + 4, a2 = 3 - (o2 + 3) % 4;
            if (0 === o2 || o2 > e2 - r2) {
              console.error("KTXLoader: keyAndValueByteSize out of bounds");
              break;
            }
            for (var l2 = 0; l2 < o2 && 0 !== t3.getUint8(s2 + l2); l2++) ;
            if (-1 === l2) {
              console.error("KTXLoader: Failed to find null byte terminating kvData key");
              break;
            }
            var h2 = new TextDecoder().decode(new Uint8Array(t3.buffer, s2, l2)), u2 = new DataView(t3.buffer, s2 + l2 + 1, o2 - l2 - 1);
            n2.set(h2, u2), r2 += 4 + o2 + a2;
          }
          return n2;
        }, t2.loadKeyValueData = false, t2;
      }(), pd = function(t2, e2) {
        return (pd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function fd(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        pd(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var md, gd, vd = function(t2) {
        function e2(e3, i2, n2, r2) {
          void 0 === e3 && (e3 = 1500), void 0 === n2 && (n2 = 16384), void 0 === r2 && (r2 = false);
          var o2 = t2.call(this) || this;
          return n2 > 16384 && (n2 = 16384), o2._properties = [false, true, false, false, false], o2._maxSize = e3, o2._batchSize = n2, o2._buffers = null, o2._bufferUpdateIDs = [], o2._updateID = 0, o2.interactiveChildren = false, o2.blendMode = Sc.b.NORMAL, o2.autoResize = r2, o2.roundPixels = true, o2.baseTexture = null, o2.setProperties(i2), o2._tint = 0, o2.tintRgb = new Float32Array(4), o2.tint = 16777215, o2;
        }
        return fd(e2, t2), e2.prototype.setProperties = function(t3) {
          t3 && (this._properties[0] = "vertices" in t3 || "scale" in t3 ? !!t3.vertices || !!t3.scale : this._properties[0], this._properties[1] = "position" in t3 ? !!t3.position : this._properties[1], this._properties[2] = "rotation" in t3 ? !!t3.rotation : this._properties[2], this._properties[3] = "uvs" in t3 ? !!t3.uvs : this._properties[3], this._properties[4] = "tint" in t3 || "alpha" in t3 ? !!t3.tint || !!t3.alpha : this._properties[4]);
        }, e2.prototype.updateTransform = function() {
          this.displayObjectUpdateTransform();
        }, Object.defineProperty(e2.prototype, "tint", { get: function() {
          return this._tint;
        }, set: function(t3) {
          this._tint = t3, Object(Ph.hex2rgb)(t3, this.tintRgb);
        }, enumerable: false, configurable: true }), e2.prototype.render = function(t3) {
          var e3 = this;
          this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
            return e3.onChildrenChange(0);
          })), t3.batch.setObjectRenderer(t3.plugins.particle), t3.plugins.particle.render(this));
        }, e2.prototype.onChildrenChange = function(t3) {
          for (var e3 = Math.floor(t3 / this._batchSize); this._bufferUpdateIDs.length < e3; ) this._bufferUpdateIDs.push(0);
          this._bufferUpdateIDs[e3] = ++this._updateID;
        }, e2.prototype.dispose = function() {
          if (this._buffers) {
            for (var t3 = 0; t3 < this._buffers.length; ++t3) this._buffers[t3].destroy();
            this._buffers = null;
          }
        }, e2.prototype.destroy = function(e3) {
          t2.prototype.destroy.call(this, e3), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
        }, e2;
      }(Oh.b), _d = function() {
        function t2(t3, e2, i2) {
          this.geometry = new Vh.l(), this.indexBuffer = null, this.size = i2, this.dynamicProperties = [], this.staticProperties = [];
          for (var n2 = 0; n2 < t3.length; ++n2) {
            var r2 = t3[n2];
            r2 = { attributeName: r2.attributeName, size: r2.size, uploadFunction: r2.uploadFunction, type: r2.type || Sc.r.FLOAT, offset: r2.offset }, e2[n2] ? this.dynamicProperties.push(r2) : this.staticProperties.push(r2);
          }
          this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
        }
        return t2.prototype.initBuffers = function() {
          var t3 = this.geometry, e2 = 0;
          this.indexBuffer = new Vh.h(Object(Ph.createIndicesForQuads)(this.size), true, true), t3.addIndex(this.indexBuffer), this.dynamicStride = 0;
          for (var i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
            (s2 = this.dynamicProperties[i2]).offset = e2, e2 += s2.size, this.dynamicStride += s2.size;
          }
          var n2 = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
          this.dynamicData = new Float32Array(n2), this.dynamicDataUint32 = new Uint32Array(n2), this.dynamicBuffer = new Vh.h(this.dynamicData, false, false);
          var r2 = 0;
          this.staticStride = 0;
          for (i2 = 0; i2 < this.staticProperties.length; ++i2) {
            (s2 = this.staticProperties[i2]).offset = r2, r2 += s2.size, this.staticStride += s2.size;
          }
          var o2 = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
          this.staticData = new Float32Array(o2), this.staticDataUint32 = new Uint32Array(o2), this.staticBuffer = new Vh.h(this.staticData, true, false);
          for (i2 = 0; i2 < this.dynamicProperties.length; ++i2) {
            var s2 = this.dynamicProperties[i2];
            t3.addAttribute(s2.attributeName, this.dynamicBuffer, 0, s2.type === Sc.r.UNSIGNED_BYTE, s2.type, 4 * this.dynamicStride, 4 * s2.offset);
          }
          for (i2 = 0; i2 < this.staticProperties.length; ++i2) {
            s2 = this.staticProperties[i2];
            t3.addAttribute(s2.attributeName, this.staticBuffer, 0, s2.type === Sc.r.UNSIGNED_BYTE, s2.type, 4 * this.staticStride, 4 * s2.offset);
          }
        }, t2.prototype.uploadDynamic = function(t3, e2, i2) {
          for (var n2 = 0; n2 < this.dynamicProperties.length; n2++) {
            var r2 = this.dynamicProperties[n2];
            r2.uploadFunction(t3, e2, i2, r2.type === Sc.r.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, r2.offset);
          }
          this.dynamicBuffer._updateID++;
        }, t2.prototype.uploadStatic = function(t3, e2, i2) {
          for (var n2 = 0; n2 < this.staticProperties.length; n2++) {
            var r2 = this.staticProperties[n2];
            r2.uploadFunction(t3, e2, i2, r2.type === Sc.r.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, r2.offset);
          }
          this.staticBuffer._updateID++;
        }, t2.prototype.destroy = function() {
          this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
        }, t2;
      }(), yd = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return i2.shader = null, i2.properties = null, i2.tempMatrix = new Lh.d(), i2.properties = [{ attributeName: "aVertexPosition", size: 2, uploadFunction: i2.uploadVertices, offset: 0 }, { attributeName: "aPositionCoord", size: 2, uploadFunction: i2.uploadPosition, offset: 0 }, { attributeName: "aRotation", size: 1, uploadFunction: i2.uploadRotation, offset: 0 }, { attributeName: "aTextureCoord", size: 2, uploadFunction: i2.uploadUvs, offset: 0 }, { attributeName: "aColor", size: 1, type: Sc.r.UNSIGNED_BYTE, uploadFunction: i2.uploadTint, offset: 0 }], i2.shader = Vh.r.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}), i2.state = Vh.s.for2d(), i2;
        }
        return fd(e2, t2), e2.prototype.render = function(t3) {
          var e3 = t3.children, i2 = t3._maxSize, n2 = t3._batchSize, r2 = this.renderer, o2 = e3.length;
          if (0 !== o2) {
            o2 > i2 && !t3.autoResize && (o2 = i2);
            var s2 = t3._buffers;
            s2 || (s2 = t3._buffers = this.generateBuffers(t3));
            var a2 = e3[0]._texture.baseTexture;
            this.state.blendMode = Object(Ph.correctBlendMode)(t3.blendMode, a2.alphaMode), r2.state.set(this.state);
            var l2 = r2.gl, h2 = t3.worldTransform.copyTo(this.tempMatrix);
            h2.prepend(r2.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = h2.toArray(true), this.shader.uniforms.uColor = Object(Ph.premultiplyRgba)(t3.tintRgb, t3.worldAlpha, this.shader.uniforms.uColor, a2.alphaMode), this.shader.uniforms.uSampler = a2, this.renderer.shader.bind(this.shader);
            for (var u2 = false, c2 = 0, d2 = 0; c2 < o2; c2 += n2, d2 += 1) {
              var p2 = o2 - c2;
              p2 > n2 && (p2 = n2), d2 >= s2.length && s2.push(this._generateOneMoreBuffer(t3));
              var f2 = s2[d2];
              f2.uploadDynamic(e3, c2, p2);
              var m2 = t3._bufferUpdateIDs[d2] || 0;
              (u2 = u2 || f2._updateID < m2) && (f2._updateID = t3._updateID, f2.uploadStatic(e3, c2, p2)), r2.geometry.bind(f2.geometry), l2.drawElements(l2.TRIANGLES, 6 * p2, l2.UNSIGNED_SHORT, 0);
            }
          }
        }, e2.prototype.generateBuffers = function(t3) {
          for (var e3 = [], i2 = t3._maxSize, n2 = t3._batchSize, r2 = t3._properties, o2 = 0; o2 < i2; o2 += n2) e3.push(new _d(this.properties, r2, n2));
          return e3;
        }, e2.prototype._generateOneMoreBuffer = function(t3) {
          var e3 = t3._batchSize, i2 = t3._properties;
          return new _d(this.properties, i2, e3);
        }, e2.prototype.uploadVertices = function(t3, e3, i2, n2, r2, o2) {
          for (var s2 = 0, a2 = 0, l2 = 0, h2 = 0, u2 = 0; u2 < i2; ++u2) {
            var c2 = t3[e3 + u2], d2 = c2._texture, p2 = c2.scale.x, f2 = c2.scale.y, m2 = d2.trim, g2 = d2.orig;
            m2 ? (s2 = (a2 = m2.x - c2.anchor.x * g2.width) + m2.width, l2 = (h2 = m2.y - c2.anchor.y * g2.height) + m2.height) : (s2 = g2.width * (1 - c2.anchor.x), a2 = g2.width * -c2.anchor.x, l2 = g2.height * (1 - c2.anchor.y), h2 = g2.height * -c2.anchor.y), n2[o2] = a2 * p2, n2[o2 + 1] = h2 * f2, n2[o2 + r2] = s2 * p2, n2[o2 + r2 + 1] = h2 * f2, n2[o2 + 2 * r2] = s2 * p2, n2[o2 + 2 * r2 + 1] = l2 * f2, n2[o2 + 3 * r2] = a2 * p2, n2[o2 + 3 * r2 + 1] = l2 * f2, o2 += 4 * r2;
          }
        }, e2.prototype.uploadPosition = function(t3, e3, i2, n2, r2, o2) {
          for (var s2 = 0; s2 < i2; s2++) {
            var a2 = t3[e3 + s2].position;
            n2[o2] = a2.x, n2[o2 + 1] = a2.y, n2[o2 + r2] = a2.x, n2[o2 + r2 + 1] = a2.y, n2[o2 + 2 * r2] = a2.x, n2[o2 + 2 * r2 + 1] = a2.y, n2[o2 + 3 * r2] = a2.x, n2[o2 + 3 * r2 + 1] = a2.y, o2 += 4 * r2;
          }
        }, e2.prototype.uploadRotation = function(t3, e3, i2, n2, r2, o2) {
          for (var s2 = 0; s2 < i2; s2++) {
            var a2 = t3[e3 + s2].rotation;
            n2[o2] = a2, n2[o2 + r2] = a2, n2[o2 + 2 * r2] = a2, n2[o2 + 3 * r2] = a2, o2 += 4 * r2;
          }
        }, e2.prototype.uploadUvs = function(t3, e3, i2, n2, r2, o2) {
          for (var s2 = 0; s2 < i2; ++s2) {
            var a2 = t3[e3 + s2]._texture._uvs;
            a2 ? (n2[o2] = a2.x0, n2[o2 + 1] = a2.y0, n2[o2 + r2] = a2.x1, n2[o2 + r2 + 1] = a2.y1, n2[o2 + 2 * r2] = a2.x2, n2[o2 + 2 * r2 + 1] = a2.y2, n2[o2 + 3 * r2] = a2.x3, n2[o2 + 3 * r2 + 1] = a2.y3, o2 += 4 * r2) : (n2[o2] = 0, n2[o2 + 1] = 0, n2[o2 + r2] = 0, n2[o2 + r2 + 1] = 0, n2[o2 + 2 * r2] = 0, n2[o2 + 2 * r2 + 1] = 0, n2[o2 + 3 * r2] = 0, n2[o2 + 3 * r2 + 1] = 0, o2 += 4 * r2);
          }
        }, e2.prototype.uploadTint = function(t3, e3, i2, n2, r2, o2) {
          for (var s2 = 0; s2 < i2; ++s2) {
            var a2 = t3[e3 + s2], l2 = a2._texture.baseTexture.alphaMode > 0, h2 = a2.alpha, u2 = h2 < 1 && l2 ? Object(Ph.premultiplyTint)(a2._tintRGB, h2) : a2._tintRGB + (255 * h2 << 24);
            n2[o2] = u2, n2[o2 + r2] = u2, n2[o2 + 2 * r2] = u2, n2[o2 + 3 * r2] = u2, o2 += 4 * r2;
          }
        }, e2.prototype.destroy = function() {
          t2.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
        }, e2;
      }(Vh.m), xd = i(4);
      !function(t2) {
        t2.MITER = "miter", t2.BEVEL = "bevel", t2.ROUND = "round";
      }(md || (md = {})), function(t2) {
        t2.BUTT = "butt", t2.ROUND = "round", t2.SQUARE = "square";
      }(gd || (gd = {}));
      var bd = { adaptive: true, maxLength: 10, minSegments: 8, maxSegments: 2048, epsilon: 1e-4, _segmentsCount: function(t2, e2) {
        if (void 0 === e2 && (e2 = 20), !this.adaptive || !t2 || isNaN(t2)) return e2;
        var i2 = Math.ceil(t2 / this.maxLength);
        return i2 < this.minSegments ? i2 = this.minSegments : i2 > this.maxSegments && (i2 = this.maxSegments), i2;
      } }, Td = function() {
        function t2() {
          this.color = 16777215, this.alpha = 1, this.texture = Vh.t.WHITE, this.matrix = null, this.visible = false, this.reset();
        }
        return t2.prototype.clone = function() {
          var e2 = new t2();
          return e2.color = this.color, e2.alpha = this.alpha, e2.texture = this.texture, e2.matrix = this.matrix, e2.visible = this.visible, e2;
        }, t2.prototype.reset = function() {
          this.color = 16777215, this.alpha = 1, this.texture = Vh.t.WHITE, this.matrix = null, this.visible = false;
        }, t2.prototype.destroy = function() {
          this.texture = null, this.matrix = null;
        }, t2;
      }(), Ed = function(t2, e2) {
        return (Ed = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function Sd(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        Ed(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      function wd(t2, e2) {
        var i2, n2;
        void 0 === e2 && (e2 = false);
        var r2 = t2.length;
        if (!(r2 < 6)) {
          for (var o2 = 0, s2 = 0, a2 = t2[r2 - 2], l2 = t2[r2 - 1]; s2 < r2; s2 += 2) {
            var h2 = t2[s2], u2 = t2[s2 + 1];
            o2 += (h2 - a2) * (u2 + l2), a2 = h2, l2 = u2;
          }
          if (!e2 && o2 > 0 || e2 && o2 <= 0) {
            var c2 = r2 / 2;
            for (s2 = c2 + c2 % 2; s2 < r2; s2 += 2) {
              var d2 = r2 - s2 - 2, p2 = r2 - s2 - 1, f2 = s2, m2 = s2 + 1;
              i2 = [t2[f2], t2[d2]], t2[d2] = i2[0], t2[f2] = i2[1], n2 = [t2[m2], t2[p2]], t2[p2] = n2[0], t2[m2] = n2[1];
            }
          }
        }
      }
      var Ad = { build: function(t2) {
        t2.points = t2.shape.points.slice();
      }, triangulate: function(t2, e2) {
        var i2 = t2.points, n2 = t2.holes, r2 = e2.points, o2 = e2.indices;
        if (i2.length >= 6) {
          wd(i2, false);
          for (var s2 = [], a2 = 0; a2 < n2.length; a2++) {
            var l2 = n2[a2];
            wd(l2.points, true), s2.push(i2.length / 2), i2 = i2.concat(l2.points);
          }
          var h2 = Object(Ph.earcut)(i2, s2, 2);
          if (!h2) return;
          var u2 = r2.length / 2;
          for (a2 = 0; a2 < h2.length; a2 += 3) o2.push(h2[a2] + u2), o2.push(h2[a2 + 1] + u2), o2.push(h2[a2 + 2] + u2);
          for (a2 = 0; a2 < i2.length; a2++) r2.push(i2[a2]);
        }
      } }, Md = { build: function(t2) {
        var e2, i2, n2, r2, o2, s2, a2 = t2.points;
        if (t2.type === Lh.l.CIRC) {
          var l2 = t2.shape;
          e2 = l2.x, i2 = l2.y, o2 = s2 = l2.radius, n2 = r2 = 0;
        } else if (t2.type === Lh.l.ELIP) {
          var h2 = t2.shape;
          e2 = h2.x, i2 = h2.y, o2 = h2.width, s2 = h2.height, n2 = r2 = 0;
        } else {
          var u2 = t2.shape, c2 = u2.width / 2, d2 = u2.height / 2;
          e2 = u2.x + c2, i2 = u2.y + d2, n2 = c2 - (o2 = s2 = Math.max(0, Math.min(u2.radius, Math.min(c2, d2)))), r2 = d2 - s2;
        }
        if (o2 >= 0 && s2 >= 0 && n2 >= 0 && r2 >= 0) {
          var p2 = Math.ceil(2.3 * Math.sqrt(o2 + s2)), f2 = 8 * p2 + (n2 ? 4 : 0) + (r2 ? 4 : 0);
          if (a2.length = f2, 0 !== f2) {
            if (0 === p2) return a2.length = 8, a2[0] = a2[6] = e2 + n2, a2[1] = a2[3] = i2 + r2, a2[2] = a2[4] = e2 - n2, void (a2[5] = a2[7] = i2 - r2);
            var m2 = 0, g2 = 4 * p2 + (n2 ? 2 : 0) + 2, v2 = g2, _2 = f2, y2 = e2 + (w2 = n2 + o2), x2 = e2 - w2, b2 = i2 + (A2 = r2);
            if (a2[m2++] = y2, a2[m2++] = b2, a2[--g2] = b2, a2[--g2] = x2, r2) {
              var T2 = i2 - A2;
              a2[v2++] = x2, a2[v2++] = T2, a2[--_2] = T2, a2[--_2] = y2;
            }
            for (var E2 = 1; E2 < p2; E2++) {
              var S2 = Math.PI / 2 * (E2 / p2);
              y2 = e2 + (w2 = n2 + Math.cos(S2) * o2), x2 = e2 - w2, b2 = i2 + (A2 = r2 + Math.sin(S2) * s2), T2 = i2 - A2;
              a2[m2++] = y2, a2[m2++] = b2, a2[--g2] = b2, a2[--g2] = x2, a2[v2++] = x2, a2[v2++] = T2, a2[--_2] = T2, a2[--_2] = y2;
            }
            var w2, A2;
            y2 = e2 + (w2 = n2), x2 = e2 - w2, b2 = i2 + (A2 = r2 + s2), T2 = i2 - A2;
            a2[m2++] = y2, a2[m2++] = b2, a2[--_2] = T2, a2[--_2] = y2, n2 && (a2[m2++] = x2, a2[m2++] = b2, a2[--_2] = T2, a2[--_2] = x2);
          }
        } else a2.length = 0;
      }, triangulate: function(t2, e2) {
        var i2, n2, r2 = t2.points, o2 = e2.points, s2 = e2.indices, a2 = o2.length / 2, l2 = a2;
        if (t2.type !== Lh.l.RREC) {
          var h2 = t2.shape;
          i2 = h2.x, n2 = h2.y;
        } else {
          var u2 = t2.shape;
          i2 = u2.x + u2.width / 2, n2 = u2.y + u2.height / 2;
        }
        var c2 = t2.matrix;
        o2.push(t2.matrix ? c2.a * i2 + c2.c * n2 + c2.tx : i2, t2.matrix ? c2.b * i2 + c2.d * n2 + c2.ty : n2), a2++, o2.push(r2[0], r2[1]);
        for (var d2 = 2; d2 < r2.length; d2 += 2) o2.push(r2[d2], r2[d2 + 1]), s2.push(a2++, l2, a2);
        s2.push(l2 + 1, l2, a2);
      } }, Cd = { build: function(t2) {
        var e2 = t2.shape, i2 = e2.x, n2 = e2.y, r2 = e2.width, o2 = e2.height, s2 = t2.points;
        s2.length = 0, s2.push(i2, n2, i2 + r2, n2, i2 + r2, n2 + o2, i2, n2 + o2);
      }, triangulate: function(t2, e2) {
        var i2 = t2.points, n2 = e2.points, r2 = n2.length / 2;
        n2.push(i2[0], i2[1], i2[2], i2[3], i2[6], i2[7], i2[4], i2[5]), e2.indices.push(r2, r2 + 1, r2 + 2, r2 + 1, r2 + 2, r2 + 3);
      } };
      function Rd(t2, e2, i2) {
        return t2 + (e2 - t2) * i2;
      }
      function Id(t2, e2, i2, n2, r2, o2, s2) {
        void 0 === s2 && (s2 = []);
        for (var a2 = s2, l2 = 0, h2 = 0, u2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0; f2 <= 20; ++f2) l2 = Rd(t2, i2, m2 = f2 / 20), h2 = Rd(e2, n2, m2), u2 = Rd(i2, r2, m2), c2 = Rd(n2, o2, m2), d2 = Rd(l2, u2, m2), p2 = Rd(h2, c2, m2), 0 === f2 && a2[a2.length - 2] === d2 && a2[a2.length - 1] === p2 || a2.push(d2, p2);
        return a2;
      }
      var Pd = { build: function(t2) {
        if (Jd.nextRoundedRectBehavior) Md.build(t2);
        else {
          var e2 = t2.shape, i2 = t2.points, n2 = e2.x, r2 = e2.y, o2 = e2.width, s2 = e2.height, a2 = Math.max(0, Math.min(e2.radius, Math.min(o2, s2) / 2));
          i2.length = 0, a2 ? (Id(n2, r2 + a2, n2, r2, n2 + a2, r2, i2), Id(n2 + o2 - a2, r2, n2 + o2, r2, n2 + o2, r2 + a2, i2), Id(n2 + o2, r2 + s2 - a2, n2 + o2, r2 + s2, n2 + o2 - a2, r2 + s2, i2), Id(n2 + a2, r2 + s2, n2, r2 + s2, n2, r2 + s2 - a2, i2)) : i2.push(n2, r2, n2 + o2, r2, n2 + o2, r2 + s2, n2, r2 + s2);
        }
      }, triangulate: function(t2, e2) {
        if (Jd.nextRoundedRectBehavior) Md.triangulate(t2, e2);
        else {
          for (var i2 = t2.points, n2 = e2.points, r2 = e2.indices, o2 = n2.length / 2, s2 = Object(Ph.earcut)(i2, null, 2), a2 = 0, l2 = s2.length; a2 < l2; a2 += 3) r2.push(s2[a2] + o2), r2.push(s2[a2 + 1] + o2), r2.push(s2[a2 + 2] + o2);
          for (a2 = 0, l2 = i2.length; a2 < l2; a2++) n2.push(i2[a2], i2[++a2]);
        }
      } };
      function Od(t2, e2, i2, n2, r2, o2, s2, a2) {
        var l2, h2;
        s2 ? (l2 = n2, h2 = -i2) : (l2 = -n2, h2 = i2);
        var u2 = t2 - i2 * r2 + l2, c2 = e2 - n2 * r2 + h2, d2 = t2 + i2 * o2 + l2, p2 = e2 + n2 * o2 + h2;
        return a2.push(u2, c2), a2.push(d2, p2), 2;
      }
      function Nd(t2, e2, i2, n2, r2, o2, s2, a2) {
        var l2 = i2 - t2, h2 = n2 - e2, u2 = Math.atan2(l2, h2), c2 = Math.atan2(r2 - t2, o2 - e2);
        a2 && u2 < c2 ? u2 += 2 * Math.PI : !a2 && u2 > c2 && (c2 += 2 * Math.PI);
        var d2 = u2, p2 = c2 - u2, f2 = Math.abs(p2), m2 = Math.sqrt(l2 * l2 + h2 * h2), g2 = 1 + (15 * f2 * Math.sqrt(m2) / Math.PI >> 0), v2 = p2 / g2;
        if (d2 += v2, a2) {
          s2.push(t2, e2), s2.push(i2, n2);
          for (var _2 = 1, y2 = d2; _2 < g2; _2++, y2 += v2) s2.push(t2, e2), s2.push(t2 + Math.sin(y2) * m2, e2 + Math.cos(y2) * m2);
          s2.push(t2, e2), s2.push(r2, o2);
        } else {
          s2.push(i2, n2), s2.push(t2, e2);
          for (_2 = 1, y2 = d2; _2 < g2; _2++, y2 += v2) s2.push(t2 + Math.sin(y2) * m2, e2 + Math.cos(y2) * m2), s2.push(t2, e2);
          s2.push(r2, o2), s2.push(t2, e2);
        }
        return 2 * g2;
      }
      function Ld(t2, e2) {
        t2.lineStyle.native ? function(t3, e3) {
          var i2 = 0, n2 = t3.shape, r2 = t3.points || n2.points, o2 = n2.type !== Lh.l.POLY || n2.closeStroke;
          if (0 !== r2.length) {
            var s2 = e3.points, a2 = e3.indices, l2 = r2.length / 2, h2 = s2.length / 2, u2 = h2;
            for (s2.push(r2[0], r2[1]), i2 = 1; i2 < l2; i2++) s2.push(r2[2 * i2], r2[2 * i2 + 1]), a2.push(u2, u2 + 1), u2++;
            o2 && a2.push(u2, h2);
          }
        }(t2, e2) : function(t3, e3) {
          var i2 = t3.shape, n2 = t3.points || i2.points.slice(), r2 = e3.closePointEps;
          if (0 !== n2.length) {
            var o2 = t3.lineStyle, s2 = new Lh.g(n2[0], n2[1]), a2 = new Lh.g(n2[n2.length - 2], n2[n2.length - 1]), l2 = i2.type !== Lh.l.POLY || i2.closeStroke, h2 = Math.abs(s2.x - a2.x) < r2 && Math.abs(s2.y - a2.y) < r2;
            if (l2) {
              n2 = n2.slice(), h2 && (n2.pop(), n2.pop(), a2.set(n2[n2.length - 2], n2[n2.length - 1]));
              var u2 = 0.5 * (s2.x + a2.x), c2 = 0.5 * (a2.y + s2.y);
              n2.unshift(u2, c2), n2.push(u2, c2);
            }
            var d2 = e3.points, p2 = n2.length / 2, f2 = n2.length, m2 = d2.length / 2, g2 = o2.width / 2, v2 = g2 * g2, _2 = o2.miterLimit * o2.miterLimit, y2 = n2[0], x2 = n2[1], b2 = n2[2], T2 = n2[3], E2 = 0, S2 = 0, w2 = -(x2 - T2), A2 = y2 - b2, M2 = 0, C2 = 0, R2 = Math.sqrt(w2 * w2 + A2 * A2);
            w2 /= R2, A2 /= R2, w2 *= g2, A2 *= g2;
            var I2 = o2.alignment, P2 = 2 * (1 - I2), O2 = 2 * I2;
            l2 || (o2.cap === gd.ROUND ? f2 += Nd(y2 - w2 * (P2 - O2) * 0.5, x2 - A2 * (P2 - O2) * 0.5, y2 - w2 * P2, x2 - A2 * P2, y2 + w2 * O2, x2 + A2 * O2, d2, true) + 2 : o2.cap === gd.SQUARE && (f2 += Od(y2, x2, w2, A2, P2, O2, true, d2))), d2.push(y2 - w2 * P2, x2 - A2 * P2), d2.push(y2 + w2 * O2, x2 + A2 * O2);
            for (var N2 = 1; N2 < p2 - 1; ++N2) {
              y2 = n2[2 * (N2 - 1)], x2 = n2[2 * (N2 - 1) + 1], b2 = n2[2 * N2], T2 = n2[2 * N2 + 1], E2 = n2[2 * (N2 + 1)], S2 = n2[2 * (N2 + 1) + 1], w2 = -(x2 - T2), A2 = y2 - b2, w2 /= R2 = Math.sqrt(w2 * w2 + A2 * A2), A2 /= R2, w2 *= g2, A2 *= g2, M2 = -(T2 - S2), C2 = b2 - E2, M2 /= R2 = Math.sqrt(M2 * M2 + C2 * C2), C2 /= R2, M2 *= g2, C2 *= g2;
              var L2 = b2 - y2, D2 = x2 - T2, F2 = b2 - E2, B2 = S2 - T2, U2 = D2 * F2 - B2 * L2, k2 = U2 < 0;
              if (Math.abs(U2) < 0.1) d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(b2 + w2 * O2, T2 + A2 * O2);
              else {
                var G2 = (-w2 + y2) * (-A2 + T2) - (-w2 + b2) * (-A2 + x2), H2 = (-M2 + E2) * (-C2 + T2) - (-M2 + b2) * (-C2 + S2), j2 = (L2 * H2 - F2 * G2) / U2, z2 = (B2 * G2 - D2 * H2) / U2, V2 = (j2 - b2) * (j2 - b2) + (z2 - T2) * (z2 - T2), X2 = b2 + (j2 - b2) * P2, W2 = T2 + (z2 - T2) * P2, Y2 = b2 - (j2 - b2) * O2, q2 = T2 - (z2 - T2) * O2, Z2 = k2 ? P2 : O2;
                V2 <= Math.min(L2 * L2 + D2 * D2, F2 * F2 + B2 * B2) + Z2 * Z2 * v2 ? o2.join === md.BEVEL || V2 / v2 > _2 ? (k2 ? (d2.push(X2, W2), d2.push(b2 + w2 * O2, T2 + A2 * O2), d2.push(X2, W2), d2.push(b2 + M2 * O2, T2 + C2 * O2)) : (d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(Y2, q2), d2.push(b2 - M2 * P2, T2 - C2 * P2), d2.push(Y2, q2)), f2 += 2) : o2.join === md.ROUND ? k2 ? (d2.push(X2, W2), d2.push(b2 + w2 * O2, T2 + A2 * O2), f2 += Nd(b2, T2, b2 + w2 * O2, T2 + A2 * O2, b2 + M2 * O2, T2 + C2 * O2, d2, true) + 4, d2.push(X2, W2), d2.push(b2 + M2 * O2, T2 + C2 * O2)) : (d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(Y2, q2), f2 += Nd(b2, T2, b2 - w2 * P2, T2 - A2 * P2, b2 - M2 * P2, T2 - C2 * P2, d2, false) + 4, d2.push(b2 - M2 * P2, T2 - C2 * P2), d2.push(Y2, q2)) : (d2.push(X2, W2), d2.push(Y2, q2)) : (d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(b2 + w2 * O2, T2 + A2 * O2), o2.join === md.ROUND ? f2 += k2 ? Nd(b2, T2, b2 + w2 * O2, T2 + A2 * O2, b2 + M2 * O2, T2 + C2 * O2, d2, true) + 2 : Nd(b2, T2, b2 - w2 * P2, T2 - A2 * P2, b2 - M2 * P2, T2 - C2 * P2, d2, false) + 2 : o2.join === md.MITER && V2 / v2 <= _2 && (k2 ? (d2.push(Y2, q2), d2.push(Y2, q2)) : (d2.push(X2, W2), d2.push(X2, W2)), f2 += 2), d2.push(b2 - M2 * P2, T2 - C2 * P2), d2.push(b2 + M2 * O2, T2 + C2 * O2), f2 += 2);
              }
            }
            y2 = n2[2 * (p2 - 2)], x2 = n2[2 * (p2 - 2) + 1], b2 = n2[2 * (p2 - 1)], w2 = -(x2 - (T2 = n2[2 * (p2 - 1) + 1])), A2 = y2 - b2, w2 /= R2 = Math.sqrt(w2 * w2 + A2 * A2), A2 /= R2, w2 *= g2, A2 *= g2, d2.push(b2 - w2 * P2, T2 - A2 * P2), d2.push(b2 + w2 * O2, T2 + A2 * O2), l2 || (o2.cap === gd.ROUND ? f2 += Nd(b2 - w2 * (P2 - O2) * 0.5, T2 - A2 * (P2 - O2) * 0.5, b2 - w2 * P2, T2 - A2 * P2, b2 + w2 * O2, T2 + A2 * O2, d2, false) + 2 : o2.cap === gd.SQUARE && (f2 += Od(b2, T2, w2, A2, P2, O2, false, d2)));
            var J2 = e3.indices, K2 = bd.epsilon * bd.epsilon;
            for (N2 = m2; N2 < f2 + m2 - 2; ++N2) y2 = d2[2 * N2], x2 = d2[2 * N2 + 1], b2 = d2[2 * (N2 + 1)], T2 = d2[2 * (N2 + 1) + 1], E2 = d2[2 * (N2 + 2)], S2 = d2[2 * (N2 + 2) + 1], Math.abs(y2 * (T2 - S2) + b2 * (S2 - x2) + E2 * (x2 - T2)) < K2 || J2.push(N2, N2 + 1, N2 + 2);
          }
        }(t2, e2);
      }
      var Dd, Fd = function() {
        function t2() {
        }
        return t2.curveTo = function(t3, e2, i2, n2, r2, o2) {
          var s2 = o2[o2.length - 2], a2 = o2[o2.length - 1] - e2, l2 = s2 - t3, h2 = n2 - e2, u2 = i2 - t3, c2 = Math.abs(a2 * u2 - l2 * h2);
          if (c2 < 1e-8 || 0 === r2) return o2[o2.length - 2] === t3 && o2[o2.length - 1] === e2 || o2.push(t3, e2), null;
          var d2 = a2 * a2 + l2 * l2, p2 = h2 * h2 + u2 * u2, f2 = a2 * h2 + l2 * u2, m2 = r2 * Math.sqrt(d2) / c2, g2 = r2 * Math.sqrt(p2) / c2, v2 = m2 * f2 / d2, _2 = g2 * f2 / p2, y2 = m2 * u2 + g2 * l2, x2 = m2 * h2 + g2 * a2, b2 = l2 * (g2 + v2), T2 = a2 * (g2 + v2), E2 = u2 * (m2 + _2), S2 = h2 * (m2 + _2);
          return { cx: y2 + t3, cy: x2 + e2, radius: r2, startAngle: Math.atan2(T2 - x2, b2 - y2), endAngle: Math.atan2(S2 - x2, E2 - y2), anticlockwise: l2 * h2 > u2 * a2 };
        }, t2.arc = function(t3, e2, i2, n2, r2, o2, s2, a2, l2) {
          for (var h2 = s2 - o2, u2 = bd._segmentsCount(Math.abs(h2) * r2, 40 * Math.ceil(Math.abs(h2) / Lh.f)), c2 = h2 / (2 * u2), d2 = 2 * c2, p2 = Math.cos(c2), f2 = Math.sin(c2), m2 = u2 - 1, g2 = m2 % 1 / m2, v2 = 0; v2 <= m2; ++v2) {
            var _2 = c2 + o2 + d2 * (v2 + g2 * v2), y2 = Math.cos(_2), x2 = -Math.sin(_2);
            l2.push((p2 * y2 + f2 * x2) * r2 + i2, (p2 * -x2 + f2 * y2) * r2 + n2);
          }
        }, t2;
      }(), Bd = function() {
        function t2() {
        }
        return t2.curveLength = function(t3, e2, i2, n2, r2, o2, s2, a2) {
          for (var l2 = 0, h2 = 0, u2 = 0, c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0, v2 = 0, _2 = 0, y2 = t3, x2 = e2, b2 = 1; b2 <= 10; ++b2) v2 = y2 - (m2 = (f2 = (p2 = (d2 = 1 - (h2 = b2 / 10)) * d2) * d2) * t3 + 3 * p2 * h2 * i2 + 3 * d2 * (u2 = h2 * h2) * r2 + (c2 = u2 * h2) * s2), _2 = x2 - (g2 = f2 * e2 + 3 * p2 * h2 * n2 + 3 * d2 * u2 * o2 + c2 * a2), y2 = m2, x2 = g2, l2 += Math.sqrt(v2 * v2 + _2 * _2);
          return l2;
        }, t2.curveTo = function(e2, i2, n2, r2, o2, s2, a2) {
          var l2 = a2[a2.length - 2], h2 = a2[a2.length - 1];
          a2.length -= 2;
          var u2 = bd._segmentsCount(t2.curveLength(l2, h2, e2, i2, n2, r2, o2, s2)), c2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0;
          a2.push(l2, h2);
          for (var g2 = 1, v2 = 0; g2 <= u2; ++g2) p2 = (d2 = (c2 = 1 - (v2 = g2 / u2)) * c2) * c2, m2 = (f2 = v2 * v2) * v2, a2.push(p2 * l2 + 3 * d2 * v2 * e2 + 3 * c2 * f2 * n2 + m2 * o2, p2 * h2 + 3 * d2 * v2 * i2 + 3 * c2 * f2 * r2 + m2 * s2);
        }, t2;
      }(), Ud = function() {
        function t2() {
        }
        return t2.curveLength = function(t3, e2, i2, n2, r2, o2) {
          var s2 = t3 - 2 * i2 + r2, a2 = e2 - 2 * n2 + o2, l2 = 2 * i2 - 2 * t3, h2 = 2 * n2 - 2 * e2, u2 = 4 * (s2 * s2 + a2 * a2), c2 = 4 * (s2 * l2 + a2 * h2), d2 = l2 * l2 + h2 * h2, p2 = 2 * Math.sqrt(u2 + c2 + d2), f2 = Math.sqrt(u2), m2 = 2 * u2 * f2, g2 = 2 * Math.sqrt(d2), v2 = c2 / f2;
          return (m2 * p2 + f2 * c2 * (p2 - g2) + (4 * d2 * u2 - c2 * c2) * Math.log((2 * f2 + v2 + p2) / (v2 + g2))) / (4 * m2);
        }, t2.curveTo = function(e2, i2, n2, r2, o2) {
          for (var s2 = o2[o2.length - 2], a2 = o2[o2.length - 1], l2 = bd._segmentsCount(t2.curveLength(s2, a2, e2, i2, n2, r2)), h2 = 0, u2 = 0, c2 = 1; c2 <= l2; ++c2) {
            var d2 = c2 / l2;
            h2 = s2 + (e2 - s2) * d2, u2 = a2 + (i2 - a2) * d2, o2.push(h2 + (e2 + (n2 - e2) * d2 - h2) * d2, u2 + (i2 + (r2 - i2) * d2 - u2) * d2);
          }
        }, t2;
      }(), kd = function() {
        function t2() {
          this.reset();
        }
        return t2.prototype.begin = function(t3, e2, i2) {
          this.reset(), this.style = t3, this.start = e2, this.attribStart = i2;
        }, t2.prototype.end = function(t3, e2) {
          this.attribSize = e2 - this.attribStart, this.size = t3 - this.start;
        }, t2.prototype.reset = function() {
          this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
        }, t2;
      }(), Gd = ((Dd = {})[Lh.l.POLY] = Ad, Dd[Lh.l.CIRC] = Md, Dd[Lh.l.ELIP] = Md, Dd[Lh.l.RECT] = Cd, Dd[Lh.l.RREC] = Pd, Dd), Hd = [], jd = [], zd = function() {
        function t2(t3, e2, i2, n2) {
          void 0 === e2 && (e2 = null), void 0 === i2 && (i2 = null), void 0 === n2 && (n2 = null), this.points = [], this.holes = [], this.shape = t3, this.lineStyle = i2, this.fillStyle = e2, this.matrix = n2, this.type = t3.type;
        }
        return t2.prototype.clone = function() {
          return new t2(this.shape, this.fillStyle, this.lineStyle, this.matrix);
        }, t2.prototype.destroy = function() {
          this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
        }, t2;
      }(), Vd = new Lh.g(), Xd = new Oh.a(), Wd = function(t2) {
        function e2() {
          var e3 = t2.call(this) || this;
          return e3.closePointEps = 1e-4, e3.boundsPadding = 0, e3.uvsFloat32 = null, e3.indicesUint16 = null, e3.batchable = false, e3.points = [], e3.colors = [], e3.uvs = [], e3.indices = [], e3.textureIds = [], e3.graphicsData = [], e3.drawCalls = [], e3.batchDirty = -1, e3.batches = [], e3.dirty = 0, e3.cacheDirty = -1, e3.clearDirty = 0, e3.shapeIndex = 0, e3._bounds = new Oh.a(), e3.boundsDirty = -1, e3;
        }
        return Sd(e2, t2), Object.defineProperty(e2.prototype, "bounds", { get: function() {
          return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
        }, enumerable: false, configurable: true }), e2.prototype.invalidate = function() {
          this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
          for (var t3 = 0; t3 < this.drawCalls.length; t3++) this.drawCalls[t3].texArray.clear(), jd.push(this.drawCalls[t3]);
          this.drawCalls.length = 0;
          for (t3 = 0; t3 < this.batches.length; t3++) {
            var e3 = this.batches[t3];
            e3.reset(), Hd.push(e3);
          }
          this.batches.length = 0;
        }, e2.prototype.clear = function() {
          return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
        }, e2.prototype.drawShape = function(t3, e3, i2, n2) {
          void 0 === e3 && (e3 = null), void 0 === i2 && (i2 = null), void 0 === n2 && (n2 = null);
          var r2 = new zd(t3, e3, i2, n2);
          return this.graphicsData.push(r2), this.dirty++, this;
        }, e2.prototype.drawHole = function(t3, e3) {
          if (void 0 === e3 && (e3 = null), !this.graphicsData.length) return null;
          var i2 = new zd(t3, null, null, e3), n2 = this.graphicsData[this.graphicsData.length - 1];
          return i2.lineStyle = n2.lineStyle, n2.holes.push(i2), this.dirty++, this;
        }, e2.prototype.destroy = function() {
          t2.prototype.destroy.call(this);
          for (var e3 = 0; e3 < this.graphicsData.length; ++e3) this.graphicsData[e3].destroy();
          this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
        }, e2.prototype.containsPoint = function(t3) {
          for (var e3 = this.graphicsData, i2 = 0; i2 < e3.length; ++i2) {
            var n2 = e3[i2];
            if (n2.fillStyle.visible && (n2.shape && (n2.matrix ? n2.matrix.applyInverse(t3, Vd) : Vd.copyFrom(t3), n2.shape.contains(Vd.x, Vd.y)))) {
              var r2 = false;
              if (n2.holes) for (var o2 = 0; o2 < n2.holes.length; o2++) {
                if (n2.holes[o2].shape.contains(Vd.x, Vd.y)) {
                  r2 = true;
                  break;
                }
              }
              if (!r2) return true;
            }
          }
          return false;
        }, e2.prototype.updateBatches = function(t3) {
          if (this.graphicsData.length) {
            if (this.validateBatching()) {
              this.cacheDirty = this.dirty;
              var e3 = this.uvs, i2 = this.graphicsData, n2 = null, r2 = null;
              this.batches.length > 0 && (r2 = (n2 = this.batches[this.batches.length - 1]).style);
              for (var o2 = this.shapeIndex; o2 < i2.length; o2++) {
                this.shapeIndex++;
                var s2 = i2[o2], a2 = s2.fillStyle, l2 = s2.lineStyle;
                Gd[s2.type].build(s2), s2.matrix && this.transformPoints(s2.points, s2.matrix), (a2.visible || l2.visible) && this.processHoles(s2.holes);
                for (var h2 = 0; h2 < 2; h2++) {
                  var u2 = 0 === h2 ? a2 : l2;
                  if (u2.visible) {
                    var c2 = u2.texture.baseTexture, d2 = this.indices.length, p2 = this.points.length / 2;
                    c2.wrapMode = Sc.s.REPEAT, 0 === h2 ? this.processFill(s2) : this.processLine(s2);
                    var f2 = this.points.length / 2 - p2;
                    0 !== f2 && (n2 && !this._compareStyles(r2, u2) && (n2.end(d2, p2), n2 = null), n2 || ((n2 = Hd.pop() || new kd()).begin(u2, d2, p2), this.batches.push(n2), r2 = u2), this.addUvs(this.points, e3, u2.texture, p2, f2, u2.matrix));
                  }
                }
              }
              var m2 = this.indices.length, g2 = this.points.length / 2;
              if (n2 && n2.end(m2, g2), 0 !== this.batches.length) {
                if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) this.indicesUint16.set(this.indices);
                else {
                  var v2 = g2 > 65535 && t3;
                  this.indicesUint16 = v2 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);
                }
                this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
              } else this.batchable = true;
            }
          } else this.batchable = true;
        }, e2.prototype._compareStyles = function(t3, e3) {
          return !(!t3 || !e3) && (t3.texture.baseTexture === e3.texture.baseTexture && (t3.color + t3.alpha === e3.color + e3.alpha && !!t3.native == !!e3.native));
        }, e2.prototype.validateBatching = function() {
          if (this.dirty === this.cacheDirty || !this.graphicsData.length) return false;
          for (var t3 = 0, e3 = this.graphicsData.length; t3 < e3; t3++) {
            var i2 = this.graphicsData[t3], n2 = i2.fillStyle, r2 = i2.lineStyle;
            if (n2 && !n2.texture.baseTexture.valid) return false;
            if (r2 && !r2.texture.baseTexture.valid) return false;
          }
          return true;
        }, e2.prototype.packBatches = function() {
          this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
          for (var t3 = this.batches, e3 = 0, i2 = t3.length; e3 < i2; e3++) for (var n2 = t3[e3], r2 = 0; r2 < n2.size; r2++) {
            var o2 = n2.start + r2;
            this.indicesUint16[o2] = this.indicesUint16[o2] - n2.attribStart;
          }
        }, e2.prototype.isBatchable = function() {
          if (this.points.length > 131070) return false;
          for (var t3 = this.batches, i2 = 0; i2 < t3.length; i2++) if (t3[i2].style.native) return false;
          return this.points.length < 2 * e2.BATCHABLE_SIZE;
        }, e2.prototype.buildDrawCalls = function() {
          for (var t3 = ++Vh.c._globalBatch, e3 = 0; e3 < this.drawCalls.length; e3++) this.drawCalls[e3].texArray.clear(), jd.push(this.drawCalls[e3]);
          this.drawCalls.length = 0;
          var i2 = this.colors, n2 = this.textureIds, r2 = jd.pop();
          r2 || ((r2 = new Vh.d()).texArray = new Vh.g()), r2.texArray.count = 0, r2.start = 0, r2.size = 0, r2.type = Sc.f.TRIANGLES;
          var o2 = 0, s2 = null, a2 = 0, l2 = false, h2 = Sc.f.TRIANGLES, u2 = 0;
          this.drawCalls.push(r2);
          for (e3 = 0; e3 < this.batches.length; e3++) {
            var c2 = this.batches[e3], d2 = c2.style, p2 = d2.texture.baseTexture;
            l2 !== !!d2.native && (h2 = (l2 = !!d2.native) ? Sc.f.LINES : Sc.f.TRIANGLES, s2 = null, o2 = 8, t3++), s2 !== p2 && (s2 = p2, p2._batchEnabled !== t3 && (8 === o2 && (t3++, o2 = 0, r2.size > 0 && ((r2 = jd.pop()) || ((r2 = new Vh.d()).texArray = new Vh.g()), this.drawCalls.push(r2)), r2.start = u2, r2.size = 0, r2.texArray.count = 0, r2.type = h2), p2.touched = 1, p2._batchEnabled = t3, p2._batchLocation = o2, p2.wrapMode = Sc.s.REPEAT, r2.texArray.elements[r2.texArray.count++] = p2, o2++)), r2.size += c2.size, u2 += c2.size, a2 = p2._batchLocation, this.addColors(i2, d2.color, d2.alpha, c2.attribSize, c2.attribStart), this.addTextureIds(n2, a2, c2.attribSize, c2.attribStart);
          }
          Vh.c._globalBatch = t3, this.packAttributes();
        }, e2.prototype.packAttributes = function() {
          for (var t3 = this.points, e3 = this.uvs, i2 = this.colors, n2 = this.textureIds, r2 = new ArrayBuffer(3 * t3.length * 4), o2 = new Float32Array(r2), s2 = new Uint32Array(r2), a2 = 0, l2 = 0; l2 < t3.length / 2; l2++) o2[a2++] = t3[2 * l2], o2[a2++] = t3[2 * l2 + 1], o2[a2++] = e3[2 * l2], o2[a2++] = e3[2 * l2 + 1], s2[a2++] = i2[l2], o2[a2++] = n2[l2];
          this._buffer.update(r2), this._indexBuffer.update(this.indicesUint16);
        }, e2.prototype.processFill = function(t3) {
          t3.holes.length ? Ad.triangulate(t3, this) : Gd[t3.type].triangulate(t3, this);
        }, e2.prototype.processLine = function(t3) {
          Ld(t3, this);
          for (var e3 = 0; e3 < t3.holes.length; e3++) Ld(t3.holes[e3], this);
        }, e2.prototype.processHoles = function(t3) {
          for (var e3 = 0; e3 < t3.length; e3++) {
            var i2 = t3[e3];
            Gd[i2.type].build(i2), i2.matrix && this.transformPoints(i2.points, i2.matrix);
          }
        }, e2.prototype.calculateBounds = function() {
          var t3 = this._bounds, e3 = Xd, i2 = Lh.d.IDENTITY;
          this._bounds.clear(), e3.clear();
          for (var n2 = 0; n2 < this.graphicsData.length; n2++) {
            var r2 = this.graphicsData[n2], o2 = r2.shape, s2 = r2.type, a2 = r2.lineStyle, l2 = r2.matrix || Lh.d.IDENTITY, h2 = 0;
            if (a2 && a2.visible && (h2 = a2.width, s2 !== Lh.l.POLY || r2.fillStyle.visible ? h2 *= Math.max(0, a2.alignment) : h2 *= Math.max(a2.alignment, 1 - a2.alignment)), i2 !== l2 && (e3.isEmpty() || (t3.addBoundsMatrix(e3, i2), e3.clear()), i2 = l2), s2 === Lh.l.RECT || s2 === Lh.l.RREC) {
              var u2 = o2;
              e3.addFramePad(u2.x, u2.y, u2.x + u2.width, u2.y + u2.height, h2, h2);
            } else if (s2 === Lh.l.CIRC) {
              var c2 = o2;
              e3.addFramePad(c2.x, c2.y, c2.x, c2.y, c2.radius + h2, c2.radius + h2);
            } else if (s2 === Lh.l.ELIP) {
              var d2 = o2;
              e3.addFramePad(d2.x, d2.y, d2.x, d2.y, d2.width + h2, d2.height + h2);
            } else {
              var p2 = o2;
              t3.addVerticesMatrix(i2, p2.points, 0, p2.points.length, h2, h2);
            }
          }
          e3.isEmpty() || t3.addBoundsMatrix(e3, i2), t3.pad(this.boundsPadding, this.boundsPadding);
        }, e2.prototype.transformPoints = function(t3, e3) {
          for (var i2 = 0; i2 < t3.length / 2; i2++) {
            var n2 = t3[2 * i2], r2 = t3[2 * i2 + 1];
            t3[2 * i2] = e3.a * n2 + e3.c * r2 + e3.tx, t3[2 * i2 + 1] = e3.b * n2 + e3.d * r2 + e3.ty;
          }
        }, e2.prototype.addColors = function(t3, e3, i2, n2, r2) {
          void 0 === r2 && (r2 = 0);
          var o2 = (e3 >> 16) + (65280 & e3) + ((255 & e3) << 16), s2 = Object(Ph.premultiplyTint)(o2, i2);
          t3.length = Math.max(t3.length, r2 + n2);
          for (var a2 = 0; a2 < n2; a2++) t3[r2 + a2] = s2;
        }, e2.prototype.addTextureIds = function(t3, e3, i2, n2) {
          void 0 === n2 && (n2 = 0), t3.length = Math.max(t3.length, n2 + i2);
          for (var r2 = 0; r2 < i2; r2++) t3[n2 + r2] = e3;
        }, e2.prototype.addUvs = function(t3, e3, i2, n2, r2, o2) {
          void 0 === o2 && (o2 = null);
          for (var s2 = 0, a2 = e3.length, l2 = i2.frame; s2 < r2; ) {
            var h2 = t3[2 * (n2 + s2)], u2 = t3[2 * (n2 + s2) + 1];
            if (o2) {
              var c2 = o2.a * h2 + o2.c * u2 + o2.tx;
              u2 = o2.b * h2 + o2.d * u2 + o2.ty, h2 = c2;
            }
            s2++, e3.push(h2 / l2.width, u2 / l2.height);
          }
          var d2 = i2.baseTexture;
          (l2.width < d2.width || l2.height < d2.height) && this.adjustUvs(e3, i2, a2, r2);
        }, e2.prototype.adjustUvs = function(t3, e3, i2, n2) {
          for (var r2 = e3.baseTexture, o2 = 1e-6, s2 = i2 + 2 * n2, a2 = e3.frame, l2 = a2.width / r2.width, h2 = a2.height / r2.height, u2 = a2.x / a2.width, c2 = a2.y / a2.height, d2 = Math.floor(t3[i2] + o2), p2 = Math.floor(t3[i2 + 1] + o2), f2 = i2 + 2; f2 < s2; f2 += 2) d2 = Math.min(d2, Math.floor(t3[f2] + o2)), p2 = Math.min(p2, Math.floor(t3[f2 + 1] + o2));
          u2 -= d2, c2 -= p2;
          for (f2 = i2; f2 < s2; f2 += 2) t3[f2] = (t3[f2] + u2) * l2, t3[f2 + 1] = (t3[f2 + 1] + c2) * h2;
        }, e2.BATCHABLE_SIZE = 100, e2;
      }(Vh.e), Yd = function(t2) {
        function e2() {
          var e3 = null !== t2 && t2.apply(this, arguments) || this;
          return e3.width = 0, e3.alignment = 0.5, e3.native = false, e3.cap = gd.BUTT, e3.join = md.MITER, e3.miterLimit = 10, e3;
        }
        return Sd(e2, t2), e2.prototype.clone = function() {
          var t3 = new e2();
          return t3.color = this.color, t3.alpha = this.alpha, t3.texture = this.texture, t3.matrix = this.matrix, t3.visible = this.visible, t3.width = this.width, t3.alignment = this.alignment, t3.native = this.native, t3.cap = this.cap, t3.join = this.join, t3.miterLimit = this.miterLimit, t3;
        }, e2.prototype.reset = function() {
          t2.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = false;
        }, e2;
      }(Td), qd = new Float32Array(3), Zd = {}, Jd = function(t2) {
        function e2(e3) {
          void 0 === e3 && (e3 = null);
          var i2 = t2.call(this) || this;
          return i2.shader = null, i2.pluginName = "batch", i2.currentPath = null, i2.batches = [], i2.batchTint = -1, i2.batchDirty = -1, i2.vertexData = null, i2._fillStyle = new Td(), i2._lineStyle = new Yd(), i2._matrix = null, i2._holeMode = false, i2.state = Vh.s.for2d(), i2._geometry = e3 || new Wd(), i2._geometry.refCount++, i2._transformID = -1, i2.tint = 16777215, i2.blendMode = Sc.b.NORMAL, i2;
        }
        return Sd(e2, t2), Object.defineProperty(e2.prototype, "geometry", { get: function() {
          return this._geometry;
        }, enumerable: false, configurable: true }), e2.prototype.clone = function() {
          return this.finishPoly(), new e2(this._geometry);
        }, Object.defineProperty(e2.prototype, "blendMode", { get: function() {
          return this.state.blendMode;
        }, set: function(t3) {
          this.state.blendMode = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
          return this._tint;
        }, set: function(t3) {
          this._tint = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "fill", { get: function() {
          return this._fillStyle;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "line", { get: function() {
          return this._lineStyle;
        }, enumerable: false, configurable: true }), e2.prototype.lineStyle = function(t3, e3, i2, n2, r2) {
          return void 0 === t3 && (t3 = null), void 0 === e3 && (e3 = 0), void 0 === i2 && (i2 = 1), void 0 === n2 && (n2 = 0.5), void 0 === r2 && (r2 = false), "number" == typeof t3 && (t3 = { width: t3, color: e3, alpha: i2, alignment: n2, native: r2 }), this.lineTextureStyle(t3);
        }, e2.prototype.lineTextureStyle = function(t3) {
          t3 = Object.assign({ width: 0, texture: Vh.t.WHITE, color: t3 && t3.texture ? 16777215 : 0, alpha: 1, matrix: null, alignment: 0.5, native: false, cap: gd.BUTT, join: md.MITER, miterLimit: 10 }, t3), this.currentPath && this.startPoly();
          var e3 = t3.width > 0 && t3.alpha > 0;
          return e3 ? (t3.matrix && (t3.matrix = t3.matrix.clone(), t3.matrix.invert()), Object.assign(this._lineStyle, { visible: e3 }, t3)) : this._lineStyle.reset(), this;
        }, e2.prototype.startPoly = function() {
          if (this.currentPath) {
            var t3 = this.currentPath.points, e3 = this.currentPath.points.length;
            e3 > 2 && (this.drawShape(this.currentPath), this.currentPath = new Lh.h(), this.currentPath.closeStroke = false, this.currentPath.points.push(t3[e3 - 2], t3[e3 - 1]));
          } else this.currentPath = new Lh.h(), this.currentPath.closeStroke = false;
        }, e2.prototype.finishPoly = function() {
          this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
        }, e2.prototype.moveTo = function(t3, e3) {
          return this.startPoly(), this.currentPath.points[0] = t3, this.currentPath.points[1] = e3, this;
        }, e2.prototype.lineTo = function(t3, e3) {
          this.currentPath || this.moveTo(0, 0);
          var i2 = this.currentPath.points, n2 = i2[i2.length - 2], r2 = i2[i2.length - 1];
          return n2 === t3 && r2 === e3 || i2.push(t3, e3), this;
        }, e2.prototype._initCurve = function(t3, e3) {
          void 0 === t3 && (t3 = 0), void 0 === e3 && (e3 = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t3, e3]) : this.moveTo(t3, e3);
        }, e2.prototype.quadraticCurveTo = function(t3, e3, i2, n2) {
          this._initCurve();
          var r2 = this.currentPath.points;
          return 0 === r2.length && this.moveTo(0, 0), Ud.curveTo(t3, e3, i2, n2, r2), this;
        }, e2.prototype.bezierCurveTo = function(t3, e3, i2, n2, r2, o2) {
          return this._initCurve(), Bd.curveTo(t3, e3, i2, n2, r2, o2, this.currentPath.points), this;
        }, e2.prototype.arcTo = function(t3, e3, i2, n2, r2) {
          this._initCurve(t3, e3);
          var o2 = this.currentPath.points, s2 = Fd.curveTo(t3, e3, i2, n2, r2, o2);
          if (s2) {
            var a2 = s2.cx, l2 = s2.cy, h2 = s2.radius, u2 = s2.startAngle, c2 = s2.endAngle, d2 = s2.anticlockwise;
            this.arc(a2, l2, h2, u2, c2, d2);
          }
          return this;
        }, e2.prototype.arc = function(t3, e3, i2, n2, r2, o2) {
          if (void 0 === o2 && (o2 = false), n2 === r2) return this;
          if (!o2 && r2 <= n2 ? r2 += Lh.f : o2 && n2 <= r2 && (n2 += Lh.f), 0 === r2 - n2) return this;
          var s2 = t3 + Math.cos(n2) * i2, a2 = e3 + Math.sin(n2) * i2, l2 = this._geometry.closePointEps, h2 = this.currentPath ? this.currentPath.points : null;
          if (h2) {
            var u2 = Math.abs(h2[h2.length - 2] - s2), c2 = Math.abs(h2[h2.length - 1] - a2);
            u2 < l2 && c2 < l2 || h2.push(s2, a2);
          } else this.moveTo(s2, a2), h2 = this.currentPath.points;
          return Fd.arc(s2, a2, t3, e3, i2, n2, r2, o2, h2), this;
        }, e2.prototype.beginFill = function(t3, e3) {
          return void 0 === t3 && (t3 = 0), void 0 === e3 && (e3 = 1), this.beginTextureFill({ texture: Vh.t.WHITE, color: t3, alpha: e3 });
        }, e2.prototype.beginTextureFill = function(t3) {
          t3 = Object.assign({ texture: Vh.t.WHITE, color: 16777215, alpha: 1, matrix: null }, t3), this.currentPath && this.startPoly();
          var e3 = t3.alpha > 0;
          return e3 ? (t3.matrix && (t3.matrix = t3.matrix.clone(), t3.matrix.invert()), Object.assign(this._fillStyle, { visible: e3 }, t3)) : this._fillStyle.reset(), this;
        }, e2.prototype.endFill = function() {
          return this.finishPoly(), this._fillStyle.reset(), this;
        }, e2.prototype.drawRect = function(t3, e3, i2, n2) {
          return this.drawShape(new Lh.j(t3, e3, i2, n2));
        }, e2.prototype.drawRoundedRect = function(t3, e3, i2, n2, r2) {
          return this.drawShape(new Lh.k(t3, e3, i2, n2, r2));
        }, e2.prototype.drawCircle = function(t3, e3, i2) {
          return this.drawShape(new Lh.a(t3, e3, i2));
        }, e2.prototype.drawEllipse = function(t3, e3, i2, n2) {
          return this.drawShape(new Lh.c(t3, e3, i2, n2));
        }, e2.prototype.drawPolygon = function() {
          for (var t3, e3 = arguments, i2 = [], n2 = 0; n2 < arguments.length; n2++) i2[n2] = e3[n2];
          var r2 = true, o2 = i2[0];
          o2.points ? (r2 = o2.closeStroke, t3 = o2.points) : t3 = Array.isArray(i2[0]) ? i2[0] : i2;
          var s2 = new Lh.h(t3);
          return s2.closeStroke = r2, this.drawShape(s2), this;
        }, e2.prototype.drawShape = function(t3) {
          return this._holeMode ? this._geometry.drawHole(t3, this._matrix) : this._geometry.drawShape(t3, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
        }, e2.prototype.clear = function() {
          return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = false, this.currentPath = null, this;
        }, e2.prototype.isFastRect = function() {
          var t3 = this._geometry.graphicsData;
          return !(1 !== t3.length || t3[0].shape.type !== Lh.l.RECT || t3[0].matrix || t3[0].holes.length || t3[0].lineStyle.visible && t3[0].lineStyle.width);
        }, e2.prototype._render = function(t3) {
          this.finishPoly();
          var e3 = this._geometry, i2 = t3.context.supports.uint32Indices;
          e3.updateBatches(i2), e3.batchable ? (this.batchDirty !== e3.batchDirty && this._populateBatches(), this._renderBatched(t3)) : (t3.batch.flush(), this._renderDirect(t3));
        }, e2.prototype._populateBatches = function() {
          var t3 = this._geometry, e3 = this.blendMode, i2 = t3.batches.length;
          this.batchTint = -1, this._transformID = -1, this.batchDirty = t3.batchDirty, this.batches.length = i2, this.vertexData = new Float32Array(t3.points);
          for (var n2 = 0; n2 < i2; n2++) {
            var r2 = t3.batches[n2], o2 = r2.style.color, s2 = new Float32Array(this.vertexData.buffer, 4 * r2.attribStart * 2, 2 * r2.attribSize), a2 = new Float32Array(t3.uvsFloat32.buffer, 4 * r2.attribStart * 2, 2 * r2.attribSize), l2 = { vertexData: s2, blendMode: e3, indices: new Uint16Array(t3.indicesUint16.buffer, 2 * r2.start, r2.size), uvs: a2, _batchRGB: Object(Ph.hex2rgb)(o2), _tintRGB: o2, _texture: r2.style.texture, alpha: r2.style.alpha, worldAlpha: 1 };
            this.batches[n2] = l2;
          }
        }, e2.prototype._renderBatched = function(t3) {
          if (this.batches.length) {
            t3.batch.setObjectRenderer(t3.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
            for (var e3 = 0, i2 = this.batches.length; e3 < i2; e3++) {
              var n2 = this.batches[e3];
              n2.worldAlpha = this.worldAlpha * n2.alpha, t3.plugins[this.pluginName].render(n2);
            }
          }
        }, e2.prototype._renderDirect = function(t3) {
          var e3 = this._resolveDirectShader(t3), i2 = this._geometry, n2 = this.tint, r2 = this.worldAlpha, o2 = e3.uniforms, s2 = i2.drawCalls;
          o2.translationMatrix = this.transform.worldTransform, o2.tint[0] = (n2 >> 16 & 255) / 255 * r2, o2.tint[1] = (n2 >> 8 & 255) / 255 * r2, o2.tint[2] = (255 & n2) / 255 * r2, o2.tint[3] = r2, t3.shader.bind(e3), t3.geometry.bind(i2, e3), t3.state.set(this.state);
          for (var a2 = 0, l2 = s2.length; a2 < l2; a2++) this._renderDrawCallDirect(t3, i2.drawCalls[a2]);
        }, e2.prototype._renderDrawCallDirect = function(t3, e3) {
          for (var i2 = e3.texArray, n2 = e3.type, r2 = e3.size, o2 = e3.start, s2 = i2.count, a2 = 0; a2 < s2; a2++) t3.texture.bind(i2.elements[a2], a2);
          t3.geometry.draw(n2, r2, o2);
        }, e2.prototype._resolveDirectShader = function(t3) {
          var e3 = this.shader, i2 = this.pluginName;
          if (!e3) {
            if (!Zd[i2]) {
              for (var n2 = t3.plugins[i2].MAX_TEXTURES, r2 = new Int32Array(n2), o2 = 0; o2 < n2; o2++) r2[o2] = o2;
              var s2 = { tint: new Float32Array([1, 1, 1, 1]), translationMatrix: new Lh.d(), default: Vh.v.from({ uSamplers: r2 }, true) }, a2 = t3.plugins[i2]._shader.program;
              Zd[i2] = new Vh.r(a2, s2);
            }
            e3 = Zd[i2];
          }
          return e3;
        }, e2.prototype._calculateBounds = function() {
          this.finishPoly();
          var t3 = this._geometry;
          if (t3.graphicsData.length) {
            var e3 = t3.bounds, i2 = e3.minX, n2 = e3.minY, r2 = e3.maxX, o2 = e3.maxY;
            this._bounds.addFrame(this.transform, i2, n2, r2, o2);
          }
        }, e2.prototype.containsPoint = function(t3) {
          return this.worldTransform.applyInverse(t3, e2._TEMP_POINT), this._geometry.containsPoint(e2._TEMP_POINT);
        }, e2.prototype.calculateTints = function() {
          if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            for (var t3 = Object(Ph.hex2rgb)(this.tint, qd), e3 = 0; e3 < this.batches.length; e3++) {
              var i2 = this.batches[e3], n2 = i2._batchRGB, r2 = (t3[0] * n2[0] * 255 << 16) + (t3[1] * n2[1] * 255 << 8) + (0 | t3[2] * n2[2] * 255);
              i2._tintRGB = (r2 >> 16) + (65280 & r2) + ((255 & r2) << 16);
            }
          }
        }, e2.prototype.calculateVertices = function() {
          var t3 = this.transform._worldID;
          if (this._transformID !== t3) {
            this._transformID = t3;
            for (var e3 = this.transform.worldTransform, i2 = e3.a, n2 = e3.b, r2 = e3.c, o2 = e3.d, s2 = e3.tx, a2 = e3.ty, l2 = this._geometry.points, h2 = this.vertexData, u2 = 0, c2 = 0; c2 < l2.length; c2 += 2) {
              var d2 = l2[c2], p2 = l2[c2 + 1];
              h2[u2++] = i2 * d2 + r2 * p2 + s2, h2[u2++] = o2 * p2 + n2 * d2 + a2;
            }
          }
        }, e2.prototype.closePath = function() {
          var t3 = this.currentPath;
          return t3 && (t3.closeStroke = true, this.finishPoly()), this;
        }, e2.prototype.setMatrix = function(t3) {
          return this._matrix = t3, this;
        }, e2.prototype.beginHole = function() {
          return this.finishPoly(), this._holeMode = true, this;
        }, e2.prototype.endHole = function() {
          return this.finishPoly(), this._holeMode = false, this;
        }, e2.prototype.destroy = function(e3) {
          this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t2.prototype.destroy.call(this, e3);
        }, e2.nextRoundedRectBehavior = false, e2._TEMP_POINT = new Lh.g(), e2;
      }(Oh.b), Kd = function(t2, e2) {
        return (Kd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Qd, $d = new Lh.g(), tp = new Uint16Array([0, 1, 2, 0, 2, 3]), ep = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this) || this;
          return i2._anchor = new Lh.e(i2._onAnchorUpdate, i2, e3 ? e3.defaultAnchor.x : 0, e3 ? e3.defaultAnchor.y : 0), i2._texture = null, i2._width = 0, i2._height = 0, i2._tint = null, i2._tintRGB = null, i2.tint = 16777215, i2.blendMode = Sc.b.NORMAL, i2._cachedTint = 16777215, i2.uvs = null, i2.texture = e3 || Vh.t.EMPTY, i2.vertexData = new Float32Array(8), i2.vertexTrimmedData = null, i2._transformID = -1, i2._textureID = -1, i2._transformTrimmedID = -1, i2._textureTrimmedID = -1, i2.indices = tp, i2.pluginName = "batch", i2.isSprite = true, i2._roundPixels = xd.b.ROUND_PIXELS, i2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Kd(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype._onTextureUpdate = function() {
          this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = Object(Ph.sign)(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = Object(Ph.sign)(this.scale.y) * this._height / this._texture.orig.height);
        }, e2.prototype._onAnchorUpdate = function() {
          this._transformID = -1, this._transformTrimmedID = -1;
        }, e2.prototype.calculateVertices = function() {
          var t3 = this._texture;
          if (this._transformID !== this.transform._worldID || this._textureID !== t3._updateID) {
            this._textureID !== t3._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t3._updateID;
            var e3 = this.transform.worldTransform, i2 = e3.a, n2 = e3.b, r2 = e3.c, o2 = e3.d, s2 = e3.tx, a2 = e3.ty, l2 = this.vertexData, h2 = t3.trim, u2 = t3.orig, c2 = this._anchor, d2 = 0, p2 = 0, f2 = 0, m2 = 0;
            if (h2 ? (d2 = (p2 = h2.x - c2._x * u2.width) + h2.width, f2 = (m2 = h2.y - c2._y * u2.height) + h2.height) : (d2 = (p2 = -c2._x * u2.width) + u2.width, f2 = (m2 = -c2._y * u2.height) + u2.height), l2[0] = i2 * p2 + r2 * m2 + s2, l2[1] = o2 * m2 + n2 * p2 + a2, l2[2] = i2 * d2 + r2 * m2 + s2, l2[3] = o2 * m2 + n2 * d2 + a2, l2[4] = i2 * d2 + r2 * f2 + s2, l2[5] = o2 * f2 + n2 * d2 + a2, l2[6] = i2 * p2 + r2 * f2 + s2, l2[7] = o2 * f2 + n2 * p2 + a2, this._roundPixels) for (var g2 = xd.b.RESOLUTION, v2 = 0; v2 < l2.length; ++v2) l2[v2] = Math.round((l2[v2] * g2 | 0) / g2);
          }
        }, e2.prototype.calculateTrimmedVertices = function() {
          if (this.vertexTrimmedData) {
            if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return;
          } else this.vertexTrimmedData = new Float32Array(8);
          this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
          var t3 = this._texture, e3 = this.vertexTrimmedData, i2 = t3.orig, n2 = this._anchor, r2 = this.transform.worldTransform, o2 = r2.a, s2 = r2.b, a2 = r2.c, l2 = r2.d, h2 = r2.tx, u2 = r2.ty, c2 = -n2._x * i2.width, d2 = c2 + i2.width, p2 = -n2._y * i2.height, f2 = p2 + i2.height;
          e3[0] = o2 * c2 + a2 * p2 + h2, e3[1] = l2 * p2 + s2 * c2 + u2, e3[2] = o2 * d2 + a2 * p2 + h2, e3[3] = l2 * p2 + s2 * d2 + u2, e3[4] = o2 * d2 + a2 * f2 + h2, e3[5] = l2 * f2 + s2 * d2 + u2, e3[6] = o2 * c2 + a2 * f2 + h2, e3[7] = l2 * f2 + s2 * c2 + u2;
        }, e2.prototype._render = function(t3) {
          this.calculateVertices(), t3.batch.setObjectRenderer(t3.plugins[this.pluginName]), t3.plugins[this.pluginName].render(this);
        }, e2.prototype._calculateBounds = function() {
          var t3 = this._texture.trim, e3 = this._texture.orig;
          !t3 || t3.width === e3.width && t3.height === e3.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
        }, e2.prototype.getLocalBounds = function(e3) {
          return 0 === this.children.length ? (this._localBounds || (this._localBounds = new Oh.a()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e3 || (this._localBoundsRect || (this._localBoundsRect = new Lh.j()), e3 = this._localBoundsRect), this._localBounds.getRectangle(e3)) : t2.prototype.getLocalBounds.call(this, e3);
        }, e2.prototype.containsPoint = function(t3) {
          this.worldTransform.applyInverse(t3, $d);
          var e3 = this._texture.orig.width, i2 = this._texture.orig.height, n2 = -e3 * this.anchor.x, r2 = 0;
          return $d.x >= n2 && $d.x < n2 + e3 && (r2 = -i2 * this.anchor.y, $d.y >= r2 && $d.y < r2 + i2);
        }, e2.prototype.destroy = function(e3) {
          if (t2.prototype.destroy.call(this, e3), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof e3 ? e3 : e3 && e3.texture) {
            var i2 = "boolean" == typeof e3 ? e3 : e3 && e3.baseTexture;
            this._texture.destroy(!!i2);
          }
          this._texture = null;
        }, e2.from = function(t3, i2) {
          return new e2(t3 instanceof Vh.t ? t3 : Vh.t.from(t3, i2));
        }, Object.defineProperty(e2.prototype, "roundPixels", { get: function() {
          return this._roundPixels;
        }, set: function(t3) {
          this._roundPixels !== t3 && (this._transformID = -1), this._roundPixels = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
          return Math.abs(this.scale.x) * this._texture.orig.width;
        }, set: function(t3) {
          var e3 = Object(Ph.sign)(this.scale.x) || 1;
          this.scale.x = e3 * t3 / this._texture.orig.width, this._width = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return Math.abs(this.scale.y) * this._texture.orig.height;
        }, set: function(t3) {
          var e3 = Object(Ph.sign)(this.scale.y) || 1;
          this.scale.y = e3 * t3 / this._texture.orig.height, this._height = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "anchor", { get: function() {
          return this._anchor;
        }, set: function(t3) {
          this._anchor.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tint", { get: function() {
          return this._tint;
        }, set: function(t3) {
          this._tint = t3, this._tintRGB = (t3 >> 16) + (65280 & t3) + ((255 & t3) << 16);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "texture", { get: function() {
          return this._texture;
        }, set: function(t3) {
          this._texture !== t3 && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t3 || Vh.t.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t3 && (t3.baseTexture.valid ? this._onTextureUpdate() : t3.once("update", this._onTextureUpdate, this)));
        }, enumerable: false, configurable: true }), e2;
      }(Oh.b), ip = function(t2, e2) {
        return (ip = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      !function(t2) {
        t2[t2.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t2[t2.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
      }(Qd || (Qd = {}));
      var np = { align: "left", breakWords: false, dropShadow: false, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: "black", dropShadowDistance: 5, fill: "black", fillGradientType: Qd.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: "Arial", fontSize: 26, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", letterSpacing: 0, lineHeight: 0, lineJoin: "miter", miterLimit: 10, padding: 0, stroke: "black", strokeThickness: 0, textBaseline: "alphabetic", trim: false, whiteSpace: "pre", wordWrap: false, wordWrapWidth: 100, leading: 0 }, rp = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"], op = function() {
        function t2(t3) {
          this.styleID = 0, this.reset(), lp(this, t3, t3);
        }
        return t2.prototype.clone = function() {
          var e2 = {};
          return lp(e2, this, np), new t2(e2);
        }, t2.prototype.reset = function() {
          lp(this, np, np);
        }, Object.defineProperty(t2.prototype, "align", { get: function() {
          return this._align;
        }, set: function(t3) {
          this._align !== t3 && (this._align = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "breakWords", { get: function() {
          return this._breakWords;
        }, set: function(t3) {
          this._breakWords !== t3 && (this._breakWords = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadow", { get: function() {
          return this._dropShadow;
        }, set: function(t3) {
          this._dropShadow !== t3 && (this._dropShadow = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowAlpha", { get: function() {
          return this._dropShadowAlpha;
        }, set: function(t3) {
          this._dropShadowAlpha !== t3 && (this._dropShadowAlpha = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowAngle", { get: function() {
          return this._dropShadowAngle;
        }, set: function(t3) {
          this._dropShadowAngle !== t3 && (this._dropShadowAngle = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowBlur", { get: function() {
          return this._dropShadowBlur;
        }, set: function(t3) {
          this._dropShadowBlur !== t3 && (this._dropShadowBlur = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowColor", { get: function() {
          return this._dropShadowColor;
        }, set: function(t3) {
          var e2 = ap(t3);
          this._dropShadowColor !== e2 && (this._dropShadowColor = e2, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "dropShadowDistance", { get: function() {
          return this._dropShadowDistance;
        }, set: function(t3) {
          this._dropShadowDistance !== t3 && (this._dropShadowDistance = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fill", { get: function() {
          return this._fill;
        }, set: function(t3) {
          var e2 = ap(t3);
          this._fill !== e2 && (this._fill = e2, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fillGradientType", { get: function() {
          return this._fillGradientType;
        }, set: function(t3) {
          this._fillGradientType !== t3 && (this._fillGradientType = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fillGradientStops", { get: function() {
          return this._fillGradientStops;
        }, set: function(t3) {
          (function(t4, e2) {
            if (!Array.isArray(t4) || !Array.isArray(e2)) return false;
            if (t4.length !== e2.length) return false;
            for (var i2 = 0; i2 < t4.length; ++i2) if (t4[i2] !== e2[i2]) return false;
            return true;
          })(this._fillGradientStops, t3) || (this._fillGradientStops = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontFamily", { get: function() {
          return this._fontFamily;
        }, set: function(t3) {
          this.fontFamily !== t3 && (this._fontFamily = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontSize", { get: function() {
          return this._fontSize;
        }, set: function(t3) {
          this._fontSize !== t3 && (this._fontSize = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontStyle", { get: function() {
          return this._fontStyle;
        }, set: function(t3) {
          this._fontStyle !== t3 && (this._fontStyle = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontVariant", { get: function() {
          return this._fontVariant;
        }, set: function(t3) {
          this._fontVariant !== t3 && (this._fontVariant = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "fontWeight", { get: function() {
          return this._fontWeight;
        }, set: function(t3) {
          this._fontWeight !== t3 && (this._fontWeight = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "letterSpacing", { get: function() {
          return this._letterSpacing;
        }, set: function(t3) {
          this._letterSpacing !== t3 && (this._letterSpacing = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "lineHeight", { get: function() {
          return this._lineHeight;
        }, set: function(t3) {
          this._lineHeight !== t3 && (this._lineHeight = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "leading", { get: function() {
          return this._leading;
        }, set: function(t3) {
          this._leading !== t3 && (this._leading = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "lineJoin", { get: function() {
          return this._lineJoin;
        }, set: function(t3) {
          this._lineJoin !== t3 && (this._lineJoin = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "miterLimit", { get: function() {
          return this._miterLimit;
        }, set: function(t3) {
          this._miterLimit !== t3 && (this._miterLimit = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "padding", { get: function() {
          return this._padding;
        }, set: function(t3) {
          this._padding !== t3 && (this._padding = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "stroke", { get: function() {
          return this._stroke;
        }, set: function(t3) {
          var e2 = ap(t3);
          this._stroke !== e2 && (this._stroke = e2, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "strokeThickness", { get: function() {
          return this._strokeThickness;
        }, set: function(t3) {
          this._strokeThickness !== t3 && (this._strokeThickness = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "textBaseline", { get: function() {
          return this._textBaseline;
        }, set: function(t3) {
          this._textBaseline !== t3 && (this._textBaseline = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "trim", { get: function() {
          return this._trim;
        }, set: function(t3) {
          this._trim !== t3 && (this._trim = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "whiteSpace", { get: function() {
          return this._whiteSpace;
        }, set: function(t3) {
          this._whiteSpace !== t3 && (this._whiteSpace = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "wordWrap", { get: function() {
          return this._wordWrap;
        }, set: function(t3) {
          this._wordWrap !== t3 && (this._wordWrap = t3, this.styleID++);
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "wordWrapWidth", { get: function() {
          return this._wordWrapWidth;
        }, set: function(t3) {
          this._wordWrapWidth !== t3 && (this._wordWrapWidth = t3, this.styleID++);
        }, enumerable: false, configurable: true }), t2.prototype.toFontString = function() {
          var t3 = "number" == typeof this.fontSize ? this.fontSize + "px" : this.fontSize, e2 = this.fontFamily;
          Array.isArray(this.fontFamily) || (e2 = this.fontFamily.split(","));
          for (var i2 = e2.length - 1; i2 >= 0; i2--) {
            var n2 = e2[i2].trim();
            !/([\"\'])[^\'\"]+\1/.test(n2) && rp.indexOf(n2) < 0 && (n2 = '"' + n2 + '"'), e2[i2] = n2;
          }
          return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t3 + " " + e2.join(",");
        }, t2;
      }();
      function sp(t2) {
        return "number" == typeof t2 ? Object(Ph.hex2string)(t2) : ("string" == typeof t2 && 0 === t2.indexOf("0x") && (t2 = t2.replace("0x", "#")), t2);
      }
      function ap(t2) {
        if (Array.isArray(t2)) {
          for (var e2 = 0; e2 < t2.length; ++e2) t2[e2] = sp(t2[e2]);
          return t2;
        }
        return sp(t2);
      }
      function lp(t2, e2, i2) {
        for (var n2 in i2) Array.isArray(e2[n2]) ? t2[n2] = e2[n2].slice() : t2[n2] = e2[n2];
      }
      var hp = function() {
        function t2(t3, e2, i2, n2, r2, o2, s2, a2, l2) {
          this.text = t3, this.style = e2, this.width = i2, this.height = n2, this.lines = r2, this.lineWidths = o2, this.lineHeight = s2, this.maxLineWidth = a2, this.fontProperties = l2;
        }
        return t2.measureText = function(e2, i2, n2, r2) {
          void 0 === r2 && (r2 = t2._canvas), n2 = null == n2 ? i2.wordWrap : n2;
          var o2 = i2.toFontString(), s2 = t2.measureFont(o2);
          0 === s2.fontSize && (s2.fontSize = i2.fontSize, s2.ascent = i2.fontSize);
          var a2 = r2.getContext("2d");
          a2.font = o2;
          for (var l2 = (n2 ? t2.wordWrap(e2, i2, r2) : e2).split(/(?:\r\n|\r|\n)/), h2 = new Array(l2.length), u2 = 0, c2 = 0; c2 < l2.length; c2++) {
            var d2 = a2.measureText(l2[c2]).width + (l2[c2].length - 1) * i2.letterSpacing;
            h2[c2] = d2, u2 = Math.max(u2, d2);
          }
          var p2 = u2 + i2.strokeThickness;
          i2.dropShadow && (p2 += i2.dropShadowDistance);
          var f2 = i2.lineHeight || s2.fontSize + i2.strokeThickness, m2 = Math.max(f2, s2.fontSize + i2.strokeThickness) + (l2.length - 1) * (f2 + i2.leading);
          return i2.dropShadow && (m2 += i2.dropShadowDistance), new t2(e2, i2, p2, m2, l2, h2, f2 + i2.leading, u2, s2);
        }, t2.wordWrap = function(e2, i2, n2) {
          void 0 === n2 && (n2 = t2._canvas);
          for (var r2 = n2.getContext("2d"), o2 = 0, s2 = "", a2 = "", l2 = /* @__PURE__ */ Object.create(null), h2 = i2.letterSpacing, u2 = i2.whiteSpace, c2 = t2.collapseSpaces(u2), d2 = t2.collapseNewlines(u2), p2 = !c2, f2 = i2.wordWrapWidth + h2, m2 = t2.tokenize(e2), g2 = 0; g2 < m2.length; g2++) {
            var v2 = m2[g2];
            if (t2.isNewline(v2)) {
              if (!d2) {
                a2 += t2.addLine(s2), p2 = !c2, s2 = "", o2 = 0;
                continue;
              }
              v2 = " ";
            }
            if (c2) {
              var _2 = t2.isBreakingSpace(v2), y2 = t2.isBreakingSpace(s2[s2.length - 1]);
              if (_2 && y2) continue;
            }
            var x2 = t2.getFromCache(v2, h2, l2, r2);
            if (x2 > f2) if ("" !== s2 && (a2 += t2.addLine(s2), s2 = "", o2 = 0), t2.canBreakWords(v2, i2.breakWords)) for (var b2 = t2.wordWrapSplit(v2), T2 = 0; T2 < b2.length; T2++) {
              for (var E2 = b2[T2], S2 = 1; b2[T2 + S2]; ) {
                var w2 = b2[T2 + S2], A2 = E2[E2.length - 1];
                if (t2.canBreakChars(A2, w2, v2, T2, i2.breakWords)) break;
                E2 += w2, S2++;
              }
              T2 += E2.length - 1;
              var M2 = t2.getFromCache(E2, h2, l2, r2);
              M2 + o2 > f2 && (a2 += t2.addLine(s2), p2 = false, s2 = "", o2 = 0), s2 += E2, o2 += M2;
            }
            else {
              s2.length > 0 && (a2 += t2.addLine(s2), s2 = "", o2 = 0);
              var C2 = g2 === m2.length - 1;
              a2 += t2.addLine(v2, !C2), p2 = false, s2 = "", o2 = 0;
            }
            else x2 + o2 > f2 && (p2 = false, a2 += t2.addLine(s2), s2 = "", o2 = 0), (s2.length > 0 || !t2.isBreakingSpace(v2) || p2) && (s2 += v2, o2 += x2);
          }
          return a2 += t2.addLine(s2, false);
        }, t2.addLine = function(e2, i2) {
          return void 0 === i2 && (i2 = true), e2 = t2.trimRight(e2), e2 = i2 ? e2 + "\n" : e2;
        }, t2.getFromCache = function(t3, e2, i2, n2) {
          var r2 = i2[t3];
          if ("number" != typeof r2) {
            var o2 = t3.length * e2;
            r2 = n2.measureText(t3).width + o2, i2[t3] = r2;
          }
          return r2;
        }, t2.collapseSpaces = function(t3) {
          return "normal" === t3 || "pre-line" === t3;
        }, t2.collapseNewlines = function(t3) {
          return "normal" === t3;
        }, t2.trimRight = function(e2) {
          if ("string" != typeof e2) return "";
          for (var i2 = e2.length - 1; i2 >= 0; i2--) {
            var n2 = e2[i2];
            if (!t2.isBreakingSpace(n2)) break;
            e2 = e2.slice(0, -1);
          }
          return e2;
        }, t2.isNewline = function(e2) {
          return "string" == typeof e2 && t2._newlines.indexOf(e2.charCodeAt(0)) >= 0;
        }, t2.isBreakingSpace = function(e2, i2) {
          return "string" == typeof e2 && t2._breakingSpaces.indexOf(e2.charCodeAt(0)) >= 0;
        }, t2.tokenize = function(e2) {
          var i2 = [], n2 = "";
          if ("string" != typeof e2) return i2;
          for (var r2 = 0; r2 < e2.length; r2++) {
            var o2 = e2[r2], s2 = e2[r2 + 1];
            t2.isBreakingSpace(o2, s2) || t2.isNewline(o2) ? ("" !== n2 && (i2.push(n2), n2 = ""), i2.push(o2)) : n2 += o2;
          }
          return "" !== n2 && i2.push(n2), i2;
        }, t2.canBreakWords = function(t3, e2) {
          return e2;
        }, t2.canBreakChars = function(t3, e2, i2, n2, r2) {
          return true;
        }, t2.wordWrapSplit = function(t3) {
          return t3.split("");
        }, t2.measureFont = function(e2) {
          if (t2._fonts[e2]) return t2._fonts[e2];
          var i2 = { ascent: 0, descent: 0, fontSize: 0 }, n2 = t2._canvas, r2 = t2._context;
          r2.font = e2;
          var o2 = t2.METRICS_STRING + t2.BASELINE_SYMBOL, s2 = Math.ceil(r2.measureText(o2).width), a2 = Math.ceil(r2.measureText(t2.BASELINE_SYMBOL).width), l2 = Math.ceil(t2.HEIGHT_MULTIPLIER * a2);
          a2 = a2 * t2.BASELINE_MULTIPLIER | 0, n2.width = s2, n2.height = l2, r2.fillStyle = "#f00", r2.fillRect(0, 0, s2, l2), r2.font = e2, r2.textBaseline = "alphabetic", r2.fillStyle = "#000", r2.fillText(o2, 0, a2);
          var h2 = r2.getImageData(0, 0, s2, l2).data, u2 = h2.length, c2 = 4 * s2, d2 = 0, p2 = 0, f2 = false;
          for (d2 = 0; d2 < a2; ++d2) {
            for (var m2 = 0; m2 < c2; m2 += 4) if (255 !== h2[p2 + m2]) {
              f2 = true;
              break;
            }
            if (f2) break;
            p2 += c2;
          }
          for (i2.ascent = a2 - d2, p2 = u2 - c2, f2 = false, d2 = l2; d2 > a2; --d2) {
            for (m2 = 0; m2 < c2; m2 += 4) if (255 !== h2[p2 + m2]) {
              f2 = true;
              break;
            }
            if (f2) break;
            p2 -= c2;
          }
          return i2.descent = d2 - a2, i2.fontSize = i2.ascent + i2.descent, t2._fonts[e2] = i2, i2;
        }, t2.clearMetrics = function(e2) {
          void 0 === e2 && (e2 = ""), e2 ? delete t2._fonts[e2] : t2._fonts = {};
        }, Object.defineProperty(t2, "_canvas", { get: function() {
          if (!t2.__canvas) {
            var e2 = void 0;
            try {
              var i2 = new OffscreenCanvas(0, 0), n2 = i2.getContext("2d");
              if (n2 && n2.measureText) return t2.__canvas = i2, i2;
              e2 = document.createElement("canvas");
            } catch (t3) {
              e2 = document.createElement("canvas");
            }
            e2.width = e2.height = 10, t2.__canvas = e2;
          }
          return t2.__canvas;
        }, enumerable: false, configurable: true }), Object.defineProperty(t2, "_context", { get: function() {
          return t2.__context || (t2.__context = t2._canvas.getContext("2d")), t2.__context;
        }, enumerable: false, configurable: true }), t2;
      }();
      hp._fonts = {}, hp.METRICS_STRING = "|\xC9q\xC5", hp.BASELINE_SYMBOL = "M", hp.BASELINE_MULTIPLIER = 1.4, hp.HEIGHT_MULTIPLIER = 2, hp._newlines = [10, 13], hp._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
      var up = { texture: true, children: false, baseTexture: true }, cp = function(t2) {
        function e2(e3, i2, n2) {
          var r2 = this, o2 = false;
          n2 || (n2 = document.createElement("canvas"), o2 = true), n2.width = 3, n2.height = 3;
          var s2 = Vh.t.from(n2);
          return s2.orig = new Lh.j(), s2.trim = new Lh.j(), (r2 = t2.call(this, s2) || this)._ownCanvas = o2, r2.canvas = n2, r2.context = r2.canvas.getContext("2d"), r2._resolution = xd.b.RESOLUTION, r2._autoResolution = true, r2._text = null, r2._style = null, r2._styleListener = null, r2._font = "", r2.text = e3, r2.style = i2, r2.localStyleID = -1, r2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          ip(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype.updateText = function(t3) {
          var i2 = this._style;
          if (this.localStyleID !== i2.styleID && (this.dirty = true, this.localStyleID = i2.styleID), this.dirty || !t3) {
            this._font = this._style.toFontString();
            var n2, r2, o2 = this.context, s2 = hp.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), a2 = s2.width, l2 = s2.height, h2 = s2.lines, u2 = s2.lineHeight, c2 = s2.lineWidths, d2 = s2.maxLineWidth, p2 = s2.fontProperties;
            this.canvas.width = Math.ceil(Math.ceil(Math.max(1, a2) + 2 * i2.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, l2) + 2 * i2.padding) * this._resolution), o2.scale(this._resolution, this._resolution), o2.clearRect(0, 0, this.canvas.width, this.canvas.height), o2.font = this._font, o2.lineWidth = i2.strokeThickness, o2.textBaseline = i2.textBaseline, o2.lineJoin = i2.lineJoin, o2.miterLimit = i2.miterLimit;
            for (var f2 = i2.dropShadow ? 2 : 1, m2 = 0; m2 < f2; ++m2) {
              var g2 = i2.dropShadow && 0 === m2, v2 = g2 ? Math.ceil(Math.max(1, l2) + 2 * i2.padding) : 0, _2 = v2 * this._resolution;
              if (g2) {
                o2.fillStyle = "black", o2.strokeStyle = "black";
                var y2 = i2.dropShadowColor, x2 = Object(Ph.hex2rgb)("number" == typeof y2 ? y2 : Object(Ph.string2hex)(y2)), b2 = i2.dropShadowBlur * this._resolution, T2 = i2.dropShadowDistance * this._resolution;
                o2.shadowColor = "rgba(" + 255 * x2[0] + "," + 255 * x2[1] + "," + 255 * x2[2] + "," + i2.dropShadowAlpha + ")", o2.shadowBlur = b2, o2.shadowOffsetX = Math.cos(i2.dropShadowAngle) * T2, o2.shadowOffsetY = Math.sin(i2.dropShadowAngle) * T2 + _2;
              } else o2.fillStyle = this._generateFillStyle(i2, h2, s2), o2.strokeStyle = i2.stroke, o2.shadowColor = "black", o2.shadowBlur = 0, o2.shadowOffsetX = 0, o2.shadowOffsetY = 0;
              var E2 = (u2 - p2.fontSize) / 2;
              (!e2.nextLineHeightBehavior || u2 - p2.fontSize < 0) && (E2 = 0);
              for (var S2 = 0; S2 < h2.length; S2++) n2 = i2.strokeThickness / 2, r2 = i2.strokeThickness / 2 + S2 * u2 + p2.ascent + E2, "right" === i2.align ? n2 += d2 - c2[S2] : "center" === i2.align && (n2 += (d2 - c2[S2]) / 2), i2.stroke && i2.strokeThickness && this.drawLetterSpacing(h2[S2], n2 + i2.padding, r2 + i2.padding - v2, true), i2.fill && this.drawLetterSpacing(h2[S2], n2 + i2.padding, r2 + i2.padding - v2);
            }
            this.updateTexture();
          }
        }, e2.prototype.drawLetterSpacing = function(t3, i2, n2, r2) {
          void 0 === r2 && (r2 = false);
          var o2 = this._style.letterSpacing, s2 = e2.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
          if (0 === o2 || s2) return s2 && (this.context.letterSpacing = o2, this.context.textLetterSpacing = o2), void (r2 ? this.context.strokeText(t3, i2, n2) : this.context.fillText(t3, i2, n2));
          for (var a2 = i2, l2 = Array.from ? Array.from(t3) : t3.split(""), h2 = this.context.measureText(t3).width, u2 = 0, c2 = 0; c2 < l2.length; ++c2) {
            var d2 = l2[c2];
            r2 ? this.context.strokeText(d2, a2, n2) : this.context.fillText(d2, a2, n2);
            for (var p2 = "", f2 = c2 + 1; f2 < l2.length; ++f2) p2 += l2[f2];
            a2 += h2 - (u2 = this.context.measureText(p2).width) + o2, h2 = u2;
          }
        }, e2.prototype.updateTexture = function() {
          var t3 = this.canvas;
          if (this._style.trim) {
            var e3 = Object(Ph.trimCanvas)(t3);
            e3.data && (t3.width = e3.width, t3.height = e3.height, this.context.putImageData(e3.data, 0, 0));
          }
          var i2 = this._texture, n2 = this._style, r2 = n2.trim ? 0 : n2.padding, o2 = i2.baseTexture;
          i2.trim.width = i2._frame.width = t3.width / this._resolution, i2.trim.height = i2._frame.height = t3.height / this._resolution, i2.trim.x = -r2, i2.trim.y = -r2, i2.orig.width = i2._frame.width - 2 * r2, i2.orig.height = i2._frame.height - 2 * r2, this._onTextureUpdate(), o2.setRealSize(t3.width, t3.height, this._resolution), i2.updateUvs(), this.dirty = false;
        }, e2.prototype._render = function(e3) {
          this._autoResolution && this._resolution !== e3.resolution && (this._resolution = e3.resolution, this.dirty = true), this.updateText(true), t2.prototype._render.call(this, e3);
        }, e2.prototype.updateTransform = function() {
          this.updateText(true), t2.prototype.updateTransform.call(this);
        }, e2.prototype.getBounds = function(e3, i2) {
          return this.updateText(true), -1 === this._textureID && (e3 = false), t2.prototype.getBounds.call(this, e3, i2);
        }, e2.prototype.getLocalBounds = function(e3) {
          return this.updateText(true), t2.prototype.getLocalBounds.call(this, e3);
        }, e2.prototype._calculateBounds = function() {
          this.calculateVertices(), this._bounds.addQuad(this.vertexData);
        }, e2.prototype._generateFillStyle = function(t3, e3, i2) {
          var n2, r2 = t3.fill;
          if (!Array.isArray(r2)) return r2;
          if (1 === r2.length) return r2[0];
          var o2 = t3.dropShadow ? t3.dropShadowDistance : 0, s2 = t3.padding || 0, a2 = this.canvas.width / this._resolution - o2 - 2 * s2, l2 = this.canvas.height / this._resolution - o2 - 2 * s2, h2 = r2.slice(), u2 = t3.fillGradientStops.slice();
          if (!u2.length) for (var c2 = h2.length + 1, d2 = 1; d2 < c2; ++d2) u2.push(d2 / c2);
          if (h2.unshift(r2[0]), u2.unshift(0), h2.push(r2[r2.length - 1]), u2.push(1), t3.fillGradientType === Qd.LINEAR_VERTICAL) {
            n2 = this.context.createLinearGradient(a2 / 2, s2, a2 / 2, l2 + s2);
            var p2 = i2.fontProperties.fontSize + t3.strokeThickness;
            for (d2 = 0; d2 < e3.length; d2++) {
              var f2 = i2.lineHeight * (d2 - 1) + p2, m2 = i2.lineHeight * d2, g2 = m2;
              d2 > 0 && f2 > m2 && (g2 = (m2 + f2) / 2);
              var v2 = m2 + p2, _2 = i2.lineHeight * (d2 + 1), y2 = v2;
              d2 + 1 < e3.length && _2 < v2 && (y2 = (v2 + _2) / 2);
              for (var x2 = (y2 - g2) / l2, b2 = 0; b2 < h2.length; b2++) {
                var T2 = 0;
                T2 = "number" == typeof u2[b2] ? u2[b2] : b2 / h2.length;
                var E2 = Math.min(1, Math.max(0, g2 / l2 + T2 * x2));
                E2 = Number(E2.toFixed(5)), n2.addColorStop(E2, h2[b2]);
              }
            }
          } else {
            n2 = this.context.createLinearGradient(s2, l2 / 2, a2 + s2, l2 / 2);
            var S2 = h2.length + 1, w2 = 1;
            for (d2 = 0; d2 < h2.length; d2++) {
              var A2 = void 0;
              A2 = "number" == typeof u2[d2] ? u2[d2] : w2 / S2, n2.addColorStop(A2, h2[d2]), w2++;
            }
          }
          return n2;
        }, e2.prototype.destroy = function(e3) {
          "boolean" == typeof e3 && (e3 = { children: e3 }), e3 = Object.assign({}, up, e3), t2.prototype.destroy.call(this, e3), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
        }, Object.defineProperty(e2.prototype, "width", { get: function() {
          return this.updateText(true), Math.abs(this.scale.x) * this._texture.orig.width;
        }, set: function(t3) {
          this.updateText(true);
          var e3 = Object(Ph.sign)(this.scale.x) || 1;
          this.scale.x = e3 * t3 / this._texture.orig.width, this._width = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this.updateText(true), Math.abs(this.scale.y) * this._texture.orig.height;
        }, set: function(t3) {
          this.updateText(true);
          var e3 = Object(Ph.sign)(this.scale.y) || 1;
          this.scale.y = e3 * t3 / this._texture.orig.height, this._height = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "style", { get: function() {
          return this._style;
        }, set: function(t3) {
          t3 = t3 || {}, this._style = t3 instanceof op ? t3 : new op(t3), this.localStyleID = -1, this.dirty = true;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "text", { get: function() {
          return this._text;
        }, set: function(t3) {
          t3 = String(null == t3 ? "" : t3), this._text !== t3 && (this._text = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
          return this._resolution;
        }, set: function(t3) {
          this._autoResolution = false, this._resolution !== t3 && (this._resolution = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), e2.nextLineHeightBehavior = false, e2.experimentalLetterSpacing = false, e2;
      }(ep);
      xd.b.UPLOADS_PER_FRAME = 4;
      var dp = function(t2, e2) {
        return (dp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var pp = function() {
        function t2(t3) {
          this.maxItemsPerFrame = t3, this.itemsLeft = 0;
        }
        return t2.prototype.beginFrame = function() {
          this.itemsLeft = this.maxItemsPerFrame;
        }, t2.prototype.allowedToUpload = function() {
          return this.itemsLeft-- > 0;
        }, t2;
      }();
      function fp(t2, e2) {
        var i2 = false;
        if (t2 && t2._textures && t2._textures.length) {
          for (var n2 = 0; n2 < t2._textures.length; n2++) if (t2._textures[n2] instanceof Vh.t) {
            var r2 = t2._textures[n2].baseTexture;
            -1 === e2.indexOf(r2) && (e2.push(r2), i2 = true);
          }
        }
        return i2;
      }
      function mp(t2, e2) {
        if (t2.baseTexture instanceof Vh.c) {
          var i2 = t2.baseTexture;
          return -1 === e2.indexOf(i2) && e2.push(i2), true;
        }
        return false;
      }
      function gp(t2, e2) {
        if (t2._texture && t2._texture instanceof Vh.t) {
          var i2 = t2._texture.baseTexture;
          return -1 === e2.indexOf(i2) && e2.push(i2), true;
        }
        return false;
      }
      function vp(t2, e2) {
        return e2 instanceof cp && (e2.updateText(true), true);
      }
      function _p(t2, e2) {
        if (e2 instanceof op) {
          var i2 = e2.toFontString();
          return hp.measureFont(i2), true;
        }
        return false;
      }
      function yp(t2, e2) {
        if (t2 instanceof cp) {
          -1 === e2.indexOf(t2.style) && e2.push(t2.style), -1 === e2.indexOf(t2) && e2.push(t2);
          var i2 = t2._texture.baseTexture;
          return -1 === e2.indexOf(i2) && e2.push(i2), true;
        }
        return false;
      }
      function xp(t2, e2) {
        return t2 instanceof op && (-1 === e2.indexOf(t2) && e2.push(t2), true);
      }
      var bp = function() {
        function t2(t3) {
          var e2 = this;
          this.limiter = new pp(xd.b.UPLOADS_PER_FRAME), this.renderer = t3, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = false, this.delayedTick = function() {
            e2.queue && e2.prepareItems();
          }, this.registerFindHook(yp), this.registerFindHook(xp), this.registerFindHook(fp), this.registerFindHook(mp), this.registerFindHook(gp), this.registerUploadHook(vp), this.registerUploadHook(_p);
        }
        return t2.prototype.upload = function(t3, e2) {
          "function" == typeof t3 && (e2 = t3, t3 = null), t3 && this.add(t3), this.queue.length ? (e2 && this.completes.push(e2), this.ticking || (this.ticking = true, Dh.a.system.addOnce(this.tick, this, Dh.c.UTILITY))) : e2 && e2();
        }, t2.prototype.tick = function() {
          setTimeout(this.delayedTick, 0);
        }, t2.prototype.prepareItems = function() {
          for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
            var t3 = this.queue[0], e2 = false;
            if (t3 && !t3._destroyed) {
              for (var i2 = 0, n2 = this.uploadHooks.length; i2 < n2; i2++) if (this.uploadHooks[i2](this.uploadHookHelper, t3)) {
                this.queue.shift(), e2 = true;
                break;
              }
            }
            e2 || this.queue.shift();
          }
          if (this.queue.length) Dh.a.system.addOnce(this.tick, this, Dh.c.UTILITY);
          else {
            this.ticking = false;
            var r2 = this.completes.slice(0);
            this.completes.length = 0;
            for (i2 = 0, n2 = r2.length; i2 < n2; i2++) r2[i2]();
          }
        }, t2.prototype.registerFindHook = function(t3) {
          return t3 && this.addHooks.push(t3), this;
        }, t2.prototype.registerUploadHook = function(t3) {
          return t3 && this.uploadHooks.push(t3), this;
        }, t2.prototype.add = function(t3) {
          for (var e2 = 0, i2 = this.addHooks.length; e2 < i2 && !this.addHooks[e2](t3, this.queue); e2++) ;
          if (t3 instanceof Oh.b) for (e2 = t3.children.length - 1; e2 >= 0; e2--) this.add(t3.children[e2]);
          return this;
        }, t2.prototype.destroy = function() {
          this.ticking && Dh.a.system.remove(this.tick, this), this.ticking = false, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
        }, t2;
      }();
      function Tp(t2, e2) {
        return e2 instanceof Vh.c && (e2._glTextures[t2.CONTEXT_UID] || t2.texture.bind(e2), true);
      }
      function Ep(t2, e2) {
        if (!(e2 instanceof Jd)) return false;
        var i2 = e2.geometry;
        e2.finishPoly(), i2.updateBatches();
        for (var n2 = i2.batches, r2 = 0; r2 < n2.length; r2++) {
          var o2 = n2[r2].style.texture;
          o2 && Tp(t2, o2.baseTexture);
        }
        return i2.batchable || t2.geometry.bind(i2, e2._resolveDirectShader(t2)), true;
      }
      function Sp(t2, e2) {
        return t2 instanceof Jd && (e2.push(t2), true);
      }
      var wp = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return i2.uploadHookHelper = i2.renderer, i2.registerFindHook(Sp), i2.registerUploadHook(Tp), i2.registerUploadHook(Ep), i2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          dp(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2;
      }(bp), Ap = (function() {
        function t2(t3) {
          this.maxMilliseconds = t3, this.frameStart = 0;
        }
        t2.prototype.beginFrame = function() {
          this.frameStart = Date.now();
        }, t2.prototype.allowedToUpload = function() {
          return Date.now() - this.frameStart < this.maxMilliseconds;
        };
      }(), function() {
        function t2(t3, e2, i2) {
          void 0 === i2 && (i2 = null), this._texture = t3 instanceof Vh.t ? t3 : null, this.baseTexture = t3 instanceof Vh.c ? t3 : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e2;
          var n2 = this.baseTexture.resource;
          this.resolution = this._updateResolution(i2 || (n2 ? n2.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
        }
        return t2.prototype._updateResolution = function(t3) {
          void 0 === t3 && (t3 = null);
          var e2 = this.data.meta.scale, i2 = Object(Ph.getResolutionOfUrl)(t3, null);
          return null === i2 && (i2 = void 0 !== e2 ? parseFloat(e2) : 1), 1 !== i2 && this.baseTexture.setResolution(i2), i2;
        }, t2.prototype.parse = function(e2) {
          this._batchIndex = 0, this._callback = e2, this._frameKeys.length <= t2.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
        }, t2.prototype._processFrames = function(e2) {
          for (var i2 = e2, n2 = t2.BATCH_SIZE; i2 - e2 < n2 && i2 < this._frameKeys.length; ) {
            var r2 = this._frameKeys[i2], o2 = this._frames[r2], s2 = o2.frame;
            if (s2) {
              var a2 = null, l2 = null, h2 = false !== o2.trimmed && o2.sourceSize ? o2.sourceSize : o2.frame, u2 = new Lh.j(0, 0, Math.floor(h2.w) / this.resolution, Math.floor(h2.h) / this.resolution);
              a2 = o2.rotated ? new Lh.j(Math.floor(s2.x) / this.resolution, Math.floor(s2.y) / this.resolution, Math.floor(s2.h) / this.resolution, Math.floor(s2.w) / this.resolution) : new Lh.j(Math.floor(s2.x) / this.resolution, Math.floor(s2.y) / this.resolution, Math.floor(s2.w) / this.resolution, Math.floor(s2.h) / this.resolution), false !== o2.trimmed && o2.spriteSourceSize && (l2 = new Lh.j(Math.floor(o2.spriteSourceSize.x) / this.resolution, Math.floor(o2.spriteSourceSize.y) / this.resolution, Math.floor(s2.w) / this.resolution, Math.floor(s2.h) / this.resolution)), this.textures[r2] = new Vh.t(this.baseTexture, a2, u2, l2, o2.rotated ? 2 : 0, o2.anchor), Vh.t.addToCache(this.textures[r2], r2);
            }
            i2++;
          }
        }, t2.prototype._processAnimations = function() {
          var t3 = this.data.animations || {};
          for (var e2 in t3) {
            this.animations[e2] = [];
            for (var i2 = 0; i2 < t3[e2].length; i2++) {
              var n2 = t3[e2][i2];
              this.animations[e2].push(this.textures[n2]);
            }
          }
        }, t2.prototype._parseComplete = function() {
          var t3 = this._callback;
          this._callback = null, this._batchIndex = 0, t3.call(this, this.textures);
        }, t2.prototype._nextBatch = function() {
          var e2 = this;
          this._processFrames(this._batchIndex * t2.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
            e2._batchIndex * t2.BATCH_SIZE < e2._frameKeys.length ? e2._nextBatch() : (e2._processAnimations(), e2._parseComplete());
          }, 0);
        }, t2.prototype.destroy = function(t3) {
          var e2;
          for (var i2 in void 0 === t3 && (t3 = false), this.textures) this.textures[i2].destroy();
          this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t3 && (null === (e2 = this._texture) || void 0 === e2 || e2.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null;
        }, t2.BATCH_SIZE = 1e3, t2;
      }()), Mp = function() {
        function t2() {
        }
        return t2.use = function(e2, i2) {
          var n2, r2, o2 = this, s2 = e2.name + "_image";
          if (e2.data && e2.type === pc.TYPE.JSON && e2.data.frames && !o2.resources[s2]) {
            var a2 = null === (r2 = null === (n2 = e2.data) || void 0 === n2 ? void 0 : n2.meta) || void 0 === r2 ? void 0 : r2.related_multi_packs;
            if (Array.isArray(a2)) for (var l2 = function(t3) {
              if ("string" != typeof t3) return "continue";
              var i3 = t3.replace(".json", ""), n3 = Ph.url.resolve(e2.url.replace(o2.baseUrl, ""), t3);
              if (o2.resources[i3] || Object.values(o2.resources).some(function(t4) {
                return Ph.url.format(Ph.url.parse(t4.url)) === n3;
              })) return "continue";
              var r3 = { crossOrigin: e2.crossOrigin, loadType: pc.LOAD_TYPE.XHR, xhrType: pc.XHR_RESPONSE_TYPE.JSON, parentResource: e2, metadata: e2.metadata };
              o2.add(i3, n3, r3);
            }, h2 = 0, u2 = a2; h2 < u2.length; h2++) {
              l2(u2[h2]);
            }
            var c2 = { crossOrigin: e2.crossOrigin, metadata: e2.metadata.imageMetadata, parentResource: e2 }, d2 = t2.getResourcePath(e2, o2.baseUrl);
            o2.add(s2, d2, c2, function(t3) {
              if (t3.error) i2(t3.error);
              else {
                var n3 = new Ap(t3.texture, e2.data, e2.url);
                n3.parse(function() {
                  e2.spritesheet = n3, e2.textures = n3.textures, i2();
                });
              }
            });
          } else i2();
        }, t2.getResourcePath = function(t3, e2) {
          return t3.isDataUrl ? t3.data.meta.image : Ph.url.resolve(t3.url.replace(e2, ""), t3.data.meta.image);
        }, t2;
      }(), Cp = function(t2, e2) {
        return (Cp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function Rp(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        Cp(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var Ip = new Lh.g(), Pp = function(t2) {
        function e2(e3, i2, n2) {
          void 0 === i2 && (i2 = 100), void 0 === n2 && (n2 = 100);
          var r2 = t2.call(this, e3) || this;
          return r2.tileTransform = new Lh.m(), r2._width = i2, r2._height = n2, r2.uvMatrix = r2.texture.uvMatrix || new Vh.u(e3), r2.pluginName = "tilingSprite", r2.uvRespectAnchor = false, r2;
        }
        return Rp(e2, t2), Object.defineProperty(e2.prototype, "clampMargin", { get: function() {
          return this.uvMatrix.clampMargin;
        }, set: function(t3) {
          this.uvMatrix.clampMargin = t3, this.uvMatrix.update(true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tileScale", { get: function() {
          return this.tileTransform.scale;
        }, set: function(t3) {
          this.tileTransform.scale.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "tilePosition", { get: function() {
          return this.tileTransform.position;
        }, set: function(t3) {
          this.tileTransform.position.copyFrom(t3);
        }, enumerable: false, configurable: true }), e2.prototype._onTextureUpdate = function() {
          this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
        }, e2.prototype._render = function(t3) {
          var e3 = this._texture;
          e3 && e3.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t3.batch.setObjectRenderer(t3.plugins[this.pluginName]), t3.plugins[this.pluginName].render(this));
        }, e2.prototype._calculateBounds = function() {
          var t3 = this._width * -this._anchor._x, e3 = this._height * -this._anchor._y, i2 = this._width * (1 - this._anchor._x), n2 = this._height * (1 - this._anchor._y);
          this._bounds.addFrame(this.transform, t3, e3, i2, n2);
        }, e2.prototype.getLocalBounds = function(e3) {
          return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e3 || (this._localBoundsRect || (this._localBoundsRect = new Lh.j()), e3 = this._localBoundsRect), this._bounds.getRectangle(e3)) : t2.prototype.getLocalBounds.call(this, e3);
        }, e2.prototype.containsPoint = function(t3) {
          this.worldTransform.applyInverse(t3, Ip);
          var e3 = this._width, i2 = this._height, n2 = -e3 * this.anchor._x;
          if (Ip.x >= n2 && Ip.x < n2 + e3) {
            var r2 = -i2 * this.anchor._y;
            if (Ip.y >= r2 && Ip.y < r2 + i2) return true;
          }
          return false;
        }, e2.prototype.destroy = function(e3) {
          t2.prototype.destroy.call(this, e3), this.tileTransform = null, this.uvMatrix = null;
        }, e2.from = function(t3, i2) {
          return new e2(t3 instanceof Vh.t ? t3 : Vh.t.from(t3, i2), i2.width, i2.height);
        }, Object.defineProperty(e2.prototype, "width", { get: function() {
          return this._width;
        }, set: function(t3) {
          this._width = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this._height;
        }, set: function(t3) {
          this._height = t3;
        }, enumerable: false, configurable: true }), e2;
      }(ep), Op = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", Np = new Lh.d(), Lp = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return e3.runners.contextChange.add(i2), i2.quad = new Vh.o(), i2.state = Vh.s.for2d(), i2;
        }
        return Rp(e2, t2), e2.prototype.contextChange = function() {
          var t3 = this.renderer, e3 = { globals: t3.globalUniforms };
          this.simpleShader = Vh.r.from(Op, "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", e3), this.shader = t3.context.webGLVersion > 1 ? Vh.r.from("#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n", "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n", e3) : Vh.r.from(Op, "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n", e3);
        }, e2.prototype.render = function(t3) {
          var e3 = this.renderer, i2 = this.quad, n2 = i2.vertices;
          n2[0] = n2[6] = t3._width * -t3.anchor.x, n2[1] = n2[3] = t3._height * -t3.anchor.y, n2[2] = n2[4] = t3._width * (1 - t3.anchor.x), n2[5] = n2[7] = t3._height * (1 - t3.anchor.y);
          var r2 = t3.uvRespectAnchor ? t3.anchor.x : 0, o2 = t3.uvRespectAnchor ? t3.anchor.y : 0;
          (n2 = i2.uvs)[0] = n2[6] = -r2, n2[1] = n2[3] = -o2, n2[2] = n2[4] = 1 - r2, n2[5] = n2[7] = 1 - o2, i2.invalidate();
          var s2 = t3._texture, a2 = s2.baseTexture, l2 = t3.tileTransform.localTransform, h2 = t3.uvMatrix, u2 = a2.isPowerOfTwo && s2.frame.width === a2.width && s2.frame.height === a2.height;
          u2 && (a2._glTextures[e3.CONTEXT_UID] ? u2 = a2.wrapMode !== Sc.s.CLAMP : a2.wrapMode === Sc.s.CLAMP && (a2.wrapMode = Sc.s.REPEAT));
          var c2 = u2 ? this.simpleShader : this.shader, d2 = s2.width, p2 = s2.height, f2 = t3._width, m2 = t3._height;
          Np.set(l2.a * d2 / f2, l2.b * d2 / m2, l2.c * p2 / f2, l2.d * p2 / m2, l2.tx / f2, l2.ty / m2), Np.invert(), u2 ? Np.prepend(h2.mapCoord) : (c2.uniforms.uMapCoord = h2.mapCoord.toArray(true), c2.uniforms.uClampFrame = h2.uClampFrame, c2.uniforms.uClampOffset = h2.uClampOffset), c2.uniforms.uTransform = Np.toArray(true), c2.uniforms.uColor = Object(Ph.premultiplyTintToRgba)(t3.tint, t3.worldAlpha, c2.uniforms.uColor, a2.alphaMode), c2.uniforms.translationMatrix = t3.transform.worldTransform.toArray(true), c2.uniforms.uSampler = s2, e3.shader.bind(c2), e3.geometry.bind(i2), this.state.blendMode = Object(Ph.correctBlendMode)(t3.blendMode, a2.alphaMode), e3.state.set(this.state), e3.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
        }, e2;
      }(Vh.m), Dp = i(8), Fp = function(t2, e2) {
        return (Fp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Bp = function() {
        this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
      }, Up = function() {
        function t2() {
        }
        return t2.test = function(t3) {
          return "string" == typeof t3 && 0 === t3.indexOf("info face=");
        }, t2.parse = function(t3) {
          var e2 = t3.match(/^[a-z]+\s+.+$/gm), i2 = { info: [], common: [], page: [], char: [], chars: [], kerning: [], kernings: [], distanceField: [] };
          for (var n2 in e2) {
            var r2 = e2[n2].match(/^[a-z]+/gm)[0], o2 = e2[n2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), s2 = {};
            for (var a2 in o2) {
              var l2 = o2[a2].split("="), h2 = l2[0], u2 = l2[1].replace(/"/gm, ""), c2 = parseFloat(u2), d2 = isNaN(c2) ? u2 : c2;
              s2[h2] = d2;
            }
            i2[r2].push(s2);
          }
          var p2 = new Bp();
          return i2.info.forEach(function(t4) {
            return p2.info.push({ face: t4.face, size: parseInt(t4.size, 10) });
          }), i2.common.forEach(function(t4) {
            return p2.common.push({ lineHeight: parseInt(t4.lineHeight, 10) });
          }), i2.page.forEach(function(t4) {
            return p2.page.push({ id: parseInt(t4.id, 10), file: t4.file });
          }), i2.char.forEach(function(t4) {
            return p2.char.push({ id: parseInt(t4.id, 10), page: parseInt(t4.page, 10), x: parseInt(t4.x, 10), y: parseInt(t4.y, 10), width: parseInt(t4.width, 10), height: parseInt(t4.height, 10), xoffset: parseInt(t4.xoffset, 10), yoffset: parseInt(t4.yoffset, 10), xadvance: parseInt(t4.xadvance, 10) });
          }), i2.kerning.forEach(function(t4) {
            return p2.kerning.push({ first: parseInt(t4.first, 10), second: parseInt(t4.second, 10), amount: parseInt(t4.amount, 10) });
          }), i2.distanceField.forEach(function(t4) {
            return p2.distanceField.push({ distanceRange: parseInt(t4.distanceRange, 10), fieldType: t4.fieldType });
          }), p2;
        }, t2;
      }(), kp = function() {
        function t2() {
        }
        return t2.test = function(t3) {
          return t3 instanceof XMLDocument && t3.getElementsByTagName("page").length && null !== t3.getElementsByTagName("info")[0].getAttribute("face");
        }, t2.parse = function(t3) {
          for (var e2 = new Bp(), i2 = t3.getElementsByTagName("info"), n2 = t3.getElementsByTagName("common"), r2 = t3.getElementsByTagName("page"), o2 = t3.getElementsByTagName("char"), s2 = t3.getElementsByTagName("kerning"), a2 = t3.getElementsByTagName("distanceField"), l2 = 0; l2 < i2.length; l2++) e2.info.push({ face: i2[l2].getAttribute("face"), size: parseInt(i2[l2].getAttribute("size"), 10) });
          for (l2 = 0; l2 < n2.length; l2++) e2.common.push({ lineHeight: parseInt(n2[l2].getAttribute("lineHeight"), 10) });
          for (l2 = 0; l2 < r2.length; l2++) e2.page.push({ id: parseInt(r2[l2].getAttribute("id"), 10) || 0, file: r2[l2].getAttribute("file") });
          for (l2 = 0; l2 < o2.length; l2++) {
            var h2 = o2[l2];
            e2.char.push({ id: parseInt(h2.getAttribute("id"), 10), page: parseInt(h2.getAttribute("page"), 10) || 0, x: parseInt(h2.getAttribute("x"), 10), y: parseInt(h2.getAttribute("y"), 10), width: parseInt(h2.getAttribute("width"), 10), height: parseInt(h2.getAttribute("height"), 10), xoffset: parseInt(h2.getAttribute("xoffset"), 10), yoffset: parseInt(h2.getAttribute("yoffset"), 10), xadvance: parseInt(h2.getAttribute("xadvance"), 10) });
          }
          for (l2 = 0; l2 < s2.length; l2++) e2.kerning.push({ first: parseInt(s2[l2].getAttribute("first"), 10), second: parseInt(s2[l2].getAttribute("second"), 10), amount: parseInt(s2[l2].getAttribute("amount"), 10) });
          for (l2 = 0; l2 < a2.length; l2++) e2.distanceField.push({ fieldType: a2[l2].getAttribute("fieldType"), distanceRange: parseInt(a2[l2].getAttribute("distanceRange"), 10) });
          return e2;
        }, t2;
      }(), Gp = function() {
        function t2() {
        }
        return t2.test = function(t3) {
          if ("string" == typeof t3 && t3.indexOf("<font>") > -1) {
            var e2 = new globalThis.DOMParser().parseFromString(t3, "text/xml");
            return kp.test(e2);
          }
          return false;
        }, t2.parse = function(t3) {
          var e2 = new globalThis.DOMParser().parseFromString(t3, "text/xml");
          return kp.parse(e2);
        }, t2;
      }(), Hp = [Up, kp, Gp];
      function jp(t2) {
        for (var e2 = 0; e2 < Hp.length; e2++) if (Hp[e2].test(t2)) return Hp[e2];
        return null;
      }
      function zp(t2, e2, i2, n2, r2, o2, s2) {
        var a2 = i2.text, l2 = i2.fontProperties;
        e2.translate(n2, r2), e2.scale(o2, o2);
        var h2 = s2.strokeThickness / 2, u2 = -s2.strokeThickness / 2;
        if (e2.font = s2.toFontString(), e2.lineWidth = s2.strokeThickness, e2.textBaseline = s2.textBaseline, e2.lineJoin = s2.lineJoin, e2.miterLimit = s2.miterLimit, e2.fillStyle = function(t3, e3, i3, n3, r3, o3) {
          var s3, a3 = i3.fill;
          if (!Array.isArray(a3)) return a3;
          if (1 === a3.length) return a3[0];
          var l3 = i3.dropShadow ? i3.dropShadowDistance : 0, h3 = i3.padding || 0, u3 = t3.width / n3 - l3 - 2 * h3, c3 = t3.height / n3 - l3 - 2 * h3, d3 = a3.slice(), p3 = i3.fillGradientStops.slice();
          if (!p3.length) for (var f3 = d3.length + 1, m2 = 1; m2 < f3; ++m2) p3.push(m2 / f3);
          if (d3.unshift(a3[0]), p3.unshift(0), d3.push(a3[a3.length - 1]), p3.push(1), i3.fillGradientType === Qd.LINEAR_VERTICAL) {
            s3 = e3.createLinearGradient(u3 / 2, h3, u3 / 2, c3 + h3);
            var g2 = 0, v2 = (o3.fontProperties.fontSize + i3.strokeThickness) / c3;
            for (m2 = 0; m2 < r3.length; m2++) for (var _2 = o3.lineHeight * m2, y2 = 0; y2 < d3.length; y2++) {
              var x2 = _2 / c3 + ("number" == typeof p3[y2] ? p3[y2] : y2 / d3.length) * v2, b2 = Math.max(g2, x2);
              b2 = Math.min(b2, 1), s3.addColorStop(b2, d3[y2]), g2 = b2;
            }
          } else {
            s3 = e3.createLinearGradient(h3, c3 / 2, u3 + h3, c3 / 2);
            var T2 = d3.length + 1, E2 = 1;
            for (m2 = 0; m2 < d3.length; m2++) {
              var S2 = void 0;
              S2 = "number" == typeof p3[m2] ? p3[m2] : E2 / T2, s3.addColorStop(S2, d3[m2]), E2++;
            }
          }
          return s3;
        }(t2, e2, s2, o2, [a2], i2), e2.strokeStyle = s2.stroke, s2.dropShadow) {
          var c2 = s2.dropShadowColor, d2 = Object(Ph.hex2rgb)("number" == typeof c2 ? c2 : Object(Ph.string2hex)(c2)), p2 = s2.dropShadowBlur * o2, f2 = s2.dropShadowDistance * o2;
          e2.shadowColor = "rgba(" + 255 * d2[0] + "," + 255 * d2[1] + "," + 255 * d2[2] + "," + s2.dropShadowAlpha + ")", e2.shadowBlur = p2, e2.shadowOffsetX = Math.cos(s2.dropShadowAngle) * f2, e2.shadowOffsetY = Math.sin(s2.dropShadowAngle) * f2;
        } else e2.shadowColor = "black", e2.shadowBlur = 0, e2.shadowOffsetX = 0, e2.shadowOffsetY = 0;
        s2.stroke && s2.strokeThickness && e2.strokeText(a2, h2, u2 + i2.lineHeight - l2.descent), s2.fill && e2.fillText(a2, h2, u2 + i2.lineHeight - l2.descent), e2.setTransform(1, 0, 0, 1, 0, 0), e2.fillStyle = "rgba(0, 0, 0, 0)";
      }
      function Vp(t2) {
        return Array.from ? Array.from(t2) : t2.split("");
      }
      function Xp(t2) {
        return t2.codePointAt ? t2.codePointAt(0) : t2.charCodeAt(0);
      }
      var Wp = function() {
        function t2(t3, e2, i2) {
          var n2, r2, o2 = t3.info[0], s2 = t3.common[0], a2 = t3.page[0], l2 = t3.distanceField[0], h2 = Object(Ph.getResolutionOfUrl)(a2.file), u2 = {};
          this._ownsTextures = i2, this.font = o2.face, this.size = o2.size, this.lineHeight = s2.lineHeight / h2, this.chars = {}, this.pageTextures = u2;
          for (var c2 = 0; c2 < t3.page.length; c2++) {
            var d2 = t3.page[c2], p2 = d2.id, f2 = d2.file;
            u2[p2] = e2 instanceof Array ? e2[c2] : e2[f2], (null == l2 ? void 0 : l2.fieldType) && "none" !== l2.fieldType && (u2[p2].baseTexture.alphaMode = Sc.a.NO_PREMULTIPLIED_ALPHA);
          }
          for (c2 = 0; c2 < t3.char.length; c2++) {
            var m2 = t3.char[c2], g2 = (p2 = m2.id, m2.page), v2 = t3.char[c2], _2 = v2.x, y2 = v2.y, x2 = v2.width, b2 = v2.height, T2 = v2.xoffset, E2 = v2.yoffset, S2 = v2.xadvance;
            _2 /= h2, y2 /= h2, x2 /= h2, b2 /= h2, T2 /= h2, E2 /= h2, S2 /= h2;
            var w2 = new Lh.j(_2 + u2[g2].frame.x / h2, y2 + u2[g2].frame.y / h2, x2, b2);
            this.chars[p2] = { xOffset: T2, yOffset: E2, xAdvance: S2, kerning: {}, texture: new Vh.t(u2[g2].baseTexture, w2), page: g2 };
          }
          for (c2 = 0; c2 < t3.kerning.length; c2++) {
            var A2 = t3.kerning[c2], M2 = A2.first, C2 = A2.second, R2 = A2.amount;
            M2 /= h2, C2 /= h2, R2 /= h2, this.chars[C2] && (this.chars[C2].kerning[M2] = R2);
          }
          this.distanceFieldRange = null == l2 ? void 0 : l2.distanceRange, this.distanceFieldType = null !== (r2 = null === (n2 = null == l2 ? void 0 : l2.fieldType) || void 0 === n2 ? void 0 : n2.toLowerCase()) && void 0 !== r2 ? r2 : "none";
        }
        return t2.prototype.destroy = function() {
          for (var t3 in this.chars) this.chars[t3].texture.destroy(), this.chars[t3].texture = null;
          for (var t3 in this.pageTextures) this._ownsTextures && this.pageTextures[t3].destroy(true), this.pageTextures[t3] = null;
          this.chars = null, this.pageTextures = null;
        }, t2.install = function(e2, i2, n2) {
          var r2;
          if (e2 instanceof Bp) r2 = e2;
          else {
            var o2 = jp(e2);
            if (!o2) throw new Error("Unrecognized data format for font.");
            r2 = o2.parse(e2);
          }
          i2 instanceof Vh.t && (i2 = [i2]);
          var s2 = new t2(r2, i2, n2);
          return t2.available[s2.font] = s2, s2;
        }, t2.uninstall = function(e2) {
          var i2 = t2.available[e2];
          if (!i2) throw new Error("No font found named '" + e2 + "'");
          i2.destroy(), delete t2.available[e2];
        }, t2.from = function(e2, i2, n2) {
          if (!e2) throw new Error("[BitmapFont] Property `name` is required.");
          var r2 = Object.assign({}, t2.defaultOptions, n2), o2 = r2.chars, s2 = r2.padding, a2 = r2.resolution, l2 = r2.textureWidth, h2 = r2.textureHeight, u2 = function(t3) {
            "string" == typeof t3 && (t3 = [t3]);
            for (var e3 = [], i3 = 0, n3 = t3.length; i3 < n3; i3++) {
              var r3 = t3[i3];
              if (Array.isArray(r3)) {
                if (2 !== r3.length) throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + r3.length + ".");
                var o3 = r3[0].charCodeAt(0), s3 = r3[1].charCodeAt(0);
                if (s3 < o3) throw new Error("[BitmapFont]: Invalid character range.");
                for (var a3 = o3, l3 = s3; a3 <= l3; a3++) e3.push(String.fromCharCode(a3));
              } else e3.push.apply(e3, Vp(r3));
            }
            if (0 === e3.length) throw new Error("[BitmapFont]: Empty set when resolving characters.");
            return e3;
          }(o2), c2 = i2 instanceof op ? i2 : new op(i2), d2 = l2, p2 = new Bp();
          p2.info[0] = { face: c2.fontFamily, size: c2.fontSize }, p2.common[0] = { lineHeight: c2.fontSize };
          for (var f2, m2, g2, v2 = 0, _2 = 0, y2 = 0, x2 = [], b2 = 0; b2 < u2.length; b2++) {
            f2 || ((f2 = document.createElement("canvas")).width = l2, f2.height = h2, m2 = f2.getContext("2d"), g2 = new Vh.c(f2, { resolution: a2 }), x2.push(new Vh.t(g2)), p2.page.push({ id: x2.length - 1, file: "" }));
            var T2 = hp.measureText(u2[b2], c2, false, f2), E2 = T2.width, S2 = Math.ceil(T2.height), w2 = Math.ceil(("italic" === c2.fontStyle ? 2 : 1) * E2);
            if (_2 >= h2 - S2 * a2) {
              if (0 === _2) throw new Error("[BitmapFont] textureHeight " + h2 + "px is too small for " + c2.fontSize + "px fonts");
              --b2, f2 = null, m2 = null, g2 = null, _2 = 0, v2 = 0, y2 = 0;
            } else if (y2 = Math.max(S2 + T2.fontProperties.descent, y2), w2 * a2 + v2 >= d2) --b2, _2 += y2 * a2, _2 = Math.ceil(_2), v2 = 0, y2 = 0;
            else {
              zp(f2, m2, T2, v2, _2, a2, c2);
              var A2 = Xp(T2.text);
              p2.char.push({ id: A2, page: x2.length - 1, x: v2 / a2, y: _2 / a2, width: w2, height: S2, xoffset: 0, yoffset: 0, xadvance: Math.ceil(E2 - (c2.dropShadow ? c2.dropShadowDistance : 0) - (c2.stroke ? c2.strokeThickness : 0)) }), v2 += (w2 + 2 * s2) * a2, v2 = Math.ceil(v2);
            }
          }
          b2 = 0;
          for (var M2 = u2.length; b2 < M2; b2++) for (var C2 = u2[b2], R2 = 0; R2 < M2; R2++) {
            var I2 = u2[R2], P2 = m2.measureText(C2).width, O2 = m2.measureText(I2).width, N2 = m2.measureText(C2 + I2).width - (P2 + O2);
            N2 && p2.kerning.push({ first: Xp(C2), second: Xp(I2), amount: N2 });
          }
          var L2 = new t2(p2, x2, true);
          return void 0 !== t2.available[e2] && t2.uninstall(e2), t2.available[e2] = L2, L2;
        }, t2.ALPHA = [["a", "z"], ["A", "Z"], " "], t2.NUMERIC = [["0", "9"]], t2.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], t2.ASCII = [[" ", "~"]], t2.defaultOptions = { resolution: 1, textureWidth: 512, textureHeight: 512, padding: 4, chars: t2.ALPHANUMERIC }, t2.available = {}, t2;
      }(), Yp = [], qp = [], Zp = [], Jp = (function(t2) {
        function e2(i2, n2) {
          void 0 === n2 && (n2 = {});
          var r2 = t2.call(this) || this;
          r2._tint = 16777215;
          var o2 = Object.assign({}, e2.styleDefaults, n2), s2 = o2.align, a2 = o2.tint, l2 = o2.maxWidth, h2 = o2.letterSpacing, u2 = o2.fontName, c2 = o2.fontSize;
          if (!Wp.available[u2]) throw new Error('Missing BitmapFont "' + u2 + '"');
          return r2._activePagesMeshData = [], r2._textWidth = 0, r2._textHeight = 0, r2._align = s2, r2._tint = a2, r2._fontName = u2, r2._fontSize = c2 || Wp.available[u2].size, r2.text = i2, r2._maxWidth = l2, r2._maxLineHeight = 0, r2._letterSpacing = h2, r2._anchor = new Lh.e(function() {
            r2.dirty = true;
          }, r2, 0, 0), r2._roundPixels = xd.b.ROUND_PIXELS, r2.dirty = true, r2._resolution = xd.b.RESOLUTION, r2._autoResolution = true, r2._textureCache = {}, r2;
        }
        (function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Fp(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        })(e2, t2), e2.prototype.updateText = function() {
          for (var t3, e3 = Wp.available[this._fontName], i2 = this._fontSize / e3.size, n2 = new Lh.g(), r2 = [], o2 = [], s2 = [], a2 = Vp(this._text.replace(/(?:\r\n|\r)/g, "\n") || " "), l2 = this._maxWidth * e3.size / this._fontSize, h2 = "none" === e3.distanceFieldType ? Yp : qp, u2 = null, c2 = 0, d2 = 0, p2 = 0, f2 = -1, m2 = 0, g2 = 0, v2 = 0, _2 = 0, y2 = 0; y2 < a2.length; y2++) {
            var x2 = Xp(G2 = a2[y2]);
            if (/(?:\s)/.test(G2) && (f2 = y2, m2 = c2, _2++), "\r" !== G2 && "\n" !== G2) {
              var b2 = e3.chars[x2];
              if (b2) {
                u2 && b2.kerning[u2] && (n2.x += b2.kerning[u2]);
                var T2 = Zp.pop() || { texture: Vh.t.EMPTY, line: 0, charCode: 0, prevSpaces: 0, position: new Lh.g() };
                T2.texture = b2.texture, T2.line = p2, T2.charCode = x2, T2.position.x = n2.x + b2.xOffset + this._letterSpacing / 2, T2.position.y = n2.y + b2.yOffset, T2.prevSpaces = _2, r2.push(T2), c2 = T2.position.x + Math.max(b2.xAdvance, b2.texture.orig.width), n2.x += b2.xAdvance + this._letterSpacing, v2 = Math.max(v2, b2.yOffset + b2.texture.height), u2 = x2, -1 !== f2 && l2 > 0 && n2.x > l2 && (++g2, Object(Ph.removeItems)(r2, 1 + f2 - g2, 1 + y2 - f2), y2 = f2, f2 = -1, o2.push(m2), s2.push(r2.length > 0 ? r2[r2.length - 1].prevSpaces : 0), d2 = Math.max(d2, m2), p2++, n2.x = 0, n2.y += e3.lineHeight, u2 = null, _2 = 0);
              }
            } else o2.push(c2), s2.push(-1), d2 = Math.max(d2, c2), ++p2, ++g2, n2.x = 0, n2.y += e3.lineHeight, u2 = null, _2 = 0;
          }
          var E2 = a2[a2.length - 1];
          "\r" !== E2 && "\n" !== E2 && (/(?:\s)/.test(E2) && (c2 = m2), o2.push(c2), d2 = Math.max(d2, c2), s2.push(-1));
          var S2 = [];
          for (y2 = 0; y2 <= p2; y2++) {
            var w2 = 0;
            "right" === this._align ? w2 = d2 - o2[y2] : "center" === this._align ? w2 = (d2 - o2[y2]) / 2 : "justify" === this._align && (w2 = s2[y2] < 0 ? 0 : (d2 - o2[y2]) / s2[y2]), S2.push(w2);
          }
          var A2 = r2.length, M2 = {}, C2 = [], R2 = this._activePagesMeshData;
          for (y2 = 0; y2 < R2.length; y2++) h2.push(R2[y2]);
          for (y2 = 0; y2 < A2; y2++) {
            var I2 = (j2 = r2[y2].texture).baseTexture.uid;
            if (!M2[I2]) {
              if (!(Z2 = h2.pop())) {
                var P2 = new Dp.b(), O2 = void 0, N2 = void 0;
                "none" === e3.distanceFieldType ? (O2 = new Dp.c(Vh.t.EMPTY), N2 = Sc.b.NORMAL) : (O2 = new Dp.c(Vh.t.EMPTY, { program: Vh.n.from("// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n", "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r\n\r\n}\r\n"), uniforms: { uFWidth: 0 } }), N2 = Sc.b.NORMAL_NPM);
                var L2 = new Dp.a(P2, O2);
                L2.blendMode = N2, Z2 = { index: 0, indexCount: 0, vertexCount: 0, uvsCount: 0, total: 0, mesh: L2, vertices: null, uvs: null, indices: null };
              }
              Z2.index = 0, Z2.indexCount = 0, Z2.vertexCount = 0, Z2.uvsCount = 0, Z2.total = 0;
              var D2 = this._textureCache;
              D2[I2] = D2[I2] || new Vh.t(j2.baseTexture), Z2.mesh.texture = D2[I2], Z2.mesh.tint = this._tint, C2.push(Z2), M2[I2] = Z2;
            }
            M2[I2].total++;
          }
          for (y2 = 0; y2 < R2.length; y2++) -1 === C2.indexOf(R2[y2]) && this.removeChild(R2[y2].mesh);
          for (y2 = 0; y2 < C2.length; y2++) C2[y2].mesh.parent !== this && this.addChild(C2[y2].mesh);
          for (var y2 in this._activePagesMeshData = C2, M2) {
            var F2 = (Z2 = M2[y2]).total;
            if (!((null === (t3 = Z2.indices) || void 0 === t3 ? void 0 : t3.length) > 6 * F2) || Z2.vertices.length < 2 * Dp.a.BATCHABLE_SIZE) Z2.vertices = new Float32Array(8 * F2), Z2.uvs = new Float32Array(8 * F2), Z2.indices = new Uint16Array(6 * F2);
            else for (var B2 = Z2.total, U2 = Z2.vertices, k2 = 4 * B2 * 2; k2 < U2.length; k2++) U2[k2] = 0;
            Z2.mesh.size = 6 * F2;
          }
          for (y2 = 0; y2 < A2; y2++) {
            var G2, H2 = (G2 = r2[y2]).position.x + S2[G2.line] * ("justify" === this._align ? G2.prevSpaces : 1);
            this._roundPixels && (H2 = Math.round(H2));
            var j2, z2 = H2 * i2, V2 = G2.position.y * i2, X2 = M2[(j2 = G2.texture).baseTexture.uid], W2 = j2.frame, Y2 = j2._uvs, q2 = X2.index++;
            X2.indices[6 * q2 + 0] = 0 + 4 * q2, X2.indices[6 * q2 + 1] = 1 + 4 * q2, X2.indices[6 * q2 + 2] = 2 + 4 * q2, X2.indices[6 * q2 + 3] = 0 + 4 * q2, X2.indices[6 * q2 + 4] = 2 + 4 * q2, X2.indices[6 * q2 + 5] = 3 + 4 * q2, X2.vertices[8 * q2 + 0] = z2, X2.vertices[8 * q2 + 1] = V2, X2.vertices[8 * q2 + 2] = z2 + W2.width * i2, X2.vertices[8 * q2 + 3] = V2, X2.vertices[8 * q2 + 4] = z2 + W2.width * i2, X2.vertices[8 * q2 + 5] = V2 + W2.height * i2, X2.vertices[8 * q2 + 6] = z2, X2.vertices[8 * q2 + 7] = V2 + W2.height * i2, X2.uvs[8 * q2 + 0] = Y2.x0, X2.uvs[8 * q2 + 1] = Y2.y0, X2.uvs[8 * q2 + 2] = Y2.x1, X2.uvs[8 * q2 + 3] = Y2.y1, X2.uvs[8 * q2 + 4] = Y2.x2, X2.uvs[8 * q2 + 5] = Y2.y2, X2.uvs[8 * q2 + 6] = Y2.x3, X2.uvs[8 * q2 + 7] = Y2.y3;
          }
          for (var y2 in this._textWidth = d2 * i2, this._textHeight = (n2.y + e3.lineHeight) * i2, M2) {
            var Z2 = M2[y2];
            if (0 !== this.anchor.x || 0 !== this.anchor.y) for (var J2 = 0, K2 = this._textWidth * this.anchor.x, Q2 = this._textHeight * this.anchor.y, $2 = 0; $2 < Z2.total; $2++) Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2, Z2.vertices[J2++] -= K2, Z2.vertices[J2++] -= Q2;
            this._maxLineHeight = v2 * i2;
            var tt2 = Z2.mesh.geometry.getBuffer("aVertexPosition"), et2 = Z2.mesh.geometry.getBuffer("aTextureCoord"), it2 = Z2.mesh.geometry.getIndex();
            tt2.data = Z2.vertices, et2.data = Z2.uvs, it2.data = Z2.indices, tt2.update(), et2.update(), it2.update();
          }
          for (y2 = 0; y2 < r2.length; y2++) Zp.push(r2[y2]);
        }, e2.prototype.updateTransform = function() {
          this.validate(), this.containerUpdateTransform();
        }, e2.prototype._render = function(e3) {
          this._autoResolution && this._resolution !== e3.resolution && (this._resolution = e3.resolution, this.dirty = true);
          var i2 = Wp.available[this._fontName], n2 = i2.distanceFieldRange, r2 = i2.distanceFieldType, o2 = i2.size;
          if ("none" !== r2) for (var s2 = this.worldTransform, a2 = s2.a, l2 = s2.b, h2 = s2.c, u2 = s2.d, c2 = Math.sqrt(a2 * a2 + l2 * l2), d2 = Math.sqrt(h2 * h2 + u2 * u2), p2 = (Math.abs(c2) + Math.abs(d2)) / 2, f2 = this._fontSize / o2, m2 = 0, g2 = this._activePagesMeshData; m2 < g2.length; m2++) {
            g2[m2].mesh.shader.uniforms.uFWidth = p2 * n2 * f2 * this._resolution;
          }
          t2.prototype._render.call(this, e3);
        }, e2.prototype.getLocalBounds = function() {
          return this.validate(), t2.prototype.getLocalBounds.call(this);
        }, e2.prototype.validate = function() {
          this.dirty && (this.updateText(), this.dirty = false);
        }, Object.defineProperty(e2.prototype, "tint", { get: function() {
          return this._tint;
        }, set: function(t3) {
          if (this._tint !== t3) {
            this._tint = t3;
            for (var e3 = 0; e3 < this._activePagesMeshData.length; e3++) this._activePagesMeshData[e3].mesh.tint = t3;
          }
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "align", { get: function() {
          return this._align;
        }, set: function(t3) {
          this._align !== t3 && (this._align = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "fontName", { get: function() {
          return this._fontName;
        }, set: function(t3) {
          if (!Wp.available[t3]) throw new Error('Missing BitmapFont "' + t3 + '"');
          this._fontName !== t3 && (this._fontName = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "fontSize", { get: function() {
          return this._fontSize;
        }, set: function(t3) {
          this._fontSize !== t3 && (this._fontSize = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "anchor", { get: function() {
          return this._anchor;
        }, set: function(t3) {
          "number" == typeof t3 ? this._anchor.set(t3) : this._anchor.copyFrom(t3);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "text", { get: function() {
          return this._text;
        }, set: function(t3) {
          t3 = String(null == t3 ? "" : t3), this._text !== t3 && (this._text = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "maxWidth", { get: function() {
          return this._maxWidth;
        }, set: function(t3) {
          this._maxWidth !== t3 && (this._maxWidth = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "maxLineHeight", { get: function() {
          return this.validate(), this._maxLineHeight;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "textWidth", { get: function() {
          return this.validate(), this._textWidth;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "letterSpacing", { get: function() {
          return this._letterSpacing;
        }, set: function(t3) {
          this._letterSpacing !== t3 && (this._letterSpacing = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "roundPixels", { get: function() {
          return this._roundPixels;
        }, set: function(t3) {
          t3 !== this._roundPixels && (this._roundPixels = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "textHeight", { get: function() {
          return this.validate(), this._textHeight;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "resolution", { get: function() {
          return this._resolution;
        }, set: function(t3) {
          this._autoResolution = false, this._resolution !== t3 && (this._resolution = t3, this.dirty = true);
        }, enumerable: false, configurable: true }), e2.prototype.destroy = function(e3) {
          var i2 = this._textureCache;
          for (var n2 in i2) {
            i2[n2].destroy(), delete i2[n2];
          }
          this._textureCache = null, t2.prototype.destroy.call(this, e3);
        }, e2.styleDefaults = { align: "left", tint: 16777215, maxWidth: 0, letterSpacing: 0 };
      }(Oh.b), function() {
        function t2() {
        }
        return t2.add = function() {
          pc.setExtensionXhrType("fnt", pc.XHR_RESPONSE_TYPE.TEXT);
        }, t2.use = function(e2, i2) {
          var n2 = jp(e2.data);
          if (n2) for (var r2 = t2.getBaseUrl(this, e2), o2 = n2.parse(e2.data), s2 = {}, a2 = function(t3) {
            s2[t3.metadata.pageFile] = t3.texture, Object.keys(s2).length === o2.page.length && (e2.bitmapFont = Wp.install(o2, s2, true), i2());
          }, l2 = 0; l2 < o2.page.length; ++l2) {
            var h2 = o2.page[l2].file, u2 = r2 + h2, c2 = false;
            for (var d2 in this.resources) {
              var p2 = this.resources[d2];
              if (p2.url === u2) {
                p2.metadata.pageFile = h2, p2.texture ? a2(p2) : p2.onAfterMiddleware.add(a2), c2 = true;
                break;
              }
            }
            if (!c2) {
              var f2 = { crossOrigin: e2.crossOrigin, loadType: pc.LOAD_TYPE.IMAGE, metadata: Object.assign({ pageFile: h2 }, e2.metadata.imageMetadata), parentResource: e2 };
              this.add(u2, f2, a2);
            }
          }
          else i2();
        }, t2.getBaseUrl = function(e2, i2) {
          var n2 = i2.isDataUrl ? "" : t2.dirname(i2.url);
          return i2.isDataUrl && ("." === n2 && (n2 = ""), e2.baseUrl && n2 && "/" === e2.baseUrl.charAt(e2.baseUrl.length - 1) && (n2 += "/")), (n2 = n2.replace(e2.baseUrl, "")) && "/" !== n2.charAt(n2.length - 1) && (n2 += "/"), n2;
        }, t2.dirname = function(t3) {
          var e2 = t3.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
          return e2 === t3 ? "." : "" === e2 ? "/" : e2;
        }, t2;
      }()), Kp = function(t2, e2) {
        return (Kp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Qp = function(t2) {
        function e2(e3) {
          void 0 === e3 && (e3 = 1);
          var i2 = t2.call(this, Vh.A, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", { uAlpha: 1 }) || this;
          return i2.alpha = e3, i2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Kp(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), Object.defineProperty(e2.prototype, "alpha", { get: function() {
          return this.uniforms.uAlpha;
        }, set: function(t3) {
          this.uniforms.uAlpha = t3;
        }, enumerable: false, configurable: true }), e2;
      }(Vh.k), $p = function(t2, e2) {
        return ($p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function tf(t2, e2) {
        function i2() {
          this.constructor = t2;
        }
        $p(t2, e2), t2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
      }
      var ef, nf, rf, of, sf, af, lf, hf, uf, cf, df, pf, ff, mf, gf, vf, _f, yf, xf, bf = { 5: [0.153388, 0.221461, 0.250301], 7: [0.071303, 0.131514, 0.189879, 0.214607], 9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236], 11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596], 13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641], 15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448] }, Tf = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
      !function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(ef || (ef = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(nf || (nf = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(rf || (rf = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(of || (of = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(sf || (sf = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(af || (af = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(lf || (lf = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(hf || (hf = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(uf || (uf = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(cf || (cf = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(df || (df = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(pf || (pf = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(ff || (ff = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(mf || (mf = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(gf || (gf = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(vf || (vf = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(_f || (_f = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(yf || (yf = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(xf || (xf = {}));
      var Ef = function(t2) {
        function e2(e3, i2, n2, r2, o2) {
          void 0 === i2 && (i2 = 8), void 0 === n2 && (n2 = 4), void 0 === r2 && (r2 = xd.b.FILTER_RESOLUTION), void 0 === o2 && (o2 = 5);
          var s2 = this, a2 = function(t3, e4) {
            var i3, n3 = Math.ceil(t3 / 2), r3 = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }", o3 = "";
            i3 = e4 ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
            for (var s3 = 0; s3 < t3; s3++) {
              var a3 = i3.replace("%index%", s3.toString());
              o3 += a3 = a3.replace("%sampleIndex%", s3 - (n3 - 1) + ".0"), o3 += "\n";
            }
            return r3 = (r3 = r3.replace("%blur%", o3)).replace("%size%", t3.toString());
          }(o2, e3), l2 = function(t3) {
            for (var e4, i3 = bf[t3], n3 = i3.length, r3 = Tf, o3 = "", s3 = 0; s3 < t3; s3++) {
              var a3 = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s3.toString());
              e4 = s3, s3 >= n3 && (e4 = t3 - s3 - 1), o3 += a3 = a3.replace("%value%", i3[e4].toString()), o3 += "\n";
            }
            return r3 = (r3 = r3.replace("%blur%", o3)).replace("%size%", t3.toString());
          }(o2);
          return (s2 = t2.call(this, a2, l2) || this).horizontal = e3, s2.resolution = r2, s2._quality = 0, s2.quality = n2, s2.blur = i2, s2;
        }
        return tf(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2) {
          if (i2 ? this.horizontal ? this.uniforms.strength = 1 / i2.width * (i2.width / e3.width) : this.uniforms.strength = 1 / i2.height * (i2.height / e3.height) : this.horizontal ? this.uniforms.strength = 1 / t3.renderer.width * (t3.renderer.width / e3.width) : this.uniforms.strength = 1 / t3.renderer.height * (t3.renderer.height / e3.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t3.applyFilter(this, e3, i2, n2);
          else {
            var r2 = t3.getFilterTexture(), o2 = t3.renderer, s2 = e3, a2 = r2;
            this.state.blend = false, t3.applyFilter(this, s2, a2, mf.CLEAR);
            for (var l2 = 1; l2 < this.passes - 1; l2++) {
              t3.bindAndClear(s2, mf.BLIT), this.uniforms.uSampler = a2;
              var h2 = a2;
              a2 = s2, s2 = h2, o2.shader.bind(this), o2.geometry.draw(5);
            }
            this.state.blend = true, t3.applyFilter(this, a2, i2, n2), t3.returnFilterTexture(r2);
          }
        }, Object.defineProperty(e2.prototype, "blur", { get: function() {
          return this.strength;
        }, set: function(t3) {
          this.padding = 1 + 2 * Math.abs(t3), this.strength = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "quality", { get: function() {
          return this._quality;
        }, set: function(t3) {
          this._quality = t3, this.passes = t3;
        }, enumerable: false, configurable: true }), e2;
      }(Vh.k), Sf = function(t2) {
        function e2(e3, i2, n2, r2) {
          void 0 === e3 && (e3 = 8), void 0 === i2 && (i2 = 4), void 0 === n2 && (n2 = xd.b.FILTER_RESOLUTION), void 0 === r2 && (r2 = 5);
          var o2 = t2.call(this) || this;
          return o2.blurXFilter = new Ef(true, e3, i2, n2, r2), o2.blurYFilter = new Ef(false, e3, i2, n2, r2), o2.resolution = n2, o2.quality = i2, o2.blur = e3, o2.repeatEdgePixels = false, o2;
        }
        return tf(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2) {
          var r2 = Math.abs(this.blurXFilter.strength), o2 = Math.abs(this.blurYFilter.strength);
          if (r2 && o2) {
            var s2 = t3.getFilterTexture();
            this.blurXFilter.apply(t3, e3, s2, mf.CLEAR), this.blurYFilter.apply(t3, s2, i2, n2), t3.returnFilterTexture(s2);
          } else o2 ? this.blurYFilter.apply(t3, e3, i2, n2) : this.blurXFilter.apply(t3, e3, i2, n2);
        }, e2.prototype.updatePadding = function() {
          this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength));
        }, Object.defineProperty(e2.prototype, "blur", { get: function() {
          return this.blurXFilter.blur;
        }, set: function(t3) {
          this.blurXFilter.blur = this.blurYFilter.blur = t3, this.updatePadding();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "quality", { get: function() {
          return this.blurXFilter.quality;
        }, set: function(t3) {
          this.blurXFilter.quality = this.blurYFilter.quality = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blurX", { get: function() {
          return this.blurXFilter.blur;
        }, set: function(t3) {
          this.blurXFilter.blur = t3, this.updatePadding();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blurY", { get: function() {
          return this.blurYFilter.blur;
        }, set: function(t3) {
          this.blurYFilter.blur = t3, this.updatePadding();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "blendMode", { get: function() {
          return this.blurYFilter.blendMode;
        }, set: function(t3) {
          this.blurYFilter.blendMode = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "repeatEdgePixels", { get: function() {
          return this._repeatEdgePixels;
        }, set: function(t3) {
          this._repeatEdgePixels = t3, this.updatePadding();
        }, enumerable: false, configurable: true }), e2;
      }(Vh.k), wf = function(t2, e2) {
        return (wf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Af = function(t2) {
        function e2() {
          var e3 = this, i2 = { m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]), uAlpha: 1 };
          return (e3 = t2.call(this, Vh.z, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", i2) || this).alpha = 1, e3;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          wf(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype._loadMatrix = function(t3, e3) {
          void 0 === e3 && (e3 = false);
          var i2 = t3;
          e3 && (this._multiply(i2, this.uniforms.m, t3), i2 = this._colorMatrix(i2)), this.uniforms.m = i2;
        }, e2.prototype._multiply = function(t3, e3, i2) {
          return t3[0] = e3[0] * i2[0] + e3[1] * i2[5] + e3[2] * i2[10] + e3[3] * i2[15], t3[1] = e3[0] * i2[1] + e3[1] * i2[6] + e3[2] * i2[11] + e3[3] * i2[16], t3[2] = e3[0] * i2[2] + e3[1] * i2[7] + e3[2] * i2[12] + e3[3] * i2[17], t3[3] = e3[0] * i2[3] + e3[1] * i2[8] + e3[2] * i2[13] + e3[3] * i2[18], t3[4] = e3[0] * i2[4] + e3[1] * i2[9] + e3[2] * i2[14] + e3[3] * i2[19] + e3[4], t3[5] = e3[5] * i2[0] + e3[6] * i2[5] + e3[7] * i2[10] + e3[8] * i2[15], t3[6] = e3[5] * i2[1] + e3[6] * i2[6] + e3[7] * i2[11] + e3[8] * i2[16], t3[7] = e3[5] * i2[2] + e3[6] * i2[7] + e3[7] * i2[12] + e3[8] * i2[17], t3[8] = e3[5] * i2[3] + e3[6] * i2[8] + e3[7] * i2[13] + e3[8] * i2[18], t3[9] = e3[5] * i2[4] + e3[6] * i2[9] + e3[7] * i2[14] + e3[8] * i2[19] + e3[9], t3[10] = e3[10] * i2[0] + e3[11] * i2[5] + e3[12] * i2[10] + e3[13] * i2[15], t3[11] = e3[10] * i2[1] + e3[11] * i2[6] + e3[12] * i2[11] + e3[13] * i2[16], t3[12] = e3[10] * i2[2] + e3[11] * i2[7] + e3[12] * i2[12] + e3[13] * i2[17], t3[13] = e3[10] * i2[3] + e3[11] * i2[8] + e3[12] * i2[13] + e3[13] * i2[18], t3[14] = e3[10] * i2[4] + e3[11] * i2[9] + e3[12] * i2[14] + e3[13] * i2[19] + e3[14], t3[15] = e3[15] * i2[0] + e3[16] * i2[5] + e3[17] * i2[10] + e3[18] * i2[15], t3[16] = e3[15] * i2[1] + e3[16] * i2[6] + e3[17] * i2[11] + e3[18] * i2[16], t3[17] = e3[15] * i2[2] + e3[16] * i2[7] + e3[17] * i2[12] + e3[18] * i2[17], t3[18] = e3[15] * i2[3] + e3[16] * i2[8] + e3[17] * i2[13] + e3[18] * i2[18], t3[19] = e3[15] * i2[4] + e3[16] * i2[9] + e3[17] * i2[14] + e3[18] * i2[19] + e3[19], t3;
        }, e2.prototype._colorMatrix = function(t3) {
          var e3 = new Float32Array(t3);
          return e3[4] /= 255, e3[9] /= 255, e3[14] /= 255, e3[19] /= 255, e3;
        }, e2.prototype.brightness = function(t3, e3) {
          var i2 = [t3, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, t3, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(i2, e3);
        }, e2.prototype.tint = function(t3, e3) {
          var i2 = [(t3 >> 16 & 255) / 255, 0, 0, 0, 0, 0, (t3 >> 8 & 255) / 255, 0, 0, 0, 0, 0, (255 & t3) / 255, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(i2, e3);
        }, e2.prototype.greyscale = function(t3, e3) {
          var i2 = [t3, t3, t3, 0, 0, t3, t3, t3, 0, 0, t3, t3, t3, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(i2, e3);
        }, e2.prototype.blackAndWhite = function(t3) {
          this._loadMatrix([0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.hue = function(t3, e3) {
          t3 = (t3 || 0) / 180 * Math.PI;
          var i2 = Math.cos(t3), n2 = Math.sin(t3), r2 = 1 / 3, o2 = (0, Math.sqrt)(r2), s2 = [i2 + (1 - i2) * r2, r2 * (1 - i2) - o2 * n2, r2 * (1 - i2) + o2 * n2, 0, 0, r2 * (1 - i2) + o2 * n2, i2 + r2 * (1 - i2), r2 * (1 - i2) - o2 * n2, 0, 0, r2 * (1 - i2) - o2 * n2, r2 * (1 - i2) + o2 * n2, i2 + r2 * (1 - i2), 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(s2, e3);
        }, e2.prototype.contrast = function(t3, e3) {
          var i2 = (t3 || 0) + 1, n2 = -0.5 * (i2 - 1), r2 = [i2, 0, 0, 0, n2, 0, i2, 0, 0, n2, 0, 0, i2, 0, n2, 0, 0, 0, 1, 0];
          this._loadMatrix(r2, e3);
        }, e2.prototype.saturate = function(t3, e3) {
          void 0 === t3 && (t3 = 0);
          var i2 = 2 * t3 / 3 + 1, n2 = -0.5 * (i2 - 1), r2 = [i2, n2, n2, 0, 0, n2, i2, n2, 0, 0, n2, n2, i2, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(r2, e3);
        }, e2.prototype.desaturate = function() {
          this.saturate(-1);
        }, e2.prototype.negative = function(t3) {
          this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.sepia = function(t3) {
          this._loadMatrix([0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.technicolor = function(t3) {
          this._loadMatrix([1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.polaroid = function(t3) {
          this._loadMatrix([1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.toBGR = function(t3) {
          this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.kodachrome = function(t3) {
          this._loadMatrix([1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.browni = function(t3) {
          this._loadMatrix([0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.vintage = function(t3) {
          this._loadMatrix([0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.colorTone = function(t3, e3, i2, n2, r2) {
          var o2 = ((i2 = i2 || 16770432) >> 16 & 255) / 255, s2 = (i2 >> 8 & 255) / 255, a2 = (255 & i2) / 255, l2 = ((n2 = n2 || 3375104) >> 16 & 255) / 255, h2 = (n2 >> 8 & 255) / 255, u2 = (255 & n2) / 255, c2 = [0.3, 0.59, 0.11, 0, 0, o2, s2, a2, t3 = t3 || 0.2, 0, l2, h2, u2, e3 = e3 || 0.15, 0, o2 - l2, s2 - h2, a2 - u2, 0, 0];
          this._loadMatrix(c2, r2);
        }, e2.prototype.night = function(t3, e3) {
          var i2 = [-2 * (t3 = t3 || 0.1), -t3, 0, 0, 0, -t3, 0, t3, 0, 0, 0, t3, 2 * t3, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(i2, e3);
        }, e2.prototype.predator = function(t3, e3) {
          var i2 = [11.224130630493164 * t3, -4.794486999511719 * t3, -2.8746118545532227 * t3, 0 * t3, 0.40342438220977783 * t3, -3.6330697536468506 * t3, 9.193157196044922 * t3, -2.951810836791992 * t3, 0 * t3, -1.316135048866272 * t3, -3.2184197902679443 * t3, -4.2375030517578125 * t3, 7.476448059082031 * t3, 0 * t3, 0.8044459223747253 * t3, 0, 0, 0, 1, 0];
          this._loadMatrix(i2, e3);
        }, e2.prototype.lsd = function(t3) {
          this._loadMatrix([2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0], t3);
        }, e2.prototype.reset = function() {
          this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], false);
        }, Object.defineProperty(e2.prototype, "matrix", { get: function() {
          return this.uniforms.m;
        }, set: function(t3) {
          this.uniforms.m = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "alpha", { get: function() {
          return this.uniforms.uAlpha;
        }, set: function(t3) {
          this.uniforms.uAlpha = t3;
        }, enumerable: false, configurable: true }), e2;
      }(Vh.k);
      Af.prototype.grayscale = Af.prototype.greyscale;
      var Mf = function(t2, e2) {
        return (Mf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Cf = function(t2) {
        function e2(e3, i2) {
          var n2 = this, r2 = new Lh.d();
          return e3.renderable = false, (n2 = t2.call(this, "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n	gl_Position = filterVertexPosition();\n	vTextureCoord = filterTextureCoord();\n	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", { mapSampler: e3._texture, filterMatrix: r2, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]) }) || this).maskSprite = e3, n2.maskMatrix = r2, null == i2 && (i2 = 20), n2.scale = new Lh.g(i2, i2), n2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Mf(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype.apply = function(t3, e3, i2, n2) {
          this.uniforms.filterMatrix = t3.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
          var r2 = this.maskSprite.worldTransform, o2 = Math.sqrt(r2.a * r2.a + r2.b * r2.b), s2 = Math.sqrt(r2.c * r2.c + r2.d * r2.d);
          0 !== o2 && 0 !== s2 && (this.uniforms.rotation[0] = r2.a / o2, this.uniforms.rotation[1] = r2.b / o2, this.uniforms.rotation[2] = r2.c / s2, this.uniforms.rotation[3] = r2.d / s2), t3.applyFilter(this, e3, i2, n2);
        }, Object.defineProperty(e2.prototype, "map", { get: function() {
          return this.uniforms.mapSampler;
        }, set: function(t3) {
          this.uniforms.mapSampler = t3;
        }, enumerable: false, configurable: true }), e2;
      }(Vh.k), Rf = function(t2, e2) {
        return (Rf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var If = function(t2) {
        function e2() {
          return t2.call(this, "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`) || this;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Rf(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2;
      }(Vh.k), Pf = function(t2, e2) {
        return (Pf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      var Of, Nf, Lf, Df, Ff, Bf, Uf, kf, Gf, Hf, jf, zf, Vf, Xf, Wf, Yf, qf, Zf, Jf, Kf = function(t2) {
        function e2(e3, i2) {
          void 0 === e3 && (e3 = 0.5), void 0 === i2 && (i2 = Math.random());
          var n2 = t2.call(this, Vh.z, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", { uNoise: 0, uSeed: 0 }) || this;
          return n2.noise = e3, n2.seed = i2, n2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          Pf(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), Object.defineProperty(e2.prototype, "noise", { get: function() {
          return this.uniforms.uNoise;
        }, set: function(t3) {
          this.uniforms.uNoise = t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "seed", { get: function() {
          return this.uniforms.uSeed;
        }, set: function(t3) {
          this.uniforms.uSeed = t3;
        }, enumerable: false, configurable: true }), e2;
      }(Vh.k);
      !function(t2) {
        t2[t2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.WEBGL2 = 2] = "WEBGL2";
      }(Of || (Of = {})), function(t2) {
        t2[t2.UNKNOWN = 0] = "UNKNOWN", t2[t2.WEBGL = 1] = "WEBGL", t2[t2.CANVAS = 2] = "CANVAS";
      }(Nf || (Nf = {})), function(t2) {
        t2[t2.COLOR = 16384] = "COLOR", t2[t2.DEPTH = 256] = "DEPTH", t2[t2.STENCIL = 1024] = "STENCIL";
      }(Lf || (Lf = {})), function(t2) {
        t2[t2.NORMAL = 0] = "NORMAL", t2[t2.ADD = 1] = "ADD", t2[t2.MULTIPLY = 2] = "MULTIPLY", t2[t2.SCREEN = 3] = "SCREEN", t2[t2.OVERLAY = 4] = "OVERLAY", t2[t2.DARKEN = 5] = "DARKEN", t2[t2.LIGHTEN = 6] = "LIGHTEN", t2[t2.COLOR_DODGE = 7] = "COLOR_DODGE", t2[t2.COLOR_BURN = 8] = "COLOR_BURN", t2[t2.HARD_LIGHT = 9] = "HARD_LIGHT", t2[t2.SOFT_LIGHT = 10] = "SOFT_LIGHT", t2[t2.DIFFERENCE = 11] = "DIFFERENCE", t2[t2.EXCLUSION = 12] = "EXCLUSION", t2[t2.HUE = 13] = "HUE", t2[t2.SATURATION = 14] = "SATURATION", t2[t2.COLOR = 15] = "COLOR", t2[t2.LUMINOSITY = 16] = "LUMINOSITY", t2[t2.NORMAL_NPM = 17] = "NORMAL_NPM", t2[t2.ADD_NPM = 18] = "ADD_NPM", t2[t2.SCREEN_NPM = 19] = "SCREEN_NPM", t2[t2.NONE = 20] = "NONE", t2[t2.SRC_OVER = 0] = "SRC_OVER", t2[t2.SRC_IN = 21] = "SRC_IN", t2[t2.SRC_OUT = 22] = "SRC_OUT", t2[t2.SRC_ATOP = 23] = "SRC_ATOP", t2[t2.DST_OVER = 24] = "DST_OVER", t2[t2.DST_IN = 25] = "DST_IN", t2[t2.DST_OUT = 26] = "DST_OUT", t2[t2.DST_ATOP = 27] = "DST_ATOP", t2[t2.ERASE = 26] = "ERASE", t2[t2.SUBTRACT = 28] = "SUBTRACT", t2[t2.XOR = 29] = "XOR";
      }(Df || (Df = {})), function(t2) {
        t2[t2.POINTS = 0] = "POINTS", t2[t2.LINES = 1] = "LINES", t2[t2.LINE_LOOP = 2] = "LINE_LOOP", t2[t2.LINE_STRIP = 3] = "LINE_STRIP", t2[t2.TRIANGLES = 4] = "TRIANGLES", t2[t2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t2[t2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
      }(Ff || (Ff = {})), function(t2) {
        t2[t2.RGBA = 6408] = "RGBA", t2[t2.RGB = 6407] = "RGB", t2[t2.RG = 33319] = "RG", t2[t2.RED = 6403] = "RED", t2[t2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t2[t2.RGB_INTEGER = 36248] = "RGB_INTEGER", t2[t2.RG_INTEGER = 33320] = "RG_INTEGER", t2[t2.RED_INTEGER = 36244] = "RED_INTEGER", t2[t2.ALPHA = 6406] = "ALPHA", t2[t2.LUMINANCE = 6409] = "LUMINANCE", t2[t2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t2[t2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t2[t2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
      }(Bf || (Bf = {})), function(t2) {
        t2[t2.TEXTURE_2D = 3553] = "TEXTURE_2D", t2[t2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t2[t2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t2[t2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t2[t2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      }(Uf || (Uf = {})), function(t2) {
        t2[t2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t2[t2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t2[t2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t2[t2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t2[t2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t2[t2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t2[t2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t2[t2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t2[t2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t2[t2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t2[t2.BYTE = 5120] = "BYTE", t2[t2.SHORT = 5122] = "SHORT", t2[t2.INT = 5124] = "INT", t2[t2.FLOAT = 5126] = "FLOAT", t2[t2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t2[t2.HALF_FLOAT = 36193] = "HALF_FLOAT";
      }(kf || (kf = {})), function(t2) {
        t2[t2.FLOAT = 0] = "FLOAT", t2[t2.INT = 1] = "INT", t2[t2.UINT = 2] = "UINT";
      }(Gf || (Gf = {})), function(t2) {
        t2[t2.NEAREST = 0] = "NEAREST", t2[t2.LINEAR = 1] = "LINEAR";
      }(Hf || (Hf = {})), function(t2) {
        t2[t2.CLAMP = 33071] = "CLAMP", t2[t2.REPEAT = 10497] = "REPEAT", t2[t2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
      }(jf || (jf = {})), function(t2) {
        t2[t2.OFF = 0] = "OFF", t2[t2.POW2 = 1] = "POW2", t2[t2.ON = 2] = "ON", t2[t2.ON_MANUAL = 3] = "ON_MANUAL";
      }(zf || (zf = {})), function(t2) {
        t2[t2.NPM = 0] = "NPM", t2[t2.UNPACK = 1] = "UNPACK", t2[t2.PMA = 2] = "PMA", t2[t2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t2[t2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t2[t2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", t2[t2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
      }(Vf || (Vf = {})), function(t2) {
        t2[t2.NO = 0] = "NO", t2[t2.YES = 1] = "YES", t2[t2.AUTO = 2] = "AUTO", t2[t2.BLEND = 0] = "BLEND", t2[t2.CLEAR = 1] = "CLEAR", t2[t2.BLIT = 2] = "BLIT";
      }(Xf || (Xf = {})), function(t2) {
        t2[t2.AUTO = 0] = "AUTO", t2[t2.MANUAL = 1] = "MANUAL";
      }(Wf || (Wf = {})), function(t2) {
        t2.LOW = "lowp", t2.MEDIUM = "mediump", t2.HIGH = "highp";
      }(Yf || (Yf = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.SCISSOR = 1] = "SCISSOR", t2[t2.STENCIL = 2] = "STENCIL", t2[t2.SPRITE = 3] = "SPRITE";
      }(qf || (qf = {})), function(t2) {
        t2[t2.NONE = 0] = "NONE", t2[t2.LOW = 2] = "LOW", t2[t2.MEDIUM = 4] = "MEDIUM", t2[t2.HIGH = 8] = "HIGH";
      }(Zf || (Zf = {})), function(t2) {
        t2[t2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t2[t2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t2[t2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
      }(Jf || (Jf = {}));
      var Qf = new Lh.d();
      Oh.c.prototype._cacheAsBitmap = false, Oh.c.prototype._cacheData = null, Oh.c.prototype._cacheAsBitmapResolution = null, Oh.c.prototype._cacheAsBitmapMultisample = Zf.NONE;
      var $f = function() {
        this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
      };
      Object.defineProperties(Oh.c.prototype, { cacheAsBitmapResolution: { get: function() {
        return this._cacheAsBitmapResolution;
      }, set: function(t2) {
        t2 !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = t2, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
      } }, cacheAsBitmapMultisample: { get: function() {
        return this._cacheAsBitmapMultisample;
      }, set: function(t2) {
        t2 !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = t2, this.cacheAsBitmap && (this.cacheAsBitmap = false, this.cacheAsBitmap = true));
      } }, cacheAsBitmap: { get: function() {
        return this._cacheAsBitmap;
      }, set: function(t2) {
        var e2;
        this._cacheAsBitmap !== t2 && (this._cacheAsBitmap = t2, t2 ? (this._cacheData || (this._cacheData = new $f()), (e2 = this._cacheData).originalRender = this.render, e2.originalRenderCanvas = this.renderCanvas, e2.originalUpdateTransform = this.updateTransform, e2.originalCalculateBounds = this.calculateBounds, e2.originalGetLocalBounds = this.getLocalBounds, e2.originalDestroy = this.destroy, e2.originalContainsPoint = this.containsPoint, e2.originalMask = this._mask, e2.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e2 = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e2.originalRender, this.renderCanvas = e2.originalRenderCanvas, this.calculateBounds = e2.originalCalculateBounds, this.getLocalBounds = e2.originalGetLocalBounds, this.destroy = e2.originalDestroy, this.updateTransform = e2.originalUpdateTransform, this.containsPoint = e2.originalContainsPoint, this._mask = e2.originalMask, this.filterArea = e2.originalFilterArea));
      } } }), Oh.c.prototype._renderCached = function(t2) {
        !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t2), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t2));
      }, Oh.c.prototype._initCachedDisplayObject = function(t2) {
        var e2;
        if (!this._cacheData || !this._cacheData.sprite) {
          var i2 = this.alpha;
          this.alpha = 1, t2.batch.flush();
          var n2 = this.getLocalBounds(null, true).clone();
          if (this.filters && this.filters.length) {
            var r2 = this.filters[0].padding;
            n2.pad(r2);
          }
          n2.ceil(xd.b.RESOLUTION);
          var o2 = t2.renderTexture.current, s2 = t2.renderTexture.sourceFrame.clone(), a2 = t2.renderTexture.destinationFrame.clone(), l2 = t2.projection.transform, h2 = Vh.p.create({ width: n2.width, height: n2.height, resolution: this.cacheAsBitmapResolution || t2.resolution, multisample: null !== (e2 = this.cacheAsBitmapMultisample) && void 0 !== e2 ? e2 : t2.multisample }), u2 = "cacheAsBitmap_" + Object(Ph.uid)();
          this._cacheData.textureCacheId = u2, Vh.c.addToCache(h2.baseTexture, u2), Vh.t.addToCache(h2, u2);
          var c2 = this.transform.localTransform.copyTo(Qf).invert().translate(-n2.x, -n2.y);
          this.render = this._cacheData.originalRender, t2.render(this, { renderTexture: h2, clear: true, transform: c2, skipUpdateTransform: false }), t2.framebuffer.blit(), t2.projection.transform = l2, t2.renderTexture.bind(o2, s2, a2), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i2;
          var d2 = new ep(h2);
          d2.transform.worldTransform = this.transform.worldTransform, d2.anchor.x = -n2.x / n2.width, d2.anchor.y = -n2.y / n2.height, d2.alpha = i2, d2._bounds = this._bounds, this._cacheData.sprite = d2, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = d2.containsPoint.bind(d2);
        }
      }, Oh.c.prototype._renderCachedCanvas = function(t2) {
        !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t2), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t2));
      }, Oh.c.prototype._initCachedDisplayObjectCanvas = function(t2) {
        if (!this._cacheData || !this._cacheData.sprite) {
          var e2 = this.getLocalBounds(null, true), i2 = this.alpha;
          this.alpha = 1;
          var n2 = t2.context, r2 = t2._projTransform;
          e2.ceil(xd.b.RESOLUTION);
          var o2 = Vh.p.create({ width: e2.width, height: e2.height }), s2 = "cacheAsBitmap_" + Object(Ph.uid)();
          this._cacheData.textureCacheId = s2, Vh.c.addToCache(o2.baseTexture, s2), Vh.t.addToCache(o2, s2);
          var a2 = Qf;
          this.transform.localTransform.copyTo(a2), a2.invert(), a2.tx -= e2.x, a2.ty -= e2.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t2.render(this, { renderTexture: o2, clear: true, transform: a2, skipUpdateTransform: false }), t2.context = n2, t2._projTransform = r2, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i2;
          var l2 = new ep(o2);
          l2.transform.worldTransform = this.transform.worldTransform, l2.anchor.x = -e2.x / e2.width, l2.anchor.y = -e2.y / e2.height, l2.alpha = i2, l2._bounds = this._bounds, this._cacheData.sprite = l2, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t2._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l2.containsPoint.bind(l2);
        }
      }, Oh.c.prototype._calculateCachedBounds = function() {
        this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
      }, Oh.c.prototype._getCachedLocalBounds = function() {
        return this._cacheData.sprite.getLocalBounds(null);
      }, Oh.c.prototype._destroyCachedDisplayObject = function() {
        this._cacheData.sprite._texture.destroy(true), this._cacheData.sprite = null, Vh.c.removeFromCache(this._cacheData.textureCacheId), Vh.t.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
      }, Oh.c.prototype._cacheAsBitmapDestroy = function(t2) {
        this.cacheAsBitmap = false, this.destroy(t2);
      }, /*!
       * @pixi/mixin-get-child-by-name - v6.4.2
       * Compiled Thu, 02 Jun 2022 15:39:26 UTC
       *
       * @pixi/mixin-get-child-by-name is licensed under the MIT License.
       * http://www.opensource.org/licenses/mit-license
       */
      Oh.c.prototype.name = null, Oh.b.prototype.getChildByName = function(t2, e2) {
        for (var i2 = 0, n2 = this.children.length; i2 < n2; i2++) if (this.children[i2].name === t2) return this.children[i2];
        if (e2) for (i2 = 0, n2 = this.children.length; i2 < n2; i2++) {
          if (this.children[i2].getChildByName) {
            var r2 = this.children[i2].getChildByName(t2, true);
            if (r2) return r2;
          }
        }
        return null;
      }, /*!
       * @pixi/mixin-get-global-position - v6.4.2
       * Compiled Thu, 02 Jun 2022 15:39:26 UTC
       *
       * @pixi/mixin-get-global-position is licensed under the MIT License.
       * http://www.opensource.org/licenses/mit-license
       */
      Oh.c.prototype.getGlobalPosition = function(t2, e2) {
        return void 0 === t2 && (t2 = new Lh.g()), void 0 === e2 && (e2 = false), this.parent ? this.parent.toGlobal(this.position, t2, e2) : (t2.x = this.position.x, t2.y = this.position.y), t2;
      };
      var tm = i(16), em = (i(12), function(t2, e2) {
        return (em = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      });
      var im = function(t2) {
        function e2(e3, i2) {
          void 0 === i2 && (i2 = true);
          var n2 = t2.call(this, e3[0] instanceof Vh.t ? e3[0] : e3[0].texture) || this;
          return n2._textures = null, n2._durations = null, n2._autoUpdate = i2, n2._isConnectedToTicker = false, n2.animationSpeed = 1, n2.loop = true, n2.updateAnchor = false, n2.onComplete = null, n2.onFrameChange = null, n2.onLoop = null, n2._currentTime = 0, n2._playing = false, n2._previousFrame = null, n2.textures = e3, n2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          em(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype.stop = function() {
          this._playing && (this._playing = false, this._autoUpdate && this._isConnectedToTicker && (Dh.a.shared.remove(this.update, this), this._isConnectedToTicker = false));
        }, e2.prototype.play = function() {
          this._playing || (this._playing = true, this._autoUpdate && !this._isConnectedToTicker && (Dh.a.shared.add(this.update, this, Dh.c.HIGH), this._isConnectedToTicker = true));
        }, e2.prototype.gotoAndStop = function(t3) {
          this.stop();
          var e3 = this.currentFrame;
          this._currentTime = t3, e3 !== this.currentFrame && this.updateTexture();
        }, e2.prototype.gotoAndPlay = function(t3) {
          var e3 = this.currentFrame;
          this._currentTime = t3, e3 !== this.currentFrame && this.updateTexture(), this.play();
        }, e2.prototype.update = function(t3) {
          if (this._playing) {
            var e3 = this.animationSpeed * t3, i2 = this.currentFrame;
            if (null !== this._durations) {
              var n2 = this._currentTime % 1 * this._durations[this.currentFrame];
              for (n2 += e3 / 60 * 1e3; n2 < 0; ) this._currentTime--, n2 += this._durations[this.currentFrame];
              var r2 = Math.sign(this.animationSpeed * t3);
              for (this._currentTime = Math.floor(this._currentTime); n2 >= this._durations[this.currentFrame]; ) n2 -= this._durations[this.currentFrame] * r2, this._currentTime += r2;
              this._currentTime += n2 / this._durations[this.currentFrame];
            } else this._currentTime += e3;
            this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : i2 !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i2 || this.animationSpeed < 0 && this.currentFrame > i2) && this.onLoop(), this.updateTexture());
          }
        }, e2.prototype.updateTexture = function() {
          var t3 = this.currentFrame;
          this._previousFrame !== t3 && (this._previousFrame = t3, this._texture = this._textures[t3], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
        }, e2.prototype.destroy = function(e3) {
          this.stop(), t2.prototype.destroy.call(this, e3), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
        }, e2.fromFrames = function(t3) {
          for (var i2 = [], n2 = 0; n2 < t3.length; ++n2) i2.push(Vh.t.from(t3[n2]));
          return new e2(i2);
        }, e2.fromImages = function(t3) {
          for (var i2 = [], n2 = 0; n2 < t3.length; ++n2) i2.push(Vh.t.from(t3[n2]));
          return new e2(i2);
        }, Object.defineProperty(e2.prototype, "totalFrames", { get: function() {
          return this._textures.length;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "textures", { get: function() {
          return this._textures;
        }, set: function(t3) {
          if (t3[0] instanceof Vh.t) this._textures = t3, this._durations = null;
          else {
            this._textures = [], this._durations = [];
            for (var e3 = 0; e3 < t3.length; e3++) this._textures.push(t3[e3].texture), this._durations.push(t3[e3].time);
          }
          this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "currentFrame", { get: function() {
          var t3 = Math.floor(this._currentTime) % this._textures.length;
          return t3 < 0 && (t3 += this._textures.length), t3;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "playing", { get: function() {
          return this._playing;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "autoUpdate", { get: function() {
          return this._autoUpdate;
        }, set: function(t3) {
          t3 !== this._autoUpdate && (this._autoUpdate = t3, !this._autoUpdate && this._isConnectedToTicker ? (Dh.a.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Dh.a.shared.add(this.update, this), this._isConnectedToTicker = true));
        }, enumerable: false, configurable: true }), e2;
      }(ep);
      Vh.q.registerPlugin("accessibility", Nh), Vh.q.registerPlugin("extract", nc), Vh.q.registerPlugin("interaction", zh), Vh.q.registerPlugin("particle", yd), Vh.q.registerPlugin("prepare", wp), Vh.q.registerPlugin("batch", Vh.f), Vh.q.registerPlugin("tilingSprite", Lp), yc.registerPlugin(Jp), yc.registerPlugin(Oc), yc.registerPlugin(Jc), yc.registerPlugin(dd), yc.registerPlugin(Mp), Xh.registerPlugin(Dh.b), Xh.registerPlugin(xc);
      var nm, rm = { AlphaFilter: Qp, BlurFilter: Sf, BlurFilterPass: Ef, ColorMatrixFilter: Af, DisplacementFilter: Cf, FXAAFilter: If, NoiseFilter: Kf }, om = i(10), sm = i(34), am = function() {
        function t2() {
        }
        return t2.offsetPolygon = function(e2, i2) {
          var n2 = [], r2 = e2.length;
          i2 = t2.isPolygonClockwise(e2) ? i2 : -1 * i2;
          for (var o2 = 0; o2 < r2; o2 += 2) {
            var s2 = o2 - 2;
            s2 < 0 && (s2 += r2);
            var a2 = (o2 + 2) % r2, l2 = e2[o2] - e2[s2], h2 = e2[o2 + 1] - e2[s2 + 1], u2 = Math.sqrt(l2 * l2 + h2 * h2);
            l2 /= u2, h2 /= u2;
            var c2 = -(h2 *= i2), d2 = l2 *= i2, p2 = [e2[s2] + c2, e2[s2 + 1] + d2], f2 = [e2[o2] + c2, e2[o2 + 1] + d2], m2 = e2[a2] - e2[o2], g2 = e2[a2 + 1] - e2[o2 + 1];
            m2 /= u2 = Math.sqrt(m2 * m2 + g2 * g2), g2 /= u2;
            var v2 = -(g2 *= i2), _2 = m2 *= i2, y2 = [e2[o2] + v2, e2[o2 + 1] + _2], x2 = [e2[a2] + v2, e2[a2 + 1] + _2], b2 = t2.findIntersection(p2[0], p2[1], f2[0], f2[1], y2[0], y2[1], x2[0], x2[1]);
            b2 && n2.push.apply(n2, b2);
          }
          return n2;
        }, t2.findIntersection = function(t3, e2, i2, n2, r2, o2, s2, a2) {
          var l2 = (a2 - o2) * (i2 - t3) - (s2 - r2) * (n2 - e2), h2 = (s2 - r2) * (e2 - o2) - (a2 - o2) * (t3 - r2);
          if (0 === l2) return 0 === h2 && 0 === (i2 - t3) * (e2 - o2) - (n2 - e2) * (t3 - r2) ? [(t3 + i2) / 2, (e2 + n2) / 2] : null;
          var u2 = h2 / l2;
          return [t3 + u2 * (i2 - t3), e2 + u2 * (n2 - e2)];
        }, t2.isPolygonClockwise = function(t3) {
          for (var e2 = 0, i2 = 0, n2 = t3.length - 2; i2 < t3.length; n2 = i2, i2 += 2) e2 += (t3[i2] - t3[n2]) * (t3[i2 + 1] + t3[n2 + 1]);
          return e2 > 0;
        }, t2;
      }(), lm = function() {
        function t2(t3) {
          this._svgMatrix = null, this._tempMatrix = new Lh.d(), this.renderer = t3;
        }
        return t2.prototype._calcCanvasStyle = function(t3, e2) {
          var i2;
          return t3.texture && t3.texture.baseTexture !== Vh.t.WHITE.baseTexture ? t3.texture.valid ? (i2 = om.b.getTintedPattern(t3.texture, e2), this.setPatternTransform(i2, t3.matrix || Lh.d.IDENTITY)) : i2 = "#808080" : i2 = "#" + ("00000" + (0 | e2).toString(16)).slice(-6), i2;
        }, t2.prototype.render = function(t3) {
          var e2 = this.renderer, i2 = e2.context, n2 = t3.worldAlpha, r2 = t3.transform.worldTransform;
          e2.setContextTransform(r2), e2.setBlendMode(t3.blendMode);
          for (var o2, s2, a2 = t3.geometry.graphicsData, l2 = (t3.tint >> 16 & 255) / 255, h2 = (t3.tint >> 8 & 255) / 255, u2 = (255 & t3.tint) / 255, c2 = 0; c2 < a2.length; c2++) {
            var d2 = a2[c2], p2 = d2.shape, f2 = d2.fillStyle, m2 = d2.lineStyle, g2 = 0 | d2.fillStyle.color, v2 = 0 | d2.lineStyle.color;
            if (d2.matrix && e2.setContextTransform(r2.copyTo(this._tempMatrix).append(d2.matrix)), f2.visible) {
              var _2 = ((g2 >> 16 & 255) / 255 * l2 * 255 << 16) + ((g2 >> 8 & 255) / 255 * h2 * 255 << 8) + (255 & g2) / 255 * u2 * 255;
              o2 = this._calcCanvasStyle(f2, _2);
            }
            if (m2.visible) {
              var y2 = ((v2 >> 16 & 255) / 255 * l2 * 255 << 16) + ((v2 >> 8 & 255) / 255 * h2 * 255 << 8) + (255 & v2) / 255 * u2 * 255;
              s2 = this._calcCanvasStyle(m2, y2);
            }
            if (i2.lineWidth = m2.width, i2.lineCap = m2.cap, i2.lineJoin = m2.join, i2.miterLimit = m2.miterLimit, d2.type === Lh.l.POLY) {
              i2.beginPath();
              var x2 = (R2 = p2).points, b2 = d2.holes, T2 = void 0, E2 = void 0, S2 = void 0, w2 = void 0, A2 = void 0;
              i2.moveTo(x2[0], x2[1]);
              for (var M2 = 2; M2 < x2.length; M2 += 2) i2.lineTo(x2[M2], x2[M2 + 1]);
              if (R2.closeStroke && i2.closePath(), b2.length > 0) {
                A2 = [], T2 = 0, S2 = x2[0], w2 = x2[1];
                for (M2 = 2; M2 + 2 < x2.length; M2 += 2) T2 += (x2[M2] - S2) * (x2[M2 + 3] - w2) - (x2[M2 + 2] - S2) * (x2[M2 + 1] - w2);
                for (var C2 = 0; C2 < b2.length; C2++) if (x2 = b2[C2].shape.points) {
                  E2 = 0, S2 = x2[0], w2 = x2[1];
                  for (M2 = 2; M2 + 2 < x2.length; M2 += 2) E2 += (x2[M2] - S2) * (x2[M2 + 3] - w2) - (x2[M2 + 2] - S2) * (x2[M2 + 1] - w2);
                  if (E2 * T2 < 0) {
                    i2.moveTo(x2[0], x2[1]);
                    for (M2 = 2; M2 < x2.length; M2 += 2) i2.lineTo(x2[M2], x2[M2 + 1]);
                  } else {
                    i2.moveTo(x2[x2.length - 2], x2[x2.length - 1]);
                    for (M2 = x2.length - 4; M2 >= 0; M2 -= 2) i2.lineTo(x2[M2], x2[M2 + 1]);
                  }
                  b2[C2].shape.closeStroke && i2.closePath(), A2[C2] = E2 * T2 < 0;
                }
              }
              f2.visible && (i2.globalAlpha = f2.alpha * n2, i2.fillStyle = o2, i2.fill()), m2.visible && this.paintPolygonStroke(R2, m2, s2, b2, A2, n2, i2);
            } else if (d2.type === Lh.l.RECT) {
              var R2 = p2;
              if (f2.visible && (i2.globalAlpha = f2.alpha * n2, i2.fillStyle = o2, i2.fillRect(R2.x, R2.y, R2.width, R2.height)), m2.visible) {
                var I2 = m2.width * (0.5 - (1 - m2.alignment)), P2 = R2.width + 2 * I2, O2 = R2.height + 2 * I2;
                i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.strokeRect(R2.x - I2, R2.y - I2, P2, O2);
              }
            } else if (d2.type === Lh.l.CIRC) {
              R2 = p2;
              if (i2.beginPath(), i2.arc(R2.x, R2.y, R2.radius, 0, 2 * Math.PI), i2.closePath(), f2.visible && (i2.globalAlpha = f2.alpha * n2, i2.fillStyle = o2, i2.fill()), m2.visible) {
                if (0.5 !== m2.alignment) {
                  I2 = m2.width * (0.5 - (1 - m2.alignment));
                  i2.beginPath(), i2.arc(R2.x, R2.y, R2.radius + I2, 0, 2 * Math.PI), i2.closePath();
                }
                i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.stroke();
              }
            } else if (d2.type === Lh.l.ELIP) {
              R2 = p2;
              if ((z2 = 1 === m2.alignment) || this.paintEllipse(R2, f2, m2, o2, n2, i2), m2.visible) {
                if (0.5 !== m2.alignment) {
                  I2 = m2.width * (0.5 - (1 - m2.alignment));
                  var N2 = 2 * (R2.width + I2), L2 = 2 * (R2.height + I2), D2 = R2.x - N2 / 2, F2 = R2.y - L2 / 2, B2 = N2 / 2 * 0.5522848, U2 = L2 / 2 * 0.5522848, k2 = D2 + N2, G2 = F2 + L2, H2 = D2 + N2 / 2, j2 = F2 + L2 / 2;
                  i2.beginPath(), i2.moveTo(D2, j2), i2.bezierCurveTo(D2, j2 - U2, H2 - B2, F2, H2, F2), i2.bezierCurveTo(H2 + B2, F2, k2, j2 - U2, k2, j2), i2.bezierCurveTo(k2, j2 + U2, H2 + B2, G2, H2, G2), i2.bezierCurveTo(H2 - B2, G2, D2, j2 + U2, D2, j2), i2.closePath();
                }
                i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.stroke();
              }
              z2 && this.paintEllipse(R2, f2, m2, o2, n2, i2);
            } else if (d2.type === Lh.l.RREC) {
              var z2;
              R2 = p2;
              if ((z2 = 1 === m2.alignment) || this.paintRoundedRectangle(R2, f2, m2, o2, n2, i2), m2.visible) {
                if (0.5 !== m2.alignment) {
                  P2 = R2.width, O2 = R2.height, I2 = m2.width * (0.5 - (1 - m2.alignment));
                  var V2 = R2.x - I2, X2 = R2.y - I2, W2 = R2.width + 2 * I2, Y2 = R2.height + 2 * I2, q2 = I2 * (m2.alignment >= 1 ? Math.min(W2 / P2, Y2 / O2) : Math.min(P2 / W2, O2 / Y2)), Z2 = R2.radius + q2, J2 = Math.min(W2, Y2) / 2;
                  Z2 = Z2 > J2 ? J2 : Z2, i2.beginPath(), i2.moveTo(V2, X2 + Z2), i2.lineTo(V2, X2 + Y2 - Z2), i2.quadraticCurveTo(V2, X2 + Y2, V2 + Z2, X2 + Y2), i2.lineTo(V2 + W2 - Z2, X2 + Y2), i2.quadraticCurveTo(V2 + W2, X2 + Y2, V2 + W2, X2 + Y2 - Z2), i2.lineTo(V2 + W2, X2 + Z2), i2.quadraticCurveTo(V2 + W2, X2, V2 + W2 - Z2, X2), i2.lineTo(V2 + Z2, X2), i2.quadraticCurveTo(V2, X2, V2, X2 + Z2), i2.closePath();
                }
                i2.globalAlpha = m2.alpha * n2, i2.strokeStyle = s2, i2.stroke();
              }
              z2 && this.paintRoundedRectangle(R2, f2, m2, o2, n2, i2);
            }
          }
        }, t2.prototype.paintPolygonStroke = function(t3, e2, i2, n2, r2, o2, s2) {
          if (0.5 !== e2.alignment) {
            var a2 = e2.width * (0.5 - (1 - e2.alignment)), l2 = am.offsetPolygon(t3.points, a2), h2 = void 0;
            s2.beginPath(), s2.moveTo(l2[0], l2[1]);
            for (var u2 = 2; u2 < l2.length; u2 += 2) s2.lineTo(l2[u2], l2[u2 + 1]);
            t3.closeStroke && s2.closePath();
            for (var c2 = 0; c2 < n2.length; c2++) {
              if (h2 = n2[c2].shape.points, l2 = am.offsetPolygon(h2, a2), r2[c2]) {
                s2.moveTo(l2[0], l2[1]);
                for (u2 = 2; u2 < l2.length; u2 += 2) s2.lineTo(l2[u2], l2[u2 + 1]);
              } else {
                s2.moveTo(l2[l2.length - 2], l2[l2.length - 1]);
                for (u2 = l2.length - 4; u2 >= 0; u2 -= 2) s2.lineTo(l2[u2], l2[u2 + 1]);
              }
              n2[c2].shape.closeStroke && s2.closePath();
            }
          }
          s2.globalAlpha = e2.alpha * o2, s2.strokeStyle = i2, s2.stroke();
        }, t2.prototype.paintEllipse = function(t3, e2, i2, n2, r2, o2) {
          var s2 = 2 * t3.width, a2 = 2 * t3.height, l2 = t3.x - s2 / 2, h2 = t3.y - a2 / 2, u2 = s2 / 2 * 0.5522848, c2 = a2 / 2 * 0.5522848, d2 = l2 + s2, p2 = h2 + a2, f2 = l2 + s2 / 2, m2 = h2 + a2 / 2;
          0 === i2.alignment && o2.save(), o2.beginPath(), o2.moveTo(l2, m2), o2.bezierCurveTo(l2, m2 - c2, f2 - u2, h2, f2, h2), o2.bezierCurveTo(f2 + u2, h2, d2, m2 - c2, d2, m2), o2.bezierCurveTo(d2, m2 + c2, f2 + u2, p2, f2, p2), o2.bezierCurveTo(f2 - u2, p2, l2, m2 + c2, l2, m2), o2.closePath(), 0 === i2.alignment && o2.clip(), e2.visible && (o2.globalAlpha = e2.alpha * r2, o2.fillStyle = n2, o2.fill()), 0 === i2.alignment && o2.restore();
        }, t2.prototype.paintRoundedRectangle = function(t3, e2, i2, n2, r2, o2) {
          var s2 = t3.x, a2 = t3.y, l2 = t3.width, h2 = t3.height, u2 = t3.radius, c2 = Math.min(l2, h2) / 2;
          u2 = u2 > c2 ? c2 : u2, 0 === i2.alignment && o2.save(), o2.beginPath(), o2.moveTo(s2, a2 + u2), o2.lineTo(s2, a2 + h2 - u2), o2.quadraticCurveTo(s2, a2 + h2, s2 + u2, a2 + h2), o2.lineTo(s2 + l2 - u2, a2 + h2), o2.quadraticCurveTo(s2 + l2, a2 + h2, s2 + l2, a2 + h2 - u2), o2.lineTo(s2 + l2, a2 + u2), o2.quadraticCurveTo(s2 + l2, a2, s2 + l2 - u2, a2), o2.lineTo(s2 + u2, a2), o2.quadraticCurveTo(s2, a2, s2, a2 + u2), o2.closePath(), 0 === i2.alignment && o2.clip(), e2.visible && (o2.globalAlpha = e2.alpha * r2, o2.fillStyle = n2, o2.fill()), 0 === i2.alignment && o2.restore();
        }, t2.prototype.setPatternTransform = function(t3, e2) {
          if (false !== this._svgMatrix) {
            if (!this._svgMatrix) {
              var i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
              if (i2 && i2.createSVGMatrix && (this._svgMatrix = i2.createSVGMatrix()), !this._svgMatrix || !t3.setTransform) return void (this._svgMatrix = false);
            }
            this._svgMatrix.a = e2.a, this._svgMatrix.b = e2.b, this._svgMatrix.c = e2.c, this._svgMatrix.d = e2.d, this._svgMatrix.e = e2.tx, this._svgMatrix.f = e2.ty, t3.setTransform(this._svgMatrix.inverse());
          }
        }, t2.prototype.destroy = function() {
          this.renderer = null, this._svgMatrix = null, this._tempMatrix = null;
        }, t2;
      }(), hm = new Lh.d();
      Jd.prototype.generateCanvasTexture = function(t2, e2) {
        void 0 === e2 && (e2 = 1);
        var i2 = this.getLocalBounds(), n2 = Vh.p.create({ width: i2.width, height: i2.height, scaleMode: t2, resolution: e2 });
        nm || (nm = new om.a()), this.transform.updateLocalTransform(), this.transform.localTransform.copyTo(hm), hm.invert(), hm.tx -= i2.x, hm.ty -= i2.y, nm.render(this, { renderTexture: n2, clear: true, transform: hm });
        var r2 = Vh.t.from(n2.baseTexture._canvasRenderTarget.canvas, { scaleMode: t2 });
        return r2.baseTexture.setResolution(e2), r2;
      }, Jd.prototype.cachedGraphicsData = [], Jd.prototype._renderCanvas = function(t2) {
        true !== this.isMask && (this.finishPoly(), t2.plugins.graphics.render(this));
      };
      var um = new Lh.d(), cm = function() {
        function t2(t3) {
          this.renderer = t3;
        }
        return t2.prototype.render = function(t3) {
          var e2 = t3._texture, i2 = this.renderer, n2 = i2.context;
          if (e2.valid) {
            var r2 = e2._frame.width, o2 = e2._frame.height, s2 = t3.transform.worldTransform, a2 = 0, l2 = 0, h2 = e2.baseTexture.getDrawableSource();
            if (!(e2.orig.width <= 0 || e2.orig.height <= 0) && e2.valid && h2) {
              i2.setBlendMode(t3.blendMode, true), i2.context.globalAlpha = t3.worldAlpha;
              var u2 = e2.baseTexture.scaleMode === Sc.p.LINEAR;
              i2.smoothProperty && i2.context[i2.smoothProperty] !== u2 && (n2[i2.smoothProperty] = u2), e2.trim ? (a2 = e2.trim.width / 2 + e2.trim.x - t3.anchor.x * e2.orig.width, l2 = e2.trim.height / 2 + e2.trim.y - t3.anchor.y * e2.orig.height) : (a2 = (0.5 - t3.anchor.x) * e2.orig.width, l2 = (0.5 - t3.anchor.y) * e2.orig.height), e2.rotate && (s2.copyTo(um), s2 = um, Lh.n.matrixAppendRotationInv(s2, e2.rotate, a2, l2), a2 = 0, l2 = 0), a2 -= r2 / 2, l2 -= o2 / 2, i2.setContextTransform(s2, t3.roundPixels, 1), t3.roundPixels && (a2 |= 0, l2 |= 0);
              var c2 = e2.baseTexture.resolution, d2 = i2._outerBlend;
              d2 && (n2.save(), n2.beginPath(), n2.rect(a2 * i2.resolution, l2 * i2.resolution, r2 * i2.resolution, o2 * i2.resolution), n2.clip()), 16777215 !== t3.tint ? (t3._cachedTint === t3.tint && t3._tintedCanvas.tintId === t3._texture._updateID || (t3._cachedTint = t3.tint, t3._tintedCanvas = om.b.getTintedCanvas(t3, t3.tint)), n2.drawImage(t3._tintedCanvas, 0, 0, Math.floor(r2 * c2), Math.floor(o2 * c2), Math.floor(a2 * i2.resolution), Math.floor(l2 * i2.resolution), Math.floor(r2 * i2.resolution), Math.floor(o2 * i2.resolution))) : n2.drawImage(h2, e2._frame.x * c2, e2._frame.y * c2, Math.floor(r2 * c2), Math.floor(o2 * c2), Math.floor(a2 * i2.resolution), Math.floor(l2 * i2.resolution), Math.floor(r2 * i2.resolution), Math.floor(o2 * i2.resolution)), d2 && n2.restore(), i2.setBlendMode(Sc.b.NORMAL);
            }
          }
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }();
      ep.prototype._tintedCanvas = null, ep.prototype._renderCanvas = function(t2) {
        t2.plugins.sprite.render(this);
      };
      var dm = new Lh.j(), pm = function() {
        function t2(t3) {
          this.renderer = t3;
        }
        return t2.prototype.image = function(t3, e2, i2) {
          var n2 = new Image();
          return n2.src = this.base64(t3, e2, i2), n2;
        }, t2.prototype.base64 = function(t3, e2, i2) {
          return this.canvas(t3).toDataURL(e2, i2);
        }, t2.prototype.canvas = function(t3) {
          var e2, i2, n2, r2, o2 = this.renderer;
          t3 && (r2 = t3 instanceof Vh.p ? t3 : o2.generateTexture(t3)), r2 ? (e2 = r2.baseTexture._canvasRenderTarget.context, i2 = r2.baseTexture._canvasRenderTarget.resolution, n2 = r2.frame) : (e2 = o2.rootContext, i2 = o2.resolution, (n2 = dm).width = this.renderer.width, n2.height = this.renderer.height);
          var s2 = Math.floor(n2.width * i2 + 1e-4), a2 = Math.floor(n2.height * i2 + 1e-4), l2 = new Ph.CanvasRenderTarget(s2, a2, 1), h2 = e2.getImageData(n2.x * i2, n2.y * i2, s2, a2);
          return l2.context.putImageData(h2, 0, 0), l2.canvas;
        }, t2.prototype.pixels = function(t3) {
          var e2, i2, n2, r2, o2 = this.renderer;
          t3 && (r2 = t3 instanceof Vh.p ? t3 : o2.generateTexture(t3)), r2 ? (e2 = r2.baseTexture._canvasRenderTarget.context, i2 = r2.baseTexture._canvasRenderTarget.resolution, n2 = r2.frame) : (e2 = o2.rootContext, i2 = o2.resolution, (n2 = dm).width = o2.width, n2.height = o2.height);
          var s2 = n2.x * i2, a2 = n2.y * i2, l2 = n2.width * i2, h2 = n2.height * i2;
          return e2.getImageData(s2, a2, l2, h2).data;
        }, t2.prototype.destroy = function() {
          this.renderer = null;
        }, t2;
      }(), fm = function(t2, e2) {
        return (fm = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
          t3.__proto__ = e3;
        } || function(t3, e3) {
          for (var i2 in e3) e3.hasOwnProperty(i2) && (t3[i2] = e3[i2]);
        })(t2, e2);
      };
      function mm(t2, e2) {
        var i2 = t2;
        if (e2 instanceof Vh.c) {
          var n2 = e2.source, r2 = 0 === n2.width ? i2.canvas.width : Math.min(i2.canvas.width, n2.width), o2 = 0 === n2.height ? i2.canvas.height : Math.min(i2.canvas.height, n2.height);
          return i2.ctx.drawImage(n2, 0, 0, r2, o2, 0, 0, i2.canvas.width, i2.canvas.height), true;
        }
        return false;
      }
      var gm, vm = function(t2) {
        function e2(e3) {
          var i2 = t2.call(this, e3) || this;
          return i2.uploadHookHelper = i2, i2.canvas = document.createElement("canvas"), i2.canvas.width = 16, i2.canvas.height = 16, i2.ctx = i2.canvas.getContext("2d"), i2.registerUploadHook(mm), i2;
        }
        return function(t3, e3) {
          function i2() {
            this.constructor = t3;
          }
          fm(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (i2.prototype = e3.prototype, new i2());
        }(e2, t2), e2.prototype.destroy = function() {
          t2.prototype.destroy.call(this), this.ctx = null, this.canvas = null;
        }, e2;
      }(bp), _m = new Lh.d(), ym = new Lh.d(), xm = [new Lh.g(), new Lh.g(), new Lh.g(), new Lh.g()];
      Pp.prototype._renderCanvas = function(t2) {
        var e2 = this._texture;
        if (e2.baseTexture.valid) {
          var i2 = t2.context, n2 = this.worldTransform, r2 = e2.baseTexture, o2 = r2.getDrawableSource(), s2 = r2.resolution;
          if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
            this._textureID = this._texture._updateID;
            var a2 = new Ph.CanvasRenderTarget(e2._frame.width, e2._frame.height, s2);
            16777215 !== this.tint ? (this._tintedCanvas = om.b.getTintedCanvas(this, this.tint), a2.context.drawImage(this._tintedCanvas, 0, 0)) : a2.context.drawImage(o2, -e2._frame.x * s2, -e2._frame.y * s2), this._cachedTint = this.tint, this._canvasPattern = a2.context.createPattern(a2.canvas, "repeat");
          }
          i2.globalAlpha = this.worldAlpha, t2.setBlendMode(this.blendMode), this.tileTransform.updateLocalTransform();
          var l2 = this.tileTransform.localTransform, h2 = this._width, u2 = this._height;
          _m.identity(), ym.copyFrom(l2), this.uvRespectAnchor || ym.translate(-this.anchor.x * h2, -this.anchor.y * u2), ym.scale(this.tileScale.x / s2, this.tileScale.y / s2), _m.prepend(ym), _m.prepend(n2), t2.setContextTransform(_m), i2.fillStyle = this._canvasPattern;
          var c2 = this.anchor.x * -h2, d2 = this.anchor.y * -u2;
          xm[0].set(c2, d2), xm[1].set(c2 + h2, d2), xm[2].set(c2 + h2, d2 + u2), xm[3].set(c2, d2 + u2);
          for (var p2 = 0; p2 < 4; p2++) ym.applyInverse(xm[p2], xm[p2]);
          i2.beginPath(), i2.moveTo(xm[0].x, xm[0].y);
          for (p2 = 1; p2 < 4; p2++) i2.lineTo(xm[p2].x, xm[p2].y);
          i2.closePath(), i2.fill();
        }
      }, /*!
       * @pixi/canvas-particle-container - v6.4.2
       * Compiled Thu, 02 Jun 2022 15:39:26 UTC
       *
       * @pixi/canvas-particle-container is licensed under the MIT License.
       * http://www.opensource.org/licenses/mit-license
       */
      vd.prototype.renderCanvas = function(t2) {
        if (this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable) {
          var e2 = t2.context, i2 = this.worldTransform, n2 = true, r2 = 0, o2 = 0, s2 = 0, a2 = 0;
          t2.setBlendMode(this.blendMode), e2.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
          for (var l2 = 0; l2 < this.children.length; ++l2) {
            var h2 = this.children[l2];
            if (h2.visible && h2._texture.valid) {
              var u2 = h2._texture.frame;
              if (e2.globalAlpha = this.worldAlpha * h2.alpha, h2.rotation % (2 * Math.PI) == 0) n2 && (t2.setContextTransform(i2, false, 1), n2 = false), r2 = h2.anchor.x * (-u2.width * h2.scale.x) + h2.position.x + 0.5, o2 = h2.anchor.y * (-u2.height * h2.scale.y) + h2.position.y + 0.5, s2 = u2.width * h2.scale.x, a2 = u2.height * h2.scale.y;
              else {
                n2 || (n2 = true), h2.displayObjectUpdateTransform();
                var c2 = h2.worldTransform;
                t2.setContextTransform(c2, this.roundPixels, 1), r2 = h2.anchor.x * -u2.width + 0.5, o2 = h2.anchor.y * -u2.height + 0.5, s2 = u2.width, a2 = u2.height;
              }
              var d2 = h2._texture.baseTexture.resolution;
              e2.drawImage(h2._texture.baseTexture.getDrawableSource(), u2.x * d2, u2.y * d2, u2.width * d2, u2.height * d2, r2 * t2.resolution, o2 * t2.resolution, s2 * t2.resolution, a2 * t2.resolution);
            }
          }
        }
      }, /*!
       * @pixi/canvas-display - v6.4.2
       * Compiled Thu, 02 Jun 2022 15:39:26 UTC
       *
       * @pixi/canvas-display is licensed under the MIT License.
       * http://www.opensource.org/licenses/mit-license
       */
      Oh.b.prototype._renderCanvas = function(t2) {
      }, Oh.b.prototype.renderCanvas = function(t2) {
        if (this.visible && !(this.worldAlpha <= 0) && this.renderable) {
          this._mask && t2.maskManager.pushMask(this._mask), this._renderCanvas(t2);
          for (var e2 = 0, i2 = this.children.length; e2 < i2; ++e2) this.children[e2].renderCanvas(t2);
          this._mask && t2.maskManager.popMask(t2);
        }
      }, Oh.c.prototype.renderCanvas = function(t2) {
      }, /*!
       * @pixi/canvas-text - v6.4.2
       * Compiled Thu, 02 Jun 2022 15:39:26 UTC
       *
       * @pixi/canvas-text is licensed under the MIT License.
       * http://www.opensource.org/licenses/mit-license
       */
      cp.prototype._renderCanvas = function(t2) {
        this._autoResolution && this._resolution !== t2.resolution && (this._resolution = t2.resolution, this.dirty = true), this.updateText(true), ep.prototype._renderCanvas.call(this, t2);
      }, /*!
       * pixi.js-legacy - v6.4.2
       * Compiled Thu, 02 Jun 2022 15:39:26 UTC
       *
       * pixi.js-legacy is licensed under the MIT License.
       * http://www.opensource.org/licenses/mit-license
       */
      om.a.registerPlugin("accessibility", Nh), om.a.registerPlugin("extract", pm), om.a.registerPlugin("graphics", lm), om.a.registerPlugin("interaction", zh), om.a.registerPlugin("mesh", sm.a), om.a.registerPlugin("prepare", vm), om.a.registerPlugin("sprite", cm);
      class bm extends Za.a {
        constructor() {
          super(), this.prevTime = -1, this.times = 0, this.valueTotal = 0, this.destroyed = false, this.value = 0, this.calcFps();
        }
        calcFps() {
          requestAnimationFrame((t2) => {
            const e2 = t2 - this.prevTime;
            this.valueTotal += e2, this.times += 1, this.times > 20 && (this.value = Math.floor(1e3 * this.times / this.valueTotal), this.valueTotal = 0, this.times = 0, this.destroyed || this.emit("update", this.value)), this.prevTime = t2, this.destroyed || this.calcFps();
          });
        }
        destroy() {
          this.destroyed = true;
        }
      }
      !function(t2) {
        t2.ResourceError = "RESOURCE_ERROR", t2.RuntimeError = "RUNTIME_ERROR", t2.RuntimeWarn = "RUNTIME_WARN", t2.CanvasCrash = "CANVAS_CRASH";
      }(gm || (gm = {}));
      class Tm extends Error {
        constructor(t2, e2) {
          var i2, n2;
          super(e2), i2 = this, n2 = new.target.prototype, Object.setPrototypeOf ? Object.setPrototypeOf(i2, n2) : i2.__proto__ && (i2.__proto__ = n2), this.errorType = t2, this.errorMsg = e2;
        }
        static transform(t2) {
          return t2 instanceof Tm ? t2 : new Tm(gm.RuntimeError, t2.message);
        }
      }
      function Em() {
        return function(t2, e2, i2) {
          const n2 = i2.value;
          i2.value = function(...t3) {
            try {
              return n2.apply(this, t3);
            } catch (t4) {
              throw new Tm(gm.RuntimeWarn, t4.message);
            }
          };
        };
      }
      var Sm = i(48), wm = i.n(Sm), Am = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      function Mm() {
        return r();
      }
      const Cm = "__delay_resolve_result__";
      function Rm(t2) {
        return new Promise((e2) => {
          setTimeout(() => {
            e2(Cm);
          }, t2);
        });
      }
      function Im(t2, e2) {
        return Am(this, void 0, void 0, function* () {
          const i2 = yield Promise.race([t2(), Rm(e2)]);
          return i2 === Cm ? Cm : i2;
        });
      }
      function Pm(t2, e2) {
        return Am(this, void 0, void 0, function* () {
          const i2 = Date.now();
          for (; !t2() && Date.now() - i2 < e2; ) yield Rm(16);
        });
      }
      var Om = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      function Nm(t2, e2) {
        return Om(this, void 0, void 0, function* () {
          const i2 = yield Im(() => fetch(t2), e2);
          if (i2 === Cm) throw new Tm(gm.ResourceError, `"${t2}" loaded timeout"`);
          if (!i2.ok) throw new Tm(gm.ResourceError, `"${t2}" loaded failed with status "${i2.status}"`);
          return i2;
        });
      }
      class Lm {
        constructor(t2, e2, i2, n2, r2, o2, s2) {
          this.timeout = 15e3, this.useCache = false, this.taskId = "", this.delegate = null, this.urlInterrupter = null, this.useCache = e2, this.localStorage = t2, this.logger = i2, this.tracker = n2, this.timeout = r2, this.delegate = o2 || null, this.urlInterrupter = s2 || null;
        }
        attachTaskId(t2) {
          this.taskId = t2;
        }
        fetchJson(t2) {
          return Om(this, void 0, void 0, function* () {
            const e2 = Date.now();
            let i2 = t2;
            const n2 = t2;
            if (this.urlInterrupter && "function" == typeof this.urlInterrupter) {
              const t3 = Date.now();
              i2 = yield this.urlInterrupter(i2), this.logger.info("use url interrupter, time: " + (Date.now() - t3), this.taskId);
            }
            let r2;
            if (this.useCache && (this.logger.info("load resource from cache. " + n2, this.taskId || ""), r2 = yield this.localStorage.getItem(n2)), r2) return this.logger.info("cache hit. " + n2, this.taskId || ""), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "cache" } }), r2;
            {
              let t3;
              if (this.delegate) {
                this.logger.info("load resource by delegate. " + n2, this.taskId || "");
                const r3 = Date.now();
                try {
                  const o2 = yield Im(() => this.delegate.loadJson(i2), this.timeout);
                  if (this.logger.info(`load resource by delegate end. ${n2}, time: ${Date.now() - r3}`, this.taskId || ""), o2 === Cm) throw new Tm(gm.ResourceError, `"${n2}" loaded timeout"`);
                  t3 = JSON.parse(o2), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "delegate" } });
                } catch (t4) {
                  this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "delegate" } });
                }
              } else {
                this.logger.info("load resource from server. " + n2, this.taskId || "");
                const r3 = Date.now();
                try {
                  t3 = yield (yield Nm("" + i2, this.timeout)).json();
                } catch (t4) {
                  throw this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "fetch" } }), t4;
                }
                this.logger.info(`load resource from server end. ${n2}, time: ${Date.now() - r3}`, this.taskId || ""), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - e2, url: i2, type: "json", channel: "fetch" } });
              }
              return this.logger.info("load end. " + n2, this.taskId || ""), this.useCache && this.localStorage.setItem(n2, t3).catch(() => {
              }), t3;
            }
          });
        }
        fetchPng(t2, e2) {
          return Om(this, void 0, void 0, function* () {
            const i2 = Date.now();
            let n2 = t2;
            const r2 = t2;
            if (this.urlInterrupter && "function" == typeof this.urlInterrupter) {
              const t3 = Date.now();
              n2 = yield this.urlInterrupter(n2), this.logger.info("use url interrupter, time: " + (Date.now() - t3), this.taskId);
            }
            let o2;
            const s2 = r2 + "-v2";
            if (this.useCache && (this.logger.info("load resource from cache. " + r2, this.taskId || ""), o2 = yield this.localStorage.getItem(s2)), o2) {
              const { scale: t3, scaledBase64: e3 } = o2;
              this.logger.info("cache hit. " + r2, this.taskId || "");
              const s3 = new Vh.c(e3, { resolution: 1 });
              return this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "cache" } }), { baseTexture: s3, scale: t3 };
            }
            {
              let t3;
              if (this.delegate) try {
                this.logger.info("load resource by delegate. " + r2, this.taskId || "");
                const e3 = Date.now();
                if (t3 = yield Im(() => this.delegate.loadImage(n2), this.timeout), this.logger.info(`load resource by delegate end. ${r2}, time: ${Date.now() - e3}`, this.taskId || ""), t3 === Cm) throw new Tm(gm.ResourceError, `"${r2}" loaded timeout"`);
                this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "delegate" } });
              } catch (t4) {
                this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "delegate" } });
              }
              else try {
                this.logger.info("load resource from server. " + r2, this.taskId || "");
                const e3 = Date.now(), o3 = yield Nm(n2, this.timeout);
                this.logger.info(`load resource from server end. ${r2}, time: ${Date.now() - e3}`, this.taskId || ""), t3 = yield o3.blob(), this.tracker({ name: "slideResourceLoad", result: "success", reason: "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "fetch" } });
              } catch (t4) {
                this.tracker({ name: "slideResourceLoad", result: "fail", reason: t4 + "", payload: { duration: Date.now() - i2, url: n2, type: "image", channel: "fetch" } });
              }
              o2 = yield function(t4) {
                return new Promise((e3, i3) => {
                  const n3 = new FileReader();
                  n3.onload = () => {
                    e3(n3.result);
                  }, n3.onerror = () => {
                    i3(new Tm(gm.ResourceError, "Failed parse blob data."));
                  }, n3.readAsDataURL(t4);
                });
              }(t3);
              const a2 = document.createElement("img");
              a2.src = o2, yield new Promise((t4, e3) => {
                a2.onload = () => t4(""), a2.onerror = () => e3(new Error("load sprite image failed"));
              });
              let l2 = e2;
              const h2 = a2.width || 1, u2 = a2.height || 1, c2 = 2048, d2 = 2048;
              if (h2 > c2 || u2 > d2) {
                l2 *= c2 / h2;
                const t4 = l2 * u2;
                t4 > d2 && (l2 *= u2 / t4);
              }
              const p2 = document.createElement("canvas"), f2 = Math.ceil(a2.width * l2), m2 = Math.ceil(a2.height * l2);
              p2.width = f2, p2.height = m2;
              p2.getContext("2d").drawImage(a2, 0, 0, f2, m2);
              const g2 = p2.toDataURL("image/png"), v2 = new Vh.c(g2, { resolution: 1 });
              return this.logger.info("load end. " + r2, this.taskId || ""), this.useCache && this.localStorage.setItem(s2, { scale: l2, scaledBase64: g2 }).catch(() => {
              }), { baseTexture: v2, scale: l2 };
            }
          });
        }
        destroy() {
        }
      }
      var Dm = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Fm {
        constructor(t2) {
          this.isPaused = false, this.timestamp = 0, this.callbackList = [], this.onTimeUpdate = (t3) => {
            const e2 = t3 / (xd.b.TARGET_FPMS || 0.06);
            if (!this.isPaused) {
              this.timestamp += e2, this.callbackList = this.callbackList.filter((t5) => t5 && !t5.applied);
              let { length: t4 } = this.callbackList;
              for (let e3 = 0; e3 < t4; e3++) {
                const i2 = this.callbackList[e3];
                if (i2 && !i2.applied) {
                  if (!(i2.triggerTime <= this.timestamp)) break;
                  i2.running = true, i2.fn(), i2.applied = true, t4 = this.callbackList.length;
                }
              }
            }
          }, this.ticker = t2, this.ticker.add(this.onTimeUpdate);
        }
        setTimeout(t2, e2) {
          const i2 = Mm(), n2 = this.timestamp + Math.max(e2 || 16, 16);
          return this.callbackList.push({ fn: t2, triggerTime: n2, id: i2, applied: false, running: false }), this.callbackList.sort((t3, e3) => t3.triggerTime - e3.triggerTime), i2;
        }
        clearTimeout(t2) {
          const e2 = this.callbackList.findIndex((e3) => e3.id === t2);
          e2 >= 0 && !this.callbackList[e2].running && this.callbackList.splice(e2, 1);
        }
        delay(t2) {
          return new Promise((e2) => {
            this.setTimeout(e2, t2);
          });
        }
        waitUntil(t2, e2) {
          return Dm(this, void 0, void 0, function* () {
            const i2 = this.timestamp;
            for (; !t2() && this.timestamp - i2 < e2; ) yield this.delay(50);
          });
        }
        pause() {
          this.isPaused = true;
        }
        resume() {
          this.isPaused = false;
        }
      }
      var Bm = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      function Um(t2, e2, i2) {
        return i2 ? Math.floor(parseFloat(t2) * e2) : Math.ceil(parseFloat(t2) * e2);
      }
      const km = { w: false, h: false, x: true, y: true };
      class Gm {
        constructor(t2) {
          this.gifs = /* @__PURE__ */ Object.create(null), this.textures = /* @__PURE__ */ Object.create(null), this.frames = /* @__PURE__ */ Object.create(null), this.spriteSheets = [], this.loader = t2;
        }
        getTexture(t2) {
          return this.textures[t2] || null;
        }
        getFrameData(t2) {
          return this.frames[t2];
        }
        getGifFrames(t2) {
          return this.gifs[t2] ? this.gifs[t2].filter((t3) => !!t3) : [];
        }
        loadSpriteSheetItem(t2, e2, i2, n2) {
          return Bm(this, void 0, void 0, function* () {
            const r2 = yield this.loader.fetchJson(`${t2}/${e2}/jsonOutput/${i2}.json`), { baseTexture: o2, scale: s2 } = yield this.loader.fetchPng(`${t2}/${e2}/jsonOutput/${i2}.png`, n2);
            !function(t3, e3) {
              t3.meta && t3.meta.size && ["w", "h"].forEach((i3) => {
                t3.meta.size[i3] = Um(t3.meta.size[i3], e3, km[i3]);
              }), t3.frames && Object.keys(t3.frames).forEach((i3) => {
                t3.frames[i3].frame && ["x", "y", "w", "h"].forEach((n3) => {
                  t3.frames[i3].frame[n3] = Um(t3.frames[i3].frame[n3], e3, km[n3]);
                }), t3.frames[i3].spriteSourceSize && ["x", "y", "w", "h"].forEach((n3) => {
                  t3.frames[i3].spriteSourceSize[n3] = Um(t3.frames[i3].spriteSourceSize[n3], e3, km[n3]);
                }), t3.frames[i3].sourceSize && ["w", "h"].forEach((n3) => {
                  t3.frames[i3].sourceSize[n3] = Um(t3.frames[i3].sourceSize[n3], e3, km[n3]);
                });
              });
            }(r2, s2);
            const a2 = new Ap(o2, r2);
            yield new Promise((t3) => {
              a2.parse(() => t3(""));
            }), this.spriteSheets.push(a2), Object.keys(a2.textures).forEach((t3) => {
              const e3 = t3.match(/^(.+)_gif_(\d+)$/);
              if (e3 && e3[1] && e3[2]) {
                const i3 = e3[1];
                this.gifs[i3] || (this.gifs[i3] = []);
                const n3 = parseInt(e3[2], 10);
                this.gifs[i3][n3] = a2.textures[t3];
              } else this.frames[t3] = r2.frames[t3], this.textures[t3] = a2.textures[t3];
            });
          });
        }
        destroy() {
          this.spriteSheets.forEach((t2) => t2.destroy(true)), this.spriteSheets = [], this.gifs = /* @__PURE__ */ Object.create(null), this.textures = /* @__PURE__ */ Object.create(null), this.frames = /* @__PURE__ */ Object.create(null);
        }
      }
      var Hm = i(18), jm = i.n(Hm), zm = i(13), Vm = i.n(zm);
      function Xm(t2, e2, i2) {
        let n2, r2;
        const o2 = Math.round(t2) % 360;
        if (o2 % 180 == 0) n2 = Math.cos(o2 * (Math.PI / 180)) * e2, r2 = 0;
        else if (o2 % 90 == 0) n2 = 0, r2 = Math.sin(o2 * (Math.PI / 180)) * i2;
        else {
          const t3 = function(t4) {
            const e3 = t4 * Math.PI / 180;
            return Math.tan(e3);
          }(o2);
          n2 = e2 * i2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(e2 * t3, 2)), (o2 > 90 && o2 < 270 || o2 < -90 && o2 > -270) && (n2 = -n2), r2 = t3 * n2;
        }
        return { x: n2, y: r2 };
      }
      function Wm(t2, e2, i2, n2, r2, o2) {
        const s2 = t2, a2 = e2;
        let l2, h2, u2, c2, d2;
        if (0 === Math.round(n2)) l2 = r2, h2 = o2, d2 = 0;
        else if (Math.round(n2) >= 360) l2 = r2, h2 = o2, u2 = r2 + 2 * t2 * Math.abs(Math.cos(-i2 / 180 * Math.PI)), c2 = o2 + 2 * e2 * Math.sin(-i2 / 180 * Math.PI), d2 = 1;
        else {
          const t3 = -i2, e3 = -(i2 + n2), { x: u3, y: c3 } = Xm(t3, s2, a2), p2 = r2 - u3, f2 = o2 + c3, { x: m2, y: g2 } = Xm(e3, s2, a2);
          l2 = m2 + p2, h2 = f2 - g2, d2 = n2 >= -360 && n2 < -180 ? 1 : n2 >= -180 && n2 < 0 || n2 > 0 && n2 < 180 ? 0 : 1;
        }
        return { radiusX: s2, radiusY: a2, xAxisRotation: 0, largeArcFlag: d2, sweepFlag: n2 > 0 ? 1 : 0, endX: l2, endY: h2, middleX: u2, middleY: c2 };
      }
      class Ym {
        constructor() {
          this.pool = [];
        }
        getObject(t2) {
          const e2 = this.pool.find((t3) => !t3.isUsed);
          if (e2) return e2.isUsed = true, e2.obj;
          {
            const e3 = { obj: this.createObject(), isUsed: true, group: t2 };
            return this.pool.push(e3), e3.obj;
          }
        }
        collectObject(t2) {
          const e2 = this.pool.find((e3) => e3.obj === t2);
          e2 && (e2.isUsed = false, this.resetObject(e2.obj));
        }
        collectObjectByGroup(t2) {
          this.pool.filter((e2) => e2.group === t2).forEach((t3) => this.collectObject(t3.obj));
        }
      }
      const qm = new class extends Ym {
        createObject() {
          const t2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          return t2.setAttribute("xmlns", "http://www.w3.org/2000/svg"), t2.setAttribute("version", "1.1"), t2;
        }
        resetObject(t2) {
          t2.removeAttribute("viewBox"), t2.removeAttribute("width"), t2.removeAttribute("height"), t2.innerHTML = "";
        }
      }();
      const Zm = new class extends Ym {
        createObject() {
          return document.createElement("img");
        }
        resetObject(t2) {
          t2.removeAttribute("src");
        }
      }();
      var Jm = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Km {
        constructor(t2) {
          this.imgElements = [], this.svgElements = [], this.idToHashMap = /* @__PURE__ */ Object.create(null), this.textures = /* @__PURE__ */ Object.create(null), this.graphics = [], this.hashToIdMap = /* @__PURE__ */ Object.create(null), this.maxResolution = t2;
        }
        render(t2, e2, i2, n2) {
          return Jm(this, void 0, void 0, function* () {
            const { items: e3, width: r2, height: o2 } = t2, s2 = Zm.getObject(i2), a2 = new Vh.c(s2, { width: r2 * n2, height: o2 * n2, resolution: 1 }), l2 = qm.getObject(i2);
            this.imgElements.push(s2), this.svgElements.push(l2), l2.setAttribute("viewBox", `0 0 ${r2} ${o2}`), l2.setAttribute("width", "" + r2), l2.setAttribute("height", "" + o2);
            const h2 = {};
            e3.forEach((t3) => {
              const { item: e4, x: i3, y: r3 } = t3, o3 = i3 + 2, s3 = r3 + 2;
              e4.pathsData.forEach((t4) => {
                let e5 = "";
                t4.cmds.forEach(([i4, n3]) => {
                  e5 += i4 + " ", e5 += n3.map((e6) => (Vm()(e6) || (e6.x = e6.x + t4.offset.x + o3, e6.y = e6.y + t4.offset.y + s3), e6)).reduce((t5, e6) => (Vm()(e6) ? t5 += e6 + " " : t5 += `${e6.x} ${e6.y} `, t5), ""), e5 += " ";
                }), t4.pathElement.setAttribute("d", e5), l2.appendChild(t4.pathElement);
              });
              const u3 = e4.width - 4 - 2 * e4.padding, c3 = e4.height - 4 - 2 * e4.padding;
              this.textures[e4.hash] = { texture: new Vh.t(a2, new Lh.j((o3 + 2) * n2, (s3 + 2) * n2, u3 * n2, c3 * n2)), pivot: e4.pivot, scale: 1 / n2 }, h2[e4.hash] = this.hashToIdMap[e4.hash];
            });
            const u2 = (c2 = '<?xml version="1.0" encoding="utf-8"?>' + l2.outerHTML, "data:image/svg+xml," + encodeURIComponent(c2).replace(/'/g, "%27").replace(/"/g, "%22"));
            var c2;
            const d2 = document.createElement("img");
            d2.src = u2, yield new Promise((t3, e4) => {
              d2.onload = () => t3(""), d2.onerror = () => e4();
            });
            const p2 = document.createElement("canvas");
            p2.width = d2.width * n2, p2.height = d2.height * n2;
            p2.getContext("2d").drawImage(d2, 0, 0, p2.width, p2.height), s2.src = p2.toDataURL("image/png"), yield new Promise((t3, e4) => {
              s2.onload = () => t3(""), s2.onerror = () => e4();
            });
          });
        }
        getGraphicsData(t2) {
          const e2 = this.idToHashMap[t2] || "";
          return this.textures[e2] || null;
        }
        addGraphics(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2) {
          var c2, d2;
          if (!s2 && !l2) return t2;
          const p2 = jm()(i2 + (null !== (d2 = null === (c2 = null == s2 ? void 0 : s2.width) || void 0 === c2 ? void 0 : c2.toString()) && void 0 !== d2 ? d2 : 0) + l2 + h2 + u2);
          if (this.hashToIdMap[p2] || (this.hashToIdMap[p2] = []), this.hashToIdMap[p2].push(t2), this.idToHashMap[t2] = p2, this.graphics.findIndex((t3) => t3.hash === p2) < 0) {
            const { graphicsWidth: t3, graphicsHeight: i3, pathsData: a3, pivot: c3, padding: d3 } = function(t4, e3, i4, n3, r3, o3, s3, a4, l3) {
              var h3;
              const u3 = [], c4 = { x: Math.abs(r3.x), y: Math.abs(r3.y) };
              let d4 = 0, p3 = 0, f2 = 0, m2 = 0, g2 = 0, v2 = "none";
              const _2 = null !== (h3 = null == n3 ? void 0 : n3.width) && void 0 !== h3 ? h3 : 0;
              return s3 ? (d4 = e3, p3 = i4, g2 = 0) : (v2 = l3 || "#ff0000", g2 = _2, f2 = 0.5 * _2, m2 = 0.5 * _2, d4 = e3 + _2, p3 = i4 + _2, c4.x += 0.5 * _2, c4.y += 0.5 * _2), d4 += Math.abs(r3.x), p3 += Math.abs(r3.y), f2 += Math.abs(r3.x), m2 += Math.abs(r3.y), d4 += 4, p3 += 4, f2 += 2, m2 += 2, d4 = Math.ceil(d4), p3 = Math.ceil(p3), t4.forEach((t5) => {
                const e4 = document.createElementNS("http://www.w3.org/2000/svg", "path");
                "none" !== t5.fill && s3 ? e4.setAttribute("fill", a4 || "#ff0000") : e4.setAttribute("fill", "none"), t5.hasStroke && !s3 && (e4.setAttribute("stroke-linecap", (null == n3 ? void 0 : n3.cap) || "butt"), e4.setAttribute("stroke-linejoin", (null == n3 ? void 0 : n3.join) || "miter"), e4.setAttribute("stroke-width", g2.toString()), e4.setAttribute("stroke", v2), (null == n3 ? void 0 : n3.dash) && e4.setAttribute("stroke-dasharray", n3.dash));
                const { scale: i5 } = t5, r4 = t5.path.trim().split(" ");
                let o4 = { x: 0, y: 0 };
                const l4 = { offset: { x: f2, y: m2 }, cmds: [], pathElement: e4 };
                for (let t6 = 0; t6 < r4.length; t6 += 2) {
                  const e5 = r4[t6], n4 = r4[t6 + 1];
                  if ("M" === e5) {
                    let [t7, e6] = n4.split(",").map((t8) => Number(t8));
                    o4 = { x: t7, y: e6 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, l4.cmds.push(["M", [{ x: t7, y: e6 }]]);
                  } else if ("A" === e5) {
                    const [t7, e6, r5, s4] = n4.split(",").map((t8) => Number(t8)), a5 = r5 / Math.PI * 180, h4 = s4 / Math.PI * 180, u4 = Wm(t7, e6, a5, h4, o4.x, o4.y);
                    Math.round(h4) >= 360 ? (o4 = { x: u4.endX, y: u4.endY }, l4.cmds.push(["A", [u4.radiusX / 9525 * i5.x, u4.radiusY / 9525 * i5.y, u4.xAxisRotation, u4.largeArcFlag, u4.sweepFlag, { x: u4.middleX / 9525 * i5.x, y: u4.middleY / 9525 * i5.y }]]), l4.cmds.push(["A", [u4.radiusX / 9525 * i5.x, u4.radiusY / 9525 * i5.y, u4.xAxisRotation, u4.largeArcFlag, u4.sweepFlag, { x: u4.endX / 9525 * i5.x, y: u4.endY / 9525 * i5.y }]])) : (o4 = { x: u4.endX, y: u4.endY }, l4.cmds.push(["A", [u4.radiusX / 9525 * i5.x, u4.radiusY / 9525 * i5.y, u4.xAxisRotation, u4.largeArcFlag, u4.sweepFlag, { x: u4.endX / 9525 * i5.x, y: u4.endY / 9525 * i5.y }]]));
                  } else if ("L" === e5) {
                    let [t7, e6] = n4.split(",").map((t8) => Number(t8));
                    o4 = { x: t7, y: e6 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, l4.cmds.push(["L", [{ x: t7, y: e6 }]]);
                  } else if ("QB" === e5) {
                    let [t7, e6, r5, s4] = n4.split(",").map((t8) => Number(t8));
                    o4 = { x: r5, y: s4 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, r5 = r5 / 9525 * i5.x, s4 = s4 / 9525 * i5.y, l4.cmds.push(["Q", [{ x: t7, y: e6 }, { x: r5, y: s4 }]]);
                  } else if ("CB" === e5) {
                    let [t7, e6, r5, s4, a5, h4] = n4.split(",").map((t8) => Number(t8));
                    o4 = { x: a5, y: h4 }, t7 = t7 / 9525 * i5.x, e6 = e6 / 9525 * i5.y, r5 = r5 / 9525 * i5.x, s4 = s4 / 9525 * i5.y, a5 = a5 / 9525 * i5.x, h4 = h4 / 9525 * i5.y, l4.cmds.push(["C", [{ x: t7, y: e6 }, { x: r5, y: s4 }, { x: a5, y: h4 }]]);
                  } else "C" === e5 && l4.cmds.push(["Z", []]);
                }
                u3.push(l4);
              }), { graphicsWidth: d4, graphicsHeight: p3, pivot: c4, padding: 2, pathsData: u3 };
            }(e2, r2, o2, s2, n2, 0, l2, h2, u2);
            this.graphics.push({ hash: p2, pathsData: a3, pivot: c3, width: t3, height: i3, padding: d3 });
          }
          return t2;
        }
        pack() {
          this.graphics.forEach((t2) => {
            t2.width += 4, t2.height += 4;
          });
          return function t2(e2) {
            const i2 = [], n2 = e2.filter((t3) => {
              const e3 = t3.width < 2048 && t3.height < 2048;
              return e3 || i2.push(t3), e3;
            }).sort((t3, e3) => t3.width * t3.height - e3.width * e3.height);
            let r2 = n2.length + 1, o2 = 2050, s2 = 2050;
            const a2 = [];
            let l2 = null;
            for (; (o2 > 2048 || s2 > 2048) && n2.length > 0; ) r2 -= 1, l2 = wm()(n2.slice(0, r2)), o2 = l2.width, s2 = l2.height;
            return l2 && a2.push(l2), i2.forEach((t3) => {
              const e3 = wm()([t3]);
              a2.push(e3);
            }), r2 < n2.length ? a2.concat(t2(n2.slice(r2))) : a2;
          }(this.graphics);
        }
        destroy() {
          Object.keys(this.textures).forEach((t2) => {
            var e2;
            null === (e2 = this.textures[t2]) || void 0 === e2 || e2.texture.destroy(true);
          }), this.textures = /* @__PURE__ */ Object.create(null), this.imgElements.forEach((t2) => Zm.collectObject(t2)), this.svgElements.forEach((t2) => qm.collectObject(t2)), this.graphics = [];
        }
      }
      class Qm {
        constructor() {
          this.runningTimeNodes = {};
        }
        addRunningTimeNode(t2, e2, i2) {
          const n2 = `${e2}_${t2}`;
          if (this.runningTimeNodes[n2]) try {
            this.runningTimeNodes[n2].dispose(true);
          } catch (t3) {
          }
          this.runningTimeNodes[n2] = i2;
        }
        removeRunningTimeNode(t2, e2) {
          const i2 = `${e2}_${t2}`;
          delete this.runningTimeNodes[i2];
        }
      }
      class $m {
        constructor(t2) {
          this.eventHub = t2, this.targets = /* @__PURE__ */ Object.create(null);
        }
        getTargets() {
          return Object.keys(this.targets).map((t2) => this.targets[t2]);
        }
        addTarget(t2, e2) {
          this.targets[t2] = e2;
        }
        getTargetById(t2) {
          return this.targets[t2];
        }
        getTarget(t2, e2, i2 = { type: "el", index: 0, id: "" }) {
          var n2, r2;
          let o2 = this.targets[t2.id];
          return "shape" !== t2.type ? o2 : ("shape" === t2.type && t2.txEl && (o2 = null !== (n2 = null == o2 ? void 0 : o2.getTextElement(t2.txEl.type, t2.txEl.range)) && void 0 !== n2 ? n2 : null), "shape" === t2.type && t2.bg && 0 === i2.index && (e2 = false, o2 = null !== (r2 = null == o2 ? void 0 : o2.getBgElement()) && void 0 !== r2 ? r2 : null, this.eventHub.emit("IterateTimeNodeEnd", i2.id)), e2 && o2 ? o2.getIterateEntry(i2.type, i2.index, i2.id) : (o2 || this.eventHub.emit("IterateTimeNodeEnd", i2.id), o2));
        }
        clearTargets() {
          this.targets = /* @__PURE__ */ Object.create(null);
        }
      }
      class tg {
        constructor(t2) {
          this.target = t2;
        }
        get color() {
          return this.target.strokeColorFilter.currentColor;
        }
        set color(t2) {
          this.target.strokeColorFilter.color = t2;
        }
        get on() {
          return this.target.strokeActive ? "true" : "false";
        }
        set on(t2) {
          this.target.strokeActive = "true" === t2;
        }
      }
      class eg {
        constructor(t2) {
          this.applyCommand = (t3, e2) => {
            this.target.applyCommand(t3, e2);
          }, this.target = t2;
        }
      }
      class ig {
        constructor(t2) {
          this.target = t2;
        }
        get color() {
          return this.target.pptColorFilter.currentColor;
        }
        set color(t2) {
          this.target.pptColorActive && (this.target.pptColorFilter.color = t2);
        }
        get on() {
          return this.target.pptColorActive ? "true" : "false";
        }
        set on(t2) {
          this.target.pptColorActive = "true" === t2;
        }
        get designColor() {
          return this.target.pptColorFilter.designColor;
        }
        toString() {
          return this.color;
        }
      }
      class ng {
        constructor(t2) {
          this.target = t2;
        }
        get color() {
          return this.target.fillColorFilter.currentColor;
        }
        set color(t2) {
          this.target.fillActive && (this.target.fillColorFilter.color = t2);
        }
        get on() {
          return this.target.fillActive ? "true" : "false";
        }
        set on(t2) {
          this.target.fillActive = "true" === t2;
        }
        get designColor() {
          return this.target.fillColorFilter.designColor;
        }
      }
      class rg {
        constructor(t2, e2, i2) {
          this.hardHidden = false, this.designRotation = 0, this.target = t2, true === e2 && (this.hardHidden = true), this.designRotation = i2;
        }
        get opacity() {
          return this.target.alpha;
        }
        set opacity(t2) {
          this.target.alpha = t2;
        }
        get rotation() {
          return this.target.rotation / Math.PI * 180;
        }
        set rotation(t2) {
          this.target.rotation = t2 / 180 * Math.PI + this.designRotation;
        }
        get visibility() {
          return this.target.visible ? "visible" : "hidden";
        }
        set visibility(t2) {
          this.visibility === t2 || this.hardHidden || (this.target.visible = "visible" === t2);
        }
      }
      class og {
        constructor(t2, e2) {
          this.actions = [], this.ctx = e2, this.object = t2, this.object.interactive = true;
        }
        reset(t2) {
          this.object.interactive = false, this.object.removeAllListeners(), this.object = t2, this.object.interactive = true;
        }
        addAction(t2, e2) {
          this.actions.push([t2, e2]), "click" === e2 ? (this.object.addListener("pointertap", () => this.handleAction(t2)), this.object.cursor = "pointer") : "hover" === e2 && this.object.addListener("mouseover", () => this.handleAction(t2));
        }
        getOriginHitArea() {
          return this.object.hitArea ? this.object.hitArea : new Lh.k(0, 0, this.object.width, this.object.height);
        }
        handleAction(t2) {
          this.ctx.eventHub.emit(zy.hyperlinkTrigger, t2), this.execAction(t2);
        }
        execAction(t2) {
          var e2, i2;
          if (this.ctx.eventHub.emit(zy.userInput), "ppaction://hlinksldjump" === t2.action) {
            const i3 = (null !== (e2 = null == t2 ? void 0 : t2.target) && void 0 !== e2 ? e2 : "").match(/slide(\d+)\.xml/);
            i3 && i3[1] && this.ctx.eventHub.emit(zy.requestGotoSlide, Number(i3[1]));
          } else if ("ppaction://hlinkshowjump?jump=nextslide" === t2.action) this.ctx.eventHub.emit(zy.requestNextSlide);
          else if ("ppaction://hlinkshowjump?jump=previousslide" === t2.action) this.ctx.eventHub.emit(zy.requestPrevSlide);
          else if ("ppaction://hlinkshowjump?jump=firstslide" === t2.action) this.ctx.eventHub.emit(zy.requestGotoSlide, 1);
          else if ("ppaction://hlinkshowjump?jump=lastslide" === t2.action) this.ctx.eventHub.emit(zy.requestGotoSlide, -1);
          else if ("ppaction://hlinkshowjump?jump=lastslideviewed" === t2.action) {
            const t3 = this.ctx.lastViewedIndex;
            this.ctx.eventHub.emit(zy.requestGotoSlide, t3);
          } else "ppaction://hlinkshowjump?jump=endshow" === t2.action ? this.ctx.eventHub.emit(zy.requestGotoSlide, -1) : "" === t2.action && (null === (i2 = t2.target) || void 0 === i2 ? void 0 : i2.startsWith("http")) && this.ctx.eventHub.emit(zy.requestOpenUrl, t2.target);
        }
      }
      function sg(t2, e2, i2 = 5) {
        return Math.abs(t2 - e2) <= Math.pow(10, -i2);
      }
      function ag(t2) {
        return Math.floor(1e6 * t2) / 1e6;
      }
      class lg {
        constructor() {
          this.point = { x: 0, y: 0 }, this.slope = Math.PI / 4;
        }
        static fromPointSlope(t2, e2) {
          const i2 = new lg();
          return i2.point = t2, i2.slope = e2, i2;
        }
        resolveY(t2) {
          return Math.tan(this.slope) * (t2 - this.point.x) + this.point.y;
        }
        distanceToLinearEquation(t2) {
          return sg(this.slope, t2.slope) ? this.distanceToPoint(t2.point) : -1;
        }
        distanceToPoint(t2) {
          let e2 = 0;
          if (Math.tan(this.slope) * (t2.x - this.point.x) + this.point.y === t2.y) return 0;
          e2 = this.slope >= Math.PI / 2 ? this.slope - Math.PI / 2 : Math.PI / 2 + this.slope;
          const i2 = lg.fromPointSlope(t2, e2), n2 = this.crossPoint(i2);
          return n2 ? Math.ceil(Math.sqrt(Math.pow(n2.x - t2.x, 2) + Math.pow(n2.y - t2.y, 2))) : 0;
        }
        crossPoint(t2) {
          if (sg(t2.slope, this.slope)) return null;
          let e2 = 0, i2 = 0;
          const n2 = Math.tan(t2.slope), r2 = Math.tan(this.slope), { x: o2, y: s2 } = this.point, { x: a2, y: l2 } = t2.point;
          return sg(this.slope, Math.PI / 2) ? (e2 = this.point.x, i2 = n2 * (e2 - a2) + l2) : sg(t2.slope, Math.PI / 2) ? (e2 = t2.point.x, i2 = r2 * (e2 - o2) + s2) : sg(this.slope, Math.PI) || sg(this.slope, 0) ? (i2 = this.point.y, e2 = (i2 - l2) / n2 + a2) : sg(t2.slope, Math.PI) || sg(t2.slope, 0) ? (i2 = t2.point.y, e2 = (i2 - s2) / r2 + o2) : (e2 = (n2 * a2 - l2 + s2 - r2 * o2) / (n2 - r2), i2 = r2 * (e2 - o2) + s2), { x: e2, y: i2 };
        }
      }
      class hg {
        constructor(t2, e2, i2) {
          var n2, r2, o2, s2, a2, l2;
          this.scaleExt = { x: 1, y: 1 }, this.scaleOrigin = { x: 1, y: 1 }, this.designScale = { x: 1, y: 1 }, this.bound = new Lh.j(0, 0, 1, 1), this.pptX = 0, this.pptY = 0, this.presetSubType = 0, this.designWidth = 0, this.designHeight = 0, this.designX = 0, this.designY = 0, this.hasPreset = false, this.container = new Oh.b(), this.ctx = e2, this.style = new rg(this.container, !!t2.hardHidden, t2.rotation || 0), this.designGlobalPosition = { x: i2.parentGlobalPos.x + (null !== (r2 = null === (n2 = t2.position) || void 0 === n2 ? void 0 : n2.x) && void 0 !== r2 ? r2 : 0), y: i2.parentGlobalPos.y + (null !== (s2 = null === (o2 = t2.position) || void 0 === o2 ? void 0 : o2.y) && void 0 !== s2 ? s2 : 0) }, (t2.hlinkClick || t2.hlinkHover) && (this.hyperlink = new og(this.container, this.ctx), t2.hlinkHover && (null === (a2 = this.hyperlink) || void 0 === a2 || a2.addAction(t2.hlinkHover, "hover")), t2.hlinkClick && (null === (l2 = this.hyperlink) || void 0 === l2 || l2.addAction(t2.hlinkClick, "click"))), this.ctx.clock.waitUntil(() => {
            try {
              return !!this.container.width;
            } catch (t3) {
              return false;
            }
          }, 3e3).then(() => {
            try {
              this.designWidth = this.designWidth || this.container.width;
            } catch (t3) {
            }
          }), this.ctx.clock.waitUntil(() => {
            try {
              return !!this.container.height;
            } catch (t3) {
              return false;
            }
          }, 3e3).then(() => {
            try {
              this.designHeight = this.designHeight || this.container.height;
            } catch (t3) {
            }
          });
        }
        updateScale() {
          this.container && (this.container.scale.x = this.designScale.x * this.scaleExt.x * this.scaleOrigin.x, this.container.scale.y = this.designScale.y * this.scaleExt.y * this.scaleOrigin.y);
        }
        updateTransform(t2) {
          var e2, i2, n2, r2, o2, s2, a2, l2;
          this.designWidth = t2.width, this.designHeight = t2.height, this.designX = null !== (i2 = null === (e2 = t2.position) || void 0 === e2 ? void 0 : e2.x) && void 0 !== i2 ? i2 : 0, this.designY = null !== (r2 = null === (n2 = t2.position) || void 0 === n2 ? void 0 : n2.y) && void 0 !== r2 ? r2 : 0;
          const h2 = this.designWidth / 2, u2 = this.designHeight / 2;
          this.container.width = this.designWidth, this.container.height = this.designHeight, this.container.pivot.x = h2, this.container.pivot.y = u2;
          const c2 = null !== (s2 = null === (o2 = t2.position) || void 0 === o2 ? void 0 : o2.x) && void 0 !== s2 ? s2 : 0, d2 = null !== (l2 = null === (a2 = t2.position) || void 0 === a2 ? void 0 : a2.y) && void 0 !== l2 ? l2 : 0;
          this.container.x = c2 + h2, this.container.y = d2 + u2, t2.scale && (this.designScale = { x: t2.scale.x, y: t2.scale.y }, this.container.scale.x = t2.scale.x, this.container.scale.y = t2.scale.y), t2.rotation && (this.container.rotation = t2.rotation);
          const p2 = new Jd();
          p2.drawRect(0, 0, this.designWidth, this.designHeight), this.container.addChild(p2), this.json.hardHidden && (this.container.visible = false), this.bound.x = c2, this.bound.y = d2, this.bound.width = this.designWidth, this.bound.height = this.designHeight;
        }
        get scale() {
          return this.scaleOrigin;
        }
        set scale(t2) {
          this.scaleOrigin.x = t2.x, this.scaleOrigin.y = t2.y, this.updateScale();
        }
        get design_ppt_w() {
          return ag(this.designWidth / this.ctx.stageWidth);
        }
        get design_ppt_h() {
          return ag((this.designHeight || this.container.height) / this.ctx.stageHeight);
        }
        get design_ppt_x() {
          return ag(this.designX / this.ctx.stageWidth);
        }
        get design_ppt_y() {
          return ag(this.designY / this.ctx.stageHeight);
        }
        get ppt_w() {
          return this.scaleExt.x * this.scaleOrigin.x * this.designWidth / this.ctx.stageWidth;
        }
        set ppt_w(t2) {
          this.designWidth && (this.scaleExt.x = t2 * this.ctx.stageWidth / this.designWidth, this.updateScale());
        }
        get ppt_h() {
          const t2 = this.designHeight || this.container.height;
          return this.scaleExt.y * this.scaleOrigin.y * t2 / this.ctx.stageHeight;
        }
        set ppt_h(t2) {
          this.designHeight && (this.scaleExt.y = t2 * this.ctx.stageHeight / this.designHeight, this.updateScale());
        }
        get ppt_x() {
          return (this.container.position.x - this.container.pivot.x) / this.ctx.stageWidth;
        }
        set ppt_x(t2) {
          this.pptX = t2;
          const e2 = 544 === this.presetSubType ? this.scaleExt.x : 1;
          this.container.position.x = t2 * this.ctx.stageWidth + this.container.pivot.x * e2;
        }
        get ppt_y() {
          return (this.container.position.y - this.container.pivot.y) / this.ctx.stageHeight;
        }
        set ppt_y(t2) {
          this.pptY = t2;
          const e2 = 544 === this.presetSubType ? this.scaleExt.y : 1;
          this.container.position.y = t2 * this.ctx.stageHeight + this.container.pivot.y * e2;
        }
        get r() {
          return this.container.rotation;
        }
        set r(t2) {
          this.container.rotation = t2;
        }
        set xshear(t2) {
          this.container.skew.x = t2;
        }
        get xshear() {
          return this.container.skew.x;
        }
        set yshear(t2) {
          this.container.skew.y = t2;
        }
        get yshear() {
          return this.container.skew.y;
        }
      }
      var ug = i(112), cg = i.n(ug);
      class dg {
        constructor(t2) {
          if (this._isInit = false, this.h = 0, this.s = 0, this.l = 0, this.a = 1, t2) {
            this._isInit = true;
            const e2 = t2.match(/-?[0-9]+/g);
            e2 && (this.h = parseInt(e2[0], 10), this.s = parseInt(e2[1], 10) / 100, this.l = parseInt(e2[2], 10) / 100);
          }
        }
        isInit() {
          return this._isInit;
        }
        by(t2, e2) {
          e2.h = Math.max(Math.min(this.h + t2.h, 359), 0), e2.s = Math.max(Math.min(this.s + t2.s, 1), 0), e2.l = Math.max(Math.min(this.l + t2.l, 1), 0), e2.a = Math.max(Math.min(this.a + t2.a, 1), 0);
        }
        fromHexString(t2) {
          const [e2, i2, n2, r2] = mg(t2);
          let o2 = 0, s2 = 0, a2 = 0;
          const l2 = Math.max(e2, i2, n2), h2 = Math.min(e2, i2, n2), u2 = l2 - h2;
          a2 = (l2 + h2) / 2, 0 === u2 ? o2 = 0 : l2 === e2 ? o2 = (i2 - n2) / u2 % 6 * 60 : l2 === i2 ? o2 = 60 * ((n2 - e2) / u2 + 2) : l2 === n2 && (o2 = 60 * ((e2 - i2) / u2 + 4)), s2 = 0 === u2 ? 0 : u2 / (1 - Math.abs(2 * a2 - 1)), this.h = o2, this.s = s2, this.l = a2, this.a = r2;
        }
        interpolationFrom(t2, e2, i2) {
          const n2 = t2.h + (this.h - t2.h) * e2, r2 = t2.s + (this.s - t2.s) * e2, o2 = t2.l + (this.l - t2.l) * e2, s2 = t2.a + (this.a - t2.a) * e2;
          i2.h = Math.max(Math.min(n2, 359), 0), i2.s = Math.max(Math.min(r2, 1), 0), i2.l = Math.max(Math.min(o2, 1), 0), i2.a = Math.max(Math.min(s2, 1), 0);
        }
        toHexString() {
          let t2 = [0, 0, 0, 0];
          const { h: e2, s: i2, l: n2 } = this;
          if (e2 < 360 && e2 >= 0 && i2 <= 1 && i2 >= 0 && n2 <= 1 && n2 >= 0) {
            let r2, o2, s2;
            const a2 = (1 - Math.abs(2 * n2 - 1)) * i2, l2 = a2 * (1 - Math.abs(e2 / 60 % 2 - 1)), h2 = n2 - a2 / 2;
            [r2, o2, s2] = e2 >= 0 && e2 < 60 ? [a2, l2, 0] : e2 >= 60 && e2 < 120 ? [l2, a2, 0] : e2 >= 120 && e2 < 180 ? [0, a2, l2] : e2 >= 180 && e2 < 240 ? [0, l2, a2] : e2 >= 240 && e2 < 300 ? [l2, 0, a2] : [a2, 0, l2], t2 = [r2 + h2, o2 + h2, s2 + h2, this.a];
          }
          return gg(t2);
        }
      }
      class pg {
        constructor(t2) {
          this._isInit = false, this.r = 0, this.g = 0, this.b = 0, this.a = 0, t2 && (this._isInit = true, this.fromHexString(t2));
        }
        fromHexString(t2) {
          const [e2, i2, n2, r2] = mg(t2);
          this.r = e2, this.g = i2, this.b = n2, this.a = r2;
        }
        isInit() {
          return this._isInit;
        }
        interpolationFrom(t2, e2, i2) {
          i2.r = t2.r + (this.r - t2.r) * e2, i2.g = t2.g + (this.g - t2.g) * e2, i2.b = t2.b + (this.b - t2.b) * e2, i2.a = t2.a + (this.a - t2.a) * e2;
        }
        by(t2, e2) {
          e2.r = Math.min(Math.max(this.r + t2.r, 0), 255), e2.g = Math.min(Math.max(this.g + t2.g, 0), 255), e2.b = Math.min(Math.max(this.b + t2.b, 0), 255), e2.a = Math.min(Math.max(this.a + t2.a, 0), 1);
        }
        toHexString() {
          return gg([this.r, this.g, this.b, this.a]);
        }
      }
      function fg(t2) {
        const e2 = t2.substring(1);
        return [parseInt(e2.substring(0, 6), 16), parseInt(e2.substring(6, 8), 16) / 255];
      }
      function mg(t2) {
        return 0 === (t2 = t2.replace(/^#/, "")).substring(6, 8).length && (t2 += "FF"), [parseInt(t2.substring(0, 2).padStart(8, "0"), 16) / 255, parseInt(t2.substring(2, 4).padStart(8, "0"), 16) / 255, parseInt(t2.substring(4, 6).padStart(8, "0"), 16) / 255, parseInt(t2.substring(6, 8).padStart(8, "0"), 16) / 255];
      }
      function gg(t2) {
        return "#" + Math.round(255 * t2[0]).toString(16).padStart(2, "0") + Math.round(255 * t2[1]).toString(16).padStart(2, "0") + Math.round(255 * t2[2]).toString(16).padStart(2, "0") + Math.round(255 * t2[3]).toString(16).padStart(2, "0");
      }
      function vg(t2, e2, i2) {
        const n2 = mg(t2), r2 = mg(e2), o2 = Math.round(255 * (n2[0] + (r2[0] - n2[0]) * i2)), s2 = Math.round(255 * (n2[1] + (r2[1] - n2[1]) * i2)), a2 = Math.round(255 * (n2[2] + (r2[2] - n2[2]) * i2)), l2 = Math.round(255 * (n2[3] + (r2[3] - n2[3]) * i2));
        return "#" + o2.toString(16).padStart(2, "0") + s2.toString(16).padStart(2, "0") + a2.toString(16).padStart(2, "0") + l2.toString(16).padStart(2, "0");
      }
      class _g extends Vh.k {
        constructor() {
          super(void 0, "\nvarying vec2 vTextureCoord;\n\nuniform vec4 color;\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 texColor = texture2D(uSampler, vTextureCoord);\n\n    if (texColor.a > 0.0) {\n        vec4 resultColor = color;\n        resultColor = resultColor * texColor.a;\n        gl_FragColor = resultColor;\n    } else {\n        gl_FragColor = texColor;\n    }\n}\n", { color: new Float32Array([0, 0, 0, 0]), active: 0 }), this.currentColor = "#FFFFFFFF", this.designColor = "#FFFFFFFF";
        }
        set color(t2) {
          this.currentColor = t2;
          const e2 = mg(t2);
          this.uniforms.color = Float32Array.from(e2);
        }
        get color() {
          return this.currentColor;
        }
      }
      const yg = new rm.ColorMatrixFilter();
      yg.matrix = [1, 0, 0, 0, -0.2, 0, 1, 0, 0, -0.2, 0, 0, 1, 0, -0.2, 0, 0, 0, 1, 0];
      const xg = new rm.ColorMatrixFilter();
      xg.matrix = [1, 0, 0, 0, -0.1, 0, 1, 0, 0, -0.1, 0, 0, 1, 0, -0.1, 0, 0, 0, 1, 0];
      const bg = new rm.ColorMatrixFilter();
      bg.matrix = [1, 0, 0, 0, 0.2, 0, 1, 0, 0, 0.2, 0, 0, 1, 0, 0.2, 0, 0, 0, 1, 0];
      const Tg = new rm.ColorMatrixFilter();
      Tg.matrix = [1, 0, 0, 0, 0.1, 0, 1, 0, 0, 0.1, 0, 0, 1, 0, 0.1, 0, 0, 0, 1, 0];
      const Eg = { darken: yg, darkenLess: xg, lightenLess: Tg, lighten: bg };
      class Sg extends hg {
        constructor(t2, e2, i2) {
          super({ position: { x: t2.x, y: t2.y }, width: t2.width, height: t2.height }, e2, i2), this.fillColorFilter = new _g(), this.fill = new ng(this), this.json = t2, this.ctx = e2, this.parentGlobalPos = i2.parentGlobalPos, this.global = { x: i2.parentGlobalPos.x + t2.x, y: i2.parentGlobalPos.y + t2.y }, this.updateTransform({ position: { x: t2.x, y: t2.y }, width: t2.width, height: t2.height });
        }
        get fillActive() {
          var t2, e2;
          return (null !== (e2 = null === (t2 = this.container.filters) || void 0 === t2 ? void 0 : t2.length) && void 0 !== e2 ? e2 : -1) > 0;
        }
        set fillActive(t2) {
          var e2, i2;
          t2 ? (null !== (i2 = null === (e2 = this.container.filters) || void 0 === e2 ? void 0 : e2.indexOf(this.fillColorFilter)) && void 0 !== i2 ? i2 : -1) < 0 && (this.container.filters = [this.fillColorFilter]) : this.container.filters = [];
        }
        get renderContainer() {
          return this.container;
        }
        get interactiveContainer() {
          return this.container;
        }
        clearOnSlideChange() {
        }
        initOnReuse() {
        }
        getTextElement() {
          return null;
        }
        getBgElement() {
          return null;
        }
        get ppt_x() {
          return this.global.x / this.ctx.stageWidth;
        }
        set ppt_x(t2) {
          const e2 = t2 * this.ctx.stageWidth - this.global.x, i2 = 544 === this.presetSubType ? this.scaleExt.x : 1;
          this.container.position.x = this.designX + e2 + this.container.pivot.x * i2;
        }
        get ppt_y() {
          return this.global.y / this.ctx.stageHeight;
        }
        set ppt_y(t2) {
          const e2 = t2 * this.ctx.stageHeight - this.global.y, i2 = 544 === this.presetSubType ? this.scaleExt.y : 1;
          this.container.position.y = this.designY + e2 + this.container.pivot.y * i2;
        }
        get design_ppt_x() {
          return ag(this.global.x / this.ctx.stageWidth);
        }
        get design_ppt_y() {
          return ag(this.global.y / this.ctx.stageHeight);
        }
      }
      class wg {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2) {
          this.ctx = t2, this.type = e2, this.lineWidth = i2, this.width = n2, this.height = r2, this.fillColor = o2, this.isHorz = s2, this.renderContainer = new Oh.b(), this.ghcTextureId = `${a2}-text-p${l2}-l${h2}-u${u2}-underLine`;
        }
        createPaths() {
          if ("ww" === this.type) return null;
          {
            let t2 = `M 0,0 L ${9525 * this.width},0`, [e2, i2] = [this.width, this.lineWidth];
            return this.isHorz || (t2 = "M 0,0 L 0," + 9525 * this.height, [e2, i2] = [this.lineWidth, this.height]), { paths: [{ id: Mm(), path: t2, fill: "norm", hasStroke: true, scale: { x: 1, y: 1 }, hash: jm()(t2) }], width: e2, height: i2 };
          }
        }
        getLineStyle() {
          const t2 = { width: this.lineWidth };
          return "dotted" === this.type && (t2.dash = "" + this.lineWidth), t2;
        }
        preRender() {
          const t2 = this.createPaths();
          if (t2) {
            const { paths: e2, width: i2, height: n2 } = t2, r2 = e2.reduce((t3, e3) => t3 + e3.hash, "");
            this.ctx.graphicsTexture.addGraphics(this.ghcTextureId, e2, r2, { x: 0, y: 0 }, i2, n2, this.getLineStyle(), this.ctx.objectPoolGroup, false, null, this.fillColor);
          }
        }
        render() {
          if (this.ghcTextureId) {
            const t2 = this.ctx.graphicsTexture.getGraphicsData(this.ghcTextureId);
            t2 && (this.sprite = new ep(), this.sprite.texture = t2.texture, this.sprite.pivot.x = t2.pivot.x, this.sprite.scale.x = t2.scale, this.sprite.scale.y = t2.scale);
          }
        }
        destroy() {
          var t2;
          null === (t2 = this.sprite) || void 0 === t2 || t2.destroy({ texture: true });
        }
      }
      const Ag = 134217729;
      function Mg(t2, e2, i2, n2, r2) {
        let o2, s2, a2, l2, h2 = e2[0], u2 = n2[0], c2 = 0, d2 = 0;
        u2 > h2 == u2 > -h2 ? (o2 = h2, h2 = e2[++c2]) : (o2 = u2, u2 = n2[++d2]);
        let p2 = 0;
        if (c2 < t2 && d2 < i2) for (u2 > h2 == u2 > -h2 ? (s2 = h2 + o2, a2 = o2 - (s2 - h2), h2 = e2[++c2]) : (s2 = u2 + o2, a2 = o2 - (s2 - u2), u2 = n2[++d2]), o2 = s2, 0 !== a2 && (r2[p2++] = a2); c2 < t2 && d2 < i2; ) u2 > h2 == u2 > -h2 ? (s2 = o2 + h2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (h2 - l2), h2 = e2[++c2]) : (s2 = o2 + u2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (u2 - l2), u2 = n2[++d2]), o2 = s2, 0 !== a2 && (r2[p2++] = a2);
        for (; c2 < t2; ) s2 = o2 + h2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (h2 - l2), h2 = e2[++c2], o2 = s2, 0 !== a2 && (r2[p2++] = a2);
        for (; d2 < i2; ) s2 = o2 + u2, l2 = s2 - o2, a2 = o2 - (s2 - l2) + (u2 - l2), u2 = n2[++d2], o2 = s2, 0 !== a2 && (r2[p2++] = a2);
        return 0 === o2 && 0 !== p2 || (r2[p2++] = o2), p2;
      }
      function Cg(t2, e2) {
        let i2 = e2[0];
        for (let n2 = 1; n2 < t2; n2++) i2 += e2[n2];
        return i2;
      }
      function Rg(t2) {
        return new Float64Array(t2);
      }
      const Ig = Rg(4), Pg = Rg(8), Og = Rg(12), Ng = Rg(16), Lg = Rg(4);
      function Dg(t2, e2, i2, n2, r2, o2) {
        const s2 = (e2 - o2) * (i2 - r2), a2 = (t2 - r2) * (n2 - o2), l2 = s2 - a2;
        if (0 === s2 || 0 === a2 || s2 > 0 != a2 > 0) return l2;
        const h2 = Math.abs(s2 + a2);
        return Math.abs(l2) >= 33306690738754716e-32 * h2 ? l2 : -function(t3, e3, i3, n3, r3, o3, s3) {
          let a3, l3, h3, u2, c2, d2, p2, f2, m2, g2, v2, _2, y2, x2, b2, T2, E2, S2;
          const w2 = t3 - r3, A2 = i3 - r3, M2 = e3 - o3, C2 = n3 - o3;
          x2 = w2 * C2, d2 = Ag * w2, p2 = d2 - (d2 - w2), f2 = w2 - p2, d2 = Ag * C2, m2 = d2 - (d2 - C2), g2 = C2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = M2 * A2, d2 = Ag * M2, p2 = d2 - (d2 - M2), f2 = M2 - p2, d2 = Ag * A2, m2 = d2 - (d2 - A2), g2 = A2 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Ig[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Ig[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Ig[2] = _2 - (S2 - c2) + (v2 - c2), Ig[3] = S2;
          let R2 = Cg(4, Ig), I2 = 22204460492503146e-32 * s3;
          if (R2 >= I2 || -R2 >= I2) return R2;
          if (c2 = t3 - w2, a3 = t3 - (w2 + c2) + (c2 - r3), c2 = i3 - A2, h3 = i3 - (A2 + c2) + (c2 - r3), c2 = e3 - M2, l3 = e3 - (M2 + c2) + (c2 - o3), c2 = n3 - C2, u2 = n3 - (C2 + c2) + (c2 - o3), 0 === a3 && 0 === l3 && 0 === h3 && 0 === u2) return R2;
          if (I2 = 11093356479670487e-47 * s3 + 33306690738754706e-32 * Math.abs(R2), R2 += w2 * u2 + C2 * a3 - (M2 * h3 + A2 * l3), R2 >= I2 || -R2 >= I2) return R2;
          x2 = a3 * C2, d2 = Ag * a3, p2 = d2 - (d2 - a3), f2 = a3 - p2, d2 = Ag * C2, m2 = d2 - (d2 - C2), g2 = C2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = l3 * A2, d2 = Ag * l3, p2 = d2 - (d2 - l3), f2 = l3 - p2, d2 = Ag * A2, m2 = d2 - (d2 - A2), g2 = A2 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Lg[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Lg[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Lg[2] = _2 - (S2 - c2) + (v2 - c2), Lg[3] = S2;
          const P2 = Mg(4, Ig, 4, Lg, Pg);
          x2 = w2 * u2, d2 = Ag * w2, p2 = d2 - (d2 - w2), f2 = w2 - p2, d2 = Ag * u2, m2 = d2 - (d2 - u2), g2 = u2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = M2 * h3, d2 = Ag * M2, p2 = d2 - (d2 - M2), f2 = M2 - p2, d2 = Ag * h3, m2 = d2 - (d2 - h3), g2 = h3 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Lg[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Lg[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Lg[2] = _2 - (S2 - c2) + (v2 - c2), Lg[3] = S2;
          const O2 = Mg(P2, Pg, 4, Lg, Og);
          x2 = a3 * u2, d2 = Ag * a3, p2 = d2 - (d2 - a3), f2 = a3 - p2, d2 = Ag * u2, m2 = d2 - (d2 - u2), g2 = u2 - m2, b2 = f2 * g2 - (x2 - p2 * m2 - f2 * m2 - p2 * g2), T2 = l3 * h3, d2 = Ag * l3, p2 = d2 - (d2 - l3), f2 = l3 - p2, d2 = Ag * h3, m2 = d2 - (d2 - h3), g2 = h3 - m2, E2 = f2 * g2 - (T2 - p2 * m2 - f2 * m2 - p2 * g2), v2 = b2 - E2, c2 = b2 - v2, Lg[0] = b2 - (v2 + c2) + (c2 - E2), _2 = x2 + v2, c2 = _2 - x2, y2 = x2 - (_2 - c2) + (v2 - c2), v2 = y2 - T2, c2 = y2 - v2, Lg[1] = y2 - (v2 + c2) + (c2 - T2), S2 = _2 + v2, c2 = S2 - _2, Lg[2] = _2 - (S2 - c2) + (v2 - c2), Lg[3] = S2;
          const N2 = Mg(O2, Og, 4, Lg, Ng);
          return Ng[N2 - 1];
        }(t2, e2, i2, n2, r2, o2, h2);
      }
      Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(8), Rg(8), Rg(8), Rg(4), Rg(8), Rg(8), Rg(8), Rg(12);
      Rg(192), Rg(192);
      Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(8), Rg(8), Rg(8), Rg(8), Rg(8), Rg(8), Rg(8), Rg(8), Rg(8), Rg(4), Rg(4), Rg(4), Rg(8), Rg(16), Rg(16), Rg(16), Rg(32), Rg(32), Rg(48), Rg(64);
      Rg(1152), Rg(1152);
      Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(4), Rg(24), Rg(24), Rg(24), Rg(24), Rg(24), Rg(24), Rg(24), Rg(24), Rg(24), Rg(24), Rg(1152), Rg(1152), Rg(1152), Rg(1152), Rg(1152), Rg(2304), Rg(2304), Rg(3456), Rg(5760), Rg(8), Rg(8), Rg(8), Rg(16), Rg(24), Rg(48), Rg(48), Rg(96), Rg(192), Rg(384), Rg(384), Rg(384), Rg(768);
      Rg(96), Rg(96), Rg(96), Rg(1152);
      const Fg = Math.pow(2, -52), Bg = new Uint32Array(512);
      class Ug {
        static from(t2, e2 = Vg, i2 = Xg) {
          const n2 = t2.length, r2 = new Float64Array(2 * n2);
          for (let o2 = 0; o2 < n2; o2++) {
            const n3 = t2[o2];
            r2[2 * o2] = e2(n3), r2[2 * o2 + 1] = i2(n3);
          }
          return new Ug(r2);
        }
        constructor(t2) {
          const e2 = t2.length >> 1;
          if (e2 > 0 && "number" != typeof t2[0]) throw new Error("Expected coords to contain numbers.");
          this.coords = t2;
          const i2 = Math.max(2 * e2 - 5, 0);
          this._triangles = new Uint32Array(3 * i2), this._halfedges = new Int32Array(3 * i2), this._hashSize = Math.ceil(Math.sqrt(e2)), this._hullPrev = new Uint32Array(e2), this._hullNext = new Uint32Array(e2), this._hullTri = new Uint32Array(e2), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(e2), this._dists = new Float64Array(e2), this.update();
        }
        update() {
          const { coords: t2, _hullPrev: e2, _hullNext: i2, _hullTri: n2, _hullHash: r2 } = this, o2 = t2.length >> 1;
          let s2 = 1 / 0, a2 = 1 / 0, l2 = -1 / 0, h2 = -1 / 0;
          for (let e3 = 0; e3 < o2; e3++) {
            const i3 = t2[2 * e3], n3 = t2[2 * e3 + 1];
            i3 < s2 && (s2 = i3), n3 < a2 && (a2 = n3), i3 > l2 && (l2 = i3), n3 > h2 && (h2 = n3), this._ids[e3] = e3;
          }
          const u2 = (s2 + l2) / 2, c2 = (a2 + h2) / 2;
          let d2, p2, f2, m2 = 1 / 0;
          for (let e3 = 0; e3 < o2; e3++) {
            const i3 = kg(u2, c2, t2[2 * e3], t2[2 * e3 + 1]);
            i3 < m2 && (d2 = e3, m2 = i3);
          }
          const g2 = t2[2 * d2], v2 = t2[2 * d2 + 1];
          m2 = 1 / 0;
          for (let e3 = 0; e3 < o2; e3++) {
            if (e3 === d2) continue;
            const i3 = kg(g2, v2, t2[2 * e3], t2[2 * e3 + 1]);
            i3 < m2 && i3 > 0 && (p2 = e3, m2 = i3);
          }
          let _2 = t2[2 * p2], y2 = t2[2 * p2 + 1], x2 = 1 / 0;
          for (let e3 = 0; e3 < o2; e3++) {
            if (e3 === d2 || e3 === p2) continue;
            const i3 = Hg(g2, v2, _2, y2, t2[2 * e3], t2[2 * e3 + 1]);
            i3 < x2 && (f2 = e3, x2 = i3);
          }
          let b2 = t2[2 * f2], T2 = t2[2 * f2 + 1];
          if (x2 === 1 / 0) {
            for (let e4 = 0; e4 < o2; e4++) this._dists[e4] = t2[2 * e4] - t2[0] || t2[2 * e4 + 1] - t2[1];
            jg(this._ids, this._dists, 0, o2 - 1);
            const e3 = new Uint32Array(o2);
            let i3 = 0;
            for (let t3 = 0, n3 = -1 / 0; t3 < o2; t3++) {
              const r3 = this._ids[t3];
              this._dists[r3] > n3 && (e3[i3++] = r3, n3 = this._dists[r3]);
            }
            return this.hull = e3.subarray(0, i3), this.triangles = new Uint32Array(0), void (this.halfedges = new Uint32Array(0));
          }
          if (Dg(g2, v2, _2, y2, b2, T2) < 0) {
            const t3 = p2, e3 = _2, i3 = y2;
            p2 = f2, _2 = b2, y2 = T2, f2 = t3, b2 = e3, T2 = i3;
          }
          const E2 = function(t3, e3, i3, n3, r3, o3) {
            const s3 = i3 - t3, a3 = n3 - e3, l3 = r3 - t3, h3 = o3 - e3, u3 = s3 * s3 + a3 * a3, c3 = l3 * l3 + h3 * h3, d3 = 0.5 / (s3 * h3 - a3 * l3);
            return { x: t3 + (h3 * u3 - a3 * c3) * d3, y: e3 + (s3 * c3 - l3 * u3) * d3 };
          }(g2, v2, _2, y2, b2, T2);
          this._cx = E2.x, this._cy = E2.y;
          for (let e3 = 0; e3 < o2; e3++) this._dists[e3] = kg(t2[2 * e3], t2[2 * e3 + 1], E2.x, E2.y);
          jg(this._ids, this._dists, 0, o2 - 1), this._hullStart = d2;
          let S2 = 3;
          i2[d2] = e2[f2] = p2, i2[p2] = e2[d2] = f2, i2[f2] = e2[p2] = d2, n2[d2] = 0, n2[p2] = 1, n2[f2] = 2, r2.fill(-1), r2[this._hashKey(g2, v2)] = d2, r2[this._hashKey(_2, y2)] = p2, r2[this._hashKey(b2, T2)] = f2, this.trianglesLen = 0, this._addTriangle(d2, p2, f2, -1, -1, -1);
          for (let o3, s3, a3 = 0; a3 < this._ids.length; a3++) {
            const l3 = this._ids[a3], h3 = t2[2 * l3], u3 = t2[2 * l3 + 1];
            if (a3 > 0 && Math.abs(h3 - o3) <= Fg && Math.abs(u3 - s3) <= Fg) continue;
            if (o3 = h3, s3 = u3, l3 === d2 || l3 === p2 || l3 === f2) continue;
            let c3 = 0;
            for (let t3 = 0, e3 = this._hashKey(h3, u3); t3 < this._hashSize && (c3 = r2[(e3 + t3) % this._hashSize], -1 === c3 || c3 === i2[c3]); t3++) ;
            c3 = e2[c3];
            let m3, g3 = c3;
            for (; m3 = i2[g3], Dg(h3, u3, t2[2 * g3], t2[2 * g3 + 1], t2[2 * m3], t2[2 * m3 + 1]) >= 0; ) if (g3 = m3, g3 === c3) {
              g3 = -1;
              break;
            }
            if (-1 === g3) continue;
            let v3 = this._addTriangle(g3, l3, i2[g3], -1, -1, n2[g3]);
            n2[l3] = this._legalize(v3 + 2), n2[g3] = v3, S2++;
            let _3 = i2[g3];
            for (; m3 = i2[_3], Dg(h3, u3, t2[2 * _3], t2[2 * _3 + 1], t2[2 * m3], t2[2 * m3 + 1]) < 0; ) v3 = this._addTriangle(_3, l3, m3, n2[l3], -1, n2[_3]), n2[l3] = this._legalize(v3 + 2), i2[_3] = _3, S2--, _3 = m3;
            if (g3 === c3) for (; m3 = e2[g3], Dg(h3, u3, t2[2 * m3], t2[2 * m3 + 1], t2[2 * g3], t2[2 * g3 + 1]) < 0; ) v3 = this._addTriangle(m3, l3, g3, -1, n2[g3], n2[m3]), this._legalize(v3 + 2), n2[m3] = v3, i2[g3] = g3, S2--, g3 = m3;
            this._hullStart = e2[l3] = g3, i2[g3] = e2[_3] = l3, i2[l3] = _3, r2[this._hashKey(h3, u3)] = l3, r2[this._hashKey(t2[2 * g3], t2[2 * g3 + 1])] = g3;
          }
          this.hull = new Uint32Array(S2);
          for (let t3 = 0, e3 = this._hullStart; t3 < S2; t3++) this.hull[t3] = e3, e3 = i2[e3];
          this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }
        _hashKey(t2, e2) {
          return Math.floor(function(t3, e3) {
            const i2 = t3 / (Math.abs(t3) + Math.abs(e3));
            return (e3 > 0 ? 3 - i2 : 1 + i2) / 4;
          }(t2 - this._cx, e2 - this._cy) * this._hashSize) % this._hashSize;
        }
        _legalize(t2) {
          const { _triangles: e2, _halfedges: i2, coords: n2 } = this;
          let r2 = 0, o2 = 0;
          for (; ; ) {
            const s2 = i2[t2], a2 = t2 - t2 % 3;
            if (o2 = a2 + (t2 + 2) % 3, -1 === s2) {
              if (0 === r2) break;
              t2 = Bg[--r2];
              continue;
            }
            const l2 = s2 - s2 % 3, h2 = a2 + (t2 + 1) % 3, u2 = l2 + (s2 + 2) % 3, c2 = e2[o2], d2 = e2[t2], p2 = e2[h2], f2 = e2[u2];
            if (Gg(n2[2 * c2], n2[2 * c2 + 1], n2[2 * d2], n2[2 * d2 + 1], n2[2 * p2], n2[2 * p2 + 1], n2[2 * f2], n2[2 * f2 + 1])) {
              e2[t2] = f2, e2[s2] = c2;
              const n3 = i2[u2];
              if (-1 === n3) {
                let e3 = this._hullStart;
                do {
                  if (this._hullTri[e3] === u2) {
                    this._hullTri[e3] = t2;
                    break;
                  }
                  e3 = this._hullPrev[e3];
                } while (e3 !== this._hullStart);
              }
              this._link(t2, n3), this._link(s2, i2[o2]), this._link(o2, u2);
              const a3 = l2 + (s2 + 1) % 3;
              r2 < Bg.length && (Bg[r2++] = a3);
            } else {
              if (0 === r2) break;
              t2 = Bg[--r2];
            }
          }
          return o2;
        }
        _link(t2, e2) {
          this._halfedges[t2] = e2, -1 !== e2 && (this._halfedges[e2] = t2);
        }
        _addTriangle(t2, e2, i2, n2, r2, o2) {
          const s2 = this.trianglesLen;
          return this._triangles[s2] = t2, this._triangles[s2 + 1] = e2, this._triangles[s2 + 2] = i2, this._link(s2, n2), this._link(s2 + 1, r2), this._link(s2 + 2, o2), this.trianglesLen += 3, s2;
        }
      }
      function kg(t2, e2, i2, n2) {
        const r2 = t2 - i2, o2 = e2 - n2;
        return r2 * r2 + o2 * o2;
      }
      function Gg(t2, e2, i2, n2, r2, o2, s2, a2) {
        const l2 = t2 - s2, h2 = e2 - a2, u2 = i2 - s2, c2 = n2 - a2, d2 = r2 - s2, p2 = o2 - a2, f2 = u2 * u2 + c2 * c2, m2 = d2 * d2 + p2 * p2;
        return l2 * (c2 * m2 - f2 * p2) - h2 * (u2 * m2 - f2 * d2) + (l2 * l2 + h2 * h2) * (u2 * p2 - c2 * d2) < 0;
      }
      function Hg(t2, e2, i2, n2, r2, o2) {
        const s2 = i2 - t2, a2 = n2 - e2, l2 = r2 - t2, h2 = o2 - e2, u2 = s2 * s2 + a2 * a2, c2 = l2 * l2 + h2 * h2, d2 = 0.5 / (s2 * h2 - a2 * l2), p2 = (h2 * u2 - a2 * c2) * d2, f2 = (s2 * c2 - l2 * u2) * d2;
        return p2 * p2 + f2 * f2;
      }
      function jg(t2, e2, i2, n2) {
        if (n2 - i2 <= 20) for (let r2 = i2 + 1; r2 <= n2; r2++) {
          const n3 = t2[r2], o2 = e2[n3];
          let s2 = r2 - 1;
          for (; s2 >= i2 && e2[t2[s2]] > o2; ) t2[s2 + 1] = t2[s2--];
          t2[s2 + 1] = n3;
        }
        else {
          let r2 = i2 + 1, o2 = n2;
          zg(t2, i2 + n2 >> 1, r2), e2[t2[i2]] > e2[t2[n2]] && zg(t2, i2, n2), e2[t2[r2]] > e2[t2[n2]] && zg(t2, r2, n2), e2[t2[i2]] > e2[t2[r2]] && zg(t2, i2, r2);
          const s2 = t2[r2], a2 = e2[s2];
          for (; ; ) {
            do {
              r2++;
            } while (e2[t2[r2]] < a2);
            do {
              o2--;
            } while (e2[t2[o2]] > a2);
            if (o2 < r2) break;
            zg(t2, r2, o2);
          }
          t2[i2 + 1] = t2[o2], t2[o2] = s2, n2 - r2 + 1 >= o2 - i2 ? (jg(t2, e2, r2, n2), jg(t2, e2, i2, o2 - 1)) : (jg(t2, e2, i2, o2 - 1), jg(t2, e2, r2, n2));
        }
      }
      function zg(t2, e2, i2) {
        const n2 = t2[e2];
        t2[e2] = t2[i2], t2[i2] = n2;
      }
      function Vg(t2) {
        return t2[0];
      }
      function Xg(t2) {
        return t2[1];
      }
      function Wg(t2, e2, i2) {
        let n2 = null;
        const r2 = new Oh.b();
        if (t2.stopList.sort((t3, e3) => t3.pos - e3.pos), !t2.stopList.find((t3) => 0 === t3.pos)) {
          const e3 = t2.stopList[0];
          t2.stopList.unshift({ pos: 0, color: e3.color });
        }
        if (!t2.stopList.find((t3) => 1 === t3.pos)) {
          const e3 = t2.stopList[t2.stopList.length - 1];
          t2.stopList.push({ pos: 1, color: e3.color });
        }
        const o2 = (t3) => {
          const e3 = [];
          for (let i3 = 0, n3 = t3.length; i3 < n3 - 1; i3++) {
            const n4 = t3[i3], r3 = t3[i3 + 1], o3 = n4.pos + 0.5 * (r3.pos - n4.pos), s2 = vg(n4.color, r3.color, 0.5), a2 = 2 * i3;
            e3[a2] = n4, e3[a2 + 1] = { color: s2, pos: o3 }, e3[a2 + 2] = r3;
          }
          return e3;
        };
        if (t2.stopList = o2(t2.stopList), t2.stopList = o2(t2.stopList), n2 = t2.line ? Yg(t2, e2, i2) : t2.path ? function(t3, e3, i3) {
          var n3, r3, o3;
          const s2 = [], a2 = { x: 0, y: 0 };
          if ("circle" === (null === (n3 = t3.path) || void 0 === n3 ? void 0 : n3.path) || "rect" === (null === (r3 = t3.path) || void 0 === r3 ? void 0 : r3.path) || "shape" === (null === (o3 = t3.path) || void 0 === o3 ? void 0 : o3.path)) {
            const n4 = e3 / 2, r4 = i3 / 2, o4 = Math.sqrt(n4 * n4 + r4 * r4);
            t3.stopList.forEach((t4) => {
              if (0 === t4.pos) s2.push({ point: { x: 0, y: 0 }, color: t4.color });
              else {
                const e4 = o4 * t4.pos, i4 = new zs();
                i4.absellipse(0, 0, e4, e4, 0, 2 * Math.PI, false, 0), i4.getPoints(50).forEach((e5) => {
                  s2.push({ point: { x: e5.x, y: e5.y }, color: t4.color });
                });
              }
              a2.x = n4, a2.y = r4;
            });
          }
          return { points: s2, position: a2 };
        }(t2, e2, i2) : Yg(t2, e2, i2), n2) {
          const t3 = [], o3 = [], { position: s2, points: a2 } = n2, l2 = Ug.from(a2, (t4) => t4.point.x, (t4) => t4.point.y);
          for (let e3 = 0; e3 < l2.triangles.length; e3 += 3) t3.push(a2[l2.triangles[e3]].point.x, a2[l2.triangles[e3]].point.y), t3.push(a2[l2.triangles[e3 + 1]].point.x, a2[l2.triangles[e3 + 1]].point.y), t3.push(a2[l2.triangles[e3 + 2]].point.x, a2[l2.triangles[e3 + 2]].point.y), o3.push(...mg(a2[l2.triangles[e3]].color)), o3.push(...mg(a2[l2.triangles[e3 + 1]].color)), o3.push(...mg(a2[l2.triangles[e3 + 2]].color));
          const h2 = new Vh.l();
          h2.addAttribute("aVertexPosition", t3, 2), h2.addAttribute("aColor", o3, 4);
          const u2 = Vh.r.from("\n        precision mediump float;\n        attribute vec2 aVertexPosition;\n        attribute vec4 aColor;\n        uniform mat3 translationMatrix;\n        uniform mat3 projectionMatrix;\n        varying vec4 vColor;\n        void main() {\n            vColor = aColor;\n            gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n        }", "precision mediump float;    \n        varying vec4 vColor;\n        void main() {\n            float alpha = vColor.a;\n            vec4 color = vColor;\n            color.a = 1.0;\n            gl_FragColor = color * alpha;\n        }\n    "), c2 = new Jd();
          c2.drawRect(0, 0, e2 + 1, i2 + 1), r2.mask = c2, r2.addChild(c2);
          const d2 = new Dp.a(h2, u2);
          d2.position.x = s2.x, d2.position.y = s2.y, r2.addChild(d2);
        }
        return r2;
      }
      function Yg(t2, e2, i2) {
        const n2 = e2 / 2, r2 = i2 / 2, o2 = [{ x: -n2, y: r2 }, { x: -n2, y: -r2 }, { x: n2, y: r2 }, { x: n2, y: -r2 }], s2 = [lg.fromPointSlope({ x: -n2, y: 0 }, Math.PI / 2), lg.fromPointSlope({ x: 0, y: r2 }, 0), lg.fromPointSlope({ x: n2, y: 0 }, Math.PI / 2), lg.fromPointSlope({ x: 0, y: -r2 }, 0)], a2 = [], l2 = t2.stopList.slice(1, t2.stopList.length - 1).map((o3) => {
          var l3, h3, u3;
          const c3 = 2 * Math.PI;
          let d3 = null !== (h3 = null === (l3 = t2.line) || void 0 === l3 ? void 0 : l3.ang) && void 0 !== h3 ? h3 : 0;
          for (; d3 > c3; ) d3 -= c3;
          for (; d3 < 0; ) d3 += c3;
          const p3 = { x: 0, y: 0 };
          sg(d3, Math.PI / 2) ? (p3.x = 0, p3.y = i2 / 2 - o3.pos * i2) : sg(d3, 0) ? (p3.x = o3.pos * e2 - e2 / 2, p3.y = 0) : (p3.x = o3.pos * e2 - e2 / 2, p3.y = i2 / 2 - o3.pos * i2), d3 > Math.PI / 2 && d3 <= Math.PI && (p3.x *= -1), d3 > Math.PI && d3 <= 2 * Math.PI && (p3.y *= -1);
          const f2 = lg.fromPointSlope(p3, Math.PI / 2 - ((null === (u3 = t2.line) || void 0 === u3 ? void 0 : u3.ang) || 0)), m2 = s2.map((t3) => f2.crossPoint(t3)).filter((t3) => t3 && t3.x <= n2 && t3.x >= -n2 && t3.y <= r2 && t3.y >= -r2).map((t3) => ({ point: t3, color: o3.color })).sort((t3, e3) => e3.point.y - t3.point.y);
          a2.push(...m2);
          let g2 = Math.abs(m2[1].point.x - m2[0].point.x) / 10;
          for (let t3 = 20; t3--; ) {
            const e3 = t3 % 2 == 0 ? 1 : -1, i3 = p3.x + e3 * g2, s3 = f2.resolveY(i3);
            i3 <= n2 && i3 >= -n2 && s3 <= r2 && s3 >= -r2 && a2.push({ point: { x: i3, y: s3 }, color: o3.color }), g2 += g2;
          }
          return f2;
        });
        let h2 = [], u2 = [];
        t: for (let e3 = 0; e3 < o2.length; e3++) {
          const i3 = o2[e3];
          for (let e4 = 0; e4 < l2.length - 1; e4++) {
            const n4 = l2[e4], r4 = l2[e4 + 1], o3 = n4.distanceToLinearEquation(r4), s4 = n4.distanceToPoint(i3), h3 = r4.distanceToPoint(i3);
            if (s4 < o3 && h3 < o3) {
              const n5 = t2.stopList.slice(1, t2.stopList.length - 1)[e4], r5 = t2.stopList.slice(1, t2.stopList.length - 1)[e4 + 1], l3 = vg(n5.color, r5.color, s4 / o3);
              a2.splice(e4 + 1, 0, { point: i3, color: l3 });
              continue t;
            }
          }
          const n3 = l2[0], r3 = l2[l2.length - 1], s3 = n3.distanceToPoint(i3), c3 = r3.distanceToPoint(i3);
          s3 <= c3 ? h2.push({ point: i3, dis: s3 }) : u2.push({ point: i3, dis: c3 });
        }
        h2 = h2.sort((t3, e3) => e3.dis - t3.dis);
        const c2 = h2.map((e3, i3) => {
          if (0 === i3) return { point: e3.point, color: t2.stopList[0].color };
          {
            const i4 = t2.stopList[0].color, n3 = t2.stopList[1].color;
            return { point: e3.point, color: vg(i4, n3, 1 - (0 === h2[0].dis ? 1 : e3.dis / h2[0].dis)) };
          }
        }).sort((t3, e3) => e3.point.y - t3.point.y);
        u2 = u2.sort((t3, e3) => e3.dis - t3.dis);
        const d2 = u2.map((e3, i3) => {
          if (0 === i3) return { point: e3.point, color: t2.stopList[t2.stopList.length - 1].color };
          {
            const i4 = t2.stopList[t2.stopList.length - 2].color, n3 = t2.stopList[t2.stopList.length - 1].color;
            return { point: e3.point, color: vg(i4, n3, 0 === u2[0].dis ? 0 : e3.dis / u2[0].dis) };
          }
        }).sort((t3, e3) => e3.point.y - t3.point.y), p2 = c2.concat(...a2).concat(d2);
        for (let t3 = 0; t3 < p2.length; t3++) p2[t3].point.x += n2, p2[t3].point.y = -p2[t3].point.y + r2;
        return { points: p2, position: { x: 0, y: 0 } };
      }
      const qg = "\nvec3 rgb2hsl(vec3 rgb) {\n    float cMax = max(max(rgb.r, rgb.g), rgb.b);\n    float cMin = min(min(rgb.r, rgb.g), rgb.b);\n    float delta = cMax - cMin;\n    \n    float h = 0.0;\n    if (delta == 0.0) {\n        h = 0.0;\n    } else if (cMax == rgb.r) {\n        h = 60.0 * mod(((rgb.g - rgb.b) / delta), 6.0);\n    } else if (cMax == rgb.g ) {\n        h = 60.0 * ((rgb.b - rgb.r) / delta + 2.0);\n    } else if (cMax == rgb.b) {\n        h = 60.0 * ((rgb.r - rgb.g) / delta + 4.0);\n    }\n    \n    float l = (cMax + cMin) / 2.0;\n    \n    float s = 0.0;\n    if (delta == 0.0) {\n        s = 0.0;\n    } else {\n        s = delta / (1.0 - abs(2.0 * l - 1.0));\n    }\n    \n    return vec3(h, s, l);\n}\n", Zg = [qg], Jg = { biLevel: "\nvec4 transform(vec4 texColor, float arg) {\n    mat3 rgb2yuv = mat3(\n        0.2126, 0.7152, 0.0722,\n        -0.09991, -0.33609, 0.43600,\n        0.615, -0.5586, -0.05639\n    );\n    vec3 yuv = texColor.rgb * rgb2yuv;\n    if (yuv.x >= 0.49 || texColor.a < 0.9) {\n        return vec4(1.0, 1.0, 1.0, 1.0) * texColor.a;\n    } else {\n        return vec4(0.0, 0.0, 0.0, 1.0) * texColor.a;\n    }\n}\n", alphaModFix: "\nvec4 transform(vec4 texColor, float arg) {\n   return texColor * arg;\n}\n", alphaBiLevel: "\nvec4 transform(vec4 texColor, float arg) {\n    vec4 result = vec4(texColor);\n    result.rgb = result.rgb / texColor.a;\n    if (texColor.a < arg) {\n        result.a = 0.0;\n    } else {\n        result.a = 1.0;\n    }\n    return result;\n}\n", alphaCeiling: "\nvec4 transform(vec4 texColor, float arg) {\n    vec4 result = vec4(texColor);\n    result.rgb = result.rgb / texColor.a;\n    if (texColor.a > 0.0) {\n        result.a = 1.0;\n    }\n    return result;\n}\n", alphaFloor: "\nvec4 transform(vec4 texColor, float arg) {\n    vec4 result = vec4(texColor);\n    result.rgb = result.rgb / texColor.a;\n    if (texColor.a < 1.0) {\n        result.a = 0.0;\n    }\n    return result;\n}\n", grayscl: "\nvec4 transform(vec4 texColor, float arg) {\n    float avg = (texColor.r + texColor.g + texColor.b) / 3.0;\n    return vec4(avg, avg, avg, texColor.a);\n}\n" };
      class Kg extends Vh.k {
        constructor(t2, e2) {
          var i2;
          super(void 0, (i2 = Jg[t2], `
varying vec2 vTextureCoord;

uniform float arg;
uniform sampler2D uSampler;

${Zg.map((t3) => t3 + "\n").join("\n")}

${i2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg);
}
`), { arg: e2 });
        }
      }
      const Qg = [qg], $g = { clrChange: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    float epsilon = 0.001;\n    vec3 colorDiff = arg1.rgb - (texColor.rgb / max(texColor.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    if (colorDistance < epsilon) {\n        arg2.rgb *= arg2.a;\n        return arg2;\n    } else {\n        return texColor;\n    }\n}\n", changeBulletColor: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    if (texColor.a == 0.0) {\n        return texColor;\n    } else {\n        return arg2;\n    }\n}\n", duotone: "\nvec4 transform(vec4 texColor, vec4 arg1, vec4 arg2) {\n    // float avg = (texColor.r + texColor.g + texColor.b) / 3.0;\n    // vec3 hsl = rgb2hsl(vec3(avg, avg, avg));\n    // vec3 result = arg2.rgb * hsl.z + arg1.rgb * (1.0 - hsl.z);\n    // return vec4(result * texColor.a, texColor.a);\n    \n    float brightness = texColor.r * 0.3 + texColor.g * 0.59 + texColor.b * 0.11;\n    \n    return vec4(\n        (arg1.r + brightness * (arg2.r - arg1.r)) * texColor.a,\n        (arg1.g + brightness * (arg2.g - arg1.g)) * texColor.a,\n        (arg1.b + brightness * (arg2.b - arg1.b)) * texColor.a,\n        texColor.a\n    );\n}\n" };
      class tv extends Vh.k {
        constructor(t2, e2, i2) {
          var n2;
          super(void 0, (n2 = $g[t2], `
varying vec2 vTextureCoord;

uniform vec4 arg1;
uniform vec4 arg2;
uniform sampler2D uSampler;

${Qg.map((t3) => t3 + "\n").join("\n")}

${n2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1, arg2);
}
`), { arg1: Float32Array.from(e2), arg2: Float32Array.from(i2) });
        }
      }
      const ev = [qg], iv = { lum: "\nvec4 transform(vec4 texColor, float arg1, float arg2) {\n    vec3 rgb = texColor.rgb / texColor.a;\n\n    // \u5BF9\u6BD4\u5EA6\n    highp float C = arg2 * 255.0;\n    highp float F = (259.0 * (255.0 + C)) / (255.0 * (259.0 - C));\n    rgb.rgb = F * (rgb.rgb - 0.5) + 0.5;\n\n    // \u4EAE\u5EA6\n    rgb.rgb += arg1 * rgb.rgb;\n\n    rgb.rgb *= texColor.a;\n    return vec4(rgb, texColor.a);\n}\n" };
      class nv extends Vh.k {
        constructor(t2, e2, i2) {
          var n2;
          super(void 0, (n2 = iv[t2], `
varying vec2 vTextureCoord;

uniform float arg1;
uniform float arg2;
uniform sampler2D uSampler;

${ev.map((t3) => t3 + "\n").join("\n")}

${n2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1, arg2);
}
`), { arg1: e2, arg2: i2 });
        }
      }
      const rv = [qg], ov = { alphaInv: "\nvec4 transform(vec4 texColor, vec4 arg1) {\n    float alpha = 1.0 - texColor.a;\n    arg1.rgb = arg1.rgb * alpha;\n    arg1.a = alpha;\n    return arg1;\n}\n" };
      class sv extends Vh.k {
        constructor(t2, e2) {
          var i2;
          super(void 0, (i2 = ov[t2], `
varying vec2 vTextureCoord;

uniform vec4 arg1;
uniform sampler2D uSampler;

${rv.map((t3) => t3 + "\n").join("\n")}

${i2}

void main(void){
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor = transform(texColor, arg1);
}
`), { arg1: Float32Array.from(e2) });
        }
      }
      function av(t2, e2) {
        const i2 = [];
        return t2.forEach((t3) => {
          const n2 = ((null == e2 ? void 0 : e2.filter) || []).indexOf(t3.type) >= 0;
          if (["biLevel", "alphaBiLevel", "alphaCeiling", "alphaModFix", "alphaFloor", "grayscl"].indexOf(t3.type) >= 0 && n2) i2.push(new Kg(t3.type, t3.args[0] || 0));
          else if (["clrChange", "changeBulletColor", "duotone"].indexOf(t3.type) >= 0 && n2) {
            const e3 = mg(t3.args[0]), n3 = mg(t3.args[1]);
            i2.push(new tv(t3.type, e3, n3));
          } else if ("lum" === t3.type && n2) i2.push(new nv(t3.type, t3.args[0], t3.args[1]));
          else if ("alphaInv" === t3.type && n2) {
            const e3 = mg(t3.args[0]);
            i2.push(new sv(t3.type, e3));
          }
        }), i2;
      }
      class lv {
        constructor(t2, e2, i2, n2, r2) {
          this.ctx = t2, this.fillStyle = e2, this.width = i2, this.height = n2, this.config = r2, this.clonedObjects = [], this._displayObject = null, this.gradientHash = jm()(`${JSON.stringify(e2)}${Math.ceil(i2)}${Math.ceil(n2)}`);
        }
        get displayObject() {
          return this._displayObject || (this._displayObject = this.createDisplayObject()), this._displayObject;
        }
        set displayObject(t2) {
          this._displayObject && this._displayObject.destroy({ children: true, texture: true }), this._displayObject = t2;
        }
        get hasFill() {
          return !!this.fillStyle && "noFill" !== this.fillStyle.fillType;
        }
        createDisplayObject() {
          var t2;
          if (!this.fillStyle) return null;
          if (this.config.useSlideBackgroundFill && this.ctx.bgTexture) {
            const t3 = new ep();
            return t3.texture = this.ctx.bgTexture, t3;
          }
          if ("solidFill" === this.fillStyle.fillType || "noFill" === this.fillStyle.fillType) return null;
          if ("gradientFill" === this.fillStyle.fillType) {
            const t3 = new ep(), e2 = Wg(JSON.parse(JSON.stringify(this.fillStyle)), this.width, this.height), i2 = Vh.p.create({ width: this.width, height: this.height, resolution: this.ctx.renderer.resolution });
            return this.ctx.renderer.render(e2, { renderTexture: i2 }), e2.destroy({ children: true, texture: true }), t3.texture = i2, t3;
          }
          if ("blipFill" === this.fillStyle.fillType) {
            const { src: e2, filters: i2 } = this.fillStyle, n2 = this.ctx.spriteTexture.getTexture(e2), r2 = this.ctx.spriteTexture.getFrameData(e2);
            if (n2) {
              const e3 = new ep();
              if (e3.texture = n2, i2.length > 0 && this.config.useFilter && (this.ctx.featureList || {}).filter && (e3.filters = av(i2, this.ctx.featureList)), this.config.fillFloat) {
                const { l: i3, t: n3, r: r3, b: o2 } = this.config.fillFloat.fillRect, s2 = this.width * (1 - i3 - r3), a2 = this.height * (1 - n3 - o2), l2 = null !== (t2 = this.config.shapeRotation) && void 0 !== t2 ? t2 : 0, h2 = new Jd();
                h2.drawRect(0, 0, s2, a2), h2.pivot.x = s2 / 2, h2.pivot.y = a2 / 2, h2.rotation = l2;
                const u2 = h2.getBounds(), c2 = u2.width, d2 = u2.height;
                e3.width = c2, e3.height = d2, e3.anchor.x = 0.5, e3.anchor.y = 0.5, e3.rotation = -1 * l2, e3.name = "math-texture", 0 === l2 ? (e3.position.x = c2 / 2 + i3 * this.width, e3.position.y = d2 / 2 + n3 * this.height) : (e3.position.x = this.width / 2, e3.position.y = this.height / 2);
              } else e3.width = this.width, e3.height = this.height, r2.rotate && (e3.position.x = this.width / 2, e3.position.y = this.height / 2, e3.anchor.x = 0.5, e3.anchor.y = 0.5, e3.rotation = r2.rotate / 180 * Math.PI);
              return e3;
            }
          } else if ("gifFill" === this.fillStyle.fillType) {
            const { src: t3, delays: e2, filters: i2 } = this.fillStyle, n2 = this.ctx.spriteTexture.getGifFrames(t3).map((t4, i3) => ({ texture: t4, time: e2[i3] || 20 })), r2 = new im(n2, true);
            r2.name = Mm(), r2.width = this.width, r2.height = this.height, i2.length > 0 && this.config.useFilter && (this.ctx.featureList || {}).filter && (r2.filters = av(i2, this.ctx.featureList));
            const o2 = this.fillStyle.loop;
            let s2 = 1;
            return r2.onLoop = () => {
              s2 += 1, o2 > 0 && s2 > o2 && r2.gotoAndStop(r2.totalFrames);
            }, r2;
          }
          return null;
        }
        isSolidFill() {
          var t2;
          return "solidFill" === (null === (t2 = this.fillStyle) || void 0 === t2 ? void 0 : t2.fillType);
        }
        getSolidFillColor() {
          var t2;
          return "solidFill" === (null === (t2 = this.fillStyle) || void 0 === t2 ? void 0 : t2.fillType) ? this.fillStyle.color : "#000000";
        }
        getClonedDisplayObject() {
          const t2 = this.createDisplayObject();
          return this.clonedObjects.push(t2), t2;
        }
        destroy() {
          var t2;
          null === (t2 = this._displayObject) || void 0 === t2 || t2.destroy(), this._displayObject = null, this.clonedObjects.forEach((t3) => {
            null == t3 || t3.destroy();
          }), this.clonedObjects = [];
        }
      }
      class hv extends Vh.k {
      }
      var uv = i(113), cv = i.n(uv), dv = i(114), pv = i.n(dv);
      class fv extends hv {
        constructor(t2) {
          super(cv.a, pv.a, { uShapeFilterArea: new Float32Array([0, 0, 0, 0]), uGlowColor: mg(t2.color), uSdfSampler: Vh.t.WHITE, uSdfReady: 0, uSdfMaxDis: 0, uRad: t2.rad / 2, uSdfPosition: new Float32Array([0, 0]) }), this.priority = 3, this.json = t2;
        }
        filterAreaJustify(t2) {
          const e2 = Math.ceil(this.json.rad), i2 = Math.ceil(t2.width + 2 * e2), n2 = Math.ceil(t2.height + 2 * e2);
          return new Lh.j(t2.x - e2, t2.y - e2, i2, n2);
        }
        sdfBox(t2, e2) {
          const i2 = Math.ceil(this.json.rad), n2 = Math.ceil(t2 + 2 * i2), r2 = Math.ceil(e2 + 2 * i2);
          return new Lh.j(i2, i2, n2, r2);
        }
      }
      var mv = i(19), gv = i.n(mv), vv = i(115), _v = i.n(vv);
      class yv extends hv {
        constructor(t2) {
          super(gv.a, _v.a, { uShapeFilterArea: new Float32Array([0, 0, 0, 0]), uRad: t2.rad, uSdfSampler: Vh.t.WHITE, uSdfReady: 0, uSdfMaxDis: 1 }), this.priority = 2, this.json = t2;
        }
        filterAreaJustify(t2) {
          return t2;
        }
        sdfBox(t2, e2) {
          return new Lh.j(0, 0, t2, e2);
        }
      }
      class xv {
      }
      var bv = i(116), Tv = i.n(bv);
      class Ev extends Vh.k {
        constructor(t2) {
          super(gv.a, Tv.a, { uColor: mg(t2) });
        }
      }
      class Sv extends xv {
        constructor(t2, e2, i2) {
          super(), this.order = 1, this.outputTexture = Vh.t.WHITE, this.frameTextures = [], this.json = t2, this.effectContainer = e2, this.outputSprite = new ep(), this.targetScale = i2, this.outputSprite.scale.x = this.json.sx, this.outputSprite.scale.y = this.json.sy, this.outputSprite.skew.x = (this.targetScale.x > 0 ? 1 : -1) * this.json.kx, this.outputSprite.skew.y = (this.targetScale.y > 0 ? 1 : -1) * this.json.ky, this.outputSprite.filters = [new rm.BlurFilter(this.json.blurRad / 2, 4), new Ev(this.json.color)];
        }
        updateFrame(t2) {
          const e2 = this.frameTextures[t2];
          if (e2) {
            const t3 = this.effectContainer.getBounds(), i2 = (this.effectContainer.width - e2.width) / 2, n2 = (this.effectContainer.height - e2.height) / 2, r2 = new Lh.g(t3.x, t3.y), o2 = new Lh.g(t3.x, t3.y);
            switch (this.json.align) {
              case "tl":
                o2.x = t3.x, o2.y = t3.y;
                break;
              case "t":
                o2.x = t3.x + t3.width / 2, o2.y = t3.y, r2.x += t3.width / 2;
                break;
              case "tr":
                o2.x = t3.x + t3.width, o2.y = t3.y, r2.x += t3.width;
                break;
              case "l":
                o2.x = t3.x, o2.y = t3.y + t3.height / 2, r2.y += t3.height / 2;
                break;
              case "ctr":
                o2.x = t3.x + t3.width / 2, o2.y = t3.y + t3.height / 2, r2.x += t3.width / 2, r2.y += t3.height / 2;
                break;
              case "r":
                o2.x = t3.x + t3.width, o2.y = t3.y + t3.height / 2, r2.x += t3.width, r2.y += t3.height / 2;
                break;
              case "bl":
                o2.x = t3.x, o2.y = t3.y + t3.height, r2.y += t3.height;
                break;
              case "b":
                o2.x = t3.x + t3.width / 2, o2.y = t3.y + t3.height, r2.x += t3.width / 2, r2.y += t3.height;
                break;
              case "br":
                o2.x = t3.x + t3.width, o2.y = t3.y + t3.height, r2.x += t3.width, r2.y += t3.height;
            }
            const s2 = this.effectContainer.toLocal(o2);
            this.outputSprite.pivot.x = s2.x, this.outputSprite.pivot.y = s2.y;
            const a2 = new Lh.g(this.json.dist, 0), l2 = new Lh.d();
            l2.rotate(this.json.dir), l2.translate(r2.x + i2, r2.y + n2), l2.apply({ x: a2.x, y: a2.y }, a2);
            const h2 = this.effectContainer.toLocal(a2);
            this.outputSprite.position.x = h2.x, this.outputSprite.position.y = h2.y, this.outputSprite.texture = e2;
          }
        }
        createOutput(t2, e2) {
          this.frameTextures[e2] = t2;
        }
        setFrameOffset(t2, e2) {
        }
      }
      var wv = i(117), Av = i.n(wv);
      class Mv extends Vh.k {
        constructor(t2, e2) {
          super(gv.a, Av.a, { uStartAlpha: t2.startAlpha, uEndAlpha: t2.endAlpha, uStartPos: t2.startPos, uEndPos: t2.endPos, uHeight: e2 }), console.log(this);
        }
      }
      class Cv extends xv {
        constructor(t2, e2, i2, n2, r2) {
          super(), this.order = 2, this.outputSprite = new ep(), this.outputTexture = Vh.t.WHITE, this.frameTextures = [], this.json = t2, this.shapeScaleX = n2, this.effectContainer = e2, this.rotation = i2, this.ctx = r2, this.outputSprite.anchor.x = 0.5, this.outputSprite.anchor.y = 0.5;
          const o2 = this.effectContainer.getBounds();
          this.outputSprite.filters = [new rm.BlurFilter(this.json.blurRad / 2, 4), new Mv(this.json, o2.height)], this.outputSprite.alpha = 0.5, this.outputSprite.rotation = -1 === this.shapeScaleX ? Math.PI + 2 * this.rotation : Math.PI - 2 * this.rotation, this.outputSprite.scale.x = -1;
        }
        updateFrame(t2) {
          const e2 = this.frameTextures[t2];
          e2 && (this.outputSprite.texture = e2);
        }
        createOutput(t2, e2) {
          this.frameTextures[e2] = t2;
        }
        setFrameOffset(t2, e2) {
          const i2 = this.effectContainer.getBounds(), n2 = new Lh.g(i2.x + i2.width / 2, i2.y + i2.height / 2), r2 = new Lh.g(n2.x, n2.y + i2.height + this.json.dist), o2 = this.effectContainer.toLocal(r2);
          this.outputSprite.position.x = o2.x + t2, this.outputSprite.position.y = o2.y + e2;
        }
      }
      var Rv = i(118), Iv = i.n(Rv);
      class Pv extends hv {
        constructor(t2) {
          super(gv.a, Iv.a, {}), this.priority = 1, this.json = t2;
        }
        filterAreaJustify(t2) {
          return t2;
        }
        sdfBox() {
          return null;
        }
      }
      var Ov = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Nv extends Za.a {
        constructor(t2, e2, i2, n2, r2, o2) {
          super(), this.effects = [], this.attachs = [], this.frames = /* @__PURE__ */ new Map(), this._targetContainer = new Oh.b(), this.frameCount = 1, this.ctx = n2, this.originWidth = t2.width, this.originHeight = t2.height, this.cacheKey = i2, this.sourceSprite = new ep();
          for (const i3 of e2) switch (i3.type) {
            case "innerShadow":
              this.effects.push(new Pv(i3));
              break;
            case "softEdge":
              this.effects.push(new yv(i3));
              break;
            case "glow":
              this.effects.push(new fv(i3));
              break;
            case "reflection":
              this.attachs.push(new Cv(i3, t2, r2, o2.x, this.ctx));
              break;
            case "outerShadow":
              this.attachs.push(new Sv(i3, t2, o2));
          }
          this.effects = this.effects.sort((t3, e3) => t3.priority - e3.priority), this.attachs = this.attachs.sort((t3, e3) => t3.order - e3.order);
          for (const t3 of this.attachs) this._targetContainer.addChild(t3.outputSprite);
          this.sourceSprite.name = "source-sprite";
          const s2 = new Lh.j(0, 0, this.originWidth, this.originHeight), a2 = this.effects.map((t3) => t3.filterAreaJustify(s2)), l2 = a2.map((t3) => t3.x), h2 = a2.map((t3) => t3.y), u2 = a2.map((t3) => t3.width), c2 = a2.map((t3) => t3.height);
          this.filterArea = new Lh.j(Math.min(...l2, 0), Math.min(...h2, 0), Math.max(...u2, this.originWidth), Math.max(...c2, this.originHeight)), this.sourceSprite.filters = this.effects, this.sourceSprite.filterArea = new Lh.j(0, 0, this.filterArea.width, this.filterArea.height), this._targetSprite = new ep(), this._targetSprite.name = "effect-sprite", this._targetContainer.sortableChildren = true, this._targetSprite.zIndex = 999, this._targetContainer.addChild(this._targetSprite);
        }
        get container() {
          return this._targetContainer;
        }
        getSdfTexture(t2, e2) {
          return Ov(this, void 0, void 0, function* () {
            const i2 = `${this.cacheKey}_${t2}`, n2 = this.effects.map((t3) => ({ sdfRect: t3.sdfBox(e2.width, e2.height) })).reduce((t3, e3) => e3.sdfRect ? (t3.width < e3.sdfRect.width && (t3.width = e3.sdfRect.width), t3.height < e3.sdfRect.height && (t3.height = e3.sdfRect.height), t3) : t3, new Lh.j(0, 0));
            return 0 === n2.width || 0 === n2.height ? null : this.ctx.sdfManager.getSdf(e2, n2, i2);
          });
        }
        setFrameCount(t2) {
          this.frameCount = t2;
        }
        updateFrame(t2) {
          const e2 = this.frames.get(t2);
          if (e2) {
            this._targetSprite.texture = e2.texture, this._targetSprite.pivot.x = e2.pivotX, this._targetSprite.pivot.y = e2.pivotY;
            for (const e3 of this.attachs) e3.updateFrame(t2);
          }
        }
        hasFrame(t2) {
          return this.frames.has(t2);
        }
        setFrameOffset(t2, e2) {
          this._targetContainer.position.x = -1 * t2, this._targetContainer.position.y = -1 * e2, this.attachs.forEach((i2) => i2.setFrameOffset(t2, e2));
        }
        createFrame(t2, e2) {
          var i2, n2;
          return Ov(this, void 0, void 0, function* () {
            const r2 = e2.width, o2 = e2.height;
            if (this.frames.has(t2)) return;
            const s2 = yield this.getSdfTexture(t2, e2), a2 = null !== (i2 = null == s2 ? void 0 : s2.texture.width) && void 0 !== i2 ? i2 : 0, l2 = null !== (n2 = null == s2 ? void 0 : s2.texture.height) && void 0 !== n2 ? n2 : 0;
            for (const t3 of this.effects) {
              const i3 = t3.sdfBox(e2.width, e2.height);
              i3 && s2 && (t3.uniforms.uSdfSampler = s2.texture, t3.uniforms.uSdfIsReady = 1, t3.uniforms.uSdfMaxDis = s2.maxDis, t3.uniforms.uSdfPosition = new Float32Array([(s2.texture.width - i3.width) / 2 / s2.texture.width, (s2.texture.height - i3.height) / 2 / s2.texture.height])), t3.uniforms.uShapeFilterArea = new Float32Array([0, 0, this.filterArea.width, this.filterArea.height]);
            }
            this.sourceSprite.texture = e2;
            const h2 = (this.filterArea.width - this.sourceSprite.width) / 2, u2 = (this.filterArea.height - this.sourceSprite.height) / 2;
            this.sourceSprite.x = h2, this.sourceSprite.y = u2;
            const c2 = Math.max(r2, a2, this.filterArea.width), d2 = Math.max(o2, l2, this.filterArea.height), p2 = Vh.p.create({ width: c2, height: d2, resolution: this.ctx.renderer.resolution });
            this.ctx.renderer.render(this.sourceSprite, { renderTexture: p2 }), this.frames.set(t2, { texture: p2, pivotX: -1 * (this.originWidth - c2) / 2, pivotY: -1 * (this.originWidth - c2) / 2 });
            for (const e3 of this.attachs) e3.createOutput(p2, t2);
            Array.from(this.frames.keys()).length === this.frameCount && this.emit("ready");
          });
        }
      }
      var Lv = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Dv extends Sg {
        constructor(t2, e2, i2) {
          var n2;
          super(t2, e2, i2), this.textureContainer = new Oh.b(), this.underline = null, this.cacheSprite = new ep(), this.effectContainer = new Oh.b(), this.effectObject = null;
          const { shapeId: r2, paragraphIndex: o2, lineIndex: s2, unitIndex: a2, lineHeight: l2, width: h2, underLine: u2, fill: c2, height: d2, isHorz: p2, lineWidth: f2 } = t2, m2 = "solidFill" === (null === (n2 = null == c2 ? void 0 : c2.fill) || void 0 === n2 ? void 0 : n2.fillType) ? c2.fill.color : null;
          if (u2) {
            const t3 = p2 ? l2 / 16 : f2 / 16;
            this.underline = new wg(e2, u2.type, t3, h2, d2, m2, p2, r2, o2, s2, a2);
          }
          if (this.textGraphics = this.createTextGraphics(), this.textFill = this.createTextFill(), this.strokeGraphics = this.createStrokeGraphics(), this.strokeFill = this.createStrokeFill(), this.effectContainer.name = "effect-container", this.effectContainer.zIndex = 1, this.container.addChild(this.effectContainer), t2.effectIndexList && t2.effectIndexList.length && i2.effectList) {
            const { effectList: e3 } = i2;
            this.effectList = t2.effectIndexList.map((t3) => {
              const i3 = e3[t3];
              return "outerShadow" === i3.type && i3.dist > 5 && (i3.dist = 5), e3[t3];
            }), this.ctx.slideScopeEventHub.once("slide-render", (t3) => {
              if (this.ctx.slideIndex === t3 && this.effectObject) {
                const t4 = this.getEffectTexture();
                if (t4) {
                  const { texture: e4, offsetX: i3, offsetY: n3 } = t4;
                  this.effectObject.setFrameOffset(i3, n3), this.effectObject.createFrame(1, e4);
                }
              }
            });
          }
        }
        getEffectTexture() {
          const { lineHeight: t2, fillLineHeight: e2, isHorz: i2, lineWidth: n2 } = this.json, r2 = this.effectContainer.getLocalBounds();
          let o2 = 0, s2 = 0;
          for (const t3 of this.effectContainer.children) t3.pivot.x > o2 && (o2 = t3.pivot.x), t3.pivot.y > s2 && (s2 = t3.pivot.y);
          const a2 = new Lh.d();
          a2.translate(o2, s2);
          const l2 = Vh.p.create({ width: i2 ? r2.width : n2, height: i2 ? Math.max(e2, t2) : r2.height, resolution: 2 });
          return this.ctx.renderer.render(this.effectContainer, { renderTexture: l2, transform: a2 }), { texture: l2, offsetX: o2, offsetY: s2 };
        }
        createStrokeFill() {
          const { stroke: t2, lineWidth: e2, lineHeight: i2 } = this.json;
          return new lv(this.ctx, null == t2 ? void 0 : t2.fill, e2, i2, { useFilter: false, useSlideBackgroundFill: false });
        }
        createStrokeGraphics() {
          const { stroke: t2 } = this.json, e2 = (null == t2 ? void 0 : t2.key) ? { fillType: "blipFill", src: t2.key, filters: [] } : void 0;
          return new lv(this.ctx, e2, (null == t2 ? void 0 : t2.width) || 0, (null == t2 ? void 0 : t2.height) || 0, { useFilter: false, useSlideBackgroundFill: false });
        }
        applyEffectCacheAsBitMap() {
        }
        createTextFill() {
          const { isHorz: t2, fill: e2, lineWidth: i2, lineHeight: n2, fillLineHeight: r2 } = this.json;
          return t2 ? new lv(this.ctx, null == e2 ? void 0 : e2.fill, i2, Math.max(r2, n2), { useFilter: false, useSlideBackgroundFill: false }) : new lv(this.ctx, null == e2 ? void 0 : e2.fill, r2, n2, { useFilter: false, useSlideBackgroundFill: false });
        }
        createTextGraphics() {
          var t2;
          const { fill: e2, content: i2 } = this.json;
          let n2 = "#000000";
          "solidFill" === (null === (t2 = null == e2 ? void 0 : e2.fill) || void 0 === t2 ? void 0 : t2.fillType) && (n2 = e2.fill.color);
          const r2 = (null == e2 ? void 0 : e2.key) ? { fillType: "blipFill", src: e2.key, filters: [{ type: "changeBulletColor", args: ["#000000", n2] }] } : void 0;
          return new lv(this.ctx, r2, (null == e2 ? void 0 : e2.width) || 0, (null == e2 ? void 0 : e2.height) || 0, { useFilter: "\u25FE" === i2, useSlideBackgroundFill: false });
        }
        getIterateEntry() {
          return null;
        }
        getBgElement() {
          return null;
        }
        updateTransform(t2) {
          var e2, i2, n2, r2;
          const { isHorz: o2 } = this.json;
          t2.position = { x: o2 && null !== (i2 = null === (e2 = t2.position) || void 0 === e2 ? void 0 : e2.x) && void 0 !== i2 ? i2 : 0, y: o2 ? 0 : null !== (r2 = null === (n2 = t2.position) || void 0 === n2 ? void 0 : n2.y) && void 0 !== r2 ? r2 : 0 }, t2.width = o2 ? this.json.width : this.json.lineWidth, t2.height = o2 ? this.json.lineHeight : this.json.height, super.updateTransform(t2);
        }
        preRender() {
          var t2;
          null === (t2 = this.underline) || void 0 === t2 || t2.preRender();
        }
        render(t2) {
          t2.addSubMTask(() => Lv(this, void 0, void 0, function* () {
            this.doRender();
          }), "@TextUnitImpl[doRender]"), t2.addSubMTask(() => Lv(this, void 0, void 0, function* () {
            var t3;
            if (this.effectList && this.effectList.length > 0) {
              const e2 = `${this.ctx.taskId}_${this.ctx.slideIndex}_${null === (t3 = this.json.fill) || void 0 === t3 ? void 0 : t3.key}_${this.json.effectIndexList}`;
              this.effectObject = new Nv(this.effectContainer, this.effectList, e2, this.ctx, 0, new Lh.g(1, 1)), this.effectObject.on("ready", () => {
                var t4;
                this.effectContainer.visible = false, this.effectObject.container.zIndex = 10, this.container.addChild(this.effectObject.container), null === (t4 = this.effectObject) || void 0 === t4 || t4.updateFrame(1);
              });
            }
          }), "@ShapeImpl[post.render]");
        }
        doRender() {
          let t2 = false;
          const { lineWidth: e2, lineHeight: i2, baseLine: n2, isHorz: r2, underline: o2, height: s2, width: a2, highlightColor: l2, x: h2, y: u2, content: c2, fillLineHeight: d2, fill: p2 } = this.json;
          let f2 = false !== this.json.needFill;
          if (p2 && p2.fill && "solidFill" !== p2.fill.fillType && (f2 = true), l2) {
            const t3 = new Jd(), [n3, o3] = fg(l2);
            t3.beginFill(n3, o3), t3.drawRect(0, 0, r2 ? a2 : e2, r2 ? i2 : s2), t3.endFill(), this.textureContainer.addChild(t3);
          }
          if (this.textGraphics.displayObject) {
            const e3 = this.textGraphics.displayObject;
            if (r2 && (e3.position.y = u2 > 0 ? u2 : 0), f2) {
              const i3 = this.textFill.displayObject;
              if (i3) i3.mask = e3, i3.addChild(e3), i3.position.x = -h2, e3.position.x += h2, t2 = true, this.textureContainer.addChild(i3);
              else if (this.textFill.isSolidFill()) {
                const i4 = new _g();
                i4.color = this.textFill.getSolidFillColor(), e3.filters = [i4], t2 = true, this.textureContainer.addChild(e3);
              }
            } else this.textureContainer.addChild(e3);
          }
          if (this.strokeGraphics.displayObject) {
            const e3 = this.strokeGraphics.displayObject;
            if (f2) {
              const i3 = this.strokeFill.displayObject;
              if (i3) i3.mask = e3, i3.addChild(e3), r2 ? i3.position.y = u2 > 0 ? u2 : 0 : i3.position.x = h2, this.textureContainer.addChild(i3);
              else if (this.strokeFill.isSolidFill()) {
                r2 ? e3.position.y = u2 > 0 ? u2 : 0 : e3.position.x = h2;
                const i4 = new _g();
                i4.color = this.strokeFill.getSolidFillColor(), e3.filters = [i4], t2 = true, this.textureContainer.addChild(e3);
              }
            } else r2 ? e3.position.y = u2 > 0 ? u2 : 0 : e3.position.x = h2, this.textureContainer.addChild(e3);
          }
          if (this.underline && (this.underline.render(), this.underline.sprite)) {
            r2 ? (this.underline.sprite.position.y = o2 ? o2 - i2 / 16 : n2, this.underline.sprite.position.x = 0) : (this.underline.sprite.position.x = 0, this.underline.sprite.position.y = 0);
            const t3 = this.textFill.getClonedDisplayObject();
            t3 ? (t3.mask = this.underline.sprite, t3.addChild(this.underline.sprite), this.textureContainer.addChild(t3)) : this.textureContainer.addChild(this.underline.sprite);
          }
          if (t2) {
            const t3 = Vh.p.create({ width: r2 ? a2 : e2, height: r2 ? Math.max(d2, i2) : s2, resolution: this.ctx.renderer.resolution });
            this.ctx.renderer.render(this.textureContainer, { renderTexture: t3 }), this.cacheSprite.texture = t3, r2 && u2 < 0 && (this.cacheSprite.position.y = u2), this.effectContainer.addChild(this.cacheSprite);
          } else this.effectContainer.addChild(this.textureContainer);
          this.container.name = c2;
        }
        destroy() {
          this.textFill.destroy(), this.textGraphics.destroy(), this.strokeFill.destroy(), this.strokeGraphics.destroy(), this.cacheSprite.texture.destroy(true), this.cacheSprite.destroy(), this.textureContainer.destroy(), this.container.destroy();
        }
      }
      var Fv = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Bv extends Sg {
        constructor(t2, e2, i2) {
          super(t2, e2, i2), this.units = [], this.isHorz = true, this.hyperLinkMap = /* @__PURE__ */ new Map(), this.hyperLinkContainerMap = /* @__PURE__ */ new Map(), this.effectList = [], i2.effectList && (this.effectList = i2.effectList);
        }
        getIterateElements() {
          return this.units;
        }
        getIterateEntry(t2, e2, i2) {
          return this.units[e2] ? this.units[e2] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
        }
        preRender() {
        }
        applyEffectCacheAsBitMap() {
        }
        createUnits(t2, e2, i2, n2) {
          for (let r2 = 0, o2 = this.json.textUnits.length; r2 < o2; r2++) n2.addSubMTask(() => Fv(this, void 0, void 0, function* () {
            const n3 = this.json.textUnits[r2], { height: o3, width: s2, fillHeight: a2, baseline: l2, y: h2, underline: u2 } = this.json, c2 = new Dv(Object.assign(Object.assign({}, n3), { lineHeight: o3, lineWidth: s2, baseLine: l2 - h2, underline: u2, fillLineHeight: a2 || o3, isHorz: this.isHorz, shapeId: t2, paragraphIndex: e2, lineIndex: i2, unitIndex: r2 }), this.ctx, { parentGlobalPos: this.global, effectList: this.effectList });
            if (c2.preRender(), this.units.push(c2), n3.hyperlink || n3.hlinkHover) {
              const t3 = new og(c2.container, this.ctx);
              n3.hyperlink && t3.addAction(n3.hyperlink, "click"), n3.hlinkHover && t3.addAction(n3.hlinkHover, "hover"), this.container.sortableChildren = true;
            }
          }), "@TextLineImpl[createUnits]");
        }
        render(t2) {
          for (const e2 of this.units.reverse()) e2.render(t2), t2.addSubMTask(() => Fv(this, void 0, void 0, function* () {
            this.container.addChild(e2.container);
          }), "@TextLineImpl[container.addChild]");
        }
        destroy() {
          this.units.forEach((t2) => {
            t2.destroy();
          }), this.container.destroy({ children: false }), this.hyperLinkMap.clear();
          for (const t2 of this.hyperLinkContainerMap.values()) t2.destroy({ children: true, baseTexture: true, texture: true });
          this.hyperLinkContainerMap.clear();
        }
      }
      var Uv = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class kv extends Sg {
        constructor(t2, e2, i2) {
          super(t2, e2, i2), this.iterateElements = [], this.lines = [], this.effectList = [], this.isHorz = true, i2.effectList && (this.effectList = i2.effectList);
        }
        getIterateElements() {
          if (this.iterateElements.length > 0) return this.iterateElements;
          const t2 = this.lines.reduce((t3, e2) => t3 = t3.concat(e2.getIterateElements()), []);
          return this.iterateElements = t2, t2;
        }
        getIterateEntry(t2, e2, i2) {
          const n2 = this.getIterateElements();
          return n2[e2] ? n2[e2] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
        }
        preRender() {
        }
        applyEffectCacheAsBitMap() {
        }
        createLines(t2, e2, i2) {
          for (let n2 = 0, r2 = this.json.lines.length; n2 < r2; n2++) i2.addSubMTask(() => Uv(this, void 0, void 0, function* () {
            const r3 = this.json.lines[n2], o2 = new Bv(r3, this.ctx, { parentGlobalPos: this.global, effectList: this.effectList });
            o2.isHorz = this.isHorz, o2.container.name = "line-" + n2, o2.createUnits(t2, e2, n2, i2), this.lines.push(o2);
          }), "@TextParagraphImpl[createLines]");
        }
        render(t2) {
          for (const e2 of this.lines) e2.render(t2), t2.addSubMTask(() => Uv(this, void 0, void 0, function* () {
            this.container.addChild(e2.container);
          }), "@TextParagraphImpl[container.addChild]");
        }
        destroy() {
          this.lines.forEach((t2) => {
            t2.destroy();
          }), this.container.destroy({ children: false });
        }
      }
      function Gv(t2, e2, i2) {
        let n2, r2;
        const o2 = Math.round(t2) % 360;
        if (o2 % 180 == 0) n2 = Math.cos(o2 * (Math.PI / 180)) * e2, r2 = 0;
        else if (o2 % 90 == 0) n2 = 0, r2 = -Math.sin(o2 * (Math.PI / 180)) * i2;
        else {
          const t3 = Math.tan(o2 * Math.PI / 180);
          n2 = e2 * i2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(e2 * t3, 2)), (o2 > 90 && o2 < 270 || o2 < -90 && o2 > -270) && (n2 = -n2), r2 = -t3 * n2;
        }
        return { x: n2, y: r2 };
      }
      function Hv(t2, e2, i2, n2, r2, o2) {
        const s2 = Gv((r2 = -r2) / Math.PI * 180, i2, n2), a2 = t2.x - s2.x, l2 = t2.y - s2.y;
        return { centerX: a2 / 9525 * e2.x, centerY: l2 / 9525 * e2.y, rx: i2 / 9525 * e2.x, ry: n2 / 9525 * e2.y, st: -r2, end: -r2 + o2, aClockWise: o2 < 0 };
      }
      function jv(t2) {
        const e2 = new zs(), { scale: i2 } = t2;
        let n2 = { x: 0, y: 0 };
        const r2 = t2.path.trim().split(" ");
        for (let t3 = 0; t3 < r2.length; t3 += 2) {
          const o2 = r2[t3], s2 = r2[t3 + 1];
          if ("M" === o2) {
            let [t4, r3] = s2.split(",").map((t5) => Number(t5));
            n2 = { x: t4, y: r3 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, e2.moveTo(t4, r3);
          } else if ("A" === o2) {
            const [t4, r3, o3, a2] = s2.split(",").map((t5) => Number(t5)), { centerX: l2, centerY: h2, rx: u2, ry: c2, st: d2, end: p2, aClockWise: f2 } = Hv(n2, i2, t4, r3, o3, a2);
            e2.absellipse(l2, h2, u2, c2, d2, p2, f2, 0);
          } else if ("L" === o2) {
            let [t4, r3] = s2.split(",").map((t5) => Number(t5));
            n2 = { x: t4, y: r3 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, e2.lineTo(t4, r3);
          } else if ("QB" === o2) {
            let [t4, r3, o3, a2] = s2.split(",").map((t5) => Number(t5));
            n2 = { x: o3, y: a2 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, o3 = o3 / 9525 * i2.x, a2 = a2 / 9525 * i2.y, e2.quadraticCurveTo(t4, r3, o3, a2);
          } else if ("CB" === o2) {
            let [t4, r3, o3, a2, l2, h2] = s2.split(",").map((t5) => Number(t5));
            n2 = { x: l2, y: h2 }, t4 = t4 / 9525 * i2.x, r3 = r3 / 9525 * i2.y, o3 = o3 / 9525 * i2.x, a2 = a2 / 9525 * i2.y, l2 = l2 / 9525 * i2.x, h2 = h2 / 9525 * i2.y, e2.bezierCurveTo(t4, r3, o3, a2, l2, h2);
          } else if ("C" === o2) try {
            e2.closePath();
          } catch (t4) {
          }
        }
        return e2;
      }
      function zv(t2, e2) {
        return t2.curves.map((t3) => t3.getPoints(e2)).reduce((t3, e3) => t3.concat(e3), []);
      }
      const Vv = { textCirclePour: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textStop: { top: (t2) => zv(t2, 100), bottom: (t2) => zv(t2, 100) }, textPlain: { top: (t2) => zv(t2, 100), bottom: (t2) => zv(t2, 100) }, textTriangle: { top: (t2) => zv(t2, 50), bottom: (t2) => zv(t2, 101) }, textTriangleInverted: { bottom: (t2) => zv(t2, 50), top: (t2) => zv(t2, 101) }, textChevron: { bottom: (t2) => zv(t2, 50), top: (t2) => zv(t2, 50) }, textChevronInverted: { bottom: (t2) => zv(t2, 50), top: (t2) => zv(t2, 50) }, textRingInside: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textRingOutside: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textArchUpPour: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textArchDownPour: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCurveUp: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCurveDown: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCanUp: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textCanDown: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textWave1: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textWave2: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textDoubleWave1: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textWave4: { top: (t2) => t2.getPoints(360), bottom: (t2) => t2.getPoints(360) }, textInflate: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textDeflate: { top: (t2) => t2.getPoints(180), bottom: (t2) => t2.getPoints(180) }, textInflateBottom: { top: (t2) => zv(t2, 180), bottom: (t2) => t2.getPoints(180) }, textDeflateBottom: { top: (t2) => zv(t2, 180), bottom: (t2) => t2.getPoints(180) }, textInflateTop: { bottom: (t2) => zv(t2, 180), top: (t2) => t2.getPoints(180) }, textDeflateTop: { bottom: (t2) => zv(t2, 180), top: (t2) => t2.getPoints(180) }, textFadeRight: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textFadeLeft: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textFadeUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textFadeDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textSlantUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textSlantDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textCascadeUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textCascadeDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textArchUp: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textArchDown: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) }, textCircle: { bottom: (t2) => zv(t2, 180), top: (t2) => zv(t2, 180) } };
      function Xv(t2, e2, i2, n2, r2) {
        const o2 = t2.trim().split(" "), [s2, a2] = o2[1].split(",").map((t3) => parseFloat(t3)), [l2, h2, u2, c2] = o2[3].split(",").map((t3) => parseFloat(t3)), d2 = function(t3, e3, i3, n3, r3, o3) {
          const s3 = Math.abs(o3 * Math.sqrt((i3 * i3 + n3 * n3) / 2)), a3 = Math.ceil(s3 / 9525 / 10);
          let l3 = 0, h3 = r3, u3 = { x: t3 + i3 * Math.cos(h3), y: e3 + n3 * Math.sin(h3) };
          for (let r4 = 0; r4 < a3; r4 += 1) {
            h3 += o3 / a3;
            const r5 = { x: t3 + i3 * Math.cos(h3), y: e3 + n3 * Math.sin(h3) };
            l3 += Math.sqrt(Math.pow(r5.x - u3.x, 2) + Math.pow(r5.y - u3.y, 2)), u3 = r5;
          }
          return l3;
        }(s2, a2, l2, h2, u2, c2);
        r2 *= Math.min(1, d2 / 9525 / n2);
        const p2 = new Lh.d();
        p2.translate(r2 + e2 / 2, 0), p2.rotate(2 * Math.PI - u2);
        const f2 = new Lh.g(0, 0), m2 = p2.apply(f2);
        m2.x += e2 / 2, m2.y = i2 / 2 - m2.y;
        const g2 = l2 + 9525 * r2, v2 = h2 + 9525 * r2;
        return `M ${9525 * m2.x},${9525 * m2.y} A ${g2},${v2},${u2},${c2}`;
      }
      var Wv = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Yv {
        constructor(t2, e2, i2, n2, r2) {
          var o2;
          this.iterateElements = [], this.paragraphs = [], this.effectList = [], this.container = new Oh.b(), this.textContainer = new Oh.b(), this.textColorFilter = new _g(), this.json = t2, this.ctx = e2, this.shapeRotation = r2, this.parentGlobalPos = n2, this.iterateType = i2, this.container.name = "textBody", this.global = { x: this.parentGlobalPos.x + t2.position.x, y: this.parentGlobalPos.y + t2.position.y }, this.container.position.x = t2.position.x, this.container.position.y = t2.position.y, this.container.scale.x = t2.scale.x, this.container.scale.y = t2.scale.y;
          const s2 = new Jd();
          s2.drawRect(0, 0, t2.width, t2.height), this.container.addChild(s2), this.container.addChild(this.textContainer), this.textColorFilter.currentColor = "#000000FF", this.textColorFilter.designColor = "#000000FF", this.effectList = null !== (o2 = t2.effectList) && void 0 !== o2 ? o2 : [];
        }
        get width() {
          return this.json.width;
        }
        get height() {
          return this.json.height;
        }
        get x() {
          return this.json.position.x;
        }
        get y() {
          return this.json.position.y;
        }
        set color(t2) {
          var e2;
          (null !== (e2 = this.container.filters) && void 0 !== e2 ? e2 : []).length > 0 && (this.textColorFilter.color = t2);
        }
        get color() {
          return this.textColorFilter.color;
        }
        get on() {
          var t2;
          return (null !== (t2 = this.container.filters) && void 0 !== t2 ? t2 : []).length > 0 ? "true" : "false";
        }
        set on(t2) {
          var e2;
          "true" === t2 ? (null !== (e2 = this.container.filters) && void 0 !== e2 ? e2 : []).indexOf(this.textColorFilter) < 0 && (this.container.filters = [this.textColorFilter]) : this.container.filters = [];
        }
        getTextElement(t2, e2) {
          return "paragraph" === t2 ? this.paragraphs[e2[0]] : null;
        }
        getIterateEntry(t2, e2) {
          return this.iterateElements[t2] ? this.iterateElements[t2] : (this.ctx.eventHub.emit("IterateTimeNodeEnd", e2), null);
        }
        applyEffectCacheAsBitMap() {
        }
        destroy() {
          this.paragraphs.forEach((t2) => {
            t2.destroy();
          }), this.textColorFilter.destroy();
        }
        createParagraphs(t2, e2) {
          for (let i2 = 0, n2 = this.json.paragraphs.length; i2 < n2; i2++) e2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
            var n3;
            const r2 = this.json.paragraphs[i2], o2 = new kv(r2, this.ctx, { parentGlobalPos: this.global, effectList: this.effectList });
            o2.isHorz = null === (n3 = this.json.isHorz) || void 0 === n3 || n3, o2.createLines(t2, i2, e2), e2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
              this.iterateElements = this.iterateElements.concat(o2.getIterateElements()), o2.container.name = "\u6BB5\u843D-" + i2, this.paragraphs.push(o2);
            }), "@TextBodyImpl[paragraphs.push]");
          }), "@TextBodyImpl[createParagraphs]");
        }
        render(t2) {
          for (const e2 of this.paragraphs) e2.render(t2), t2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
            this.textContainer.addChild(e2.container);
          }), "@TextBodyImpl[container.addChild]");
          t2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
            const { width: t3 } = this.container;
            this.container.scale.x < 0 && (this.container.x += -1 * t3);
          }), "@TextBodyImpl[reset width]"), t2.addSubMTask(() => Wv(this, void 0, void 0, function* () {
            if (this.json.presetTextShape) {
              const t3 = this.json.paragraphs.map((t4) => t4.x).reduce((t4, e3) => Math.min(t4, e3)), e2 = this.json.paragraphs[0].y, i2 = this.textContainer.getBounds(), { width: n2, height: r2 } = i2, { geometry: o2, type: s2 } = this.json.presetTextShape;
              if (o2.paths) {
                const i3 = Vh.p.create({ width: n2, height: r2, resolution: this.ctx.renderer.resolution }), a2 = new Lh.d();
                a2.translate(-t3, -e2), this.ctx.renderer.render(this.textContainer, { renderTexture: i3, transform: a2 });
                const l2 = void 0 !== this.json.isHorz && !this.json.isHorz;
                if (["textCircle", "textArchUp", "textArchDown"].indexOf(this.json.presetTextShape.type) >= 0) {
                  const t4 = Xv(o2.paths[0].path, this.json.width, this.json.height, n2, r2);
                  o2.paths.unshift(Object.assign(Object.assign({}, o2.paths[0]), { path: t4 }));
                }
                const h2 = function(t4, e3, i4, n3) {
                  if (!Vv[i4]) return null;
                  const r3 = Vv[i4].top(jv(e3)), o3 = Vv[i4].bottom(jv(t4));
                  if (r3.length !== o3.length) return null;
                  const s3 = Math.min(r3.length, o3.length), a3 = 1 / (s3 - 1), l3 = [], h3 = [], u2 = new Array(2 * s3).fill("").map((t5, e4) => e4);
                  for (let t5 = 0; t5 < s3; t5++) l3.push(r3[t5].x, r3[t5].y), n3 ? h3.push(1, a3 * t5) : h3.push(a3 * t5, 0), l3.push(o3[t5].x, o3[t5].y), n3 ? h3.push(0, a3 * t5) : h3.push(a3 * t5, 1);
                  return { vertices: new Float32Array(l3), uvs: new Float32Array(h3), drawMode: Sc.f.TRIANGLE_STRIP, indices: new Uint16Array(u2) };
                }(o2.paths[1], o2.paths[0], s2, l2);
                if (h2) {
                  const t4 = new tm.b(i3, h2.vertices, h2.uvs, h2.indices, h2.drawMode);
                  this.textContainer.visible = false, this.container.addChild(t4);
                }
              }
            }
          }), "presetTextShape");
        }
      }
      class qv {
        constructor(t2) {
          this.scaleX = 1, this.scaleY = 1, this.pivot = { x: 0, y: 0 }, this.paths = [], this.hash = "", this.width = 0, this.height = 0, this.graphicsId = "", this.textureId = "", this.id = t2.id, this.type = t2.type, this.heightSize = t2.heightSize, this.widthSize = t2.widthSize, this.fillStyle = t2.fillStyle || { fillType: "solidFill", color: "#ffffffff" }, this.lineWidth = t2.lineWidth || 1, this.position = t2.position || { x: 0, y: 0 }, this.rotate = t2.rotation || 1, this.path = this.getUnitPath(), this.setScaleFromLineWidth(), this.setScaleFromSize(), this.generatePaths(), this.setPivot();
        }
        setPivot() {
          switch (this.type) {
            case "oval":
            case "diamond":
              this.pivot = { x: this.width / 2, y: this.height / 2 };
              break;
            case "triangle":
              this.pivot = { x: 0.7 * this.width, y: this.height / 2 };
              break;
            case "arrow":
            case "stealth":
            default:
              this.pivot = { x: this.width, y: this.height / 2 };
          }
        }
        generatePaths() {
          this.hash = "arrow-" + jm()(this.path + this.scaleX + this.scaleY), this.paths = [{ id: this.id, path: this.path, fill: "norm", hasStroke: false, hash: this.hash, scale: { x: this.scaleX, y: this.scaleY } }];
        }
        getUnitPath() {
          switch (this.type) {
            case "stealth":
              return "M 0,0 L 95250,47625 L 0,95250 L 28575,47625 C C";
            case "oval":
              return "M 0,47625 A 47625,47625,-3.14159265,6.2831853 C C";
            case "diamond":
              return "M 47625,0 L 95250,47625 L 47625,95250 L 0,47625 C C";
            case "arrow":
              return "M 9525,0 L 95250,47625 L 9525,95250 L 0,85725 L 68389.5,47625 L 0,9525 C C";
            case "triangle":
              return "M 0,0 L 95250,47625 L 0,95250 C C";
            default:
              return "";
          }
        }
        setScaleFromLineWidth() {
          switch (this.type) {
            case "stealth":
            case "oval":
            case "diamond":
            case "arrow":
            case "triangle":
              this.scaleX *= 0.29 * this.lineWidth + 0.7, this.scaleY *= 0.29 * this.lineWidth + 0.7;
              break;
            default:
              throw new Error("can't match any arrow type!");
          }
        }
        setScaleFromSize() {
          switch (this.type) {
            case "stealth":
            case "oval":
            case "diamond":
            case "arrow":
            case "triangle":
              this.scaleX *= 1, this.scaleY *= 1;
              break;
            default:
              throw new Error("can't match any arrow type!");
          }
          switch (this.widthSize) {
            case "sm":
              this.scaleX *= 3 / 4;
              break;
            case "lg":
              this.scaleX *= 1.25;
              break;
            case "med":
              this.scaleX *= 1;
          }
          switch (this.heightSize) {
            case "sm":
              this.scaleY *= 3 / 4;
              break;
            case "lg":
              this.scaleY *= 1.25;
              break;
            case "med":
              this.scaleY *= 1;
          }
          this.width = 10 * this.scaleX, this.height = 10 * this.scaleY;
        }
      }
      class Zv {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2) {
          this.id = t2, this.ctx = e2, this.paths = i2, this.hash = n2, this.nept = r2, this.width = o2, this.height = s2, this.lineStyle = a2, this.shouldFill = l2, this.bgColor = h2, this.lnColor = u2, this.clonedObjects = [], this._displayObject = null, this.isRectangle = false, this.isPureRect = false, this.isColoredPureRect = false, this.isRectangle = this.rectangleDetect(i2), this.isRectangle && l2 ? this.bgColor ? this.isColoredPureRect = true : this.isPureRect = true : this.ctx.graphicsTexture.addGraphics(this.id, this.paths, this.hash, this.nept, this.width, this.height, this.lineStyle, this.ctx.objectPoolGroup, this.shouldFill, this.bgColor, this.lnColor);
        }
        get displayObject() {
          return this._displayObject;
        }
        pointDis(t2, e2) {
          return Math.pow(t2.x - e2.x, 2) + Math.pow(t2.y - e2.y, 2);
        }
        isPoint(t2) {
          return Number.isNaN(Number(t2.x)) || Number.isNaN(Number(t2.y));
        }
        isSquare(t2, e2) {
          if ("MLLLC" !== t2.join("") && "MLLLCC" !== t2.join("")) return false;
          const i2 = e2.filter((t3) => !this.isPoint(t3));
          if (4 !== i2.length) return false;
          const n2 = Math.min(...i2.map((t3) => t3.x)), r2 = Math.min(...i2.map((t3) => t3.y)), o2 = Math.max(...i2.map((t3) => t3.x)), s2 = Math.max(...i2.map((t3) => t3.y));
          for (const t3 of i2) if (t3.x !== n2 && t3.x !== o2 || t3.y !== r2 && t3.y !== s2) return false;
          return true;
        }
        rectangleDetect(t2) {
          if (1 !== t2.length) return false;
          const e2 = t2[0].path.trim().split(" ");
          if (10 !== e2.length) return false;
          const i2 = [], n2 = [];
          for (let t3 = 0; t3 < e2.length; t3 += 2) {
            const r3 = e2[t3], o3 = e2[t3 + 1], [s3, a2] = o3.split(",").map((t4) => Number(t4) / 100);
            i2.push(r3), n2.push({ x: s3, y: a2 });
          }
          if (this.isSquare(i2, n2)) return true;
          for (let t3 = 0; t3 < 3; t3++) {
            const e3 = n2[t3], i3 = n2[t3 + 1];
            if (e3.x !== i3.x && e3.y !== i3.y) return false;
          }
          const r2 = n2.slice(0, 4).reduce((t3, e3) => t3 + e3.x, 0) / 4, o2 = n2.slice(0, 4).reduce((t3, e3) => t3 + e3.y, 0) / 4;
          if (Number.isNaN(r2) || Number.isNaN(o2)) return false;
          const s2 = { x: r2, y: o2 };
          return sg(this.pointDis(s2, n2[0]), this.pointDis(s2, n2[1])) && sg(this.pointDis(s2, n2[0]), this.pointDis(s2, n2[2])) && sg(this.pointDis(s2, n2[0]), this.pointDis(s2, n2[3])) && this.pointDis(s2, n2[0]) === this.pointDis(s2, n2[1]);
        }
        createDisplayObject() {
          if (this.isPureRect) {
            const t2 = new Jd();
            return t2.beginFill(0, 1), t2.drawRect(0, 0, this.width, this.height), t2;
          }
          if (this.isColoredPureRect && this.bgColor) {
            const t2 = new Jd(), [e2, i2] = fg(this.bgColor);
            return t2.beginFill(e2, i2), t2.drawRect(0, 0, this.width, this.height), t2;
          }
          {
            const t2 = new ep(), e2 = this.ctx.graphicsTexture.getGraphicsData(this.id);
            return e2 ? (t2.texture = e2.texture, t2.pivot.x = e2.pivot.x, t2.pivot.y = e2.pivot.y, t2.scale.x = e2.scale, t2.scale.y = e2.scale, t2) : null;
          }
        }
        getClonedDisplayObject() {
          const t2 = this.createDisplayObject();
          return this.clonedObjects.push(t2), t2;
        }
        render() {
          this._displayObject = this.createDisplayObject();
        }
        isNeedMask(t2, e2) {
          let i2 = false;
          return this._displayObject && (i2 = !(this.isRectangle && Math.abs(t2 - this._displayObject.width) < 2 && Math.abs(e2 - this._displayObject.height) < 2 && this.shouldFill)), i2;
        }
        addArrows(t2) {
          var e2;
          null === (e2 = this._displayObject) || void 0 === e2 || e2.addChild(t2);
        }
        destroy() {
          var t2;
          null === (t2 = this._displayObject) || void 0 === t2 || t2.destroy(), this._displayObject = null, this.clonedObjects.forEach((t3) => {
            null == t3 || t3.destroy();
          }), this.clonedObjects = [];
        }
      }
      var Jv = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      const Kv = { pivot: { x: 0, y: 0 }, width: 0, height: 0 };
      class Qv extends hg {
        constructor(t2, e2, i2) {
          var n2, r2, o2, s2, a2, l2, h2, u2, c2;
          super(t2, e2, i2), this.renderContainer = new Oh.b(), this.needCacheAsBitMap = false, this.backgroundGraphics = null, this.effectList = [], this.strokeGraphics = null, this.ghco = null, this.useGroupFill = false, this.arrowList = [], this.fillColorFilter = new _g(), this.strokeColorFilter = new _g(), this.pptColorFilter = new _g(), this.id = "", this.ppt_c = new ig(this), this.fill = new ng(this), this.stroke = new tg(this), this.effectObject = null, this.effectContainer = new Oh.b(), this.effectDisposer = () => {
          }, this.json = t2, this.option = i2, this.json.fillStyle && "groupFill" === this.json.fillStyle.fillType && i2.groupFillStyle && (this.json.fillStyle = i2.groupFillStyle, this.useGroupFill = true), this.id = t2.id;
          const { fillStyle: d2, lineStyle: p2 } = this.json;
          this.container.sortableChildren = true, this.container.name = t2.id + "_container_[Shape]", this.effectContainer.name = "effect-container", this.effectContainer.zIndex = 1, this.container.addChild(this.effectContainer), this.renderContainer.name = t2.id + "_render_container_[Shape]", this.generateArrowList(), this.backgroundFill = this.createBackgroundFill(), this.backgroundGraphics = this.createBackgroundGraphics(), this.strokeFill = this.createStrokeFill(), this.strokeGraphics = this.createStrokeGraphics();
          try {
            this.ghco = new Zv(this.json.id + "-path-graphics-text-wrap", this.ctx, null !== (o2 = null === (r2 = null === (n2 = this.json.textBody) || void 0 === n2 ? void 0 : n2.presetTextShape) || void 0 === r2 ? void 0 : r2.geometry.paths) && void 0 !== o2 ? o2 : [], null !== (l2 = null === (a2 = null === (s2 = this.json.textBody) || void 0 === s2 ? void 0 : s2.presetTextShape) || void 0 === a2 ? void 0 : a2.geometry.hash) && void 0 !== l2 ? l2 : "", { x: 0, y: 0 }, (null === (h2 = this.json.textBody) || void 0 === h2 ? void 0 : h2.width) || 100, (null === (u2 = this.json.textBody) || void 0 === u2 ? void 0 : u2.height) || 100, { width: 2, fill: { fillType: "solidFill", color: "#FF0000FF" } }, false, null, null);
          } catch (t3) {
            this.ctx.logger.error(t3.message, this.ctx.taskId);
          }
          this.ctx.timingTargets.addTarget(this.id, this), "solidFill" === (null == d2 ? void 0 : d2.fillType) && (this.fillColorFilter.currentColor = d2.color, this.fillColorFilter.designColor = d2.color), "solidFill" === (null === (c2 = null == p2 ? void 0 : p2.fill) || void 0 === c2 ? void 0 : c2.fillType) && (this.strokeColorFilter.currentColor = p2.fill.color, this.strokeColorFilter.designColor = p2.fill.color), this.updateTransform(this.json), t2.textBody && (this.text = new Yv(t2.textBody, this.ctx, t2.textBody.iterateType, { x: this.designGlobalPosition.x, y: this.designGlobalPosition.y }, this.json.rotation || 0)), this.container.hitArea = new Lh.k(1, 1, this.json.width, this.json.height), this.ctx.slideScopeEventHub.once("slide-render", (t3) => {
            if (this.ctx.slideIndex === t3 && this.effectObject) {
              const t4 = this.getEffectTexture();
              if (t4) {
                const { texture: e3, offsetX: i3, offsetY: n3 } = t4;
                this.effectObject.setFrameOffset(i3, n3), this.effectObject.createFrame(1, e3);
              }
            }
          });
        }
        get interactiveContainer() {
          return this.renderContainer;
        }
        get strokeActive() {
          var t2, e2, i2, n2, r2, o2, s2;
          return this.strokeFill.displayObject ? (null !== (i2 = null === (e2 = null === (t2 = this.strokeFill.displayObject) || void 0 === t2 ? void 0 : t2.filters) || void 0 === e2 ? void 0 : e2.length) && void 0 !== i2 ? i2 : -1) > 0 : (null !== (s2 = null === (o2 = null === (r2 = null === (n2 = this.strokeGraphics) || void 0 === n2 ? void 0 : n2.displayObject) || void 0 === r2 ? void 0 : r2.filters) || void 0 === o2 ? void 0 : o2.length) && void 0 !== s2 ? s2 : -1) > 0;
        }
        set strokeActive(t2) {
          var e2, i2, n2, r2, o2, s2;
          const { displayObject: a2 } = this.strokeFill;
          t2 ? a2 && (null !== (i2 = null === (e2 = a2.filters) || void 0 === e2 ? void 0 : e2.indexOf(this.strokeColorFilter)) && void 0 !== i2 ? i2 : -1) < 0 ? a2.filters = [this.strokeColorFilter] : (null === (n2 = this.strokeGraphics) || void 0 === n2 ? void 0 : n2.displayObject) && (null !== (o2 = null === (r2 = this.strokeGraphics.displayObject.filters) || void 0 === r2 ? void 0 : r2.indexOf(this.strokeColorFilter)) && void 0 !== o2 ? o2 : -1) < 0 && (this.strokeGraphics.displayObject.filters = [this.strokeColorFilter]) : a2 ? a2.filters = [] : (null === (s2 = this.strokeGraphics) || void 0 === s2 ? void 0 : s2.displayObject) && (this.strokeGraphics.displayObject.filters = []);
        }
        get pptColorActive() {
          var t2, e2;
          return (null !== (e2 = null === (t2 = this.renderContainer.filters) || void 0 === t2 ? void 0 : t2.length) && void 0 !== e2 ? e2 : -1) > 0;
        }
        set pptColorActive(t2) {
          this.renderContainer.filters = t2 ? [this.pptColorFilter] : [];
        }
        get fillActive() {
          var t2, e2, i2, n2, r2, o2, s2;
          return this.backgroundFill.displayObject ? (null !== (i2 = null === (e2 = null === (t2 = this.backgroundFill.displayObject) || void 0 === t2 ? void 0 : t2.filters) || void 0 === e2 ? void 0 : e2.length) && void 0 !== i2 ? i2 : -1) > 0 : (null !== (s2 = null === (o2 = null === (r2 = null === (n2 = this.backgroundGraphics) || void 0 === n2 ? void 0 : n2.displayObject) || void 0 === r2 ? void 0 : r2.filters) || void 0 === o2 ? void 0 : o2.length) && void 0 !== s2 ? s2 : -1) > 0;
        }
        set fillActive(t2) {
          var e2, i2, n2, r2, o2, s2;
          t2 ? this.backgroundFill.displayObject && (null !== (i2 = null === (e2 = this.backgroundFill.displayObject.filters) || void 0 === e2 ? void 0 : e2.indexOf(this.fillColorFilter)) && void 0 !== i2 ? i2 : -1) < 0 ? this.backgroundFill.displayObject.filters = [this.fillColorFilter] : (null === (n2 = this.backgroundGraphics) || void 0 === n2 ? void 0 : n2.displayObject) && (null !== (o2 = null === (r2 = this.backgroundGraphics.displayObject.filters) || void 0 === r2 ? void 0 : r2.indexOf(this.fillColorFilter)) && void 0 !== o2 ? o2 : -1) < 0 && (this.backgroundGraphics.displayObject.filters = [this.fillColorFilter]) : this.backgroundFill.displayObject ? this.backgroundFill.displayObject.filters = [] : (null === (s2 = this.backgroundGraphics) || void 0 === s2 ? void 0 : s2.displayObject) && (this.backgroundGraphics.displayObject.filters = []);
        }
        getTextElement(t2, e2) {
          var i2, n2;
          if (this.json.isMathFallback) {
            if (!this.json.textBody) return this;
            const t3 = () => this.json.textBody.paragraphs[0].lines.length <= 1, e3 = () => this.json.textBody.paragraphs[0].lines[0].textUnits.length <= 1, i3 = () => "" === this.json.textBody.paragraphs[0].lines[0].textUnits[0].content.trim();
            if ((() => this.json.textBody.paragraphs.length <= 1)() && t3() && e3() && i3()) return this;
          }
          return null !== (n2 = null === (i2 = this.text) || void 0 === i2 ? void 0 : i2.getTextElement(t2, e2)) && void 0 !== n2 ? n2 : null;
        }
        getBgElement() {
          return this;
        }
        getIterateEntry(t2, e2, i2) {
          return 0 === e2 ? this : "el" === t2 ? (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null) : this.text ? this.text.getIterateEntry(e2 - 1, i2) || null : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
        }
        getEffectTexture() {
          const t2 = this.effectContainer.getLocalBounds();
          let e2 = 0, i2 = 0;
          for (const t3 of this.effectContainer.children) t3.pivot.x > e2 && (e2 = t3.pivot.x), t3.pivot.y > i2 && (i2 = t3.pivot.y);
          const n2 = new Lh.d();
          if (n2.translate(e2, i2), 0 === this.effectContainer.children.length) return null;
          const r2 = Vh.p.create({ width: t2.width, height: t2.height, resolution: this.ctx.renderer.resolution });
          return this.ctx.renderer.render(this.effectContainer, { renderTexture: r2, transform: n2 }), { texture: r2, offsetX: e2, offsetY: i2 };
        }
        createStrokeGraphics() {
          var t2, e2, i2, n2;
          const { id: r2, geometry: o2, lineStyle: s2 } = this.json, { width: a2, height: l2, pivot: h2 } = (null == o2 ? void 0 : o2.lineTransform) || Kv, u2 = a2 || this.json.width, c2 = l2 || this.json.height, d2 = "solidFill" === (null === (t2 = null == s2 ? void 0 : s2.fill) || void 0 === t2 ? void 0 : t2.fillType) ? s2.fill.color : null;
          return s2 && "noFill" !== (null === (e2 = s2.fill) || void 0 === e2 ? void 0 : e2.fillType) ? new Zv(r2 + "-path-graphics", this.ctx, null !== (i2 = null == o2 ? void 0 : o2.paths) && void 0 !== i2 ? i2 : [], null !== (n2 = null == o2 ? void 0 : o2.hash) && void 0 !== n2 ? n2 : "", h2 || { x: 0, y: 0 }, u2, c2, s2, false, null, d2) : null;
        }
        createStrokeFill() {
          const [t2, e2] = this.calculateFillObjectOffset(), { geometry: i2, lineStyle: n2, width: r2, height: o2 } = this.json, s2 = (null == i2 ? void 0 : i2.lineTransform) || Kv, a2 = Vm()(null == n2 ? void 0 : n2.width) ? n2.width : 1;
          return new lv(this.ctx, null == n2 ? void 0 : n2.fill, (s2.width || r2) + a2 + t2, Math.max((s2.height || o2) + a2, e2), { useFilter: true, useSlideBackgroundFill: false });
        }
        createBackgroundGraphics() {
          var t2;
          const { geometry: e2, lineStyle: i2, fillStyle: n2, id: r2 } = this.json, { width: o2, height: s2, pivot: a2 } = (null == e2 ? void 0 : e2.lineTransform) || Kv, l2 = o2 || this.json.width, h2 = s2 || this.json.height, u2 = "solidFill" === (null == n2 ? void 0 : n2.fillType) ? n2.color : null;
          return n2 && "noFill" !== n2.fillType || this.json.isPicture ? new Zv(r2 + "-bg-graphics", this.ctx, null !== (t2 = null == e2 ? void 0 : e2.paths) && void 0 !== t2 ? t2 : [], (null == e2 ? void 0 : e2.hash) || "", a2 || { x: 0, y: 0 }, l2, h2, i2, true, u2, null) : null;
        }
        createBackgroundFill() {
          var t2, e2, i2, n2;
          const { fillStyle: r2, width: o2, height: s2, lineStyle: a2, geometry: l2 } = this.json, h2 = (null == l2 ? void 0 : l2.fillTransform) || Kv, u2 = { useFilter: true, useSlideBackgroundFill: this.json.useBgFill, fillFloat: this.json.fillFloat, shapeRotation: this.json.rotation }, c2 = this.useGroupFill && (null === (t2 = this.option.groupSize) || void 0 === t2 ? void 0 : t2.w) ? this.option.groupSize.w : h2.width || o2, d2 = this.useGroupFill && (null === (e2 = this.option.groupSize) || void 0 === e2 ? void 0 : e2.h) ? this.option.groupSize.h : h2.height || s2;
          return new lv(this.ctx, r2, c2 + (null !== (i2 = null == a2 ? void 0 : a2.width) && void 0 !== i2 ? i2 : 0), d2 + (null !== (n2 = null == a2 ? void 0 : a2.width) && void 0 !== n2 ? n2 : 0), u2);
        }
        createBackground() {
          var t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2;
          const { pivot: d2, width: p2, height: f2 } = (null === (t2 = this.json.geometry) || void 0 === t2 ? void 0 : t2.fillTransform) || Kv, { displayObject: m2 } = this.backgroundFill;
          m2 ? (this.json.useBgFill && (null === (i2 = this.backgroundGraphics) || void 0 === i2 ? void 0 : i2.displayObject) ? (this.needCacheAsBitMap = true, m2.mask = this.backgroundGraphics.displayObject, m2.pivot.x = (null === (n2 = this.json.position) || void 0 === n2 ? void 0 : n2.x) || 0, m2.pivot.y = (null === (r2 = this.json.position) || void 0 === r2 ? void 0 : r2.y) || 0, this.effectContainer.addChild(this.backgroundGraphics.displayObject)) : "gifFill" === (null === (o2 = this.json.fillStyle) || void 0 === o2 ? void 0 : o2.fillType) ? (m2.height = f2 || this.designHeight, m2.width = p2 || this.designWidth, m2 instanceof im && m2.play(), (null === (s2 = this.backgroundGraphics) || void 0 === s2 ? void 0 : s2.isNeedMask(m2.width, m2.height)) && (m2.mask = this.backgroundGraphics.displayObject, this.backgroundGraphics.displayObject && this.effectContainer.addChild(this.backgroundGraphics.displayObject))) : (null === (a2 = this.backgroundGraphics) || void 0 === a2 ? void 0 : a2.isNeedMask(m2.width, m2.height)) && (this.json.fillFloat || (this.needCacheAsBitMap = true, m2.mask = this.backgroundGraphics.displayObject, this.backgroundGraphics.displayObject && this.effectContainer.addChild(this.backgroundGraphics.displayObject))), this.json.fillFloat || (m2.x = d2.x, m2.y = d2.y), this.useGroupFill && (m2.x -= null !== (h2 = null === (l2 = this.json.position) || void 0 === l2 ? void 0 : l2.x) && void 0 !== h2 ? h2 : 0, m2.y -= null !== (c2 = null === (u2 = this.json.position) || void 0 === u2 ? void 0 : u2.y) && void 0 !== c2 ? c2 : 0), this.effectContainer.addChild(m2)) : this.backgroundFill.hasFill && (null === (e2 = this.backgroundGraphics) || void 0 === e2 ? void 0 : e2.displayObject) && this.effectContainer.addChild(this.backgroundGraphics.displayObject);
        }
        createPathFill() {
          var t2, e2, i2;
          const { displayObject: n2 } = this.strokeFill, r2 = null === (t2 = this.strokeGraphics) || void 0 === t2 ? void 0 : t2.displayObject, [o2, s2] = this.calculateFillObjectOffset();
          n2 ? ((null === (e2 = this.strokeGraphics) || void 0 === e2 ? void 0 : e2.isNeedMask(n2.width, n2.height)) && r2 && (this.needCacheAsBitMap = true, n2.pivot.x = r2.pivot.x, n2.pivot.y = r2.pivot.y, r2.pivot.x = 0, r2.pivot.y = 0, n2.mask = r2, n2.addChild(r2), n2.position.x = -o2 / 2, n2.position.y = -s2 / 2, r2.position.x = o2 / 2, r2.position.y = s2 / 2), this.effectContainer.addChild(n2)) : this.strokeFill.hasFill && (null === (i2 = this.strokeGraphics) || void 0 === i2 ? void 0 : i2.displayObject) && this.effectContainer.addChild(this.strokeGraphics.displayObject);
        }
        createFilledPathMask() {
          var t2, e2, i2;
          const n2 = (null === (e2 = null === (t2 = this.json.geometry) || void 0 === t2 ? void 0 : t2.paths) || void 0 === e2 ? void 0 : e2.filter((t3) => "none" !== t3.fill && "norm" !== t3.fill)) || [];
          for (const t3 of n2) {
            const e3 = this.ctx.graphicsTexture.getGraphicsData(t3.id);
            if (e3) {
              const n3 = new ep(e3.texture);
              n3.pivot.x = e3.pivot.x, n3.pivot.y = e3.pivot.y, n3.scale.x = e3.scale, n3.scale.y = e3.scale;
              const r2 = this.backgroundFill.getClonedDisplayObject(), o2 = null === (i2 = this.backgroundGraphics) || void 0 === i2 ? void 0 : i2.getClonedDisplayObject(), s2 = r2 || o2;
              s2 && (this.backgroundFill.displayObject && (s2.pivot.x = this.backgroundFill.displayObject.pivot.x, s2.pivot.y = this.backgroundFill.displayObject.pivot.y), s2.mask = n3, s2.filters = [Eg[t3.fill]], this.needCacheAsBitMap = true, this.effectContainer.addChild(s2), this.effectContainer.addChild(n3));
            }
          }
        }
        createArrow() {
          this.arrowList.length && this.arrowList.forEach((t2) => {
            var e2;
            const i2 = this.ctx.graphicsTexture.getGraphicsData(t2.graphicsId);
            if (i2) {
              const { texture: n2 } = i2, r2 = new ep(n2);
              r2.pivot.x = t2.pivot.x, r2.pivot.y = t2.pivot.y, r2.position.x = t2.position.x, r2.position.y = t2.position.y, r2.rotation = t2.rotate / 180 * Math.PI, r2.scale.x = i2.scale, r2.scale.y = i2.scale, null === (e2 = this.backgroundGraphics) || void 0 === e2 || e2.addArrows(r2);
            }
          });
        }
        generateArrowList() {
          var t2, e2;
          const { lineArrowList: i2, lineStyle: n2, id: r2 } = this.json, o2 = "solidFill" === (null === (t2 = null == n2 ? void 0 : n2.fill) || void 0 === t2 ? void 0 : t2.fillType) ? n2.fill.color : null;
          null === (e2 = i2 || []) || void 0 === e2 || e2.forEach((t3, e3) => {
            var i3, s2;
            const a2 = new qv(Object.assign(Object.assign({}, t3), { fillStyle: null == n2 ? void 0 : n2.fill, lineWidth: null !== (i3 = null == n2 ? void 0 : n2.width) && void 0 !== i3 ? i3 : 0 }));
            a2.graphicsId = `${r2}-arrow-${e3}-graphics`, a2.textureId = `${r2}-arrow-${e3}-fill`, this.ctx.graphicsTexture.addGraphics(a2.graphicsId, null !== (s2 = a2.paths) && void 0 !== s2 ? s2 : [], a2.hash, { x: 0, y: 0 }, a2.width, a2.height, void 0, this.ctx.objectPoolGroup, true, o2, null), this.arrowList.push(a2);
          });
        }
        calculateFillObjectOffset() {
          let [t2, e2] = [0, 0];
          return this.arrowList.length && (t2 = this.arrowList.reduce((t3, e3) => Math.max(t3, e3.width), 0), e2 = this.arrowList.reduce((t3, e3) => Math.max(t3, e3.height), 0)), [t2, e2];
        }
        preRender(t2) {
          var e2, i2, n2;
          const { lineStyle: r2, geometry: o2 } = this.json, { width: s2, height: a2 } = (null == o2 ? void 0 : o2.lineTransform) || Kv, l2 = s2 || this.json.width, h2 = a2 || this.json.height, u2 = (null === (e2 = null == o2 ? void 0 : o2.paths) || void 0 === e2 ? void 0 : e2.filter((t3) => "none" !== t3.fill && "norm" !== t3.fill)) || [], c2 = "solidFill" === (null === (i2 = null == r2 ? void 0 : r2.fill) || void 0 === i2 ? void 0 : i2.fillType) ? r2.fill.color : null;
          t2.addSubMTask(() => Jv(this, void 0, void 0, function* () {
            for (const t3 of u2) this.ctx.graphicsTexture.addGraphics(t3.id, [t3], t3.hash, ((null == o2 ? void 0 : o2.lineTransform) || Kv).pivot, l2, h2, r2, this.ctx.objectPoolGroup, true, null, c2);
          }), "@ShapeImpl[addGraphics]"), null === (n2 = this.text) || void 0 === n2 || n2.createParagraphs(this.json.id, t2);
        }
        subClassRender() {
          return Jv(this, void 0, void 0, function* () {
          });
        }
        render(t2) {
          t2.addSubMTask(() => Jv(this, void 0, void 0, function* () {
            var t3, e2;
            null === (t3 = this.strokeGraphics) || void 0 === t3 || t3.render(), null === (e2 = this.backgroundGraphics) || void 0 === e2 || e2.render(), this.createBackground(), yield this.subClassRender(), this.createFilledPathMask(), this.createPathFill(), this.createArrow();
          }), "@ShapeImpl[render]"), this.text && this.text.render(t2), t2.addSubMTask(() => Jv(this, void 0, void 0, function* () {
            var t3, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2, d2;
            if ("wd" === (null === (t3 = this.json.textBody) || void 0 === t3 ? void 0 : t3.iterateType) || "lt" === (null === (e2 = this.json.textBody) || void 0 === e2 ? void 0 : e2.iterateType)) {
              if (this.renderContainer.addChild(this.container), this.text) {
                const { x: t4, y: e3 } = null !== (i2 = this.json.scale) && void 0 !== i2 ? i2 : { x: 1, y: 1 };
                this.text.container.scale.x = e3 < 0 ? -Math.abs(t4) : Math.abs(t4), this.text.container.scale.y = e3, this.text.container.position.x = (null !== (r2 = null === (n2 = this.json.position) || void 0 === n2 ? void 0 : n2.x) && void 0 !== r2 ? r2 : 0) + this.text.x, this.text.container.position.y = (null !== (s2 = null === (o2 = this.json.position) || void 0 === o2 ? void 0 : o2.y) && void 0 !== s2 ? s2 : 0) + this.text.y, this.text.container.scale.y < 0 && (this.text.container.position.y += this.text.height), this.text.container.scale.x < 0 && (this.text.container.position.x += this.json.width), this.json.textRotation && (this.text.container.rotation = this.json.textRotation), this.renderContainer.addChild(this.text.container);
              }
            } else {
              if (this.text) {
                if (this.json.textRotation) {
                  this.text.container.rotation = this.json.textRotation;
                  const { width: t5, height: e4 } = this.text, { x: i4, y: n3 } = this.text.container.position;
                  this.text.container.pivot.x = t5 / 2, this.text.container.pivot.y = e4 / 2, this.text.container.x = i4 + t5 / 2, this.text.container.y = n3 + e4 / 2;
                }
                if (cg()(this.json.textRotateWithShape) && !this.json.textRotateWithShape) {
                  const t5 = this.json.rotation || 0;
                  this.text.container.rotation = -t5;
                  const { width: e4 } = this.text;
                  this.text.container.position.x = e4;
                }
                this.text.container.zIndex = 100;
                const t4 = null === (a2 = this.json.effectList) || void 0 === a2 ? void 0 : a2.find((t5) => "outerShadow" === t5.type), e3 = null === (l2 = this.json.effectList) || void 0 === l2 ? void 0 : l2.find((t5) => "softEdge" === t5.type), i3 = null === (h2 = this.json.effectList) || void 0 === h2 ? void 0 : h2.find((t5) => "glow" === t5.type);
                t4 && 1 !== t4.sx || e3 || i3 ? this.container.addChild(this.text.container) : this.effectContainer.addChild(this.text.container);
              }
              this.renderContainer.addChild(this.container);
            }
            if ("background" === this.json.id && this.ctx.hasBackgroundFillShape) {
              const t4 = Vh.p.create({ width: this.json.width, height: this.json.height, resolution: Math.ceil(this.ctx.renderer.resolution) });
              this.ctx.renderer.render(this.renderContainer, { renderTexture: t4 }), this.ctx.bgTexture = t4;
            }
            this.json.effectList && this.json.effectList.length > 0 && (null === (u2 = this.ctx.featureList) || void 0 === u2 ? void 0 : u2.effect) && !this.ctx.forceCanvas && !this.json.media && (this.effectObject = new Nv(this.effectContainer, this.json.effectList, `${this.ctx.taskId}_${this.ctx.slideIndex}_${this.json.id}`, this.ctx, this.json.rotation || 0, new Lh.g((null === (c2 = this.json.scale) || void 0 === c2 ? void 0 : c2.x) || 1, (null === (d2 = this.json.scale) || void 0 === d2 ? void 0 : d2.y) || 1)), function(t4) {
              var e3, i3, n3;
              return "gifFill" === (null === (e3 = t4.fillStyle) || void 0 === e3 ? void 0 : e3.fillType) || ("gifFill" === (null === (n3 = null === (i3 = t4.lineStyle) || void 0 === i3 ? void 0 : i3.fill) || void 0 === n3 ? void 0 : n3.fillType) || !!t4.picFill && "gifFill" === t4.picFill.fillType);
            }(this.json) && this.effectObject.setFrameCount(-1), this.effectObject.on("ready", () => {
              var t4;
              this.effectContainer.visible = false, this.effectObject.container.zIndex = 10, this.container.addChild(this.effectObject.container), null === (t4 = this.effectObject) || void 0 === t4 || t4.updateFrame(1), this.applyEffectCacheAsBitMap(true);
            }));
          }), "@ShapeImpl[post.render]");
        }
        applyEffectCacheAsBitMap(t2) {
          var e2, i2;
          "gifFill" !== (null === (e2 = this.json.fillStyle) || void 0 === e2 ? void 0 : e2.fillType) && (null === (i2 = this.effectObject) || void 0 === i2 || i2.container.children.forEach((e3) => {
            "effect-sprite" !== e3.name && (e3.cacheAsBitmap = t2);
          }));
        }
        clearOnSlideChange() {
        }
        initOnReuse() {
        }
        destroy() {
          var t2, e2, i2, n2;
          null === (t2 = this.text) || void 0 === t2 || t2.destroy(), this.fillColorFilter.destroy(), this.strokeColorFilter.destroy(), this.backgroundFill.destroy(), null === (e2 = this.backgroundGraphics) || void 0 === e2 || e2.destroy(), this.strokeFill.destroy(), null === (i2 = this.strokeGraphics) || void 0 === i2 || i2.destroy(), this.renderContainer.destroy(), null === (n2 = this.arrowRenderTexture) || void 0 === n2 || n2.destroy(true), this.arrowList = [], this.effectDisposer();
        }
      }
      var $v = i(119);
      const t_ = new (i.n($v)).a(), e_ = t_.getDevice(), i_ = t_.getBrowser(), n_ = t_.getOS(), r_ = { isDesktop() {
        let t2 = true;
        return "mobile" === e_.type && (t2 = false), /Samsung/.test(i_.name || "") && (t2 = false), window.__nativeTags && window.__nativeTags.platform && (t2 = false), t2;
      }, isIOS() {
        let t2 = false;
        return window.__nativeTags && window.__nativeTags.platform && /^ios/i.test(window.__nativeTags.platform) && (t2 = true), n_.name && /iOS/.test(n_.name) && (t2 = true), t2;
      }, isAndroid() {
        let t2 = false;
        return window.__nativeTags && window.__nativeTags.platform && /^android/i.test(window.__nativeTags.platform) && (t2 = true), n_.name && /android/i.test(n_.name) && (t2 = true), t2;
      }, isLowGpuMemory() {
        var t2, e2;
        const i2 = null !== (e2 = null === (t2 = window.__nativeTags) || void 0 === t2 ? void 0 : t2.platform) && void 0 !== e2 ? e2 : "";
        if (i2) {
          const t3 = i2.split(" ");
          if (t3[1]) {
            if (/^iPad/.test(t3[1])) {
              const e3 = t3[1].match(/^iPad(\d+)/);
              return !(e3 && e3[1] && parseInt(e3[1], 10) >= 6);
            }
            if (/^iPhone/.test(t3[1])) {
              const e3 = t3[1].match(/^iPhone(\d+)/);
              return !(e3 && e3[1] && parseInt(e3[1], 10) >= 9);
            }
            return false;
          }
          return false;
        }
        return true;
      } };
      var o_ = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      function s_(t2, e2) {
        for (const i2 in e2) t2.style[i2] = e2[i2];
      }
      const a_ = { medianContainerClass: "median-container", hoverHiddeDelay: 1500, portalWidth: 300, portalHeight: 50, hiddenOpacity: "0", hoverOpacity: "1", opacityAnimationTime: 0.4 };
      class l_ {
        constructor(t2) {
          var e2, i2;
          this.progress = document.createElement("div"), this.totalTime = document.createElement("span"), this.playButton = document.createElement("div"), this.pauseButton = document.createElement("div"), this.currentTime = document.createElement("span"), this.mediaController = document.createElement("div"), this.currentProgress = document.createElement("div"), this.fullScreenButton = document.createElement("div"), this.exitFullScreenButton = document.createElement("div"), this.medianIsEnd = false, this.pickBookmarkIndex = 0, this.playCallBackList = [], this.duration = 0, this.isVideo = false, this.start = 0, this.end = 0, this.fullscreenStatus = false, this.fadeState = { in: false, out: false }, this.changeMediaProgress = (t3) => {
            if (this.ctx.isPlayerPaused()) return void this.ctx.logger.info("Media controller prevent seek event with paused state", this.ctx.taskId);
            t3.stopPropagation();
            const e3 = t3.offsetX / this.progress.clientWidth * this.duration;
            this.medianIsEnd = false, "interactive" !== this.ctx.mode && this.jumpToTime(e3), "local" !== this.ctx.mode && this.ctx.eventHub.emit(zy.mediaSeek, { id: this.targetId, time: e3, isPlaying: this.media.isPlaying }), this.delayHide();
          }, this.jumpToTime = (t3 = 0) => o_(this, void 0, void 0, function* () {
            yield Pm(() => !!this.duration, 3e3);
            const e3 = Math.floor(t3) + this.start;
            this.media.currentTime !== e3 && (this.media.currentTime = e3, this.changeBookmarkIndex(e3, e3 > this.media.currentTime));
          }), this.showController = (t3) => {
            t3.stopPropagation(), this.show();
          }, this.getMediaDuration = () => {
            this.duration && !Number.isNaN(this.duration) || (this.duration = this.media.duration, this.start && (this.duration -= this.start, this.jumpToTime()), this.end && (this.duration -= this.end)), this.totalTime.innerText = l_.formatTime(this.duration);
          }, this.playMedia = () => o_(this, void 0, void 0, function* () {
            this.playButton.style.display = "none", this.pauseButton.style.display = "block", yield this.media.play(), this.medianIsEnd && (this.medianIsEnd = false, this.jumpToTime()), this.playCallBackList.forEach((t3) => {
              t3();
            }), this.delayHide();
          }), this.pauseMedia = () => o_(this, void 0, void 0, function* () {
            this.playButton.style.display = "block", this.pauseButton.style.display = "none", yield this.media.pause();
          }), this.onMouseOut = (t3) => {
            t3.stopPropagation(), this.hide();
          }, this.mediaTimeUpdate = () => o_(this, void 0, void 0, function* () {
            const t3 = this.media.currentTime - this.start;
            if (this.duration > 0 && (Math.abs(t3 - this.duration) < 0.3 || t3 > this.duration) && (yield this.pauseMedia(), this.medianIsEnd = true, this.jumpToTime(), this.ctx.eventHub.emit(zy.mediaStop, { id: this.targetId }), this.onClickCancelFullScreenButtonHandle()), this.currentTime.innerText = l_.formatTime(t3), this.currentProgress.style.flex = (t3 / this.duration).toString(), this.bookmarkList && this.bookmarkList.length > 0) {
              const t4 = this.bookmarkList[this.pickBookmarkIndex];
              t4 && t4.time.toFixed(0) === this.media.currentTime.toFixed(0) && (this.ctx.timingEventHub.emit(`shape ${this.shapeId} onMediaBookmark ${t4.name}`), this.pickBookmarkIndex += 1);
            }
            this.fadeHit(t3);
          }), this.onPauseMedia = () => {
            this.playButton.style.display = "block", this.pauseButton.style.display = "none";
          }, this.onPlayMedia = () => {
            this.fadeState = { in: false, out: false }, this.fadeHit(0), this.playButton.style.display = "none", this.pauseButton.style.display = "block", this.playCallBackList.forEach((t3) => {
              t3();
            }), this.media.currentTime < this.start && this.jumpToTime();
          }, this._playMediaFromCtrl = () => {
            this.playMediaFromCtrl(false);
          }, this._pauseMediaFromCtrl = () => {
            this.pauseMediaFromCtrl(false), this.delayHide();
          }, this.onClickFullScreenButtonHandle = () => {
            this.fullscreenPlay();
          }, this.onClickCancelFullScreenButtonHandle = () => {
            this.fullscreenStatus = false, this.media.requestCancelFullscreen(), this.ctx.eventHub.emit(zy.fullscreenChange, { targetId: this.targetId, state: false }), this.delayHide();
          }, this.onFullScreenChange = (t3) => {
            const { status: e3, targetId: i3, slideIndex: n2 } = t3;
            this.changeFullScreenState(e3, i3, n2), this.delayHide();
          }, this.onContainerSizeChange = () => {
            this.setControllerPosition();
          }, this.onControllerShowStatusChange = ({ slideIndex: t3, targetId: e3, status: i3 }) => {
            if (t3 === this.ctx.slideIndex) {
              if (this.targetId === e3) {
                const { hiddenOpacity: t4, hoverOpacity: e4 } = a_;
                i3 ? (this.mediaController.style.opacity = e4, this.mediaController.style.display = "flex") : this.mediaController.style.opacity = t4;
              }
              this.delayHide();
            }
          }, this.targetId = t2.targetId, this.ctx = t2.ctx, this.height = t2.height, this.width = t2.width, this.target = t2.target, this.media = t2.media, this.info = t2.info, this.shapeId = t2.shapeId, this.canvasElement = t2.canvasElement, "video" === this.media.type && (this.isVideo = true), this.getMedianContainer(), this.createMediaController(), this.info.cut && (this.start = null !== (e2 = this.info.cut.start) && void 0 !== e2 ? e2 : 0, this.end = null !== (i2 = this.info.cut.end) && void 0 !== i2 ? i2 : 0), this.info.bookmarkList && (this.bookmarkList = this.info.bookmarkList.sort((t3, e3) => t3.time - e3.time));
        }
        get clippedDuration() {
          return this.duration;
        }
        getMedianContainer() {
          var t2;
          const { medianContainerClass: e2 } = a_;
          let i2 = null === (t2 = this.canvasElement.parentElement) || void 0 === t2 ? void 0 : t2.querySelector("." + e2);
          i2 || (i2 = document.createElement("div"), i2.className = e2, this.canvasElement.parentElement.appendChild(i2)), this.container = i2;
        }
        static formatTime(t2) {
          let e2 = "00:00";
          if (t2) {
            const i2 = Math.floor(t2 / 60), n2 = String(i2 < 0 ? 0 : i2).padStart(2, "0"), r2 = Math.floor(t2 % 60);
            e2 = `${n2}:${String(r2 < 0 ? 0 : r2).padStart(2, "0")}`;
          }
          return e2;
        }
        generatePlayButton(t2 = 20, e2 = 20) {
          const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          i2.setAttributeNS(null, "viewBox", "0 0 512 512"), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "width", e2.toString());
          const n2 = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
          return n2.setAttributeNS(null, "points", "35 0, 477 256, 35 512"), n2.setAttributeNS(null, "fill", "#000000"), i2.appendChild(n2), i2;
        }
        generatePauseButton(t2 = 20, e2 = 20) {
          const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          s_(i2, { height: t2 + "px" }), i2.setAttributeNS(null, "viewBox", "0 0 512 512"), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "width", e2.toString());
          const n2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          n2.setAttributeNS(null, "x", "35"), n2.setAttributeNS(null, "y", "0"), n2.setAttributeNS(null, "width", "148"), n2.setAttributeNS(null, "height", "512");
          const r2 = n2.cloneNode(true);
          return r2.setAttributeNS(null, "x", "330"), i2.append(n2, r2), i2;
        }
        generateFullScreenButton(t2 = 20, e2 = 20) {
          const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          s_(i2, { height: t2 + "px", width: e2 + "px" }), i2.setAttributeNS(null, "width", e2.toString()), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "viewBox", "0 0 1024 1024");
          const n2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
          return n2.setAttributeNS(null, "d", "M918.116352 107.409408c10.186752 10.175488 10.186752 26.691584 0 36.87936L653.734912 407.038976c-10.187776 10.187776-26.703872 10.187776-36.891648 0-10.175488-10.187776-10.175488-26.703872 0.013312-36.891648l264.38144-262.73792c10.174464-10.187776 26.69056-10.200064 36.87936-0.013312L918.117376 107.409408zM878.281728 148.096l-161.155072-0.44544c-11.283456 0.279552-20.85888-8.226816-21.90336-19.458048l0-13.421568c0.318464-10.671104 8.889344-19.241984 19.560448-19.560448l187.030528 0.827392c0.1792-0.037888 0.357376-0.0768 0.523264-0.089088l9.549824-0.229376c5.005312-0.152576 9.843712 1.770496 13.372416 5.336064 3.32288 3.629056 4.9664 8.49408 4.545536 13.40928l-1.032192 9.537536c0 0.191488 0.70144 0.318464 0.70144 0.49664l-0.534528 188.279808c-0.54784 9.984-9.092096 17.637376-19.076096 17.089536-0.165888-0.012288-0.319488-0.0256-0.484352-0.037888L896.009216 329.8304c-10.379264-0.0512-18.733056-8.506368-18.681856-18.885632 0.013312-0.191488 0.013312-0.381952 0.013312-0.585728L878.281728 148.096zM105.884672 916.661248c-10.187776-10.175488-10.200064-26.691584-0.013312-36.87936 0 0 0-0.013312 0.013312-0.013312l265.19552-262.73792c10.35264-10.008576 26.86976-9.729024 36.866048 0.636928 9.766912 10.110976 9.766912 26.131456 0 36.242432L143.579136 916.661248C133.072896 926.848 116.3776 926.848 105.884672 916.661248L105.884672 916.661248zM146.533376 875.973632l161.154048 0.433152c11.283456-0.292864 20.85888 8.213504 21.891072 19.458048l0 13.38368c-0.292864 10.672128-8.876032 19.255296-19.560448 19.561472l-187.858944-0.828416c-0.165888 0.037888-0.344064 0.075776-0.509952 0.089088l-9.550848 0.229376c-5.004288 0.152576-9.831424-1.782784-13.35808-5.336064-3.323904-3.629056-4.979712-8.493056-4.54656-13.395968l1.031168-9.537536c0-0.191488-0.712704-0.330752-0.700416-0.509952l0.534528-188.278784c0.534528-9.984 9.066496-17.625088 19.050496-17.089536 0.165888 0.013312 0.330752 0.0256 0.508928 0.037888l14.212096 0c10.365952 0.0512 18.719744 8.507392 18.656256 18.873344 0 0.191488 0 0.395264-0.013312 0.598016L146.533376 875.973632zM918.116352 916.661248c10.186752-10.175488 10.200064-26.691584 0.012288-36.87936 0 0 0-0.013312-0.012288-0.013312l-264.38144-262.73792c-10.365952-10.008576-26.86976-9.729024-36.87936 0.636928-9.766912 10.110976-9.766912 26.131456 0 36.242432L881.22368 916.661248c10.186752 10.186752 26.703872 10.186752 36.891648 0.013312L918.115328 916.661248 918.116352 916.661248zM878.281728 875.973632l-161.168384 0.433152c-11.270144-0.292864-20.845568 8.213504-21.890048 19.458048l0 13.38368c0.306176 10.672128 8.889344 19.241984 19.560448 19.561472l187.030528-0.828416c0.1792 0.037888 0.357376 0.075776 0.523264 0.089088l9.549824 0.229376c5.005312 0.152576 9.843712-1.782784 13.372416-5.336064 3.32288-3.629056 4.978688-8.493056 4.545536-13.395968l-1.032192-9.537536c0-0.191488 0.70144-0.330752 0.70144-0.509952l-0.534528-188.278784c-0.54784-9.984-9.092096-17.637376-19.076096-17.089536-0.165888 0.013312-0.319488 0.0256-0.484352 0.037888L896.009216 694.19008c-10.379264 0.0512-18.733056 8.507392-18.681856 18.885632 0 0.191488 0.013312 0.381952 0.013312 0.584704L878.281728 875.973632zM105.884672 107.409408c-10.187776 10.175488-10.187776 26.691584 0 36.87936l265.19552 262.750208c10.187776 10.187776 26.691584 10.187776 36.87936 0s10.175488-26.703872-0.012288-36.891648l-264.368128-262.73792C133.072896 97.222656 116.3776 97.222656 105.884672 107.409408L105.884672 107.409408zM146.533376 148.096l161.154048-0.44544c11.283456 0.292864 20.85888-8.213504 21.891072-19.458048l0-13.421568c-0.306176-10.671104-8.889344-19.241984-19.560448-19.560448l-187.858944 0.827392c-0.165888-0.0512-0.344064-0.0768-0.509952-0.089088l-9.550848-0.229376c-5.004288-0.152576-9.831424 1.782784-13.35808 5.336064-3.323904 3.629056-4.979712 8.49408-4.54656 13.40928l1.031168 9.537536c0 0.191488-0.712704 0.318464-0.700416 0.49664l0.534528 188.279808c0.534528 9.970688 9.066496 17.624064 19.050496 17.089536 0.165888-0.012288 0.330752-0.0256 0.508928-0.037888l14.212096 0c10.365952-0.0512 18.719744-8.506368 18.656256-18.87232 0-0.191488 0-0.395264-0.013312-0.598016L146.533376 148.096z"), i2.appendChild(n2), document.body.appendChild(i2), i2;
        }
        generateExitFullScreenButton(t2 = 20, e2 = 20) {
          const i2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          s_(i2, { height: t2 + "px", width: e2 + "px" }), i2.setAttributeNS(null, "width", e2.toString()), i2.setAttributeNS(null, "height", t2.toString()), i2.setAttributeNS(null, "viewBox", "0 0 1024 1024");
          const n2 = document.createElementNS("http://www.w3.org/2000/svg", "path"), r2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
          return n2.setAttributeNS(null, "d", "M716.8 998.4a25.6 25.6 0 0 1-25.6-25.6v-256a25.6 25.6 0 0 1 25.6-25.6h256a25.6 25.6 0 1 1 0 51.2h-230.4v230.4a25.6 25.6 0 0 1-25.6 25.6zM307.2 998.4a25.6 25.6 0 0 1-25.6-25.6v-230.4H51.2a25.6 25.6 0 1 1 0-51.2h256a25.6 25.6 0 0 1 25.6 25.6v256a25.6 25.6 0 0 1-25.6 25.6zM972.8 332.8h-256a25.6 25.6 0 0 1-25.6-25.6v-256a25.6 25.6 0 1 1 51.2 0v230.4h230.4a25.6 25.6 0 1 1 0 51.2zM307.2 332.8h-256a25.6 25.6 0 1 1 0-51.2h230.4V51.2a25.6 25.6 0 1 1 51.2 0v256a25.6 25.6 0 0 1-25.6 25.6z"), r2.setAttributeNS(null, "d", "M307.2 332.8a25.6 25.6 0 0 1-18.112-7.488L56.896 93.12a25.6 25.6 0 0 1 36.224-36.224l232.192 232.192A25.6 25.6 0 0 1 307.2 332.8zM716.8 332.8a25.6 25.6 0 0 1-18.112-43.712L930.88 56.896a25.6 25.6 0 0 1 36.224 36.224l-232.192 232.192a25.472 25.472 0 0 1-18.112 7.488zM948.992 974.592a25.6 25.6 0 0 1-18.112-7.488l-232.192-232.192a25.6 25.6 0 0 1 36.224-36.224l232.192 232.192a25.6 25.6 0 0 1-18.112 43.712zM75.008 974.592a25.6 25.6 0 0 1-18.112-43.712l232.192-232.192a25.6 25.6 0 0 1 36.224 36.224l-232.192 232.192a25.472 25.472 0 0 1-18.112 7.488z"), i2.appendChild(n2), i2.appendChild(r2), document.body.appendChild(i2), i2;
        }
        createButton() {
          const t2 = { marginLeft: "15px", marginRight: "10px", fontSize: "0", height: "20px", display: "flex", justifyContent: "center", alignItems: "center" };
          s_(this.playButton, Object.assign(Object.assign({}, t2), { display: "block" }));
          const e2 = this.generatePlayButton();
          s_(e2, { height: "20px" }), this.playButton.appendChild(e2), s_(this.pauseButton, Object.assign(Object.assign({}, t2), { display: "none" }));
          const i2 = this.generatePauseButton();
          if (s_(i2, { height: "20px" }), this.pauseButton.appendChild(i2), !this.isVideo) return;
          const n2 = this.generateFullScreenButton(20, 20);
          this.fullScreenButton.appendChild(n2), s_(this.fullScreenButton, Object.assign(Object.assign({}, t2), { display: "block" }));
          const r2 = this.generateExitFullScreenButton(20, 20);
          this.exitFullScreenButton.appendChild(r2), s_(this.exitFullScreenButton, Object.assign(Object.assign({}, t2), { display: "none" }));
        }
        createTimer() {
          const t2 = document.createElement("div");
          s_(t2, { width: "100px" }), this.currentTime.innerText = "00:00";
          const e2 = document.createElement("span");
          return e2.innerText = "/", t2.append(this.currentTime, e2, this.totalTime), t2;
        }
        createProgress() {
          const t2 = { flex: "1", position: "relative" };
          this.isVideo || (t2.marginRight = "10px"), s_(this.progress, t2);
          const e2 = document.createElement("div");
          s_(e2, { background: "#D9D9D9", position: "relative", height: "10px", display: "flex" }), this.progress.appendChild(e2), s_(this.currentProgress, { background: "#4F4F4F", top: "0px", left: "0", height: "10px", flex: "0" }), e2.appendChild(this.currentProgress);
        }
        fadeHit(t2) {
          if (!this.info.fade) return;
          const { start: e2, end: i2 } = this.info.fade;
          e2 && !this.fadeState.in && t2 >= 0 && (this.fadeState.in = true, this.media.fadeIn(0, e2)), i2 && !this.fadeState.out && t2 >= this.duration - i2 / 1e3 && (this.fadeState.out = true, this.media.fadeOut(0, i2));
        }
        changeBookmarkIndex(t2, e2) {
          if (this.bookmarkList && 0 !== this.bookmarkList.length) {
            if (this.pickBookmarkIndex > 0) {
              for (let e3 = 0; e3 < this.pickBookmarkIndex; e3++) if (this.bookmarkList[e3].time > t2) {
                this.pickBookmarkIndex = e3;
                break;
              }
            }
            if (e2) {
              let e3 = this.pickBookmarkIndex - 1;
              for (let i2 = 0; i2 < this.bookmarkList.length; i2++) this.bookmarkList[i2].time < t2 && (e3 = i2);
              for (let t3 = this.pickBookmarkIndex; t3 <= e3; t3++) {
                const e4 = this.bookmarkList[t3];
                e4 && this.ctx.timingEventHub.emit(`shape ${this.shapeId} onMediaBookmark ${e4.name}`);
              }
              this.pickBookmarkIndex = e3 + 1;
            }
          }
        }
        playMediaFromCtrl(t2) {
          this.ctx.isPlayerPaused() ? this.ctx.logger.info("Media controller prevent play event with paused state", this.ctx.taskId) : ("interactive" !== this.ctx.mode && this.playMedia(), "local" !== this.ctx.mode && this.ctx.eventHub.emit(zy.mediaPlay, { id: this.targetId, time: this.media.currentTime - this.start, _stateOnly: t2 }));
        }
        pauseMediaFromCtrl(t2) {
          this.ctx.isPlayerPaused() ? this.ctx.logger.info("Media controller prevent pause event with paused state", this.ctx.taskId) : ("interactive" !== this.ctx.mode && this.pauseMedia(), "local" === this.ctx.mode || this.ctx.isRendering || this.ctx.eventHub.emit(zy.mediaPause, { id: this.targetId, time: this.media.currentTime - this.start, _stateOnly: t2 }));
        }
        setControllerPosition() {
          var t2;
          const { target: e2 } = this, { portalWidth: i2, portalHeight: n2 } = a_, { stageWidth: r2, stageHeight: o2 } = this.ctx, s2 = e2.getGlobalPosition(), a2 = Number(null === (t2 = this.container) || void 0 === t2 ? void 0 : t2.getAttribute("data-scale")), l2 = r2 * a2, h2 = 1 / a2 * (i2 > l2 ? l2 / i2 : 1);
          s2.y = s2.y + this.height - n2, s2.x = Math.max(s2.x, 0), s2.x = Math.min(s2.x, r2 - i2 * h2), s2.y = Math.max(s2.y, 0), s2.y = Math.min(s2.y, o2 - n2), s_(this.mediaController, { height: n2 + "px", borderRadius: n2 / 2 + "px", width: i2 + "px", flexDirection: "row", alignItems: "center", position: "absolute", left: s2.x + "px", top: s2.y + "px", background: "#fff", zIndex: "2", border: "1px solid #ccc", transform: `scale(${h2})`, transformOrigin: "0 100%" }), this.fullscreenStatus && s_(this.mediaController, { left: "0", top: o2 - n2 + "px" });
        }
        createMediaController() {
          this.setControllerPosition(), s_(this.mediaController, { display: "none", transition: `opacity ${a_.opacityAnimationTime}s` }), this.createButton();
          const t2 = this.createTimer();
          this.createProgress(), this.mediaController.append(this.playButton, this.pauseButton, t2, this.progress), this.isVideo && this.mediaController.append(this.fullScreenButton, this.exitFullScreenButton), this.container.appendChild(this.mediaController), this.bindEvent();
        }
        addPlayCallBack(t2) {
          this.playCallBackList.push(t2);
        }
        fullscreenPlay() {
          this.fullscreenStatus = true, "interactive" !== this.ctx.mode && this.media.requestFullscreen(), "local" !== this.ctx.mode && this.ctx.eventHub.emit(zy.fullscreenChange, { targetId: this.targetId, state: true }), this.delayHide();
        }
        changeFullScreenState(t2, e2, i2) {
          i2 === this.ctx.slideIndex && (t2 && this.targetId === e2 ? this.fullscreenStatus = t2 : this.fullscreenStatus = false, this.fullscreenStatus ? (this.fullScreenButton.style.display = "none", this.exitFullScreenButton.style.display = "block") : (this.fullScreenButton.style.display = "block", this.exitFullScreenButton.style.display = "none"), this.setControllerPosition());
        }
        bindEvent() {
          r_.isDesktop() && (this.mediaController.addEventListener("mouseout", this.onMouseOut, false), this.mediaController.addEventListener("mouseover", this.showController, false)), this.progress.addEventListener("click", this.changeMediaProgress, false), this.playButton.addEventListener("click", this._playMediaFromCtrl, false), this.pauseButton.addEventListener("click", this._pauseMediaFromCtrl, false), this.media.on("durationchange", this.getMediaDuration, false), this.media.on("timeupdate", this.mediaTimeUpdate, false), this.media.on("pause", this.onPauseMedia, false), this.media.on("play", this.onPlayMedia, false), this.containerObserver = new MutationObserver(this.onContainerSizeChange), this.container && this.containerObserver.observe(this.container, { attributes: true, attributeFilter: ["data-scale", "style"] }), this.isVideo && (this.ctx.globalEventHub.on("onFullscreenChange", this.onFullScreenChange), this.ctx.globalEventHub.on("controllerShowStatusChange", this.onControllerShowStatusChange), this.fullScreenButton.addEventListener("click", this.onClickFullScreenButtonHandle, false), this.exitFullScreenButton.addEventListener("click", this.onClickCancelFullScreenButtonHandle, false));
        }
        unbindEvent() {
          var t2;
          r_.isDesktop() && (this.mediaController.removeEventListener("mouseout", this.onMouseOut, false), this.mediaController.removeEventListener("mouseover", this.showController, false)), this.progress.removeEventListener("click", this.changeMediaProgress, false), this.playButton.removeEventListener("click", this._playMediaFromCtrl, false), this.pauseButton.removeEventListener("click", this._pauseMediaFromCtrl, false), this.media.removeAllListeners(), null === (t2 = this.containerObserver) || void 0 === t2 || t2.disconnect(), this.isVideo && (this.ctx.globalEventHub.removeListener("onFullscreenChange", this.onFullScreenChange), this.ctx.globalEventHub.removeListener("controllerShowStatusChange", this.onControllerShowStatusChange), this.fullScreenButton.removeEventListener("click", this.onClickFullScreenButtonHandle, false), this.exitFullScreenButton.removeEventListener("click", this.onClickCancelFullScreenButtonHandle, false));
        }
        show() {
          this.setControllerPosition(), this.mediaController.style.opacity = a_.hoverOpacity, this.fullscreenStatus || (this.mediaController.style.display = "flex"), this.delayHide();
        }
        hide() {
          this.fullscreenStatus ? this.mediaController.style.opacity = a_.hiddenOpacity : this.mediaController.style.display = "none";
        }
        delayHide() {
          clearTimeout(this.autoHiddenTimer), this.autoHiddenTimer = setTimeout(() => {
            this.hide();
          }, a_.hoverHiddeDelay);
        }
        destroy() {
          var t2;
          this.unbindEvent(), this.playCallBackList = [], null === (t2 = this.container) || void 0 === t2 || t2.removeChild(this.mediaController);
        }
      }
      var h_ = i(120);
      class u_ extends Za.a {
        constructor(t2, e2, i2) {
          var n2, r2;
          super(), this.isGlobalPause = false, this.lastTime = -1, this.howl = null, this.rctClient = null, this.isHowlEnd = false, this.isHowlLoadEmit = false, this.staticEventId = 1001, this._catParams = void 0, this.url = t2, this.runningAudio = e2, i2 && (this._catParams = i2), Vy.RtcAudioClazz ? (this.rctClient = new Vy.RtcAudioClazz(t2, null === (n2 = this._catParams) || void 0 === n2 ? void 0 : n2.start, null === (r2 = this._catParams) || void 0 === r2 ? void 0 : r2.end), this.rctClient.on("load", () => this.emit("load")), this.rctClient.on("pause", () => this.emit("pause")), this.rctClient.on("play", () => {
            this.startTimeChangeEmit(), this.emit("play");
          }), this.rctClient.on("resumeAllAudioInterruptByAudioSessionChanged", () => {
            this.emit("resumeAllAudioInterruptByAudioSessionChanged");
          })) : (this.howl = new h_.Howl({ src: [t2] }), [this.staticEventId] = this.howl._getSoundIds(), this.howl.load(), this.howl.on("load", () => {
            this.isHowlLoadEmit = true, this.emit("load");
          }), this.howl.on("pause", () => this.emit("pause")), this.howl.on("play", () => {
            this.isHowlLoadEmit || this.emit("load"), this.isHowlEnd = false, this.startTimeChangeEmit(), this.emit("play");
          }), this.howl.on("end", () => {
            this.isHowlEnd = true;
          }));
        }
        startTimeChangeEmit() {
          this.currentTime !== this.lastTime && (this.lastTime = this.currentTime, this.emit("timeupdate", this.lastTime)), this.isPaused || setTimeout(() => {
            this.isPaused || this.startTimeChangeEmit();
          }, 300);
        }
        play() {
          var t2, e2, i2;
          this.runningAudio.has(this.url) && (null === (t2 = this.runningAudio.get(this.url)) || void 0 === t2 || t2.stop(), this.runningAudio.delete(this.url)), this.isHowlEnd = false, this.lastTime = -1, null === (e2 = this.howl) || void 0 === e2 || e2.play(this.staticEventId), null === (i2 = this.rctClient) || void 0 === i2 || i2.play(), this.runningAudio.set(this.url, this);
        }
        fade(t2, e2, i2) {
          this.howl && this.howl.fade(t2, e2, i2);
        }
        pause() {
          var t2, e2;
          null === (t2 = this.howl) || void 0 === t2 || t2.pause(this.staticEventId), null === (e2 = this.rctClient) || void 0 === e2 || e2.pause(), this.runningAudio.has(this.url) && this.runningAudio.delete(this.url);
        }
        globalPause() {
          this.isPaused || (this.isGlobalPause = true, this.pause());
        }
        globalResume() {
          this.isGlobalPause && (this.isGlobalPause = false, this.play());
        }
        stop() {
          var t2;
          null === (t2 = this.howl) || void 0 === t2 || t2.pause(this.staticEventId), this.rctClient && (this.rctClient.pause(), this.rctClient.currentTime = 0), this.runningAudio.has(this.url) && this.runningAudio.delete(this.url);
        }
        destroy() {
          var t2, e2, i2, n2, r2, o2, s2, a2;
          null === (t2 = this.howl) || void 0 === t2 || t2.stop(this.staticEventId), null === (e2 = this.howl) || void 0 === e2 || e2.unload(), null === (i2 = this.rctClient) || void 0 === i2 || i2.pause(), null === (n2 = this.rctClient) || void 0 === n2 || n2.destroy(), null === (r2 = this.rctClient) || void 0 === r2 || r2.removeAllListeners("load"), null === (o2 = this.rctClient) || void 0 === o2 || o2.removeAllListeners("play"), null === (s2 = this.rctClient) || void 0 === s2 || s2.removeAllListeners("pause"), null === (a2 = this.rctClient) || void 0 === a2 || a2.removeAllListeners("resumeAllAudioInterruptByAudioSessionChanged"), this.runningAudio.has(this.url) && this.runningAudio.delete(this.url);
        }
        get currentTime() {
          return this.rctClient ? this.rctClient.currentTime : this.howl ? this.howl.seek(this.staticEventId) : -1;
        }
        set currentTime(t2) {
          this.rctClient ? this.rctClient.currentTime = t2 : this.howl && this.howl.seek(t2, this.staticEventId);
        }
        get duration() {
          return this.rctClient ? this.rctClient.duration : this.howl ? this.howl.duration(this.staticEventId) : 0;
        }
        get isPaused() {
          return this.rctClient ? this.rctClient.isPaused : !!this.howl && !this.howl.playing(this.staticEventId);
        }
        volume(t2) {
          this.rctClient ? this.rctClient.volume(t2) : this.howl && this.howl.volume(t2);
        }
      }
      var c_ = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class d_ extends Za.a {
        constructor(t2) {
          var e2, i2, n2, r2, o2, s2, a2;
          super(), this.type = "video", this.sprite = new ep(), this.isPlaying = false, this.isGlobalPause = false, this.fullscreen = false, this.url = "", this.isLoaded = false, this.onVideoResourceLoaded = () => {
            this.isLoaded = true;
          }, this.onVideoStalled = () => {
            this.ctx.logger.warn(this.url + ", Failed to fetch data, but trying.", this.ctx.taskId);
          }, this.updateVolume = (t3) => {
            this.rtcAudio.volume(t3);
          }, this.syncFullscreenVideoState = (t3) => {
            const { targetId: e3, state: i3, slideIndex: n3 } = t3;
            n3 === this.ctx.slideIndex && e3 === this.id && (i3 ? (this.requestFullscreen(), this.ctx.latestChangeFullscreenTargetId = e3) : this.requestCancelFullscreen());
          }, this.id = t2.id, this.start = null === (e2 = t2.video.cut) || void 0 === e2 ? void 0 : e2.start, this.end = null === (i2 = t2.video.cut) || void 0 === i2 ? void 0 : i2.end, this.fullscreen = null !== (n2 = t2.video.fullscreen) && void 0 !== n2 && n2, this.container = t2.container, this.ctx = t2.ctx, this.ctx.medias[this.id] = this;
          const l2 = t2.video.src;
          this.videoResource = new Vh.w(l2, { autoLoad: true, autoPlay: false, updateFPS: 30, crossorigin: true }), null === (r2 = this.videoElement) || void 0 === r2 || r2.addEventListener("stalled", this.onVideoStalled), null === (o2 = this.videoElement) || void 0 === o2 || o2.addEventListener("loadedmetadata", this.onVideoResourceLoaded), this.url = t2.video.src;
          let h2 = t2.video.src.replace(/4$/, "3");
          this.ctx.loaderDelegate && (h2 = this.ctx.loaderDelegate.redirectMedia(h2), this.ctx.logger.info(`redirect media url from ${t2.video.src.replace(/4$/, "3")} to ${h2} by delegate.`, t2.ctx.taskId)), this.rtcAudio = new u_(h2, t2.ctx.runningAudio, { start: null === (s2 = t2.video.cut) || void 0 === s2 ? void 0 : s2.start, end: null === (a2 = t2.video.cut) || void 0 === a2 ? void 0 : a2.end }), this.rtcAudio.on("timeupdate", (t3) => {
            if (this.videoElement) {
              const e3 = this.videoElement.currentTime;
              Math.abs(e3 - t3) > 0.5 && (this.videoElement.currentTime = t3);
            }
          }), this.rtcAudio.on("resumeAllAudioInterruptByAudioSessionChanged", () => {
            var t3;
            null === (t3 = this.videoElement) || void 0 === t3 || t3.pause(), setTimeout(() => {
              var t4;
              this.rtcAudio.isPaused || null === (t4 = this.videoElement) || void 0 === t4 || t4.play();
            }, 200);
          });
          const { video: u2, width: c2, height: d2, target: p2 } = t2;
          this.controller = new l_({ targetId: t2.id, shapeId: t2.shapeId, ctx: t2.ctx, width: c2, height: d2, target: p2, media: this, info: u2, canvasElement: t2.canvasElement }), this.controller.addPlayCallBack(() => {
            this.sprite.width = c2, this.sprite.height = d2, this.ctx.clock.setTimeout(() => {
              this.sprite.visible = true;
            }, 50);
          });
          const f2 = new Vh.c(null, { height: d2, width: c2 });
          f2.resource = this.videoResource, this.videoResource.bind(f2), this.sprite = new ep(), this.sprite.visible = false, this.sprite.texture = new Vh.t(f2), this.sprite.interactive = true, this.container.addChild(this.sprite), this.sprite.on("mouseover", (t3) => {
            t3.stopPropagation(), this.controller.show();
          }), this.sprite.on("mouseout", (t3) => {
            t3.stopPropagation(), this.controller.hide();
          }), ["durationchange", "timeupdate", "pause", "play"].forEach((t3) => {
            var e3;
            null === (e3 = this.videoElement) || void 0 === e3 || e3.addEventListener(t3, () => {
              "timeupdate" === t3 && this.isPlaying, this.emit(t3);
            });
          }), this.ctx.activeMedia.add(this), this.ctx.volumeAdjuster.on("update", this.updateVolume), this.ctx.globalEventHub.on("syncFullscreenVideoState", this.syncFullscreenVideoState);
        }
        get videoElement() {
          return this.videoResource.source;
        }
        get currentTime() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.videoElement) || void 0 === t2 ? void 0 : t2.currentTime) && void 0 !== e2 ? e2 : 0;
        }
        set currentTime(t2) {
          this.rtcAudio.currentTime = t2, this.videoElement && (this.videoElement.currentTime = t2);
        }
        get paused() {
          var t2, e2;
          return null === (e2 = null === (t2 = this.videoElement) || void 0 === t2 ? void 0 : t2.paused) || void 0 === e2 || e2;
        }
        get duration() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.videoElement) || void 0 === t2 ? void 0 : t2.duration) && void 0 !== e2 ? e2 : 0;
        }
        get clippedDuration() {
          return this.controller.clippedDuration;
        }
        showController() {
          this.controller.show();
        }
        hideController() {
          this.controller.hide();
        }
        play() {
          return c_(this, void 0, void 0, function* () {
            this.isPlaying = true, this.updateVolume(this.ctx.volumeAdjuster.volume), yield this.load(), yield this.ctx.clock.waitUntil(() => {
              const t3 = this.videoElement;
              return !!(t3 && t3.videoWidth > 0);
            }, 3e3);
            const t2 = this.videoElement;
            t2 && t2.videoWidth <= 0 || (this.videoElement && (this.videoElement.volume = 0, this.videoElement.muted = true), this.rtcAudio.on("play", () => {
              var t3;
              null === (t3 = this.videoElement) || void 0 === t3 || t3.play(), this.fullscreen && this.controller.fullscreenPlay();
            }), this.rtcAudio.play());
          });
        }
        load() {
          return this.videoResource.load();
        }
        pause() {
          var t2;
          this.isPlaying = false, this.ctx.logger.warn(this.url + ", pause video manual.", this.ctx.taskId), this.ctx.logger.warn(this.url + ", pause rtc audio manual.", this.ctx.taskId), this.rtcAudio.once("pause", () => {
            var t3;
            null === (t3 = this.videoElement) || void 0 === t3 || t3.pause();
          }), this.rtcAudio.pause(), null === (t2 = this.videoElement) || void 0 === t2 || t2.pause();
        }
        globalPause() {
          this.isPlaying && (this.isGlobalPause = true, this.pause());
        }
        globalResume() {
          this.isGlobalPause && (this.isGlobalPause = false, this.play());
        }
        togglePause() {
          this.isPlaying ? this.pause() : this.play();
        }
        seek(t2) {
          this.controller.jumpToTime(t2);
        }
        stop() {
          this.rtcAudio.stop(), this.seek(0), this.pause(), this.ctx.eventHub.emit(zy.mediaStop, { id: this.id });
        }
        requestFullscreen() {
          return c_(this, void 0, void 0, function* () {
            yield Pm(() => this.isLoaded, 5e3);
            const t2 = new Vh.t(this.sprite.texture.baseTexture);
            this.ctx.globalEventHub.emit("requestFullscreen", { texture: t2, index: this.ctx.slideIndex, targetId: this.id });
          });
        }
        requestCancelFullscreen() {
          this.ctx.globalEventHub.emit("requestCancelFullscreen", { targetId: this.id, index: this.ctx.slideIndex });
        }
        destroy() {
          var t2, e2, i2;
          this.ctx.volumeAdjuster.removeListener("update", this.updateVolume), this.ctx.globalEventHub.removeListener("syncFullscreenVideoState", this.syncFullscreenVideoState), null === (t2 = this.videoElement) || void 0 === t2 || t2.removeEventListener("stalled", this.onVideoStalled), null === (e2 = this.videoElement) || void 0 === e2 || e2.removeEventListener("loadedmetadata", this.onVideoResourceLoaded), this.sprite.interactive = false, this.sprite.destroy({ texture: true, baseTexture: true }), null === (i2 = this.videoResource) || void 0 === i2 || i2.destroy(), this.rtcAudio.destroy(), this.stop(), this.controller.destroy(), this.ctx.activeMedia.delete(this);
        }
        fadeIn(t2, e2) {
          this.rtcAudio.fade(t2, this.ctx.volumeAdjuster.volume, e2);
        }
        fadeOut(t2, e2) {
          this.rtcAudio.fade(this.ctx.volumeAdjuster.volume, t2, e2);
        }
      }
      var p_ = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class f_ extends Za.a {
        constructor(t2) {
          var e2, i2;
          super(), this.type = "audio", this.isPlaying = false, this.isGlobalPause = false, this.updateVolume = (t3) => {
            this.audioPlayer.volume(t3);
          }, this.id = t2.id;
          const n2 = t2.audio.src;
          this.audioPlayer = new u_(n2, t2.ctx.runningAudio, { start: null === (e2 = t2.audio.cut) || void 0 === e2 ? void 0 : e2.start, end: null === (i2 = t2.audio.cut) || void 0 === i2 ? void 0 : i2.end }), t2.audio.cut && (this.start = t2.audio.cut.start, this.end = t2.audio.cut.end), this.ctx = t2.ctx, this.ctx.medias[this.id] = this;
          const { width: r2, height: o2, target: s2 } = t2;
          this.controller = new l_({ targetId: t2.id, shapeId: t2.shapeId, ctx: t2.ctx, height: o2, width: r2, target: s2, media: this, info: t2.audio, canvasElement: t2.canvasElement }), this.audioPlayer.on("load", () => this.emit("durationchange")), this.audioPlayer.on("timeupdate", () => this.emit("timeupdate")), this.audioPlayer.on("pause", () => this.emit("pause")), this.audioPlayer.on("play", () => this.emit("play")), this.ctx.activeMedia.add(this), this.ctx.volumeAdjuster.on("update", this.updateVolume);
        }
        get currentTime() {
          return this.audioPlayer.currentTime;
        }
        set currentTime(t2) {
          this.audioPlayer.currentTime = t2;
        }
        get clippedDuration() {
          return this.controller.clippedDuration;
        }
        get paused() {
          return this.audioPlayer.isPaused;
        }
        get isPaused() {
          return this.audioPlayer.isPaused;
        }
        get duration() {
          return this.audioPlayer.duration;
        }
        load() {
          return Promise.resolve();
        }
        showController() {
          this.controller.show();
        }
        hideController() {
          this.controller.hide();
        }
        play() {
          return p_(this, void 0, void 0, function* () {
            this.ctx.isPlayerPaused() ? this.ctx.logger.info("Audio player prevent play event with paused state", this.ctx.taskId) : (this.updateVolume(this.ctx.volumeAdjuster.volume), this.isPlaying = true, this.audioPlayer.play());
          });
        }
        pause() {
          this.ctx.isPlayerPaused() ? this.ctx.logger.info("Audio player prevent pause event with paused state", this.ctx.taskId) : (this.isPlaying = false, this.audioPlayer.pause());
        }
        globalPause() {
          this.isPlaying && (this.isGlobalPause = true, this.pause());
        }
        globalResume() {
          this.isGlobalPause && (this.isGlobalPause = false, this.play());
        }
        togglePause() {
          this.isPlaying ? this.pause() : this.play();
        }
        seek(t2) {
          this.ctx.isPlayerPaused() ? this.ctx.logger.info("Audio player prevent seek event with paused state", this.ctx.taskId) : this.controller.jumpToTime(t2);
        }
        stop() {
          this.audioPlayer.stop(), this.seek(0), this.pause(), this.ctx.eventHub.emit(zy.mediaStop, { id: this.id });
        }
        requestFullscreen() {
        }
        requestCancelFullscreen() {
        }
        destroy() {
          this.ctx.volumeAdjuster.removeListener("update", this.updateVolume), this.stop(), this.controller.destroy(), this.ctx.activeMedia.delete(this), this.audioPlayer.destroy();
        }
        fadeIn(t2, e2) {
          this.audioPlayer.fade(t2, this.ctx.volumeAdjuster.volume, e2);
        }
        fadeOut(t2, e2) {
          this.audioPlayer.fade(this.ctx.volumeAdjuster.volume, t2, e2);
        }
      }
      var m_ = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class g_ extends Qv {
        constructor(t2, e2, i2) {
          super(Object.assign(Object.assign({}, t2), { type: "Shape", useBgFill: false, textRotateWithShape: true, isPicture: true }), e2, i2), this.isInteractiveOutside = false, this.cmd = new eg(this), this.media = null == t2 ? void 0 : t2.media, this.container.name = t2.id + "_container_[Picture]", this.renderContainer.name = t2.id + "_render_container_[Picture]", this.picFill = new lv(this.ctx, t2.picFill, t2.width, t2.height, { useFilter: true, useSlideBackgroundFill: false });
        }
        applyCommand(t2, e2) {
          var i2, n2, r2, o2;
          if ("call" === e2) if (/playFrom\(([0-9.]+)\)/.test(t2)) {
            const e3 = t2.match(/playFrom\(([0-9.]+)\)/), r3 = Number(e3[1] || "0");
            null === (i2 = this.mediaPlayer) || void 0 === i2 || i2.controller.playMediaFromCtrl(true), Math.abs(r3) > 0.1 && (null === (n2 = this.mediaPlayer) || void 0 === n2 || n2.controller.jumpToTime(r3));
          } else "custom-pause" === t2 ? null === (r2 = this.mediaPlayer) || void 0 === r2 || r2.controller.pauseMediaFromCtrl(true) : "togglePause" === t2 ? this.mediaPlayer && (this.mediaPlayer.isPlaying ? this.mediaPlayer.controller.pauseMediaFromCtrl(true) : this.mediaPlayer.controller.playMediaFromCtrl(true)) : "stop" === t2 && (null === (o2 = this.mediaPlayer) || void 0 === o2 || o2.stop());
        }
        applyEffectCacheAsBitMap(t2) {
          var e2, i2, n2;
          "gifFill" === (null === (e2 = this.json.fillStyle) || void 0 === e2 ? void 0 : e2.fillType) || this.media && "video" === this.media.type || "gifFill" === (null === (i2 = this.json.picFill) || void 0 === i2 ? void 0 : i2.fillType) || null === (n2 = this.effectObject) || void 0 === n2 || n2.container.children.forEach((e3) => {
            "effect-sprite" !== e3.name && (e3.cacheAsBitmap = t2);
          });
        }
        renderPic() {
          var t2, e2, i2, n2, r2, o2;
          return m_(this, void 0, void 0, function* () {
            const { displayObject: s2 } = this.picFill;
            if (s2) {
              s2.name = this.json.id + "_pic_fill_[Picture]";
              const a2 = null === (t2 = this.backgroundGraphics) || void 0 === t2 ? void 0 : t2.getClonedDisplayObject();
              if ((null === (e2 = this.backgroundGraphics) || void 0 === e2 ? void 0 : e2.isNeedMask(s2.width, s2.height)) && a2 && (s2.mask = a2, this.effectContainer.addChild(a2)), s2.width = this.designWidth, s2.height = this.designHeight, s2 instanceof im && this.ctx.slideScopeEventHub.once("slide-render", (t3) => {
                var e3;
                this.ctx.slideIndex === t3 && (null === (e3 = this.effectObject) || void 0 === e3 || e3.setFrameCount(s2.totalFrames), s2.play(), s2.onFrameChange = (t4) => {
                  if (this.effectObject) if (this.effectObject.hasFrame(t4)) this.effectObject.updateFrame(t4);
                  else {
                    const e4 = this.getEffectTexture();
                    e4 && (this.effectObject.createFrame(t4, e4.texture), this.effectObject.setFrameOffset(e4.offsetX, e4.offsetY));
                  }
                });
              }), this.effectContainer.addChild(s2), this.media) {
                let t3 = this.media.src;
                if ("audio" === this.media.type && /mp4$/.test(t3) && (t3 = t3.replace(/mp4$/, "mp3")), this.ctx.urlInterrupter) {
                  const e3 = Date.now();
                  t3 = yield this.ctx.urlInterrupter(t3), this.ctx.logger.info("redirect media url by interrupter. time: " + (Date.now() - e3), this.ctx.taskId);
                }
                this.ctx.loaderDelegate && (t3 = this.ctx.loaderDelegate.redirectMedia(t3), this.ctx.logger.info(`redirect media url to ${t3} by delegate.`, this.ctx.taskId)), this.media.src = t3;
              }
              if ("video" === (null === (i2 = this.media) || void 0 === i2 ? void 0 : i2.type) && this.media.src) {
                if (this.mediaPlayer = new d_({ id: this.json.id + "-video", shapeId: this.json.id, ctx: this.ctx, video: this.media, height: this.designHeight, width: this.designWidth, target: s2, container: this.effectContainer, canvasElement: this.ctx.view }), (null === (n2 = this.mediaPlayer) || void 0 === n2 ? void 0 : n2.sprite) && a2) {
                  const t3 = null === (r2 = this.backgroundGraphics) || void 0 === r2 ? void 0 : r2.getClonedDisplayObject();
                  t3 && (this.mediaPlayer.sprite.mask = t3, this.container.addChild(t3));
                }
              } else "audio" === (null === (o2 = this.media) || void 0 === o2 ? void 0 : o2.type) && this.media.src && (this.mediaPlayer = new f_({ id: this.json.id + "-audio", shapeId: this.json.id, ctx: this.ctx, audio: this.media, height: this.designHeight, width: this.designWidth, target: s2, canvasElement: this.ctx.view, fade: this.media.fade }));
              this.mediaPlayer && (this.isInteractiveOutside = !!this.container.interactive, this.container.interactive = true, r_.isDesktop() ? (this.container.on("mouseover", () => {
                this.mediaPlayer.showController();
              }), this.container.on("mouseout", () => {
                this.mediaPlayer.hideController();
              }, false)) : this.container.on("pointerdown", () => {
                this.mediaPlayer.showController();
              }));
            }
          });
        }
        preRender(t2) {
          super.preRender(t2);
        }
        subClassRender() {
          return m_(this, void 0, void 0, function* () {
            yield this.renderPic();
          });
        }
        clearOnSlideChange() {
          super.clearOnSlideChange(), this.mediaPlayer && (this.container.interactive = false, this.mediaPlayer.stop(), this.mediaPlayer.hideController());
        }
        initOnReuse() {
          super.initOnReuse(), this.mediaPlayer && (this.container.interactive = true);
        }
        destroy() {
          this.mediaPlayer && (this.picFill.displayObject && !this.isInteractiveOutside && (this.container.interactive = false), this.mediaPlayer.destroy(), this.mediaPlayer = void 0), this.picFill.destroy();
        }
      }
      var v_ = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class __ extends hg {
        constructor(t2, e2, i2, n2) {
          super(t2, e2, i2), this.children = [], this.cacheSprite = new ep(), this.cacheContainer = new Oh.b(), this.json = t2, this.json.fillStyle && "groupFill" === this.json.fillStyle.fillType && i2.groupFillStyle && (this.json.fillStyle = i2.groupFillStyle), this.container.name = t2.id + "_container_[Container]", this.cacheContainer.name = t2.id + "_cache_container_[Container]", this.ctx.timingTargets.addTarget(t2.id, this), this.updateTransform(this.json), this.fillObject = new lv(this.ctx, t2.fillStyle, t2.width, t2.height, { useFilter: false, useSlideBackgroundFill: false }), this.createChildren(n2);
        }
        createChildren(t2) {
          var e2, i2, n2, r2;
          const o2 = { x: null !== (i2 = null === (e2 = this.json.position) || void 0 === e2 ? void 0 : e2.x) && void 0 !== i2 ? i2 : 0, y: null !== (r2 = null === (n2 = this.json.position) || void 0 === n2 ? void 0 : n2.y) && void 0 !== r2 ? r2 : 0 };
          for (let e3 = 0, i3 = this.json.children.length; e3 < i3; e3++) t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
            let i4 = this.json.children[e3], n3 = null;
            if (!(!this.ctx.featureList || !this.ctx.featureList.smartArt) && ("Shape" === (null == i4 ? void 0 : i4.type) || "Picture" === (null == i4 ? void 0 : i4.type)) && this.ctx.smartArtShapeList) {
              const { id: t3 } = i4, e4 = this.ctx.smartArtShapeList.find((e5) => e5.id === t3);
              e4 && (i4 = e4);
            }
            const r3 = { parentGlobalPos: o2, groupFillStyle: this.json.fillStyle, groupSize: { w: this.json.width, h: this.json.height } };
            "Shape" === (null == i4 ? void 0 : i4.type) ? n3 = new Qv(i4, this.ctx, r3) : "Picture" === (null == i4 ? void 0 : i4.type) ? n3 = new g_(i4, this.ctx, r3) : "Container" === (null == i4 ? void 0 : i4.type) && (n3 = new __(i4, this.ctx, r3, t2)), n3 && this.children.push(n3);
          }), "@ContainerImpl[child.init]");
        }
        get interactiveContainer() {
          return this.container;
        }
        get renderContainer() {
          return this.container;
        }
        preRender(t2) {
          for (const e2 of this.children) t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
            e2.preRender(t2);
          }), "@ContainerImpl[child.preRender]");
        }
        getBgElement() {
          return null;
        }
        getIterateEntry(t2, e2, i2) {
          return 0 === e2 ? this : (this.ctx.eventHub.emit("IterateTimeNodeEnd", i2), null);
        }
        getTextElement() {
          return null;
        }
        render(t2) {
          for (const e2 of this.children) e2.render(t2), t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
            this.cacheContainer.addChild(e2.renderContainer);
          }), "@ContainerImpl[child.render]");
          t2.addSubMTask(() => v_(this, void 0, void 0, function* () {
            this.container.addChild(this.cacheContainer);
          }), "@ContainerImpl[child.append]");
        }
        applyEffectCacheAsBitMap(t2) {
          this.children.forEach((e2) => e2.applyEffectCacheAsBitMap(t2));
        }
        clearOnSlideChange() {
          this.children.forEach((t2) => t2.clearOnSlideChange());
        }
        initOnReuse() {
          this.children.forEach((t2) => t2.initOnReuse());
        }
        isChildrenInteractive() {
          for (const t2 of this.json.children) if ("Container" === (null == t2 ? void 0 : t2.type) || "Stage" === (null == t2 ? void 0 : t2.type) || (null == t2 ? void 0 : t2.hlinkHover) || (null == t2 ? void 0 : t2.hlinkClick)) return true;
          return false;
        }
        destroy() {
          this.cacheSprite && this.cacheSprite.destroy({ texture: true }), this.children.forEach((t2) => t2.destroy()), this.container.destroy({ children: true, texture: true, baseTexture: true }), this.cacheContainer.destroy({ children: true, texture: true, baseTexture: true });
        }
      }
      class y_ extends Za.a {
        constructor(t2, e2, i2, n2) {
          super(), this.cond = {}, this.timeoutIds = [], this.condHandle = (t3, e3 = {}) => {
            if (t3) if (t3.delay && t3.delay > 0) {
              const i3 = this.ctx.clock.setTimeout(() => {
                t3.event && (this.cond[t3.event] = true, this.detectTrigger(e3));
              }, t3.delay);
              this.timeoutIds.push(i3);
            } else this.cond[t3.event] = true, this.detectTrigger(e3);
            else this.detectTrigger(e3);
          }, this.id = t2, this.ctx = n2, this.eventHubs = i2, e2.forEach((t3) => {
            this.addCond(t3);
          });
        }
        setTriggerParams(t2) {
          this.triggerParams = t2;
        }
        addCond(t2) {
          const e2 = (...e3) => {
            this.condHandle(t2, e3);
          };
          t2.event && (/^shape/.test(t2.event) || /^time/.test(t2.event) ? (this.cond[t2.event] = false, this.eventHubs.global.addListener(t2.event, e2)) : /^runtime/.test(t2.event) ? (this.cond[t2.event] = false, this.eventHubs.runtime.addListener(t2.event, e2)) : /^self/.test(t2.event) ? t2.delay && t2.delay > 0 && (this.cond[t2.event] = false, this.eventHubs.runtime.addListener(t2.event, e2)) : this.cond[t2.event] = false);
        }
        isTrigger() {
          return Object.keys(this.cond).every((t2) => !!this.cond[t2]);
        }
        isTriggerWithoutParent() {
          return Object.keys(this.cond).filter((t2) => "self" !== t2).every((t2) => !!this.cond[t2]);
        }
        detectTrigger(t2) {
          if (Object.keys(this.cond).every((t3) => !!this.cond[t3])) {
            Object.keys(this.cond).forEach((t3) => {
              this.cond[t3] = false;
            });
            const e2 = this.triggerParams;
            this.triggerParams = void 0, this.emit("active", e2, t2);
          }
        }
        reset() {
          Object.keys(this.cond).forEach((t2) => {
            this.cond[t2] = false;
          }), this.timeoutIds.forEach((t2) => this.ctx.clock.clearTimeout(t2));
        }
      }
      class x_ extends Za.a {
        constructor(t2) {
          super(), this.isTimeNodeEndSync = false, this.interactiveListeners = [], this.runtimeNodeEventHub = new Za.a(), this._currentSeqIndex = 0, this._currentSeqState = "idle", this.isForward = true, this.autoPlay = false, this.handlePrev = (t3 = false) => {
            var e3, i3, n3, r3, o3, s3;
            this.hasPrev() || !this.isMainSeq ? "idle" === this.currentSeqState ? (this.decrSeqIndex(), null === (e3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === e3 || e3.commonTimeNode.seekToStart(), null === (i3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === i3 || i3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : "running" === this.currentSeqState ? (null === (n3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === n3 || n3.commonTimeNode.seekToStart(), null === (r3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === r3 || r3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : "end" === this.currentSeqState && (this.currentSeqIndex >= this.commonTimeNode.children.length && (this.currentSeqIndex = this.commonTimeNode.children.length - 1), null === (o3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === o3 || o3.commonTimeNode.seekToStart(), null === (s3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === s3 || s3.commonTimeNode.clearSubList(), this.currentSeqState = "idle") : this.globalEventHub.emit("c:prev slide", t3);
          }, this.handleNext = (t3, e3) => {
            var i3, n3, r3, o3;
            if (this.isTimeNodeEndSync && (this.isTimeNodeEndSync = false, this.currentSeqState = "idle", this.currentSeqIndex = 0), !this.hasNext() && this.isMainSeq && e3) this.globalEventHub.emit("c:next slide", t3);
            else {
              if (this.isInteractiveSeq) {
                this.globalEventHub.emit("shape slide onNext" + (this.json.ctn.id || ""));
                const t4 = { result: null };
                this.findChildInfiniteRepeat(this.commonTimeNode, t4), 1 === this.commonTimeNode.children.length && t4.result && (t4.result.json.subTnLst || []).length > 0 && 0 === this.currentSeqIndex && "running" === this.currentSeqState && this.commonTimeNode.allChildrenEndHandle();
              }
              "idle" === this.currentSeqState ? null === (i3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === i3 || i3.commonTimeNode.startTimeNodeForce() : "running" === this.currentSeqState ? (null === (n3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === n3 || n3.commonTimeNode.seekToEnd(false, true), this.currentSeqState = "end", this.incrSeqIndex(), null === (r3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === r3 || r3.commonTimeNode.startTimeNodeForce()) : "end" === this.currentSeqState && (this.incrSeqIndex(), null === (o3 = this.commonTimeNode.children[this.currentSeqIndex]) || void 0 === o3 || o3.commonTimeNode.startTimeNodeForce());
            }
          };
          const { json: e2, iterateType: i2, isIterate: n2, isSub: r2, parent: o2, ctx: s2, eventHub: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2 } = t2;
          this.isMainSeq = "mainSeq" === e2.ctn.nodeType, this.isInteractiveSeq = "interactiveSeq" === e2.ctn.nodeType, this.id = e2.ctn.id, this.isIterate = n2, this.json = e2, this.ctx = s2, this.globalEventHub = a2, this.commonTimeNode = new Ty({ json: e2.ctn, isSub: r2, eventHubs: { global: a2, runtime: this.runtimeNodeEventHub }, ctx: s2, parent: o2, isIterate: false, iterateType: i2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2 || this.isInteractiveSeq, fromSeqId: this.isInteractiveSeq ? this.json.ctn.id : "" }), this.bindShapeEvent(), this.nextConds = new y_("mainSeq", e2.nextCondLst, { global: a2, runtime: this.runtimeNodeEventHub }, this.ctx), this.prevConds = new y_("mainSeq", e2.preCondLst, { global: a2, runtime: this.runtimeNodeEventHub }, this.ctx), this.commonTimeNode.on("timeNodeRestart", () => {
            this.currentSeqIndex = 0, this.currentSeqState = "idle";
          }), this.commonTimeNode.on("childTimeNodeStart", (t3) => {
            const e3 = this.commonTimeNode.children.findIndex((e4) => e4.commonTimeNode.uuid === t3.id);
            e3 >= 0 && (this.currentSeqIndex = e3), this.currentSeqState = "running", this.isMainSeq && this.ctx.eventHub.emit(zy.mainSeqStepStart, e3);
          }), this.commonTimeNode.on("childTimeNodeEnd", (t3) => {
            const e3 = this.commonTimeNode.children.findIndex((e4) => e4.commonTimeNode.uuid === t3.id);
            e3 >= 0 && (this.currentSeqIndex = e3), this.currentSeqState = "end", this.autoPlay && this.ctx.clock.setTimeout(() => {
              this.handleNext(false, true);
            }), this.isMainSeq && this.ctx.eventHub.emit(zy.mainSeqStepEnd, e3);
          }), this.commonTimeNode.on("timeNodeEndSync", () => {
            this.isTimeNodeEndSync = true, this.commonTimeNode.resetForRepeat();
          }), this.commonTimeNode.on("timeNodeDestroy", () => {
            this.interactiveListeners.forEach(([t3, e3]) => {
              t3 && e3 && t3.interactiveContainer.removeListener("pointerdown", e3);
            }), this.interactiveListeners = [];
          }), this.nextConds.on("active", (t3, e3) => {
            Array.isArray(e3) ? this.handleNext(e3[0], e3[1]) : this.handleNext(e3, true);
          }), this.prevConds.on("active", (t3, e3) => {
            Array.isArray(e3) ? this.handlePrev(e3[0]) : this.handlePrev(e3);
          });
        }
        get currentSeqIndex() {
          return this._currentSeqIndex;
        }
        set currentSeqIndex(t2) {
          this._currentSeqIndex = t2, this.isMainSeq ? this.ctx.eventHub.emit(zy.mainSeqStepChange, t2) : this.isInteractiveSeq && this.ctx.eventHub.emit(zy.interactiveSeqStateChange, { id: this.json.ctn.id, state: { step: t2, state: this._currentSeqState } });
        }
        get currentSeqState() {
          return this._currentSeqState;
        }
        set currentSeqState(t2) {
          this._currentSeqState = t2, this.isMainSeq ? this.ctx.eventHub.emit(zy.mainSeqStateChange, t2) : this.isInteractiveSeq && this.ctx.eventHub.emit(zy.interactiveSeqStateChange, { id: this.json.ctn.id, state: { step: this._currentSeqIndex, state: t2 } });
        }
        get stepLength() {
          return this.commonTimeNode.children.length;
        }
        get currentStep() {
          return this.currentSeqIndex;
        }
        get currentState() {
          return this.currentSeqState;
        }
        startAutoPlay() {
          this.autoPlay = true, this.commonTimeNode.children[0].commonTimeNode.startTimeNodeForce();
        }
        incrSeqIndex() {
          this.currentSeqIndex + 1 <= this.commonTimeNode.children.length && (this.currentSeqIndex += 1);
        }
        decrSeqIndex() {
          this.currentSeqIndex - 1 >= -1 && (this.currentSeqIndex -= 1);
        }
        hasPrev() {
          return !(this.currentSeqIndex <= 0 && "idle" === this.currentSeqState);
        }
        hasNext() {
          return !(this.currentSeqIndex >= this.commonTimeNode.children.length || this.currentSeqIndex === this.commonTimeNode.children.length - 1 && "end" === this.currentSeqState);
        }
        findChildInfiniteRepeat(t2, e2) {
          t2.isInfiniteRepeat() ? e2.result = t2 : t2.children.map((t3) => t3.commonTimeNode).forEach((t3) => this.findChildInfiniteRepeat(t3, e2));
        }
        bindShapeEvent() {
          "interactiveSeq" === this.json.ctn.nodeType && this.json.nextCondLst.forEach((t2) => {
            if (/^shape/.test(t2.event)) {
              const e2 = t2.event.split(" ")[1];
              if (e2) {
                const t3 = this.ctx.timingTargets.getTargetById(e2);
                if (t3) {
                  t3.interactiveContainer.interactive = true, t3.interactiveContainer.cursor = "pointer";
                  const i2 = () => {
                    this.ctx.eventHub.emit(zy.userInput);
                    const t4 = `shape ${e2} onClick`, { mode: i3 } = this.ctx;
                    "interactive" !== i3 && "sync" !== i3 || this.ctx.eventHub.emit(zy.interactiveSeqAction, { action: t4, seqId: this.json.ctn.id }), "sync" !== i3 && "local" !== i3 || this.globalEventHub.emit(t4);
                  };
                  t3.interactiveContainer.on("pointerdown", i2), this.interactiveListeners.push([t3, i2]);
                }
              }
            }
          });
        }
        setCurrentStep(t2, e2) {
          const { length: i2 } = this.commonTimeNode.children;
          if (t2 > i2) return;
          this.isInteractiveSeq && 0 === this.commonTimeNode.applyCount && (this.commonTimeNode.applyCount = 1);
          let n2 = t2;
          if (this.commonTimeNode.seekToStart(), -1 === n2 && (n2 = i2 - 1), 0 !== n2 || "start" !== e2) {
            if (n2 >= 0 && n2 < i2) for (let t3 = 0; t3 <= n2; t3++) {
              const i3 = this.commonTimeNode.children[t3];
              t3 !== n2 ? i3.commonTimeNode.seekToEnd(false, true) : "start" === e2 ? i3.commonTimeNode.seekToStart() : "end" === e2 && i3.commonTimeNode.seekToEnd(false, true);
            }
            this.currentSeqIndex = n2, this.currentSeqState = "start" === e2 ? "idle" : "end";
          }
        }
      }
      function b_(t2, e2, i2) {
        const n2 = e2.split(".");
        n2.reduce((r2, o2, s2) => {
          if (r2) return s2 !== n2.length - 1 ? r2[o2] : void (r2[o2] = i2);
          console.warn(`${t2} not support ${e2}`);
        }, t2);
      }
      function T_(t2, e2) {
        if (!e2) return null;
        return e2.split(".").reduce((i2, n2) => i2 ? i2[n2] : (console.warn(`${t2} not support ${e2}`), null), t2);
      }
      class E_ {
        constructor(t2) {
          this.timingTarget = null, this.runtimeNodeEventHub = new Za.a(), this.basicOnTimeNodeEnd = () => {
            if (this.isConflict) {
              const { target: t3 } = this.json.cBhvr, e3 = this.getTargetId(t3);
              this.ctx.conflictTimeNodeManager.removeRunningTimeNode(e3, this.modifyAttrKey);
            }
          }, this.basicOnTimeNodeStart = () => {
            this.timingTarget && this.timingTarget.applyEffectCacheAsBitMap(false);
          }, this.basicOnTimeLineStart = () => {
            if (this.isConflict) {
              const { target: t3 } = this.json.cBhvr;
              if ("next" === this.activeWhenConflict) {
                const e3 = this.getTargetId(t3);
                this.ctx.conflictTimeNodeManager.addRunningTimeNode(e3, this.modifyAttrKey, this.commonTimeNode);
              } else "prev" === this.activeWhenConflict && this.commonTimeNode.dispose();
            }
          };
          const { isIterate: e2, isSub: i2, json: n2, ctx: r2, parent: o2, eventHub: s2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 } = t2;
          this.json = n2, this.id = n2.cBhvr.ctn.id, this.ctx = r2, this.globalEventHub = s2, this.commonTimeNode = new Ty({ json: n2.cBhvr.ctn, isSub: i2, eventHubs: { global: s2, runtime: this.runtimeNodeEventHub }, ctx: r2, parent: o2, isIterate: e2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 }), this.timingTarget = this.ctx.timingTargets.getTarget(n2.cBhvr.target, e2, { type: a2, index: l2, id: h2 }), this.commonTimeNode.on("seekToStart", () => this.onSeekToStart()), this.commonTimeNode.on("seekToEnd", () => this.onSeekToEnd()), this.commonTimeNode.on("timelineStart", this.basicOnTimeLineStart), this.commonTimeNode.on("timeNodeEnd", this.basicOnTimeNodeEnd), this.commonTimeNode.on("timeNodeStart", this.basicOnTimeNodeStart);
        }
        getTargetId(t2) {
          let e2 = t2.id;
          return "shape" === t2.type && t2.txEl && (e2 = `${e2}-txEl-${t2.txEl.range[0]}`), this.commonTimeNode.isIterate && (e2 = `${e2}-iterate-${this.commonTimeNode.iterateIndex}`), e2;
        }
      }
      class S_ extends E_ {
        constructor(t2) {
          super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.startVal = null, this.updateStartValue = () => {
            this.timingTarget && (this.startVal = T_(this.timingTarget, this.json.cBhvr.attrList[0]));
          }, this.onSeekToStart = () => {
            const t3 = this.json.cBhvr.attrList[0];
            null !== this.startVal && this.timingTarget && b_(this.timingTarget, t3, this.startVal);
          }, this.onSeekToEnd = () => {
            const t3 = this.json.cBhvr.attrList[0], e2 = this.json.cBhvr.to || this.json.to;
            e2 && this.timingTarget && b_(this.timingTarget, t3, e2);
          }, this.commonTimeNode.on("timeNodeStart", this.updateStartValue), this.commonTimeNode.on("timeNodeCreate", this.updateStartValue), this.commonTimeNode.on("timeUpdate", ({ duration: t3, delta: e2 }) => {
            if (e2 / t3 >= 1) {
              const t4 = this.json.cBhvr.attrList[0];
              this.json.cBhvr.attrList.length > 1 && console.warn("this.json.cBhvr.attrList.length > 0");
              const e3 = this.json.cBhvr.to || this.json.to;
              e3 && this.timingTarget && b_(this.timingTarget, t4, e3);
            }
          });
        }
        get modifyAttrKey() {
          return this.json.cBhvr.attrList[0];
        }
      }
      var w_ = function(t2, e2, i2, n2) {
        var r2, o2 = arguments.length, s2 = o2 < 3 ? e2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(e2, i2) : n2;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s2 = Reflect.decorate(t2, e2, i2, n2);
        else for (var a2 = t2.length - 1; a2 >= 0; a2--) (r2 = t2[a2]) && (s2 = (o2 < 3 ? r2(s2) : o2 > 3 ? r2(e2, i2, s2) : r2(e2, i2)) || s2);
        return o2 > 3 && s2 && Object.defineProperty(e2, i2, s2), s2;
      };
      class A_ {
        constructor(t2, e2) {
          this.math = { pi: Math.PI, e: Math.E, abs: Math.abs, acos: Math.acos, asin: Math.asin, atan: Math.atan, ceil: Math.ceil, cos: Math.cos, cosh: Math.cosh, deg: (t3) => t3 / Math.PI * 180, exp: Math.exp, floor: Math.floor, ln: Math.log, max: Math.max, min: Math.min, rad: (t3) => t3 / 180 * Math.PI, rand: Math.random, sin: Math.sin, sinh: Math.sinh, sqrt: Math.sqrt, tan: Math.tan, tanh: Math.tanh }, this.timingTarget = e2, this.val = t2.val.value, this.time = t2.time, t2.fmla && (this.fmla = this.parseFmla(t2.fmla));
        }
        parseFmla(t2) {
          let e2 = t2.replace(/#ppt_h/g, `(${this.timingTarget.design_ppt_h})`);
          return e2 = e2.replace(/#ppt_w/g, `(${this.timingTarget.design_ppt_w})`), e2 = e2.replace(/#ppt_x/g, `(${this.timingTarget.design_ppt_x})`), e2 = e2.replace(/#ppt_y/g, `(${this.timingTarget.design_ppt_y})`), e2 = e2.replace(/ppt_w/g, "vars.ppt_w"), e2 = e2.replace(/ppt_h/g, "vars.ppt_h"), e2 = e2.replace(/ppt_x/g, "vars.ppt_x"), e2 = e2.replace(/ppt_y/g, "vars.ppt_y"), e2 = e2.replace(/#/g, "vars."), ["abs", "acos", "asin", "atan", "ceil", "cos", "cosh", "deg", "exp", "floor", "ln", "max", "min", "rad", "rand", "sin", "sinh", "sqrt", "tan", "tanh", "pi", "e"].forEach((t3) => {
            const i2 = new RegExp(`([^a-z])${t3}([^a-z])`, "g");
            e2 = e2.replace(i2, (e3, i3, n2) => `${i3}math.${t3}${n2}`);
          }), new Function("vars", "math", "$", "return " + e2);
        }
      }
      class M_ extends A_ {
        constructor(t2, e2, i2) {
          super(t2, e2), this.value = t2.val.value, i2 && (this.fmla = this.parseFmla(i2));
        }
        resolveValue() {
          return this.value;
        }
        interpolationFrom(t2, e2, i2) {
          const n2 = t2.resolveValue(i2), r2 = n2 + (this.resolveValue() - n2) * e2;
          return t2.fmla ? t2.fmla(i2, this.math, r2) : r2;
        }
      }
      w_([Em()], M_.prototype, "interpolationFrom", null);
      class C_ extends A_ {
        constructor(t2, e2) {
          var i2;
          super(t2, e2), this.value = null === (i2 = t2.val) || void 0 === i2 ? void 0 : i2.value;
        }
        interpolationFrom(t2, e2, i2) {
          let n2 = t2.resolveValue(i2);
          return e2 > this.time && ["hidden", "visible"].indexOf(n2) < 0 && (n2 = this.resolveValue()), n2;
        }
        resolveValue() {
          return this.value || "";
        }
      }
      w_([Em()], C_.prototype, "interpolationFrom", null);
      class R_ extends A_ {
        constructor(t2, e2) {
          super(t2, e2), this.fn = this.parseFmla(this.val);
        }
        resolveValue(t2) {
          return this.fn(t2, this.math, 1);
        }
        interpolationFrom(t2, e2, i2) {
          const n2 = t2.resolveValue(i2), r2 = n2 + (this.resolveValue(i2) - n2) * e2;
          return t2.fmla ? t2.fmla(i2, this.math, r2) : r2;
        }
      }
      w_([Em()], R_.prototype, "interpolationFrom", null);
      class I_ extends A_ {
        constructor(t2, e2) {
          super(t2, e2), this.value = t2.val.value;
        }
        interpolationFrom(t2, e2) {
          return vg(t2.resolveValue(), this.value, e2);
        }
        resolveValue() {
          return this.value;
        }
      }
      w_([Em()], I_.prototype, "interpolationFrom", null);
      class P_ extends E_ {
        constructor(t2) {
          super(t2), this.isConflict = true, this.activeWhenConflict = "next", this.startVal = null, this.createVal = null, this.vars = { ppt_x: 0, ppt_y: 0, ppt_w: 0, ppt_h: 0 }, this.keyFrames = [], this.isColorAnim = false, this.onTimeNodeStart = () => {
            this.timingTarget && (this.startVal = T_(this.timingTarget, this.json.cBhvr.attrList[0]));
          }, this.updateVars = () => {
            var t3, e2, i2, n2;
            (null === (t3 = this.timingTarget) || void 0 === t3 ? void 0 : t3.ppt_h) && (this.vars.ppt_h = this.timingTarget.ppt_h), (null === (e2 = this.timingTarget) || void 0 === e2 ? void 0 : e2.ppt_w) && (this.vars.ppt_w = this.timingTarget.ppt_w), (null === (i2 = this.timingTarget) || void 0 === i2 ? void 0 : i2.ppt_x) && (this.vars.ppt_x = this.timingTarget.ppt_x), (null === (n2 = this.timingTarget) || void 0 === n2 ? void 0 : n2.ppt_y) && (this.vars.ppt_y = this.timingTarget.ppt_y), this.isColorAnim;
          }, this.onTimeUpdate = ({ duration: t3, delta: e2 }) => {
            const i2 = e2 / t3, n2 = this.keyFrames.findIndex((t4) => i2 <= t4[0]), { attrList: r2 } = this.json.cBhvr;
            if (n2 < 0) {
              const t4 = this.keyFrames[this.keyFrames.length - 1];
              return void (this.timingTarget && r2 && r2[0] && b_(this.timingTarget, r2[0], t4[1].resolveValue(this.vars)));
            }
            const o2 = n2 - 1, s2 = this.keyFrames[n2], a2 = this.keyFrames[o2] || s2, l2 = s2[0] - a2[0] == 0 ? 1 : (i2 - a2[0]) / (s2[0] - a2[0]), h2 = s2[1].interpolationFrom(a2[1], l2, this.vars);
            this.timingTarget && r2 && r2[0] && b_(this.timingTarget, r2[0], h2);
          }, this.onSeekToStart = () => {
            null !== this.startVal && this.timingTarget && b_(this.timingTarget, this.json.cBhvr.attrList[0], this.startVal);
          }, this.onSeekToEnd = () => {
            this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
          }, this.onDestroy = () => {
            null !== this.createVal && this.timingTarget && b_(this.timingTarget, this.json.cBhvr.attrList[0], this.createVal);
          }, this.initKeyFrames(), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timelineStart", this.updateVars), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeDestroy", this.onDestroy), this.createVal = T_(this.timingTarget, this.json.cBhvr.attrList[0]);
        }
        get modifyAttrKey() {
          return this.json.cBhvr.attrList[0];
        }
        initKeyFrames() {
          var t2;
          const { valueType: e2 } = this.json;
          if (this.json.tavLst.length <= 0) {
            if (this.json.to) {
              if (this.json.from || this.startVal) {
                const t4 = { time: 0, val: { type: "string", value: this.json.from || this.startVal.toString() }, fmla: "" };
                if ("num" === e2 && this.timingTarget) {
                  const e3 = new R_(t4, this.timingTarget);
                  this.keyFrames.push([t4.time, e3]);
                }
              }
              const t3 = { time: 1, val: { type: "string", value: this.json.to }, fmla: "" };
              if ("num" === e2 && this.timingTarget) {
                const e3 = new R_(t3, this.timingTarget);
                this.keyFrames.push([t3.time, e3]);
              }
            } else if (this.json.by) {
              const i2 = { time: 0, val: { type: "string", value: this.json.cBhvr.attrList[0] }, fmla: "" };
              if ("num" === e2 && this.timingTarget) {
                const t3 = new R_(i2, this.timingTarget);
                this.keyFrames.push([i2.time, t3]);
              }
              const n2 = { time: 1, val: { type: "string", value: ((null === (t2 = i2.val) || void 0 === t2 ? void 0 : t2.value) || "") + "+" + this.json.by }, fmla: "" };
              if ("num" === e2 && this.timingTarget) {
                const t3 = new R_(n2, this.timingTarget);
                this.keyFrames.push([n2.time, t3]);
              }
            }
          }
          if (this.json.tavLst.length > 0) {
            for (const t3 of this.json.tavLst) if (t3.val && this.timingTarget) {
              let i2 = null;
              "string" === t3.val.type ? "num" === e2 ? i2 = new R_(t3, this.timingTarget) : "str" === e2 && (i2 = new C_(t3, this.timingTarget)) : "number" === t3.val.type ? i2 = new M_(t3, this.timingTarget) : "color" === t3.val.type ? (this.isColorAnim = true, i2 = new I_(t3, this.timingTarget)) : "boolean" === t3.val.type && console.warn("not implements"), i2 && this.keyFrames.push([t3.time, i2]);
            }
          }
        }
      }
      class O_ extends Vh.k {
        constructor(t2, e2, i2) {
          super(t2, e2, i2);
        }
        set percent(t2) {
          this.uniforms.percent = t2;
        }
        set transition(t2) {
          this.uniforms.transition = t2;
        }
      }
      var N_ = i(121), L_ = i.n(N_), D_ = i(122), F_ = i.n(D_);
      var B_ = i(123), U_ = i.n(B_);
      var k_ = i(124), G_ = i.n(k_), H_ = i(9), j_ = i.n(H_);
      var z_ = i(125), V_ = i.n(z_);
      var X_ = i(126), W_ = i.n(X_);
      const Y_ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAMAAABHPGVmAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAr5QTFRFAAAATwAAOQAAZgAAKwAAPAAAPQAA7AAA/wAA/QAAugAA5QAAsQAAwQAAsAAAfwAAawAASQAAZAAAOAAAJwAALAAALQAAqQAAiwAAmgAA5AAA7QAAtQAAhQAALwAAfAAAXwAAYQAAigAAuQAAfgAAswAAcgAArQAAqgAAZwAAaQAAMgAAGAAAiAAAjwAA1gAA6QAA+wAA7wAA2AAAbQAA2gAA3QAAuwAA3wAA2QAAxQAA0QAAzwAA0gAAXQAAYAAADAAADwAAGQAALgAAjgAAcAAAzQAAwgAA+gAA3AAAGwAAoAAAowAAcQAAVwAA1QAAIQAAWQAA5wAAsgAAuAAASwAAbwAARwAAMAAAnAAAUQAAaAAA9wAA4gAAPwAAbAAAOwAAlwAA0wAAjQAAvAAAwwAAkwAAQQAAvgAAnwAAvQAA0AAA2wAAwAAAWwAATQAACwAABwAAQgAAtgAAgwAAvwAAgQAAlgAAEAAAxgAAtwAAmAAARgAAjAAAdwAAqwAArwAAywAAYgAACAAAmwAAHwAApQAA8QAAdAAAbgAAFgAAgAAAogAAewAAXgAA6AAA9gAA/AAAzgAA3gAAkgAAngAAdQAARAAAmQAATgAAUgAAJQAAIgAAqAAARQAAPgAAxwAACQAAAgAAMQAAiQAAhwAA4AAAUAAABQAAeQAAygAA9AAAFQAAVQAAyAAANQAA4wAAKAAAWAAAZQAApwAA4QAAyQAAXAAAkQAArAAAdgAApgAAHgAA8gAA/gAA6gAA8wAAFwAAHQAAhgAArgAAnQAANAAASAAA7gAAlQAAJgAA+AAA8AAANwAAJAAAHAAANgAAkAAAKQAAoQAAzAAABgAAFAAATAAAeAAAAQAADgAAggAA6wAAEQAAfQAAVAAA9QAAIAAADQAAEgAAVgAA5gAAQAAABAAA1wAA+QAAUHExBAAAJDlJREFUeJwlevk/lPv7/2XtOrKNsWcbzGCMJSmSpSxJZtQkjPEOg5mxRWns+xpZyr5ECGmcLIOsdVK2oyJbcVI0J8fp/Bff2+d7/+BhPO6Z1+u+ruf1XF4GAEAGZOXkFRQBTiD+dgKVTiqrqKqpq5M0ZMmaWtoAOrp6+qcMDMFIzdiEYmpmbqJBpVlYWtFJitYMG1sbFTskLvvTDmcQHM+ec3ImXp13uYCubvB/l7sHkC9eAk8jcy9Eb5/LvldQzQ+v+jsw1ZAlfwYDAK5dZ98IvIlBwXRNXVYIJ9TpLJUb9j9LvBVOj4jkRVGj/Y1i8AwiH09eEwhjMU4uXtsiAWLlqInMcLh+28okKRnuhNy945lic0+Uqu7NdErDdB/5DBo7MwuE4J+dw8jIzcsvwEIUFFGEisWQm1ACpcZlxF7vl1c8YMCJyqrqGio+fFRbVw8NjU2uec0isNWhVuq2XMPzmjcRBVHhSWCtXaPR2mZoybHzL0TUfmxPabeR6yg/+6QTY83VQNOkSwkbumsgkgzwtKe8tDdHYM7ts3sW1Q/Pn3PEWaGmYjoje+B3ewx9bM4V0LNfDB5XL3/o5v1hSBi5fzvQkQESOkQOwiiwI++5YBdkDjFIrKEx3cZK4Ti8eAlZpjcnYMSHKG0ygKKVeFSLRpOZNL9p19Ku1Q9enKlp45lZiQGr7hlWS17RKWp03mv8481cQnwBUNTAXwIUeAvsJwCCTnV4FyJC9CrKYDnOT91DpRZSG8Bsn7pAw2Ihd7Hn7R0hynXezjQcvQTyMGgUjV12kiW75XaR7Z9OK9kD0/j6ckfyk/fcPHCkvkz48NG/r3p4FeRpoQa9JA74sJAOcLubirEPqXqTpZ1hNzUN5exoNVbk5RmSOQqcJix5yWvvRZZ9nyay+tqAsb6U76oAwo3wgXvJkK6sCpOYQBTIdT6cg92rSxWh16pdV2c8NnDzfQhveqvND4k6aAB0ssWnHuL2yZQ7AHLzJTgUrreyZeWewhawpw1RMDWYHLP1OcNQgKzwlKVP5JV5crB7cZ+NRJ6AB3wx/x3RsEufEkozLu+g7+zkekfLbFQo8byEubp5ld7Ot2CQKxJ7qguZxF4SB3ozQF2pCEIbcaFxg6eAr0/MbeHb1DCK+vQCA3j4YTcwjNiWyEgcq1dRlfnXsq31K3hhhvNX/CYM0JC+asxk91d+7ahTr6AAaTAn3U2lTBfjIc1pr5VEX94yw8uIZhWQVAHQj66iLErxDLqNmN0wuO9hYf6FN+boQb1FjENYJAiWKrru2ejWzoZX6M9A91p2Sw1TTRT/rdDQsyiOT1f6br4fKm6Fpeb9qocNfvYOLPAuczuA5BTbeVT2O/ghlkYEScGHX0Df3StfyMT4iYHCTEQTLj04iWePVx6aomPYGLc08OXB+drJLqoq42/wXqB5eagtaqR+ZAPsymG8utBxt1rO8zFTPHITA50gCMQ4Gw7tQBZFo0DBsWb5ExlyKoBbvRAO7jdv6U8jMYne4Y+iWXmg53gvbNYsGg+gU3elEnaeXB/ufFUKJiyZdNZemo10NviBxr65KE1k/Rijg8KTan5647eoiJQAYPIL+9fuHPb/VSMucg/bcJHzKt557SPRYF8voq1+2SIWmSgQCZo2ZjhlymMigEZdZQ3MzX6wmmMTECwNWieLpWDlKihSZ2sVVwNX9AmecOXtMHP7C/WwPzvKbZqiJIYFZ7PuZngFJmNi9YatOLLQU77vGbS6PzGdsQVn/Ad7nQyALeZVbm01GA72t5bvR/aWTWVIIEVDwDJanzjqAc8QuFl4Yr9/2WTdPVPmHCtY7ZEZ4mJoDqURsbWcaHwtmIqJWrIXshpck5ilsHlYM34YFFXTG3dGzKrDMBxB8gsDn7G3bW/TDpe51ALDmy5KQW8lUgg4guspE7TN7wCTbFWnf7gBB16vuHtYoXsWo14j1cD9/Z+oyj5GF95jqI9KG0s6YtJ0N0jtISrVAZQcIO251QuKrBIaH7k2hLK/Mw8pyNmCnott3tGm6XjT9DsZUps7H8DCHwjc731hFRtTaF2UQ572Ca4Qp/On0RVdmFD0A219YL4DcFBN/lnfBvNr12E0W2MSZatepyNLVIbbFIg7jaYfoR/4W1VUKqL6zsF4NpNiq4orZEhCEjExd7AQ2j+B6GMOPmekeA7+DsM0IAsIqj31xrtAzvWqBsjmIWC6+uBONItM9R+HA8rGHxptX9JAF/G0L6QEiy3McdFEhp4+YNA0FHNwnW0/RFFEtwHRb/hwQsbzX/heYihsB6nNVJssfHnqQe/acYKMv8LqcRe7aEF7Y6ugtWxKLILeNmlzVF277PqxIg8dSxpo5gsaMBFxfgwvdWBhOvzOHHHzx4JUHLNpyc8LUzkLcfiIv3A2jQxpeQ1iL4IKUJ1dTmigtKLpgi6QjX2d8ISbHl1B8bH0UEbnI2DMVm5h4+6Ko+kTd3VVSVPGkpp4/p+BW7/faCjBhlD7MoDqRpcOJxz6lBe8gWYtBP80qaKf86k0FP9L1ziS+Y1m8MPaWpcD8BXkG2flILIvKvoC/hr8upkS1N2pwbQD5NtZmC6iNb2JUVJTRDoZxTXibAjQDp3w/y5Bhld8zynk7OU1S3S3LPnJLvjhzcfUaKeYeJwtkmPDDbYpWt0gTaf8e/gL32vUwV1i7lHVD65CN0n+CySLiHLZfbSx/XYollUUj09xeL/Cjqg2DUp2eM7igsEZPyXlnve63tfjYjZSbBwtUf7mlAhvX0N/CzxFIKE25lol9uEzuf4B95AK6EAVtXBSn3XGA6bVuISAxQuuFKTClSg4xz/VEivy43BYA1UY4x7aSd/i1RMdwdgzi68x0JEYIfLBbEMag6Kcur0R3WGGtXvT2744+WPE4QaWz1rrbq5fEmwQTMwOLPRNs2jAJiPTPpAjXA48lyGNDo/aEnNyEv39YQtTIKcLY2gVw/SWl2eGCgmvgRKcowIU96xWM6PvyJhk/4dRHbP4A2JaG+uq0xb1J15Gaa++VgngHKhh3L3grVzTsa95kyjw3wgZLYViuASK6smRQA8Ds39GAisCnrN+wiGik1BsIZfpFhk9aVvJNr+pUWJbSmxoOAqRzseBsHsCPJ+9EvFA6HLDuymPuB3VbLuUAeRzs5AnmhdV52drj6JdA/9JE6GEWqDZIrYYlrYCDM7hLcefRsAoFiZc4P3tYx5qFsH9ttFzAL0L/lgSwvjbS4Hlik7xGLuSVfejKzFhvtnHF3039B8VGq1UCpg4+cLt0KMDi46N3M5F9YWHiD/InKc21mDdj2pCGZNgqLihu2j14oFnH9dxycOd1FsVBZ+cMEBkuu0U7wwPJEfc9SWATH9MuG0EvfyJPxuf9enmuy3ipIOtB/Tq8fRSfpzQFs03/H+7yBgpxgsOgaPD69B90NfAH5SMhqmB4xns1ARtQlmao4VcBTRTDeuo6wPwzlIp/AQcGagk6KNOsPIQxV8P+wi/EIUDDVLWFGWvjTzIZnkLRH1UoJhWpXMTjPAjt3UAX17p6WGAJwxrWKi26AC0+gNR2jzhlwfEJrgvQCombOyaY8/bLwB9fMvueMLQvWNkBKGC0lq0Ht3KzP5jCcE4StVpESb3tdp2iHeZtLDMQ26rGa6n0GpULC4tIz4jBBxadsL3wHdFQPwahEAq1xR5rwJkcKwXQrx0f6F7awZw4fPbGa1gUiXJVpYOUgng1Il6/kdwHeGfQlS+PdZEZ/WbBBOmQjvC0LG6wpXRfApSSh5UP+GjCtGd2HwGkHtuvHkJDGvpqBlcXLXap5CKR9eJRzlgZ8W4zK891g7/yQl4SpDRz5B6E6FEUxFv8K/4i/p8Hn1DOZxLx2FQHi3X/cwgM0LCK+TZnTMszAMO3JUIXyO6zOQNiThG4OXOrwJNCE8XwV95JJ175KWLydZwJE882VhaOGyWMiSKcP771g4kaYKUFB2Dmz0JUdUk75Pplh8T7VBZwUY90zTpUDwWxIJNQ4p3+oSPgHVcJUQVskdpHklpVCunu2AMvq7HI2HuekbnizilxbZeVzVwQLUBT133fJUvswkKMu+OHgCDmIJX9+b8TDTiXIyTQUrXPXFm5NsIOF7X6snH0GkbLAqxPlJ9ecWoX5Ywy8Vl/GgAlgE21JAfp4T0F8NwItrDq/BXLuXDsET46eLTOOKK5svMyhZ3Ah1ePwHOvYdijiwWbAEJnbIP5V95SOcbXM43qIJm+5G32UABbhvaNNvRffVynh4jmDDQ3V+XtC1dHWnr5PFwd9Ds2UdVaIEHmECBo9V1OAz0w9Q7ZONc7xXtF+8+ETCmmX+G7+2+flmEDTEww2Dr5eQAbJggPltoLQ9vmismCRLQYIvSsXqDWOIS85DgRSlAhWjGdOxACJXNVdyGoSxA1lu2eETiYQrdn23iL9SxSRCa5LgEX0CruBRSxHIQWrdV/mq5qOUyNgs9QUYv+xsmlhwRichkxSqZko2RwH46USV7CUofNLnT23rewuaB+3Y+8g82zzjibgmdChhbQRFk34o/zPECaRHy7wKj5wlFDE8H30Jva81PwVlVT/UNLeH5C/T9cIDrBy3capubs5y2F7ATbAwpRvThn7BsaBvwbu0BBMDxHEtAsSE3DVOdF+kWWcXsfX3AFYeWSbrZP/TS/H80MGryotBYxj1U8rWXomZeevT+aQ0crFNLeulQLpiCr0J3rB5jTS3MR+wbSYRJirC2/5eEGCMHpzOUFWEplMsWaW0SVaCL8y8rZVI4hiy4qyEC7CW0YwNHTGLxvJ2vW6GNMctZQNF8YFxN+y/di6ENOZNtphmlCkIZsU3uvDqzlidm8vQCrkUfzYk6D4AYr6tk+mccy/i8xBKFQzibM/wWTIysZ6cDt/XhySBb1niUMBJRN+ILdWbj7Z6dnUgLZELPYXWeyXNhzV48NvUbAWzWEC0lD8PwVIGTt6rveS3h3gX3XiVRg1O5poRFvgPCL17nEx324dKJT5AC5OU7RFWXuEp0U1v+MRgY7mxikdoB4lle086YyXrr61aA8eVem+VOaY1TKn/sOxOeRhIcR4AZLNrygau7faIG/T/vTPO010Kbci6K9mAYPE3+D/Q/02VDHhOfPxxTud5MF+8KsrdY8Bw4TELjh26cdDiBfCo2ptEyDRsJrRk1KZcvgta3ckuK5CRPn7AxcptUHMpozoAU68b9ElVYL1uhaVz7RTJwRJ15W+0X8HZs7gUMi9wPAEik099Y6ilYhW7j1KNLmlFXlRwAb+NvU+PbN1AfHY1t+/sN4J1JVfn7FDYLloP1Scsg9GA3s2b6XMPgHYNbve6n3ghsmK0WGyzvNrCU7t0veADh7RGOKA7vXwYQc0uuPZMJMUQMLbBdz+2kFzkStJJNFEvH/f/cT1wnXJfsflkfnn+qJe89nGfU5c6Fpsd3vp8y31fD+eHg8uZSYXdwqcoBT9DS0aTRKoaZrdSqk0KtkFZb4+BBqXAnpKdyVLXBuP5clrK5wxSYyIWrghPCaNnLhJkp/A3x8fsMgMczROQeBhpGULvpU+ZNQqKLZQMr2c5uvEvEMHOemnBn5rN1M88Y+/TkhOxUIBP/2P2jr1+oIelfW2KEQFOnrjfGzrGWUsS6YsjIBTxTDwc64bw+fGhfW5AnvnpxLYAJDBm2lJ6rvaNZZMrsfTANYByHtYSbJahyNwhmaepqjdIPb+zS9jVAgfRHPZEjU1Gd3rhA/5cI2/I7HkyV/yE2rhd7VLRC+6h3nRnBwqHqGw2HNB46i9yPFIYrAbBjbP8Xiw3DuyzbyCf9d4TVDRcSKQussrgoejwBiAjYwZi0qcQK8KuYyotDvMBHuWgDgNhVUXyHsaOlkxmK4H0+NoRd5BhMX9v+E0DX3JzZF4fOt9EZhbDdj5dngkuAUBvofWKvSxgvWN/JXhGtuib/SxfY8KRQCXuP9M9m4RKN/YNl9WjkI76xL/vI3tkUW8UwNyBJ97wf3vZkr8zgZWjt09M51pPhhhhIa5n7iOjQUKxcVfAILZl0T4jc7FxaD1109JL9Ca0sSBbrEuNCQcFBiIv+SZSJPYe/1EYItPw54SrCk2fKxMmvjDJ19ORWT937dR9t2yrEWeJCbBTuaVFvARwhlXYkVrmPmMoeHL//5uHAvRj2Y8axOXO33AUsW/qXsBWn9CxkKIYN1C7xCb9tfTfE+3+m+utf4yM6L/i+ic02U8cQ2F98GKWj7KuD2pLDXkPCLCOzaCvJfwOemmSw+9kphfUY4yI+yj5/MmQxX+dJTNMaPNhkZY4Wbc3tEQKBn08wseAkoa6qqIQUIOD3kPmDGdgoM1ToC4KklkiDUBk4Uk/Fidp8zCJcFBMgHj+etTxbRFeHvwhf80CiSt3z3DIFYl6k1lWLVvRBn0lpMVKj6PITC0tar9jbVAPhHP8k4rhblOqCcOdqrAPy67Z1WL4TfMfVx0GLrHQJyH8iQUus8lkFKuv5kcYrNvW13YfKuZ89ORAmC15BmyKxBFilYKq8dxQRWdqGLLb8Rij6WrIs7/mxVyFptbrarK6uDO1v3yxzOWQjtaz2W/01pTvN/Omyfx8D2VGPK80olW8HfnliYW8J7UjIcIlewB+DJW6whrBEqHlPOAQ8W/xs1Hn5GmuasOM+K9M5T9RYI+PMwnvMsCTG6r+dbVXfMESA2YjneGLq0D1CQv4w2JrzNXBsshiH+QHHQa2Mr/AZ4I3FCYwSF30Bqgti3TOnZKmjAfxUANcv/0JqQQ2HHnOhMOwJodHns6/25Jg743Q1lQ+KbmEPuPq51Bt83snYTH17IxKtNv2roT2epeJDTPX4a0X9SZHNHJqSie0RtRDgKb5JGNRAJr4h2aypQVI68DWseD13hXjPfFQtgcpsWw3+bHWbYNMQ5bN4cjo9d8aBirB8/oJdnePZQoxNeCAZZbotwjOCA0wROeUdcuZjnmA4UdjXjcB5b5xb9AZYmwdFSH2DdhvscW5z5QnIMnYTFRngKajbkSdjvvVyWw6LwIJWxlYhshBPGlg4xDUFZOFLf2UlA4MUe8DA8TIea+IX2smNzuP0vmleE8ArQR+UsNqTqekrljgz0+vhX5+FaB5qs3t9J5cPuwScX+MPS/UkluQXNh5WrJFM9p4CGban0P71P43YKxglb2X+cyKQ94h/diX4v9RaCpnBsnLBEiBNo/0idpiYrznuGrJbXrCBGfcS8UOZNOTvW4hnUTwJkuVcBHodNx3R8t5LtTDmf9/EmsNByWOE4XyHplSzut+ilAlOYAW6FAoMlRP17j9CYvp40MImU7d5GfS2Drx+GW3yciuygcSeJPwW0wzd8Jx7iITtZPchNXC6aPAtKQrB2xa8z53r/+NXr2nhyLPFySAhSY0IYOQBgKT6h3kSWUhtwoeuSh11H23xn6OOue1lRwSZFtnWn9cdSaaEGqWp9dYsa7+ChyZcubQzxJjXzXLk9h89vBXfZGDIlvpsP4QIbmPMjqxhqsBfefv19nkI6ATGqFQsHNSKV1bi5RDhNzYOR3Ckunra8gfjADKT/ll0bAtT+Gyj2d7NLfv1oX/s3Dxbwcs6upK916xmn4Cn9qoUPECeybc02KdxfxGRB0zT8l0Zikliu1neuQQ0TmnzytBG1jCdcA7AUAfwLbEnAjIqNRI/tr3AS3HHzaJJ1AVHLTuHM72nkWqYVDDf+j66wmI+h8Lmvxl4OGEXnX3JOrwBz08R7ELtwHigs810rOj0viiWN/+sC7Ni5oBKQ6bZk8eHN3PYLZzQgVjEb5jNex3lMrEC0EzpQ3faNx4xd523exujDDnuf5ZP5S7v7/UuKqkqW2X94NfxXy7549ho3WWi6n1Vt7ABUIeJc5cdqWkRZrf4aNACabeODzxEINKtnW6CGh5734US98i9pjARiQfrdT+ax6iuaQ68hRSbykUQcJUr4DoFBkm4wgd2hq4tBIt5iGqkmIYjIK97X2Ac+y7Al6Eas2r5VF3EkYVixIGsqzlkm0RXA05xqwaznFZjzk8V80Y+iIDhMyNdfSpEMp3IheR2cbKGSnSfWK1HK5rU73te+Y+mp46Jt6oD3xe3/MKUzoD2UBzNmu3iQW2uCJHd2ne9t/x3h7lnn4kBxCEAK//UgVlyjyz9W5JHgDWu3g3OlGHBZO/680MjgZCrLsuOfLU+5jPl2Pxck02uqzyqmPlhPA0isbdnhRis6Qh/S179zV226tq30IMf1KqJ+bHgSCHhjM64dbIL8GGt21vGOEXP+/AJcER6NjIb286TKSzTCCidNp6Zf3rpsWZnG5dNhuEqU94Fd2sYHaDOgM3A3LO9nxQazFRTOJsT7cD4eScDOsG8UfQGqlmCqM7L0/3ZpnWylRSPqBu/B+eHEfYNZO+0QTaWrYVbLURYIK4TWR8iESRGfHHQWgthnGCFSR6XhpDR2Xtq0uhr2QQvOUVv8Giw6ImYIgOdd8OPo1dxm1hQCQV84zTzso6krY75wTfRjcwV5Geb/tJ4owfFd8kC7FDPX9B9mBYVZ0zuK21vYoVpvazdgKlwKfwFKZSgPgFfDQtTRYNOvy6JNZ7OeYCWEFJq/hygT5KPD9mIbenEBsAvHdzCG/K5iPb4S4aP/YhnMDJHIP/icNM6ztIK9gkRRdA71nyoMef+2jb3neklwx0pHH2SIdKb2jwOWG3JCmYK4Iva+7eEG0a3If9Da4KaFAGMYlTTCfFBFSoyK7YMSwyuICgV8M49c7bf4VqtKi5LOaLKCJlVZ5zBpLrIr9LvsMNctO/oiM3ab/MknNJPPbnirNLPbGflQrRr2aJJYXg/QIsh8k1PXzz+z9w5gIxiXea4P0RlO2OUDqhJdvv8EBpRLy6Z9p8GR+FFKgDHcGsMkkbMnJz0q7hAhDVdF3sCfBM6hj2P4SlE5njIsBmSky6FhkNYd2UfgLt37a35+BEvupCA+Jh5kmC5dWaGeQNmz35EEQvhwZG3qxKo/RZr66hM7IJ5Won7gh78anK172Zt3buKAMKyMDjzdR9ufcCZ0zU4DOA5RKIgkAMTbytB3LQFlT5MH/An6qfRJPjj2dg5WFP3mdlZkwFePrA+3eN2Wu0A+WAFKZrztzJRibcqCweEddxU/PSGWxOnjHtOUDzfDk9lEvDDj39cFH1E9dVeQLGVI3Qgeo0M34dZ6K/3cb9BBZcZf8uS+BivagqBuLW31L60FMADuX1jiTur3n1ZrBrIgpkFO//0OmyT9qWthHcnwzLRswTdDbgUflRNCAvfaODDSX8vQLo7QBDltK42Y/OdFbS1zUYFLv6qSiV43zDiUrcAtbEqoMVBPa37+RMTuT1gmrJVH1qqYsi12cyakNWPLrTGqg9NO1KY2vPwISkCnxobu6FodJWlXUwABhb1LwveepTps6Tt0E8j+tabfLiI+MdLLWSxLqA1cJON1hz8aZkisUWXUMhNOQpLrIR062CCV3Bg0ZwlU9OhbKefT1NjDog/g2q+TAW89zQllayE0d/y9qAdSAucb3iKOXZYzSSmdealQNS1IL3qMUpowYU6uuO7LEqyPD05MgXvXy6frzzrkpBXlAx+J30gur7J4OT/ziwA3fvIcKvLAHet4sqms0BCkZk6CKbyRPu8Xqwsv5KGfYcI4thniGI9nFwFwt1bfZm9racBom20+/R8n0upa1EAueM5b9A7lN3BE9empZqOTj5NkKNeCf630MV2jeKeEP8cImJ5W9l3gYGDg1wPxxZcmBvsZ4qZXUMim6a/M2jKAsHtYvPN1A0FsH3AAbpFvCxA200RpdN9ME2nSQL2g5pg9OIw6KkYT3gKe7QmWrItoXK1c/XBbJQ6pVOca2BzfQfoOCTygsFljpEPDG+tBLrte+jUDP2DcYKLisBjhgtTZnAmgmg8/Aus/awVIZGqScBZ1xa/82qG7rzT0BDLldEs0sP5HS8oNhU3lhDue5NS0TUt0T7YTZvSGH0HEYEs97dJ7xpNO1TKokYmLWenco4PvNEsv2hQ85pcgDjlA29jwVT9IoAcXQGCnhPG8fgYyhJ64NNzBiWf5p1XdoBx+xtXoPiVbK44FcHipEqTaar9/ruKsdneZuJmevOHPOjhmtvwVVX8Nmx+/eftj7gZmxlF3ocI/n5T0byPxzPfMi24AxSQeAGjdI3Q4hc5ffAT7v7F89ZNEgj6fheuHl2hjRQlG4EMMwpiAnsm1HT499a+zKPMejH0uAfnT4JyItDTiDQ4l5DoO/sQZ0HkzGpiM8KQNwaHk0Un9WaO+yuA1ZTV9z8Jm13bqwTlfNHncIi8M/kHQMFhMF7Imo2mUw/Sox7Bh3W6UplqvEiy+g2NvVzFPCtGkHSTLuFSL2CtGzpPY+E5O0PK3HSbUnBzNBZodkNnUAlch2Zk9/9F8JuAYBirgoVpE7QyheJ33WDOysDFYMSXBdm20XfXCWcGzsGyvXE8FJN7EadsGjIDzZ+GtIUEBWuQ6o87kaDvo4eplYs4dz6P06lSSCA0yAvpXKD1djjC8dnWdYtWsLpl4Fplhje74Y6i/M7VMSQnRvD54/CC4LPzx4vghhIOzVo6bLzl7QIHPvVyM/drqBBZ3tW1lYqvXfauRfH5WHe+RcHI+xxeqDECqJ9tdXLyy9L7RqxyUaZKwmlAux+zEzdzITSRlr36YuSm0LBhTpkivodWytR6BNULFxftqF42QqKLmoog9WlYNRb4GtNm93bHuxBvV5VcOUeY6N/9xDutwbqYhaN3rIzpg1M6XfrYctTdA5Msr2v4Aydmb+Nl2/Eqw+jSXYvctmuDHYUAei0pUc6E5N1bULPEjHAr+HI3gwDjpDg0nE2fMkXneCumq9ifZR5IKUOqn0aDIfN64olrhaHfV4msozkdG/3j5HHqsf5Els8kwvDrCaK4/BXb+YzYC00mJEOu8njPsKgB9dG+FjqqeToCsJKLTvHS+iQTnqFquCJ+yCckuDaHLnP4GzroGg7BelrYZWStEFay3j+vkEuXHy3B2zG5xBqSx+/pxoEOv+OfiCfq5QMCCNq26xXC+1DZ+eQdH2jJ9FXSh9yrISZTk56jTzMIzG9+Ye+pumQffxmh2lcvPXjmNWL3PoOgRpkx4o/TZzE2y3IMtEZNxpNUlBqFlnBVXuPS0TIBkF+ZfvW3y2bGWD14zb8Cju5+wiSW1pIIRRtD0DeaxOLIvup5BZ2R2QfQVx6ryHH4H/rls/fRJy6KIdsJ/qVsWrBZaKgKOhP0GOUjA16wS+vlpcmot72SIWJWQDwyiD04TLSU6LyObtnOC2W5QA0OCGXHtlTi9Cyh95AIL8UU6AaQOaDSDfuf3DbxO4065WUdqPZ6Zj9S26jGlhDs/3mX1c4h+to5J2UwvgO3dkFtmKMBF3OuQvskMsOO8R5FnXblT4zMUpkjhs3m1ygag6zQWKfFOQCFM8jmAFtaCpCqDX77xqhE3B99uGU3UT+41SufAp9fQENvgk5lwqneywazIE9IpGT8v23sBPibAHG34mLWiivxnjk8p2S5ofshihnLQd4CU5ABpVcMX/5Hg39Jm55k+hgxugBCGIR5KmY+qz6US5/wKYimBbjTOSBlyD9OiYpWxtoLH6PcoaUdK0dW4vKR121dfMwumvgSBf8g0fsVN0w8jbplh7Df1FVC9wZuTbZStSswGJu6IngHRvBgOFag8F3hwPVNuUYjxNngNURuMvnnOvway+3l+1sK7aILbzdSzAxUCtG9/CaaHsBFIVzMWEH7upNL6Hr6P+oI4i+VqT6NyQrYUMkRXYd2P1ZjEMDaJ1rrurxTBgTfMw9cZe8SHIAz0JA7jpgDmr+InVbg0HrkFNZVhQ2uBKn75tLEZwfMp2azBhkglsAXDPx2BccwTDGmnsjRDh2jHh9ynTQY4vLqcuv/NWRlP8sFHWyxSmm38ikF1UoTywoZL0oFE4I4ujqIcvCuo+0ABPohIMdyq8EqgTcogXcYNCGdgvytDCA/fwt2eG78+OAANOgmKkOI8WdjE3FaFdqW6rx/oOBunJoqMLOwnPtv67Cw7PY8c4jFvek2G/hk1Thivu5Pf2iV8YDA8DyziBPz6MKlF9XQlRt7ZRV09nZrygwo00ME7IpFuOiEsUrd14UcCvNC/DPkbFmqB1uQIg477mFiq2niVADUYnvdjiQPNpFfMTo4yg4X+tDW3rmH2WE9E2rY0ES40wM6QRwaQL5/fepJULkj3Zc6L1ItuWmO6zXbvou399GBCPcQwB2+rRpubsw03qWL2iRyHH9Afl/YHuFYa8v7zEXDEigXJo9RAtTM4BTzElQhSgePv55AmHTo4W9v4SmkPDlLIhOpcXBK4GO2AnyzeN0MaKP7umX9bZAfc5LA84bxj3frYCxezbP9KG7QeJzevIhiAU4p/j+y2OyMV2mxNgAAAABJRU5ErkJggg==";
      var q_ = i(127), Z_ = i.n(q_);
      var J_ = i(128), K_ = i.n(J_);
      var Q_ = i(129), $_ = i.n(Q_);
      var ty = i(130), ey = i.n(ty);
      var iy = i(131), ny = i.n(iy);
      var ry = i(132), oy = i.n(ry);
      var sy = i(133), ay = i.n(sy);
      var ly = i(134), hy = i.n(ly);
      var uy = i(135), cy = i.n(uy);
      const dy = { wipe: class extends O_ {
        constructor(t2) {
          super(F_.a, L_.a, { percent: 0, direction: 1, transition: 0 });
          let e2 = 1;
          "up" === t2 ? e2 = 1 : "down" === t2 ? e2 = 2 : "left" === t2 ? e2 = 3 : "right" === t2 && (e2 = 4), this.uniforms.direction = e2;
        }
      }, fade: class extends O_ {
        constructor(t2) {
          super(void 0, U_.a, { percent: 0, transition: 1 });
          let e2 = 1;
          "out" === t2 ? e2 = -1 : "in" === t2 && (e2 = 1), this.uniforms.transition = Math.pow(e2, e2);
        }
      }, blinds: class extends O_ {
        constructor(t2) {
          super(j_.a, G_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "vertical" === t2 ? 1 : 0;
        }
      }, checkerboard: class extends O_ {
        constructor(t2) {
          super(j_.a, V_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "down" === t2 ? 1 : 0;
        }
      }, dissolve: class extends O_ {
        constructor(t2) {
          super(j_.a, W_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.setTextTure();
        }
        setTextTure() {
          this.uniforms.dissolveSampler = Vh.t.from(Y_);
        }
      }, randombar: class extends O_ {
        constructor(t2) {
          super(j_.a, Z_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "vertical" === t2 ? 1 : 0, this.setTextTure();
        }
        setTextTure() {
          this.uniforms.dissolveSampler = Vh.t.from(Y_);
        }
      }, circle: class extends O_ {
        constructor(t2) {
          super(j_.a, K_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "out" === t2 ? 1 : 0;
        }
      }, box: class extends O_ {
        constructor(t2) {
          super(j_.a, $_.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "out" === t2 ? 1 : 0;
        }
      }, diamond: class extends O_ {
        constructor(t2) {
          super(j_.a, ey.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "out" === t2 ? 1 : 0;
        }
      }, plus: class extends O_ {
        constructor(t2) {
          super(j_.a, ny.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "out" === t2 ? 1 : 0;
        }
      }, barn: class extends O_ {
        constructor(t2) {
          super(j_.a, oy.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "inHorizontal" === t2 ? 1 : "outHorizontal" === t2 ? 2 : "outVertical" === t2 ? 3 : 0;
        }
      }, strips: class extends O_ {
        constructor(t2) {
          super(j_.a, ay.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = "upLeft" === t2 ? 1 : "downRight" === t2 ? 2 : "upRight" === t2 ? 3 : 0;
        }
      }, wedge: class extends O_ {
        constructor(t2) {
          super(j_.a, hy.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) });
        }
      }, wheel: class extends O_ {
        constructor(t2) {
          super(j_.a, cy.a, { percent: 0, transition: 1, rect: new Float32Array([0, 0, 0, 0]) }), this.uniforms.option = Number(t2) || 1;
        }
      } };
      class py extends E_ {
        constructor(t2) {
          var e2;
          super(t2), this.filterType = "", this.isConflict = false, this.activeWhenConflict = "prev", this.onTimeUpdate = ({ duration: t3, delta: e3 }) => {
            var i3;
            const n3 = e3 / t3;
            if (this.filter) {
              this.filter.percent = this.commonTimeNode.applyTimeFilter(n3);
              const t4 = null === (i3 = this.timingTarget) || void 0 === i3 ? void 0 : i3.container.getBounds();
              t4 && (this.filter.uniforms.uBoundRect = new Float32Array([t4.x, t4.y, t4.width, t4.height]));
            }
            n3 >= 1 && this.timingTarget && this.ctx.clock.setTimeout(() => {
              this.removeFilter();
            }, 34);
          }, this.onSeekToStart = () => {
            this.timingTarget && this.removeFilter();
          }, this.onSeekToEnd = () => {
            this.timingTarget && this.removeFilter();
          }, this.onDestroy = () => {
            this.removeFilter();
          }, this.commonTimeNode.on("timelineStart", () => {
            this.filter && this.timingTarget && (this.timingTarget.container.filters && 0 !== this.timingTarget.container.filters.length ? this.timingTarget.container.filters.push(this.filter) : this.timingTarget.container.filters = [this.filter]);
          }), this.commonTimeNode.on("timeNodeDestroy", this.onDestroy), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate);
          let i2 = 1;
          "out" === t2.json.transition && (i2 = -1);
          const n2 = null === (e2 = t2.json.filter) || void 0 === e2 ? void 0 : e2.match(/^([a-zA-Z]+)(\((.+)\))?/);
          if (n2) {
            const t3 = n2[1], e3 = n2[3];
            dy[t3] && (this.filter = new dy[t3](e3), this.filterType = `${t3}-${e3}`, this.filter && (this.filter.transition = i2));
          }
        }
        get modifyAttrKey() {
          return this.filterType;
        }
        removeFilter() {
          var t2;
          if (!(null === (t2 = this.timingTarget) || void 0 === t2 ? void 0 : t2.container.filters) || !this.filter) return;
          const e2 = this.timingTarget.container.filters.findIndex((t3) => t3 === this.filter);
          e2 >= 0 && this.timingTarget.container.filters.splice(e2, 1);
        }
      }
      class fy extends E_ {
        constructor(t2) {
          super(t2), this.isConflict = true, this.activeWhenConflict = "next", this.startPos = null, this.onTimeNodeStart = () => {
            var t3, e2;
            this.startPos = { x: (null === (t3 = this.timingTarget) || void 0 === t3 ? void 0 : t3.ppt_x) || 0, y: (null === (e2 = this.timingTarget) || void 0 === e2 ? void 0 : e2.ppt_y) || 0 };
          }, this.onTimeUpdate = ({ duration: t3, delta: e2 }) => {
            var i2;
            const n2 = e2 / t3, r2 = null === (i2 = this.path) || void 0 === i2 ? void 0 : i2.getPoint(n2);
            this.timingTarget && r2 && (this.timingTarget.ppt_x = r2.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r2.y + +this.timingTarget.design_ppt_y);
          }, this.onSeekToStart = () => {
            this.timingTarget && this.startPos && (this.timingTarget.ppt_x = this.startPos.x, this.timingTarget.ppt_y = this.startPos.y);
          }, this.onSeekToEnd = () => {
            var t3, e2, i2;
            const n2 = null !== (e2 = null === (t3 = this.commonTimeNode.json) || void 0 === t3 ? void 0 : t3.spd) && void 0 !== e2 ? e2 : 1, r2 = null === (i2 = this.path) || void 0 === i2 ? void 0 : i2.getPoint(n2 > 0 ? 1 : 0);
            this.timingTarget && r2 && (this.timingTarget.ppt_x = r2.x + this.timingTarget.design_ppt_x, this.timingTarget.ppt_y = r2.y + this.timingTarget.design_ppt_y);
          }, this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeDestroy", this.onSeekToStart), this.createPath();
        }
        get modifyAttrKey() {
          return "motion";
        }
        createPath() {
          var t2;
          const e2 = new zs(), i2 = null === (t2 = this.json.path) || void 0 === t2 ? void 0 : t2.match(/[MLCmlc][^MLCmlc]+/g);
          if (i2) for (const t3 of i2) {
            const [i3, ...n2] = t3.trim().replace(/\s+/g, " ").split(" ");
            if ("M" === i3) {
              const [t4, i4] = n2.map((t5) => Number(t5));
              e2.moveTo(t4, i4);
            } else if ("L" === i3) {
              const [t4, i4] = n2.map((t5) => Number(t5));
              e2.lineTo(t4, i4);
            } else if ("C" === i3) {
              const [t4, i4, r2, o2, s2, a2] = n2.map((t5) => Number(t5));
              e2.bezierCurveTo(t4, i4, r2, o2, s2, a2);
            } else if ("Z" === i3) e2.closePath();
            else if ("E" === i3) console.warn("not implements");
            else if ("c" === i3) {
              const [t4, i4, r2, o2, s2, a2] = n2.map((t5) => Number(t5)), l2 = e2.currentPoint;
              e2.bezierCurveTo(t4 + l2.x, i4 + l2.y, r2 + l2.x, o2 + l2.y, s2 + l2.x, a2 + l2.y);
            } else if ("l" === i3) {
              const t4 = e2.currentPoint, [i4, r2] = n2.map((t5) => Number(t5));
              e2.lineTo(i4 + t4.x, r2 + t4.y);
            } else if ("m" === i3) {
              const t4 = e2.currentPoint, [i4, r2] = n2.map((t5) => Number(t5));
              e2.moveTo(i4 + t4.x, r2 + t4.y);
            }
          }
          this.path = e2;
        }
      }
      class my extends E_ {
        constructor(t2) {
          var e2;
          super(t2), this.isConflict = true, this.activeWhenConflict = "next", this.startVal = null, this.createVal = null, this.onTimelineStart = (t3) => {
            t3.isReverse || this.updateCurrentValue();
          }, this.onTimeUpdate = ({ duration: t3, delta: e3 }) => {
            var i2, n2, r2, o2, s2;
            const a2 = e3 / t3, l2 = { x: 1, y: 1 };
            if (this.to) {
              const t4 = null !== (i2 = this.from) && void 0 !== i2 ? i2 : { x: null !== (r2 = null === (n2 = this.startVal) || void 0 === n2 ? void 0 : n2.x) && void 0 !== r2 ? r2 : 1, y: null !== (s2 = null === (o2 = this.startVal) || void 0 === o2 ? void 0 : o2.y) && void 0 !== s2 ? s2 : 1 };
              l2.x = t4.x + (this.to.x - t4.x) * a2, l2.y = t4.y + (this.to.y - t4.y) * a2;
            } else if (this.by) {
              const t4 = { x: this.by.x, y: this.by.y };
              l2.x = 1 + (t4.x - 1) * a2, l2.y = 1 + (t4.y - 1) * a2;
            }
            this.timingTarget && (this.timingTarget.scale = l2);
          }, this.onTimeNodeStart = () => {
            this.timingTarget && (this.startVal = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
          }, this.onSeekToStart = () => {
            this.timingTarget && this.startVal && (this.timingTarget.scale = this.startVal);
          }, this.onSeekToEnd = () => {
            this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
          }, this.onDestroy = () => {
            null !== this.createVal && this.timingTarget && (this.timingTarget.scale = this.createVal);
          }, this.from = t2.json.from, this.to = t2.json.to, this.by = t2.json.by, this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeDestroy", this.onSeekToStart), (null === (e2 = this.timingTarget) || void 0 === e2 ? void 0 : e2.scale.x) && (this.createVal = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
        }
        get modifyAttrKey() {
          return "scale";
        }
        updateCurrentValue() {
          this.timingTarget && (this.current = { x: this.timingTarget.scale.x, y: this.timingTarget.scale.y });
        }
      }
      class gy extends E_ {
        constructor(t2) {
          super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.isTimelineStart = false, this.startColorString = null, this.currentColorString = "#FFFFFFFF", this.onTimelineStart = (t3) => {
            if (this.isTimelineStart) return;
            this.isTimelineStart = true, t3.isReverse || this.updateCurrentValue(), this.from.isInit() || this.from.fromHexString(this.currentColorString), this.to.isInit() || this.from.by(this.by, this.to);
            const e2 = this.json.cBhvr.attrList[0], [i2] = e2.split(".");
            b_(this.timingTarget, i2 + ".on", "true");
          }, this.onTimeNodeEnd = () => {
            const t3 = this.json.cBhvr.attrList[0];
            if ("remove" === this.json.cBhvr.ctn.fill) {
              const [e2] = t3.split(".");
              b_(this.timingTarget, e2 + ".on", "false");
            }
            this.isTimelineStart = false;
          }, this.onSeekToStart = () => {
            var t3;
            const e2 = this.json.cBhvr.attrList[0];
            if (this.timingTarget) {
              this.onTimeUpdate({ duration: 1, delta: 0 });
              const i2 = "ppt_c.color" === e2 || "text.color" === e2;
              if ((null === (t3 = this.timingTarget.fill) || void 0 === t3 ? void 0 : t3.designColor.toUpperCase()) === this.from.toHexString().toUpperCase() || i2) {
                const [t4] = e2.split(".");
                b_(this.timingTarget, t4 + ".on", "false");
              }
            }
          }, this.onTimeNodeStart = () => {
            if (this.timingTarget) {
              const t3 = this.json.cBhvr.attrList[0], e2 = T_(this.timingTarget, t3);
              e2 && (this.startColorString = e2);
            }
          }, this.onTimeUpdate = ({ delta: t3, duration: e2 }) => {
            const i2 = t3 / e2;
            if (this.to.interpolationFrom(this.from, i2, this.target), this.timingTarget) {
              const t4 = this.json.cBhvr.attrList[0];
              b_(this.timingTarget, t4, this.target.toHexString());
            }
          }, this.onSeekToEnd = () => {
            this.isTimelineStart || this.onTimelineStart({ isReverse: false, activeCount: 0, id: "" }), this.onTimeUpdate({ duration: 1, delta: 1 });
          }, this.replaceAttrToRelation(), "rgb" === this.json.clrSpc ? (this.from = new pg(this.json.from), this.to = new pg(this.json.to), this.by = new pg(this.json.by), this.target = new pg()) : (this.from = new dg(this.json.from), this.to = new dg(this.json.to), this.by = new dg(this.json.by), this.target = new dg()), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeNodeEnd", this.onTimeNodeEnd), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeDestroy", this.onSeekToStart);
        }
        replaceAttrToRelation() {
          const t2 = this.json.cBhvr.attrList[0];
          "ppt_c" !== t2 ? "style.color" === t2 && (this.json.cBhvr.attrList[0] = "text.color") : this.json.cBhvr.attrList[0] = "ppt_c.color";
        }
        get modifyAttrKey() {
          return this.json.cBhvr.attrList[0];
        }
        updateCurrentValue() {
          if (this.timingTarget) {
            const t2 = this.json.cBhvr.attrList[0], e2 = T_(this.timingTarget, t2);
            e2 && (this.currentColorString = e2);
          }
        }
      }
      class vy extends E_ {
        constructor(t2) {
          super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.startVal = null, this.createVal = null, this.lastVal = null, this.onTimelineStart = (t3) => {
            this.lastVal = null, t3.isReverse || this.updateCurrentValue();
          }, this.onTimeUpdate = ({ duration: t3, delta: e2 }) => {
            const i2 = e2 / t3;
            let n2 = 0, r2 = 0;
            if (void 0 !== this.from && void 0 !== this.to) {
              n2 = this.from, r2 = this.to;
              const t4 = n2 + (r2 - n2) * i2;
              this.timingTarget && (this.timingTarget.r = t4);
            } else if (void 0 !== this.by) {
              this.lastVal || (this.lastVal = 0);
              const t4 = this.by * i2 - this.lastVal;
              this.lastVal = this.by * i2, this.timingTarget && (this.timingTarget.r += t4);
            }
          }, this.onTimeNodeCreate = () => {
            var t3;
            Vm()(null === (t3 = this.timingTarget) || void 0 === t3 ? void 0 : t3.r) && (this.createVal = this.timingTarget.r);
          }, this.onTimeNodeStart = () => {
            var t3;
            Vm()(null === (t3 = this.timingTarget) || void 0 === t3 ? void 0 : t3.r) && (this.startVal = this.timingTarget.r);
          }, this.onSeekToStart = () => {
            this.timingTarget && null !== this.startVal && (this.timingTarget.r = this.startVal);
          }, this.onSeekToEnd = () => {
            this.onTimeUpdate({ duration: 1, delta: 1, isReverse: false });
          }, this.onDestroy = () => {
            this.timingTarget && null !== this.createVal && (this.timingTarget.r = this.createVal), this.startVal = null;
          }, this.from = this.json.from, this.to = this.json.to, this.by = this.json.by, this.by ? this.isConflict = false : this.isConflict = true, this.onTimeNodeCreate(), this.commonTimeNode.on("timeNodeStart", this.onTimeNodeStart), this.commonTimeNode.on("timeNodeCreate", this.onTimeNodeStart), this.commonTimeNode.on("timelineStart", this.onTimelineStart), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("timeNodeDestroy", this.onDestroy);
        }
        get modifyAttrKey() {
          return "rotate";
        }
        updateCurrentValue() {
          var t2;
          this.currentVal = null === (t2 = this.timingTarget) || void 0 === t2 ? void 0 : t2.r;
        }
      }
      class _y extends E_ {
        constructor(t2) {
          super(t2), this.isConflict = false, this.activeWhenConflict = "next", this.isApplied = false, this.onTimeUpdate = () => {
            var t3, e2;
            const { cmd: i2, cmdType: n2 } = this.json;
            !this.isApplied && i2 && n2 && (this.isApplied = true, null === (e2 = null === (t3 = this.timingTarget) || void 0 === t3 ? void 0 : t3.cmd) || void 0 === e2 || e2.applyCommand(i2, n2), this.commonTimeNode.seekToEnd(false));
          }, this.onSeekToStart = () => {
            var t3, e2;
            this.commonTimeNode.isInInteractiveSeq || null === (e2 = null === (t3 = this.timingTarget) || void 0 === t3 ? void 0 : t3.cmd) || void 0 === e2 || e2.applyCommand("custom-pause", "call");
          }, this.onSeekToEnd = () => {
          }, this.commonTimeNode.on("timeNodeStart", () => {
            this.isApplied = false;
          }), this.commonTimeNode.on("timeNodeEnd", () => {
            this.isApplied = false;
          }), this.commonTimeNode.on("timeUpdate", this.onTimeUpdate), this.commonTimeNode.on("seekToStart", this.onSeekToStart), this.commonTimeNode.on("seekToEnd", this.onSeekToEnd);
        }
        get modifyAttrKey() {
          var t2, e2, i2, n2;
          return (null !== (e2 = null === (t2 = this.json) || void 0 === t2 ? void 0 : t2.cmd) && void 0 !== e2 ? e2 : "") + (null !== (n2 = null === (i2 = this.json) || void 0 === i2 ? void 0 : i2.cmdType) && void 0 !== n2 ? n2 : "");
        }
      }
      class yy {
        constructor(t2) {
          this.runtimeNodeEventHub = new Za.a(), this.onVolumeUpdate = (t3) => {
            this.audio.volume(t3);
          }, this.stopAudio = () => {
            this.audio.stop();
          }, this.destroy = () => {
            this.stopAudio(), this.audio.destroy(), this.ctx.activeMedia.delete(this.audio), this.ctx.volumeAdjuster.off("update", this.onVolumeUpdate);
          };
          const { json: e2, isIterate: i2, isSub: n2, eventHub: r2, ctx: o2, parent: s2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 } = t2;
          this.json = e2, this.id = e2.cMediaNode.ctn.id, this.commonTimeNode = new Ty({ json: e2.cMediaNode.ctn, isSub: n2, eventHubs: { global: r2, runtime: this.runtimeNodeEventHub }, ctx: o2, parent: s2, isIterate: i2, iterateType: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 });
          let d2 = e2.cMediaNode.tgtEl;
          o2.loaderDelegate && (d2 = o2.loaderDelegate.redirectMedia(d2), o2.logger.info(`redirect media url from ${e2.cMediaNode.tgtEl} to ${d2} by delegate.`, o2.taskId)), this.audio = new u_(d2, o2.runningAudio), o2.activeMedia.add(this.audio), this.commonTimeNode.on("timelineStart", () => {
            this.audio.volume(o2.volumeAdjuster.volume), this.audio.play();
          }), this.commonTimeNode.on("seekToStart", this.stopAudio), this.commonTimeNode.on("seekToEnd", this.stopAudio), this.commonTimeNode.on("timeNodeDestroy", this.destroy), this.ctx = o2, this.ctx.volumeAdjuster.on("update", this.onVolumeUpdate);
        }
      }
      function xy(t2) {
        return function(t3) {
          var e2;
          return !!(null === (e2 = t3) || void 0 === e2 ? void 0 : e2.cBhvr);
        }(t2) ? t2.cBhvr.ctn : function(t3) {
          var e2, i2;
          return !!(null === (i2 = null === (e2 = t3) || void 0 === e2 ? void 0 : e2.cMediaNode) || void 0 === i2 ? void 0 : i2.ctn);
        }(t2) ? t2.cMediaNode.ctn : t2.ctn;
      }
      var by = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Ty extends Za.a {
        constructor(t2) {
          var e2, i2;
          super(), this.uuid = Mm(), this.isSub = false, this.isShadow = false, this.startCount = 0, this.applyCount = 0, this.isReverse = false, this.isConflictDispose = false, this.isIterateEnd = false, this.parentTimeNode = null, this.isActive = false, this.isDestroy = false, this.shouldSeekOnStart = false, this.repeatTimeoutId = "", this.iterateShadows = [], this.isEndEventsEmitted = false, this.tmFilter = [], this.timeDelta = 0, this.isIterate = false, this.iterateType = "el", this.iterateIndex = 0, this.children = [], this.subList = [], this.duration = 0, this.isNegativeSpeed = false, this.handleEndCond = () => {
            this.isActive && (this.isActive = false, this.isInfiniteRepeat() ? this.repeatTimeNodeEnd() : this.seekToEnd(false, true));
          }, this.handleActive = (t3 = true) => {
            if (this.isActive = true, this.isConflictDispose = false, this.applyCount += 1, this.json.iterate || this.emit("timeNodeStart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.startCount > 0 && this.json.restart) {
              if ("never" === this.json.restart) return;
              "whenNotActive" !== this.json.restart && "always" !== this.json.restart || (this.seekToStart(), this.emit("timeNodeRestart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.startTimeLine(t3));
            } else this.startTimeLine(t3);
          }, this.updateTimeLine = (t3) => {
            const e3 = t3 / (xd.b.TARGET_FPMS || 0.06);
            this.timeDelta += e3, this.duration - this.timeDelta <= e3 && (this.timeDelta = this.duration), this.timeDelta < this.duration ? this.emit("timeUpdate", { delta: this.isReverse || this.isNegativeSpeed ? this.duration - this.timeDelta : this.timeDelta, duration: this.duration, isReverse: this.isReverse }) : (this.emit("timeUpdate", { delta: this.isReverse || this.isNegativeSpeed ? 0 : this.duration, duration: this.duration, isReverse: this.isReverse }), this.onTimeLineEnd());
          }, this.handleEnd = (t3 = false) => {
            (this.isTimeNodeEnd() || t3) && (this.isActive = false, this.isSub && this.destroy(), this.emitEndEvents());
          };
          const { isSub: n2, isIterate: r2, ctx: o2, eventHubs: s2, parent: a2, json: l2, iterateType: h2, iterateId: u2, iterateIndex: c2, isInInteractiveSeq: d2, fromSeqId: p2 } = t2;
          this.isSub = n2, this.fromSeqId = p2, this.isInInteractiveSeq = d2, this.isIterate = r2, this.parentTimeNode = a2, this.json = l2, this.ctx = o2, this.iterateIndex = c2, this.eventHubs = s2, this.iterateType = h2, this.iterateId = u2, this.tmFilter = null !== (i2 = null === (e2 = l2.tmFilter) || void 0 === e2 ? void 0 : e2.split(";").map((t3) => t3.split(",").map((t4) => parseFloat(t4.trim())))) && void 0 !== i2 ? i2 : [];
          const f2 = Number(this.json.dur), m2 = this.json.spd || 1;
          if (this.isNegativeSpeed = m2 < 0, Number.isNaN(f2) || (this.duration = f2 / Math.abs(m2)), this.uuid += "--" + this.json.id, this.setPreStyle(), l2.childTnLst && this.createChildren(l2.childTnLst), this.startConds = new y_(this.json.id || "", l2.stCondLst, s2, this.ctx), this.endConds = new y_(this.json.id || "", l2.endCondLst, s2, this.ctx), l2.endSync && (this.endSync = new y_(this.json.id || "", [l2.endSync], s2, this.ctx), this.endSync.on("active", () => {
            var t3;
            "interactiveSeq" === this.json.nodeType && (this.isActive = false, this.shouldSeekOnStart = true, this.emit("timeNodeEndSync"), null === (t3 = this.endSync) || void 0 === t3 || t3.reset());
          })), this.startConds.on("active", (t3) => {
            this.isActive || (this.shouldSeekOnStart && (this.shouldSeekOnStart = false, this.seekToStart()), this.handleActive(t3));
          }), this.endConds.on("active", () => {
            this.handleEndCond(), this.children.forEach((t3) => t3.commonTimeNode.handleEndCond());
          }), this.parentTimeNode && this.parentTimeNode.on("timeNodeStart", () => {
            this.applyCount = 0;
          }), this.isSub && "nextClick" === this.json.masterRel) {
            const t3 = "shape slide onNext" + this.fromSeqId;
            this.startConds.addCond({ event: t3 });
          }
          this.json.iterate && false === this.isIterate && this.createIterateShadow();
        }
        createIterateShadow() {
          const t2 = Mm();
          let e2 = true, i2 = 0;
          const n2 = (i3) => {
            i3 === t2 && (e2 = false, this.ctx.eventHub.removeListener("IterateTimeNodeEnd", n2));
          };
          for (this.ctx.eventHub.on("IterateTimeNodeEnd", n2); e2; ) {
            const e3 = JSON.parse(JSON.stringify(this.json)), n3 = new Ty({ json: e3, isSub: false, eventHubs: this.eventHubs, ctx: this.ctx, parent: null, isIterate: true, iterateType: e3.iterate.type, iterateIndex: i2, iterateId: t2, isInInteractiveSeq: this.isInInteractiveSeq, fromSeqId: this.fromSeqId });
            this.iterateShadows[i2] = n3, i2 += 1;
          }
        }
        isInfiniteRepeat() {
          return this.json.repeatCount > 999999998;
        }
        getReverse() {
          return this.isReverse;
        }
        setReverse(t2) {
          this.isReverse = t2;
        }
        createTimeNode(t2, e2) {
          let i2 = null;
          const n2 = { json: t2, isSub: e2, isIterate: this.isIterate, eventHub: this.eventHubs.global, ctx: this.ctx, parent: this, iterateType: this.iterateType, iterateIndex: this.iterateIndex, iterateId: this.iterateId, isInInteractiveSeq: this.isInInteractiveSeq, fromSeqId: this.fromSeqId };
          return "seq" === t2.type ? i2 = new x_(n2) : "par" === t2.type ? i2 = new Ey(n2) : "set" === t2.type ? i2 = new S_(n2) : "anim" === t2.type ? i2 = new P_(n2) : "animEffect" === t2.type ? i2 = new py(n2) : "animMotion" === t2.type ? i2 = new fy(n2) : "animScale" === t2.type ? i2 = new my(n2) : "animClr" === t2.type ? i2 = new gy(n2) : "animRot" === t2.type ? i2 = new vy(n2) : "cmd" === t2.type ? i2 = new _y(n2) : "audio" === t2.type && (i2 = new yy(n2)), i2;
        }
        createSubList(t2) {
          this.subList && this.subList.forEach((t3) => t3.commonTimeNode.destroy()), this.subList = [], t2.forEach((t3) => {
            const e2 = this.createTimeNode(t3, true);
            e2 && this.subList.push(e2);
          });
        }
        bindCommonTimeNodeEvent(t2) {
          t2.commonTimeNode.on("timeNodeStart", (t3) => {
            this.emit("childTimeNodeStart", t3);
          }), t2.commonTimeNode.on("timeNodeEnd", (t3) => {
            this.emit("childTimeNodeEnd", t3), this.children.every((t4) => t4.commonTimeNode.isTimeNodeEndWhenDetectEndSync()) && (this.json.iterate || this.allChildrenEndHandle());
          });
        }
        createChildren(t2) {
          function e2(t3) {
            return xy(t3).presetOrder;
          }
          function i2(t3) {
            return /^slide/.test(t3) ? "slide" : /^layout/.test(t3) ? "layout" : /^master/.test(t3) ? "master" : "unknow";
          }
          const n2 = ["master", "layout", "slide", "unknow"];
          if (t2 && t2[0] && e2(t2[0])) {
            [...t2].sort((t3, r2) => {
              var o2, s2, a2, l2;
              const h2 = xy(t3).id, u2 = xy(r2).id;
              if (h2 && u2) {
                const a3 = i2(h2), l3 = i2(u2);
                if (a3 === l3) return (null !== (o2 = e2(t3)) && void 0 !== o2 ? o2 : 0) - (null !== (s2 = e2(r2)) && void 0 !== s2 ? s2 : 0);
                return n2.indexOf(a3) - n2.indexOf(l3);
              }
              return (null !== (a2 = e2(t3)) && void 0 !== a2 ? a2 : 0) - (null !== (l2 = e2(r2)) && void 0 !== l2 ? l2 : 0);
            }).forEach((t3) => {
              const e3 = this.createTimeNode(t3, false);
              e3 && (this.bindCommonTimeNodeEvent(e3), this.children.push(e3));
            });
          } else t2.forEach((t3) => {
            const e3 = this.createTimeNode(t3, false);
            e3 && (this.bindCommonTimeNodeEvent(e3), this.children.push(e3));
          });
        }
        playReverse() {
          this.isReverse = true, this.startReverseTimeLine(), this.children.forEach((t2) => t2.commonTimeNode.playReverse());
        }
        allChildrenEndHandle() {
          if (!this.isDestroy) {
            if (this.json.autoRev && !this.isReverse) return this.isReverse = true, void this.playReverse();
            this.isReverse && (this.isReverse = false), this.json.repeatCount && this.json.repeatCount > this.applyCount ? this.repeatTimeoutId = this.ctx.clock.setTimeout(() => {
              this.seekToStart(false), this.resetForRepeat(), this.startTimeNodeRepeat();
            }) : (this.json.iterate && !this.isIterate && (this.isIterateEnd = true), this.eventHubs.runtime.emit("runtime all end"), this.startSubList(), this.handleEnd());
          }
        }
        resetForRepeat() {
          this.isInInteractiveSeq && this.isInfiniteRepeat() && this.repeatTimeNodeEnd(), this.timeDelta = 0, this.children.forEach((t2) => t2.commonTimeNode.resetForRepeat());
        }
        startSubList() {
          this.subList.forEach((t2) => t2.commonTimeNode.startTimeNode());
        }
        startReverseTimeLine() {
          this.isEndEventsEmitted = false, this.timeDelta = 0;
          const t2 = 1e3 / this.ctx.ticker.maxFPS;
          this.duration <= t2 && this.duration > 0 ? (this.emit("timeUpdate", { delta: this.duration, duration: this.duration, isReverse: this.isReverse }), this.ctx.eventHub.emit(zy.animateEnd), this.ctx.ticker.remove(this.updateTimeLine)) : this.duration > t2 && (this.ctx.eventHub.emit(zy.animateStart), this.ctx.ticker.add(this.updateTimeLine));
        }
        startTimeLine(t2 = true) {
          if (t2 && (this.isEndEventsEmitted = false, this.eventHubs.global.emit(`time ${this.json.id} begin`), this.eventHubs.global.emit(`time ${this.json.id} onBegin`), this.eventHubs.runtime.emit(`runtime ${this.json.id} begin`)), this.json.iterate) return void this.startIterate();
          this.timeDelta = 0, this.emit("timelineStart", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse });
          const e2 = 1e3 / this.ctx.ticker.maxFPS;
          this.duration <= e2 && this.duration > 0 ? (this.timeDelta = this.isReverse ? 0 : this.duration, this.emit("timeUpdate", { delta: this.timeDelta, duration: this.duration, isReverse: this.isReverse }), this.emit("timelineEnd", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }), this.ctx.ticker.addOnce(() => {
            this.onTimeLineEnd();
          })) : this.duration > e2 && (this.ctx.eventHub.emit(zy.animateStart), this.updateTimeLine(0), this.ctx.ticker.add(this.updateTimeLine));
        }
        startIterate() {
          return by(this, void 0, void 0, function* () {
            if (this.json.iterate) {
              this.isIterateEnd = false;
              for (const t2 of this.iterateShadows) {
                if (this.isIterateEnd) break;
                t2.children.forEach((t3) => {
                  t3.commonTimeNode.startTimeNode();
                }), t2.applyCount += 1, yield this.ctx.clock.delay(this.json.iterate.interval);
              }
              this.onTimeLineEnd();
            }
          });
        }
        applyTimeFilter(t2) {
          if (!this.tmFilter.every((t3) => Vm()(t3[0]) && Vm()(t3[1]))) return t2;
          for (let e2 = 0; e2 < this.tmFilter.length; e2++) {
            const i2 = this.tmFilter[e2];
            if (t2 < i2[0]) {
              const n2 = this.tmFilter[e2 - 1];
              return (t2 - n2[0]) / (i2[0] - n2[0]) * (i2[1] - n2[1]) + n2[1];
            }
          }
          return this.tmFilter.length > 0 ? this.tmFilter[this.tmFilter.length - 1][1] : t2;
        }
        isNatureTimeEnd() {
          return this.duration >= 0 && this.timeDelta >= this.duration;
        }
        findTargets() {
          const t2 = [], e2 = (i2) => {
            i2.forEach((i3) => {
              var n2, r2, o2;
              i3.cBhvr && i3.cBhvr.target && t2.findIndex((t3) => t3.id === i3.cBhvr.target.id) < 0 && t2.push(i3.cBhvr.target), (null === (r2 = null === (n2 = null == i3 ? void 0 : i3.cBhvr) || void 0 === n2 ? void 0 : n2.ctn) || void 0 === r2 ? void 0 : r2.childTnLst) && i3.cBhvr.ctn.childTnLst.length > 0 && e2(i3.cBhvr.ctn.childTnLst), (null === (o2 = null == i3 ? void 0 : i3.ctn) || void 0 === o2 ? void 0 : o2.childTnLst) && i3.ctn.childTnLst.length > 0 && e2(i3.ctn.childTnLst);
            });
          };
          return e2(this.json.childTnLst || []), t2;
        }
        setPreStyle() {
          this.json.presetClass && this.findTargets().forEach((t2) => {
            if (this.json.iterate) {
              let e2 = 0, i2 = true;
              for (; i2; ) {
                const n2 = this.ctx.timingTargets.getTarget(t2, true, { type: this.json.iterate.type, index: e2, id: "" });
                n2 && (this.setPreStyleForTarget(n2), e2 += 1), i2 = !!n2;
              }
            } else {
              const e2 = this.ctx.timingTargets.getTarget(t2, false);
              e2 && this.setPreStyleForTarget(e2);
            }
          });
        }
        setPreStyleForTarget(t2) {
          var e2, i2;
          if (t2 && this.json.presetSubtype && (t2.presetSubType = this.json.presetSubtype), t2 && !t2.hasPreset) if ("entr" === this.json.presetClass) {
            const n2 = null === (i2 = null === (e2 = this.json) || void 0 === e2 ? void 0 : e2.childTnLst) || void 0 === i2 ? void 0 : i2.filter((t3) => "set" === t3.type && "visible" === t3.to);
            (null == n2 ? void 0 : n2.length) && (t2.hasPreset = true, t2.style.visibility = "hidden");
          } else ("exit" === this.json.presetClass || "path" === this.json.presetClass || "emph" === this.json.presetClass) && (t2.hasPreset = true, t2.style.visibility = "visible");
        }
        startTimeNodeRepeat() {
          this.timeDelta = 0, this.isActive = true, this.applyCount += 1, this.startTimeLine(false), this.json.iterate || this.emit("timeNodeRepeat", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse });
        }
        startTimeNodeForce() {
          this.json.subTnLst && this.createSubList(this.json.subTnLst), this.timeDelta = 0, this.isActive = true, this.handleActive(false);
        }
        startTimeNode(t2 = true) {
          if (this.isDestroy) return;
          this.collectStartValue(), this.timeDelta = 0, this.isReverse = false, this.json.subTnLst && this.createSubList(this.json.subTnLst), this.startConds.setTriggerParams(t2);
          const e2 = this.json.stCondLst.filter((t3) => /^self/.test(t3.event || ""))[0];
          e2 && this.startConds.condHandle(e2);
          const i2 = this.json.endCondLst.filter((t3) => /^self/.test(t3.event || ""))[0];
          i2 && this.endConds.condHandle(i2), this.startConds.condHandle();
        }
        onTimeLineEnd() {
          this.dispose(), (0 === this.children.length || this.json.iterate) && this.allChildrenEndHandle();
        }
        clearSubList() {
          this.subList.forEach((t2) => t2.commonTimeNode.destroy());
        }
        seekToStart(t2 = true) {
          if (this.isEndEventsEmitted = false, this.isActive = false, this.dispose(), this.timeDelta = 0, this.emit("seekToStart"), this.json.iterate && !this.isIterate) return this.isIterateEnd = true, void this.iterateShadows.forEach((e2) => e2.seekToStart(t2));
          if (t2) for (let t3 = this.subList.length - 1; t3 >= 0; t3--) {
            const e2 = this.subList[t3];
            null == e2 || e2.commonTimeNode.seekToStart();
          }
          for (let t3 = this.children.length - 1; t3 >= 0; t3--) {
            const e2 = this.children[t3];
            null == e2 || e2.commonTimeNode.seekToStart();
          }
          if (this.children.length > 1) for (let t3 = this.children.length - 1; t3 >= 0; t3--) {
            const e2 = this.children[t3];
            null == e2 || e2.commonTimeNode.seekToStart();
          }
        }
        repeatTimeNodeEnd() {
          this.dispose(), this.children.forEach((t2) => {
            t2.commonTimeNode.isActive = false, t2.commonTimeNode.dispose();
          });
        }
        dispose(t2 = false) {
          this.isConflictDispose = t2, this.ctx.clock.clearTimeout(this.repeatTimeoutId), this.ctx.eventHub.emit(zy.animateEnd);
          try {
            this.ctx.ticker.remove(this.updateTimeLine);
          } catch (t3) {
          }
          this.startConds.reset(), this.endConds.reset();
        }
        seekToEnd(t2, e2 = false) {
          if (this.isInfiniteRepeat()) return;
          !this.isActive && this.applyCount <= 0 && this.collectStartValue(), this.applyCount = this.json.repeatCount, this.json.autoRev && (this.isReverse = true), this.timeDelta = this.duration, this.isActive = false, this.dispose();
          const i2 = this.json.autoRev || t2;
          if (i2 ? this.emit("seekToStart") : this.emit("seekToEnd"), this.json.iterate && !this.isIterate) return this.isIterateEnd = true, void this.iterateShadows.forEach((t3) => t3.seekToEnd(i2, e2));
          0 === this.children.length && (this.eventHubs.runtime.emit("runtime all end"), this.handleEnd()), this.children.forEach((t3) => t3.commonTimeNode.seekToEnd(i2, e2)), e2 && this.json.subTnLst && (this.subList.length <= 0 && this.createSubList(this.json.subTnLst), this.subList.forEach((t3) => t3.commonTimeNode.seekToEnd(false)), this.clearSubList());
        }
        isTimeNodeEndWhenDetectEndSync() {
          if (this.isInInteractiveSeq && this.isInfiniteRepeat()) return true;
          let t2 = true;
          return this.children.length > 0 && (t2 = t2 && this.children.every((t3) => t3.commonTimeNode.isTimeNodeEndWhenDetectEndSync())), this.json.repeatCount && (t2 = t2 && this.applyCount >= this.json.repeatCount), this.json.autoRev && (t2 = t2 && !this.isReverse), t2 = t2 && this.isNatureTimeEnd(), !!this.isConflictDispose || (!(!this.isIterateEnd || !this.json.iterate) || t2);
        }
        isTimeNodeEnd() {
          let t2 = true;
          return this.children.length > 0 && (t2 = t2 && this.children.every((t3) => t3.commonTimeNode.isTimeNodeEnd())), this.json.repeatCount && (t2 = t2 && this.applyCount >= this.json.repeatCount), this.json.autoRev && (t2 = t2 && !this.isReverse), t2 = t2 && this.isNatureTimeEnd(), !!this.isConflictDispose || (!(!this.isIterateEnd || !this.json.iterate) || t2);
        }
        emitEndEvents() {
          this.isEndEventsEmitted || (this.isEndEventsEmitted = true, this.eventHubs.global.emit(`time ${this.json.id} end`), this.eventHubs.global.emit(`time ${this.json.id} onEnd`), this.eventHubs.runtime.emit(`runtime ${this.json.id} end`), this.emit("timeNodeEnd", { id: this.uuid, activeCount: this.applyCount, isReverse: this.isReverse }));
        }
        collectStartValue() {
          this.emit("timeNodeCreate"), this.children.forEach((t2) => t2.commonTimeNode.collectStartValue());
        }
        destroy() {
          this.emit("timeNodeDestroy"), this.isDestroy = true, this.dispose(), this.startConds.removeAllListeners(), this.endConds.removeAllListeners(), this.children.forEach((t2) => t2.commonTimeNode.destroy()), this.clearSubList();
        }
      }
      class Ey extends Za.a {
        constructor(t2) {
          super(), this.isRunning = false, this.runtimeNodeEventHub = new Za.a();
          const { json: e2, iterateType: i2, isIterate: n2, isSub: r2, parent: o2, ctx: s2, eventHub: a2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 } = t2;
          this.id = e2.ctn.id, this.json = e2, this.ctx = s2, this.isIterate = n2, this.globalEventHub = a2, this.commonTimeNode = new Ty({ json: e2.ctn, isSub: r2, eventHubs: { global: a2, runtime: this.runtimeNodeEventHub }, ctx: s2, parent: o2, isIterate: false, iterateType: i2, iterateIndex: l2, iterateId: h2, isInInteractiveSeq: u2, fromSeqId: c2 }), this.commonTimeNode.on("timeNodeStart", () => {
            this.commonTimeNode.children.forEach((t3) => {
              t3.commonTimeNode.setReverse(this.commonTimeNode.getReverse()), t3.commonTimeNode.startTimeNode();
            }), this.isRunning || (this.isRunning = true, this.globalEventHub.emit(`runtime ${this.id} begin`), this.emit("begin"));
          }), this.commonTimeNode.on("timeNodeRepeat", () => {
            this.commonTimeNode.children.forEach((t3) => {
              t3.commonTimeNode.startTimeNode(false);
            });
          }), this.commonTimeNode.on("timeNodeEnd", () => {
            this.commonTimeNode.isTimeNodeEnd() && this.isRunning && (this.isRunning = false, this.globalEventHub.emit(`runtime ${this.id} end`), this.emit("end")), "exit" === this.commonTimeNode.json.presetClass && this.commonTimeNode.children.length >= 1 && this.commonTimeNode.children[this.commonTimeNode.children.length - 1] instanceof S_ && this.commonTimeNode.children.forEach((t3) => {
              t3 instanceof S_ || "function" != typeof t3.onSeekToStart || t3.onSeekToStart();
            });
          });
        }
      }
      var Sy = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class wy {
        constructor(t2, e2, i2) {
          this.json = t2, this.ctx = i2, this.globalEventHub = e2;
          const n2 = t2.timeNodeList.find((t3) => "par" === t3.type && "tmRoot" === t3.ctn.nodeType);
          n2 && (this.tmRoot = new Ey({ json: n2, isSub: false, isIterate: false, eventHub: e2, ctx: i2, parent: null, iterateType: "el", iterateIndex: 0, iterateId: "", isInInteractiveSeq: false, fromSeqId: "" }), this.mainSeq = this.tmRoot.commonTimeNode.children.find((t3) => {
            var e3, i3, n3;
            return "seq" === (null === (e3 = t3.json) || void 0 === e3 ? void 0 : e3.type) && "mainSeq" === (null === (n3 = null === (i3 = t3.json) || void 0 === i3 ? void 0 : i3.ctn) || void 0 === n3 ? void 0 : n3.nodeType);
          }));
        }
        findSeq(t2) {
          var e2;
          return null === (e2 = this.tmRoot) || void 0 === e2 ? void 0 : e2.commonTimeNode.children.find((e3) => {
            var i2, n2, r2;
            return "seq" === (null === (i2 = e3.json) || void 0 === i2 ? void 0 : i2.type) && (null === (r2 = null === (n2 = e3.json) || void 0 === n2 ? void 0 : n2.ctn) || void 0 === r2 ? void 0 : r2.id) === t2;
          });
        }
        start() {
          var t2, e2;
          return Sy(this, void 0, void 0, function* () {
            this.json.autoPlayMainSeq ? (yield this.ctx.clock.delay(16), null === (t2 = this.mainSeq) || void 0 === t2 || t2.commonTimeNode.startTimeNode()) : null === (e2 = this.mainSeq) || void 0 === e2 || e2.commonTimeNode.startTimeNode();
          });
        }
        setMainSeqApplied() {
          this.mainSeq && (this.mainSeq.commonTimeNode.applyCount = 1);
        }
        collectMainSeqStartValue() {
          var t2;
          null === (t2 = this.mainSeq) || void 0 === t2 || t2.commonTimeNode.collectStartValue();
        }
        setMainSeqStep(t2, e2) {
          var i2;
          -1 === t2 && this.mainSeq && (this.mainSeq.commonTimeNode.applyCount = 1), null === (i2 = this.mainSeq) || void 0 === i2 || i2.setCurrentStep(t2, e2);
        }
        destroy() {
          var t2;
          this.globalEventHub.removeAllListeners(), null === (t2 = this.tmRoot) || void 0 === t2 || t2.commonTimeNode.destroy();
        }
        hasMainSeq() {
          return !!this.mainSeq && this.mainSeq.commonTimeNode.children.length > 0;
        }
        currentMainSeqState() {
          return this.mainSeq ? this.mainSeq.currentState : null;
        }
        currentMainSeqStep() {
          return this.mainSeq ? this.mainSeq.currentStep : 0;
        }
        currentMainSeqLength() {
          return this.mainSeq ? this.mainSeq.stepLength : 0;
        }
        mainSeqHasNextStep() {
          return !!this.mainSeq && this.mainSeq.hasNext();
        }
        mainSeqHasPrevStep() {
          return !!this.mainSeq && this.mainSeq.hasPrev();
        }
        seekInteractiveSeqToEnd(t2) {
          const e2 = this.findSeq(t2);
          e2 && e2.commonTimeNode.seekToEnd(false, true);
        }
        setInteractiveSeqState(t2, e2, i2) {
          const n2 = this.findSeq(t2);
          n2 && n2.setCurrentStep(e2, i2);
        }
        resetAllInteractiveSeq() {
          var t2;
          ((null === (t2 = this.tmRoot) || void 0 === t2 ? void 0 : t2.commonTimeNode.children.filter((t3) => {
            var e2, i2, n2;
            return "seq" === (null === (e2 = t3.json) || void 0 === e2 ? void 0 : e2.type) && "interactiveSeq" === (null === (n2 = null === (i2 = t3.json) || void 0 === i2 ? void 0 : i2.ctn) || void 0 === n2 ? void 0 : n2.nodeType);
          })) || []).forEach((t3) => {
            t3.setCurrentStep(0, "start");
          });
        }
        applyInteractiveAction(t2) {
          this.globalEventHub.emit(t2);
        }
      }
      var Ay = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class My extends __ {
        constructor(t2, e2, i2, n2) {
          super({ id: "stage", width: t2.width, height: t2.height, type: "Container", children: t2.children }, e2, { parentGlobalPos: i2 }, n2), this.isRendered = false, this.isTimingStartValueCollected = false, this.json = t2, this.json.smartArtShapeList && (e2.smartArtShapeList = this.json.smartArtShapeList), e2.hasBackgroundFillShape = this.detectUseBackgroundFill(this.json), this.container.visible = false, this.ctx = e2;
          const r2 = new Jd();
          r2.beginFill(16777215), r2.drawRect(0, 0, t2.width, t2.height), r2.endFill(), this.container.addChild(r2);
        }
        detectUseBackgroundFill(t2) {
          return !!t2 && ("Picture" === t2.type || "Shape" === t2.type ? t2.useBgFill : !(!t2.children || !Array.isArray(t2.children)) && t2.children.some((t3) => this.detectUseBackgroundFill(t3)));
        }
        initOnReuse() {
          super.initOnReuse(), this.ctx.timingEventHub.on("c:prev slide", (t2) => {
            this.ctx.eventHub.emit(zy.requestPrevSlide, t2);
          }), this.ctx.timingEventHub.on("c:next slide", (t2, e2) => {
            this.ctx.eventHub.emit(zy.requestNextSlide, t2, e2);
          });
        }
        get interactiveContainer() {
          return this.container;
        }
        applyEffectCacheAsBitMap(t2) {
          this.children.forEach((e2) => e2.applyEffectCacheAsBitMap(t2));
        }
        render(t2) {
          if (this.isRendered) return;
          this.collectAnimatedIds().forEach((t3) => this.ctx.animatedIds.add(t3)), this.isRendered = true, super.render(t2), t2.addSubMTask(() => Ay(this, void 0, void 0, function* () {
            this.ctx.eventHub.emit("StageRenderEnd");
          }), "@StageImpl[emit.StageRenderEnd]");
        }
        isListTimeNode(t2) {
          return ["excel", "seq", "par"].indexOf(t2.type) >= 0;
        }
        isAnimatedTimeNode(t2) {
          return !!t2.cBhvr;
        }
        collectAnimatedIdsForTimeNode(t2, e2) {
          var i2;
          this.isListTimeNode(t2) ? null === (i2 = t2.ctn.childTnLst) || void 0 === i2 || i2.forEach((t3) => {
            this.collectAnimatedIdsForTimeNode(t3, e2);
          }) : this.isAnimatedTimeNode(t2) && e2.push(t2.cBhvr.target.id);
        }
        collectAnimatedIds() {
          const t2 = [];
          return this.json.timing && this.json.timing.timeNodeList.forEach((e2) => {
            this.collectAnimatedIdsForTimeNode(e2, t2);
          }), t2;
        }
        createTiming() {
          this.json.timing && !this.timing && (this.timing = new wy(this.json.timing, this.ctx.timingEventHub, this.ctx));
        }
        startTiming() {
          var t2;
          return (null === (t2 = this.timing) || void 0 === t2 ? void 0 : t2.start()) || Promise.resolve();
        }
        setMainSeqApplied() {
          var t2;
          null === (t2 = this.timing) || void 0 === t2 || t2.setMainSeqApplied();
        }
        setMainSeqStep(t2, e2) {
          var i2;
          null === (i2 = this.timing) || void 0 === i2 || i2.setMainSeqStep(t2, e2);
        }
        collectMainSeqStartValue() {
          var t2;
          this.isTimingStartValueCollected || (this.isTimingStartValueCollected = true, null === (t2 = this.timing) || void 0 === t2 || t2.collectMainSeqStartValue());
        }
        hasTiming() {
          return !!this.timing;
        }
        clearOnSlideChange() {
          this.ctx.eventHub.removeAllListeners(), this.ctx.timingEventHub.removeAllListeners(), super.clearOnSlideChange();
        }
        clearOnTransactionEnd() {
          var t2, e2;
          this.ctx.timingTargets.getTargets().forEach((t3) => {
            t3.hasPreset = false;
          }), null === (t2 = this.timing) || void 0 === t2 || t2.resetAllInteractiveSeq(), null === (e2 = this.timing) || void 0 === e2 || e2.destroy(), this.timing = void 0;
        }
        destroy() {
          var t2, e2;
          this.isTimingStartValueCollected = false, this.isRendered = false, this.ctx.eventHub.removeAllListeners(), this.ctx.graphicsTexture.destroy(), null === (t2 = this.ctx.bgTexture) || void 0 === t2 || t2.destroy(true), this.ctx.spriteTexture.destroy(), this.ctx.timingEventHub.removeAllListeners(), null === (e2 = this.timing) || void 0 === e2 || e2.destroy(), this.timing = void 0, super.destroy();
        }
        mainSeqStep() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.timing) || void 0 === t2 ? void 0 : t2.currentMainSeqStep()) && void 0 !== e2 ? e2 : 0;
        }
        mainSeqLength() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.timing) || void 0 === t2 ? void 0 : t2.currentMainSeqLength()) && void 0 !== e2 ? e2 : 0;
        }
        mainSeqHasNextStep() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.timing) || void 0 === t2 ? void 0 : t2.mainSeqHasNextStep()) && void 0 !== e2 && e2;
        }
        mainSeqHasPrevStep() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.timing) || void 0 === t2 ? void 0 : t2.mainSeqHasPrevStep()) && void 0 !== e2 && e2;
        }
        mainSeqState() {
          return this.timing ? this.timing.currentMainSeqState() : null;
        }
        nextStep(t2, e2) {
          var i2;
          this.hasTiming() && (null === (i2 = this.timing) || void 0 === i2 ? void 0 : i2.hasMainSeq()) ? (this.ctx.timingEventHub.emit("shape slide onStopAudio"), this.ctx.timingEventHub.emit("shape slide onNext", t2, e2)) : this.ctx.eventHub.emit(zy.requestNextSlide, t2, e2);
        }
        prevStep(t2 = false) {
          var e2;
          this.hasTiming() && (null === (e2 = this.timing) || void 0 === e2 ? void 0 : e2.hasMainSeq()) ? (this.ctx.timingEventHub.emit("shape slide onStopAudio"), this.ctx.timingEventHub.emit("shape slide onPrev", t2)) : this.ctx.eventHub.emit(zy.requestPrevSlide, t2);
        }
        applyInteractiveAction(t2) {
          var e2;
          null === (e2 = this.timing) || void 0 === e2 || e2.applyInteractiveAction(t2);
        }
        seekInteractiveSeqToEnd(t2) {
          var e2;
          null === (e2 = this.timing) || void 0 === e2 || e2.seekInteractiveSeqToEnd(t2);
        }
        setInteractiveSeqState(t2, e2, i2) {
          var n2;
          null === (n2 = this.timing) || void 0 === n2 || n2.setInteractiveSeqState(t2, e2, i2);
        }
        setMediaState(t2, e2, i2) {
          return Ay(this, void 0, void 0, function* () {
            const n2 = this.ctx.medias[t2];
            n2 && (e2 ? i2 ? (yield Pm(() => n2.clippedDuration > 0, 5e3), i2 < n2.clippedDuration && (n2.once("play", () => {
              n2.seek(i2);
            }), yield n2.play())) : yield n2.play() : (i2 && n2.seek(i2), yield n2.pause()));
          });
        }
        setMediaCurrentTime(t2, e2) {
          const i2 = this.ctx.medias[t2];
          i2 && i2.seek(e2);
        }
      }
      class Cy {
        constructor(t2) {
          this.ticker = t2, this.tasks = [], this.couldRunning = false, this.applyNext = () => {
            this.tasks = this.tasks.filter((t4) => !t4.isEmpty());
            const t3 = this.tasks[0];
            t3 && t3.applyNext();
          }, t2.add(this.applyNext);
        }
        addTask(t2) {
          this.tasks.push(t2), t2.once("task-finish", () => {
            const e2 = this.tasks.indexOf(t2);
            e2 >= 0 && this.tasks.splice(e2, 1);
          }), t2.once("task-error", () => {
            const e2 = this.tasks.indexOf(t2);
            e2 >= 0 && this.tasks.splice(e2, 1);
          });
        }
        start() {
          this.couldRunning = true;
        }
        stop() {
          this.couldRunning = false;
        }
      }
      var Ry = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      const Iy = (t2) => new Promise((e2) => setTimeout(e2, t2));
      class Py extends Za.a {
        constructor(t2, e2, i2) {
          super(), this.slideIndex = t2, this.taskId = e2, this.logger = i2, this.uuid = Mm(), this.isCancel = false, this.tasks = [];
        }
        isEmpty() {
          return 0 === this.tasks.length;
        }
        addMTask(t2, e2) {
          this.tasks.push({ fn: t2, state: "wait", sub: [], name: e2 });
        }
        addSubMTask(t2, e2) {
          let i2 = this.tasks.findIndex((t3) => "running" === t3.state);
          i2 < 0 && (i2 = 0), this.tasks[i2].sub.push({ fn: t2, state: "wait", sub: [], name: e2 });
        }
        cancel() {
          this.tasks = [], this.isCancel = true;
        }
        applyNext() {
          if (this.tasks.some((t3) => "running" === t3.state)) return;
          if (this.tasks.some((t3) => "error" === t3.state)) return;
          if (this.tasks.every((t3) => "finish" === t3.state)) return void (this.isCancel || this.emit("task-finish"));
          const t2 = this.tasks.find((t3) => "wait" === t3.state);
          t2 && (t2.state = "running", t2.fn.apply(null).then(() => {
            if (t2.state = "finish", t2.sub.length > 0) {
              const e2 = this.tasks.findIndex((e3) => e3 === t2);
              this.tasks.splice(e2 + 1, 0, ...t2.sub);
            }
          }).catch((e2) => {
            t2.state = "error", this.logger.error(`${e2} ${e2.stack}`, this.taskId), this.emit("task-error", Tm.transform(e2), this.slideIndex);
          }));
        }
        applyAll() {
          return Ry(this, void 0, void 0, function* () {
            for (; !this.tasks.every((t2) => "finish" === t2.state); ) if (this.tasks.some((t2) => "running" === t2.state)) yield Iy(16);
            else {
              if (this.tasks.some((t2) => "error" === t2.state)) return;
              {
                const t2 = this.tasks.find((t3) => "wait" === t3.state);
                if (t2) {
                  t2.state = "running";
                  try {
                    if ((yield Im(() => t2.fn.apply(null), 6e4)) === Cm) throw new Tm(gm.RuntimeError, `subtask ${t2.name} apply timeout`);
                    if (t2.state = "finish", t2.sub.length > 0) {
                      const e2 = this.tasks.findIndex((e3) => e3 === t2);
                      this.tasks.splice(e2 + 1, 0, ...t2.sub);
                    }
                  } catch (e2) {
                    let i2;
                    i2 = (null == e2 ? void 0 : e2.errorType) ? e2 : new Tm(gm.RuntimeError, `subtask ${t2.name} error. ${e2}`), t2.state = "error", this.logger.error(`${e2} ${e2.stack}`, this.taskId), this.emit("task-error", Tm.transform(i2), this.slideIndex);
                    break;
                  }
                }
              }
            }
            !this.isCancel && this.tasks.every((t2) => "finish" === t2.state) && this.emit("task-finish");
          });
        }
      }
      var Oy = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Ny {
        constructor(t2, e2) {
          if (this.renderer = t2, this.localStorage = e2, this.outputData = /* @__PURE__ */ new Map(), this.loadingSdfKeys = /* @__PURE__ */ new Set(), !Ny.worker) {
            const t3 = new Blob(['\nself.onmessage = function(e) {\n    var data = e.data.data;\n    var key = e.data.key;\n    var height = Math.ceil(e.data.height);\n    var width = Math.ceil(e.data.width);\n    if (!data || !key) {\n        return;\n    }\n    var maxDis = 0;\n    var d = [];\n    var p = [];\n    var maxInt = Number.MAX_SAFE_INTEGER || 255 * 255 * 255;\n    var setD = function(x, y, v) { d[y * width + x] = v; };\n    var getD = function(x, y) { return d[y * width + x]; };\n    var setP = function(x, y, v) { p[y * width + x] = v; };\n    var getP = function(x, y) { return p[y * width + x]; };\n    var isContains = function(x, y) { return x >= 0 && x < width && y >= 0 && y < height; };\n    var isInterior = function(x, y) { return data[(y * width + x) * 4 + 3] > 10; };\n    for (var y = 0; y < height; ++ y) {\n        for (var x = 0; x < width; ++ x) {\n            var c = isInterior(x, y);\n            var t = isContains(x, y - 1) ? isInterior(x, y - 1) : false;\n            var b = isContains(x, y + 1) ? isInterior(x, y + 1) : false;\n            var l = isContains(x - 1, y) ? isInterior(x - 1, y) : false;\n            var r = isContains(x + 1, y) ? isInterior(x + 1, y) : false;\n            if (c !== t || c !== b || c !== l || c !== r) {\n                setD(x, y, 0);\n                setP(x, y, [x, y]);\n            } else {\n                setD(x, y, maxInt);\n                setP(x, y, [-1, -1]);\n            }\n        }\n    }\n    \n    var f = function (x, y, dir) {\n        var d1 = 1;\n        var d2 = Math.sqrt(2);\n        var dx;\n        var dy;\n        var od;\n        switch (dir) {\n            case "TL": dx = -1; dy = -1; od = d2; break;\n            case "T": dx = 0; dy = -1; od = d1; break;\n            case "TR": dx = 1; dy = -1; od = d2; break;\n            case "L": dx = -1; dy = 0; od = d1; break;\n            case "R": dx = 1; dy = 0; od = d1; break;\n            case "BL": dx = -1; dy = 1; od = d2; break;\n            case "B": dx = 0; dy = 1; od = d1; break;\n            case "BR": dx = 1; dy = 1; od = d2; break;\n        }\n        var b = isContains(x + dx, y + dy);\n        var cb = b ? getD(x + dx, y + dy) : maxInt;\n        if (cb + od < getD(x, y)) {\n            var p = b ? getP(x + dx, y + dy) : [-1, -1];\n            var dis = Math.sqrt(Math.pow(x - p[0], 2) + Math.pow(y - p[1], 2));\n            setP(x, y, p);\n            setD(x, y, dis);\n            if (dis > maxDis) {\n                maxDis = dis;\n            }\n        }\n    };\n    \n    for (var y = 0; y < height; ++ y) {\n        for (var x = 0; x < width; ++ x) {\n            var dirs = ["TL", "T", "TR", "L"];\n            for (var i = 0; i < dirs.length; ++ i) {\n                var dir = dirs[i];\n                f(x, y, dir);\n            }\n        }\n    }\n\n    for (var y = height - 1; y >= 0; -- y) {\n        for (var x = width - 1; x >= 0; -- x) {\n            var dirs = ["R", "BL", "B", "BR"];\n            for (var i = 0; i < dirs.length; ++ i) {\n                var dir = dirs[i];\n                f(x, y, dir);\n            }\n        }\n    }\n\n    var outputData = [];\n    for (var y = 0; y < height; ++ y) {\n        for (var x = 0; x < width; ++ x) {\n            outputData.push(isInterior(x, y) ? 255: 0);\n            outputData.push(0);\n            outputData.push(0);\n            outputData.push(Math.ceil(getD(x, y) / maxDis * 255));\n        }\n    }\n    self.postMessage({\n        key, outputData, maxDis\n    });\n};\n'], { type: "text/javascript" });
            Ny.worker = new Worker(URL.createObjectURL(t3)), Ny.worker.onmessage = (t4) => {
              this.outputData.set(t4.data.key, { data: t4.data.outputData, maxDis: t4.data.maxDis });
            }, this.outputData.set("111", "222");
          }
        }
        createSdfByWorker(t2, e2, i2, n2, r2, o2, s2, a2) {
          const l2 = document.createElement("canvas");
          l2.width = r2, l2.height = o2;
          const h2 = l2.getContext("2d");
          if (!h2 || !Ny.worker) return;
          h2.drawImage(s2, t2, e2, i2, n2);
          const { data: u2 } = h2.getImageData(0, 0, r2, o2);
          Ny.worker.postMessage({ data: u2, key: a2, width: r2, height: o2 });
        }
        createSdf(t2, e2, i2) {
          const n2 = document.createElement("canvas");
          n2.width = t2, n2.height = e2;
          const r2 = n2.getContext("2d");
          if (!r2) return { src: "", maxDis: 1 };
          r2.drawImage(i2, 0, 0);
          let o2 = 0;
          const { data: s2 } = r2.getImageData(0, 0, t2, e2), a2 = [], l2 = [], h2 = function(e3, i3, n3) {
            a2[i3 * t2 + e3] = n3;
          }, u2 = function(e3, i3) {
            return a2[i3 * t2 + e3];
          }, c2 = function(e3, i3, n3) {
            l2[i3 * t2 + e3] = n3;
          }, d2 = function(e3, i3) {
            return l2[i3 * t2 + e3];
          }, p2 = function(i3, n3) {
            return i3 >= 0 && i3 < t2 && n3 >= 0 && n3 < e2;
          }, f2 = function(e3, i3) {
            return s2[4 * (i3 * t2 + e3) + 3] > 10;
          };
          for (let i3 = 0; i3 < e2; ++i3) for (let e3 = 0; e3 < t2; ++e3) {
            const t3 = f2(e3, i3), n3 = !!p2(e3, i3 - 1) && f2(e3, i3 - 1), r3 = !!p2(e3, i3 + 1) && f2(e3, i3 + 1), o3 = !!p2(e3 - 1, i3) && f2(e3 - 1, i3), s3 = !!p2(e3 + 1, i3) && f2(e3 + 1, i3);
            t3 !== n3 || t3 !== r3 || t3 !== o3 || t3 !== s3 ? (h2(e3, i3, 0), c2(e3, i3, [e3, i3])) : (h2(e3, i3, Number.MAX_SAFE_INTEGER), c2(e3, i3, [-1, -1]));
          }
          const m2 = function(t3, e3, i3) {
            const n3 = Math.sqrt(2);
            let r3, s3, a3;
            switch (i3) {
              case "TL":
                r3 = -1, s3 = -1, a3 = n3;
                break;
              case "T":
                r3 = 0, s3 = -1, a3 = 1;
                break;
              case "TR":
                r3 = 1, s3 = -1, a3 = n3;
                break;
              case "L":
                r3 = -1, s3 = 0, a3 = 1;
                break;
              case "R":
                r3 = 1, s3 = 0, a3 = 1;
                break;
              case "BL":
                r3 = -1, s3 = 1, a3 = n3;
                break;
              case "B":
                r3 = 0, s3 = 1, a3 = 1;
                break;
              case "BR":
                r3 = 1, s3 = 1, a3 = n3;
            }
            const l3 = p2(t3 + r3, e3 + s3);
            if ((l3 ? u2(t3 + r3, e3 + s3) : Number.MAX_SAFE_INTEGER) + a3 < u2(t3, e3)) {
              const i4 = l3 ? d2(t3 + r3, e3 + s3) : [-1, -1], n4 = Math.sqrt(Math.pow(t3 - i4[0], 2) + Math.pow(e3 - i4[1], 2));
              c2(t3, e3, i4), h2(t3, e3, n4), n4 > o2 && (o2 = n4);
            }
          };
          for (let i3 = 0; i3 < e2; ++i3) for (let e3 = 0; e3 < t2; ++e3) {
            const t3 = ["TL", "T", "TR", "L"];
            for (const n3 of t3) m2(e3, i3, n3);
          }
          for (let i3 = e2 - 1; i3 >= 0; --i3) for (let e3 = t2 - 1; e3 >= 0; --e3) {
            const t3 = ["R", "BL", "B", "BR"];
            for (const n3 of t3) m2(e3, i3, n3);
          }
          const g2 = [];
          for (let i3 = 0; i3 < e2; ++i3) for (let e3 = 0; e3 < t2; ++e3) g2.push(0, 0, 0, Math.ceil(u2(e3, i3) / o2 * 255));
          return r2.putImageData(new ImageData(Uint8ClampedArray.from(g2), t2, e2), 0, 0), { src: n2.toDataURL("image/png"), maxDis: o2 };
        }
        getSdf(t2, e2, i2) {
          return Oy(this, void 0, void 0, function* () {
            const n2 = Math.ceil(e2.width), r2 = Math.ceil(e2.height), o2 = Math.ceil(e2.width - t2.width) / 2, s2 = Math.ceil(e2.height - t2.height) / 2;
            let a2 = yield this.localStorage.getItem(`sdf-${i2}-src`), l2 = yield this.localStorage.getItem(`sdf-${i2}-maxDis`);
            if (!(a2 && l2 || this.loadingSdfKeys.has(i2))) {
              this.loadingSdfKeys.add(i2);
              const e3 = this.renderer.plugins.extract.image(t2, "image/png");
              e3.addEventListener("load", () => {
                this.createSdfByWorker(o2, s2, t2.width, t2.height, n2, r2, e3, i2);
              }), e3.addEventListener("error", () => null), yield Pm(() => !!this.outputData.has(i2), 2e3), this.loadingSdfKeys.delete(i2);
              const h2 = this.outputData.get(i2);
              if (h2) {
                this.outputData.delete(i2);
                const t3 = document.createElement("canvas");
                t3.width = n2, t3.height = r2;
                const e4 = t3.getContext("2d");
                if (!e4) return null;
                e4.putImageData(new ImageData(Uint8ClampedArray.from(h2.data), n2, r2), 0, 0), a2 = t3.toDataURL("image/png"), l2 = h2.maxDis, this.localStorage.setItem(`sdf-${i2}-src`, a2).catch(() => {
                }), this.localStorage.setItem(`sdf-${i2}-maxDis`, l2).catch(() => {
                });
              }
            }
            if (!a2 || !l2) return null;
            return document.createElement("img").src = a2, Vh.t.fromURL(a2).then((t3) => ({ texture: t3, maxDis: l2 })).catch(() => null);
          });
        }
      }
      Ny.worker = null;
      var Ly = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class Dy {
        constructor(t2, e2, i2, n2, r2, o2, s2, a2, l2, h2, u2, c2, d2, p2, f2, m2, g2) {
          this.loader = t2, this.mode = e2, this.renderer = i2, this.ticker = n2, this.view = r2, this.clock = o2, this.objPoolGroup = s2, this.errorChannel = a2, this.localstorage = l2, this.logger = h2, this.loaderDelegate = u2, this.urlInterrupter = c2, this.isPlayerPaused = d2, this.maxResolution = p2, this.volumeAdjuster = f2, this.forceCanvas = m2, this.globalEventHub = g2, this.currentStageIndex = 0, this.cacheCount = r_.isDesktop() ? 2 : 1, this.stageStates = /* @__PURE__ */ Object.create(null), this.stageJsons = /* @__PURE__ */ Object.create(null), this.stageCtxs = /* @__PURE__ */ Object.create(null), this.stageImpls = /* @__PURE__ */ Object.create(null), this.taskId = "", this.url = "", this.runningAudio = /* @__PURE__ */ new Map(), this.activeMedia = /* @__PURE__ */ new Set(), this.microTaskManager = new Cy(n2), this.sdfManager = new Ny(i2, l2);
        }
        setResourceData(t2, e2) {
          this.taskId = t2, this.url = e2;
        }
        createCtx(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => Ly(this, void 0, void 0, function* () {
            const e3 = new Gm(this.loader), i2 = new Za.a(), n2 = { taskId: this.taskId, mode: this.mode, renderer: this.renderer, graphicsTexture: new Km(this.maxResolution), stageWidth: 0, stageHeight: 0, ticker: this.ticker, timingTargets: new $m(i2), eventHub: i2, view: this.view, medias: /* @__PURE__ */ Object.create(null), lastViewedIndex: 0, conflictTimeNodeManager: new Qm(), clock: this.clock, spriteTexture: e3, slideIndex: t2, objectPoolGroup: this.objPoolGroup, hasBackgroundFillShape: false, slideScopeEventHub: new Za.a(), logger: this.logger, sdfManager: this.sdfManager, loaderDelegate: this.loaderDelegate, runningAudio: this.runningAudio, activeMedia: this.activeMedia, isPlayerPaused: this.isPlayerPaused, timingEventHub: new Za.a(), maxResolution: this.maxResolution, animatedIds: /* @__PURE__ */ new Set(), volumeAdjuster: this.volumeAdjuster, forceCanvas: this.forceCanvas, globalEventHub: this.globalEventHub, latestChangeFullscreenTargetId: "", isRendering: false, urlInterrupter: this.urlInterrupter };
            this.stageCtxs[t2] = n2;
          }), "@StagePool[createCtx]");
        }
        loadStageJson(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => Ly(this, void 0, void 0, function* () {
            const e3 = yield this.loader.fetchJson(`${this.url}/${this.taskId}/jsonOutput/slide-${t2}.json`);
            this.stageJsons[t2] = e3, this.stageCtxs[t2].stageWidth = e3.width, this.stageCtxs[t2].stageHeight = e3.height, this.stageCtxs[t2].featureList = e3.featureList;
          }), "@StagePool[loadStageJson]");
        }
        loadSpriteSheets(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => {
            const i2 = this.stageJsons[t2], { spriteTexture: n2, stageWidth: r2, stageHeight: o2 } = this.stageCtxs[t2], { coloredSheets: s2, sheets: a2 } = i2, l2 = s2 || a2;
            return l2 && l2.forEach((t3) => {
              e2.addSubMTask(() => {
                let e3 = 1;
                if (r2 > this.maxResolution.x || o2 > this.maxResolution.y) {
                  e3 = this.maxResolution.x / r2;
                  const t4 = e3 * o2;
                  t4 > this.maxResolution.y && (e3 *= this.maxResolution.y / t4);
                }
                return n2.loadSpriteSheetItem(this.url, this.taskId, t3, e3);
              }, "@StagePool[spriteTexture.loadSpriteSheetItem]");
            }), Promise.resolve();
          }, "@StagePool[loadSpriteSheets]");
        }
        createStage(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => {
            const i2 = this.stageJsons[t2], n2 = this.stageCtxs[t2], r2 = new My(i2, n2, { x: 0, y: 0 }, e2);
            return this.stageImpls[t2] = r2, Promise.resolve();
          }, "@StagePool[createStage]");
        }
        preRenderStage(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => (this.stageImpls[t2].preRender(e2), Promise.resolve()), "@StagePool[preRenderStage]");
        }
        createGraphicsTexture(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => Ly(this, void 0, void 0, function* () {
            const i2 = this.stageCtxs[t2];
            i2.graphicsTexture.pack().forEach((t3, n2) => {
              e2.addSubMTask(() => i2.graphicsTexture.render(t3, n2, this.objPoolGroup, 1), "@StagePool[graphicsTexture.render]");
            });
          }), "@StagePool[createGraphicsTexture]");
        }
        renderStage(t2) {
          const { task: e2 } = this.stageStates[t2];
          e2.addMTask(() => Ly(this, void 0, void 0, function* () {
            const i2 = this.stageImpls[t2];
            yield i2.render(e2);
          }), "@StagePool[renderStage]");
        }
        destroyStageByIndex(t2) {
          "load" === this.stageStates[t2].state && this.stageStates[t2].task.cancel(), delete this.stageStates[t2];
          this.stageImpls[t2].destroy(), delete this.stageImpls[t2], delete this.stageCtxs[t2];
        }
        destroyStage() {
          Object.keys(this.stageImpls).forEach((t2) => {
            const e2 = parseInt(t2, 10);
            Math.abs(this.currentStageIndex - e2) > this.cacheCount && this.destroyStageByIndex(e2);
          });
        }
        destroyAllStage() {
          Object.keys(this.stageImpls).forEach((t2) => {
            const e2 = parseInt(t2, 10);
            this.destroyStageByIndex(e2);
          });
        }
        preload(t2, e2 = false) {
          if (this.stageImpls[t2] || this.stageStates[t2]) return Promise.resolve();
          const i2 = new Py(t2, this.taskId, this.logger);
          return i2.on("task-error", (t3, e3) => {
            delete this.stageStates[e3], delete this.stageImpls[e3], delete this.stageCtxs[e3], this.errorChannel.emit("error", t3, e3);
          }), this.stageStates[t2] = { state: "load", task: i2 }, this.createCtx(t2), this.loadStageJson(t2), this.loadSpriteSheets(t2), this.createStage(t2), this.preRenderStage(t2), this.createGraphicsTexture(t2), this.renderStage(t2), this.microTaskManager.addTask(i2), e2 ? i2.applyAll() : new Promise((e3) => {
            i2.once("task-finish", () => {
              this.stageStates[t2].state = "finish";
              Object.keys(this.stageStates).length > 2 * this.cacheCount + 1 && this.destroyStage(), e3();
            });
          });
        }
        getStageJson(t2) {
          return this.stageJsons[t2] || null;
        }
        getStage(t2) {
          return Ly(this, void 0, void 0, function* () {
            this.currentStageIndex = t2;
            const e2 = this.stageStates[t2];
            return "finish" === (null == e2 ? void 0 : e2.state) && this.stageImpls[t2] ? this.stageImpls[t2] : "load" === (null == e2 ? void 0 : e2.state) ? (yield e2.task.applyAll(), this.stageImpls[t2]) : (yield this.preload(t2, true), this.stageImpls[t2]);
          });
        }
        destroy() {
          this.runningAudio.clear();
        }
      }
      var Fy = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      class By {
        constructor(t2) {
          var e2;
          this.logger = t2, this.taskId = "", this.isIndexDBReady = false, this.memoryCache = /* @__PURE__ */ new Map(), null === (e2 = By.localCache) || void 0 === e2 || e2.ready((t3) => {
            t3 || (this.isIndexDBReady = true);
          }).catch(() => {
            t2.warn("local storage not ready", this.taskId);
          });
        }
        get couldUseIndexDBCache() {
          return this.isIndexDBReady && this.taskId.length > 0;
        }
        attachTaskId(t2) {
          this.taskId = t2;
        }
        getItem(t2) {
          return Fy(this, void 0, void 0, function* () {
            let e2 = null;
            if (this.couldUseIndexDBCache && By.localCache) try {
              e2 = yield Im(() => By.localCache.getItem(`${this.taskId}/${t2}`), 500);
            } catch (t3) {
            }
            return e2 = e2 === Cm ? null : e2, e2 || this.memoryCache.get(t2) || null;
          });
        }
        setItem(t2, e2, i2 = false) {
          return Fy(this, void 0, void 0, function* () {
            if (!this.couldUseIndexDBCache) return i2 && this.memoryCache.set(t2, e2), Promise.resolve();
            if (By.localCache) {
              let n2 = null;
              try {
                n2 = yield Im(() => By.localCache.setItem(`${this.taskId}/${t2}`, e2).catch(() => {
                  i2 && this.memoryCache.set(t2, e2);
                }), 500);
              } catch (t3) {
              }
              n2 !== Cm && null !== n2 || !i2 || this.memoryCache.set(t2, e2);
            }
          });
        }
        dispose() {
          var t2;
          this.memoryCache = /* @__PURE__ */ new Map(), this.couldUseIndexDBCache && (null === (t2 = By.localCache) || void 0 === t2 || t2.keys().then((t3) => {
            t3.filter((t4) => t4.indexOf(this.taskId) >= 0).forEach((t4) => {
              var e2;
              null === (e2 = By.localCache) || void 0 === e2 || e2.removeItem(t4).catch(() => {
              });
            });
          }).catch(() => {
          }));
        }
      }
      By.localCache = null;
      try {
        By.localCache = o.createInstance({ name: "slide_local_cache", driver: o.INDEXEDDB, version: 1 });
      } catch (t2) {
      }
      const Uy = new Lh.j();
      class ky {
        constructor(t2) {
          this.localStorage = t2;
        }
        canvas(t2, e2, i2, n2) {
          let r2, o2, s2, a2 = false, l2 = false;
          t2 && (t2 instanceof Vh.p ? s2 = t2 : (s2 = e2.generateTexture(t2), l2 = true)), s2 ? (r2 = s2.baseTexture.resolution, o2 = s2.frame, a2 = false, e2.renderTexture.bind(s2)) : (r2 = e2.resolution, a2 = true, o2 = Uy, o2.width = e2.width, o2.height = e2.height, e2.renderTexture.bind(null));
          const h2 = Math.floor(o2.width * r2 + 1e-4), u2 = Math.floor(o2.height * r2 + 1e-4);
          let c2 = document.createElement("canvas");
          c2.width = h2, c2.height = u2;
          const d2 = c2.getContext("2d");
          if (!d2) throw new Error("ctx");
          if (i2) d2.putImageData(i2, 0, 0);
          else {
            const t3 = d2.getImageData(0, 0, h2, u2), i3 = new Uint8Array(4 * h2 * u2), { gl: s3 } = e2;
            s3.readPixels(o2.x * r2, o2.y * r2, h2, u2, s3.RGBA, s3.UNSIGNED_BYTE, i3), ky.arrayPostDivide(i3, t3.data), d2.putImageData(t3, 0, 0), n2 && this.localStorage.setItem(n2, t3).catch(() => {
            });
          }
          if (a2) {
            const t3 = document.createElement("canvas");
            t3.width = h2, t3.height = u2;
            const e3 = t3.getContext("2d");
            e3.scale(1, -1), e3.drawImage(c2, 0, -u2), c2 = t3;
          }
          return l2 && (null == s2 || s2.destroy(true)), c2;
        }
        static arrayPostDivide(t2, e2) {
          for (let i2 = 0; i2 < t2.length; i2 += 4) {
            const n2 = e2[i2 + 3] = t2[i2 + 3];
            0 !== n2 ? (e2[i2] = Math.round(Math.min(255 * t2[i2] / n2, 255)), e2[i2 + 1] = Math.round(Math.min(255 * t2[i2 + 1] / n2, 255)), e2[i2 + 2] = Math.round(Math.min(255 * t2[i2 + 2] / n2, 255))) : (e2[i2] = t2[i2], e2[i2 + 1] = t2[i2 + 1], e2[i2 + 2] = t2[i2 + 2]);
          }
        }
      }
      class Gy extends Za.a {
        constructor() {
          super(...arguments), this._volume = 0.5;
        }
        get volume() {
          return this._volume;
        }
        set volume(t2) {
          t2 < 0 && (t2 = 0), t2 > 1 && (t2 = 1), this._volume = t2, this.emit("update", this._volume);
        }
      }
      var Hy = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      };
      Ph.skipHello();
      const jy = { randomBar: "RandomLines", circle: "Shape", ripple: "Ripples", wipe: "Erase", dissolve: "Dissolve", morph: "Smooth", fade: "FadeInOut", push: "Push", split: "Separation", reveal: "Display", pull: "Uncover", cover: "Cover", flash: "Flash", checker: "Checkerboard", blinds: "WindowShades", curtains: "Curtain", fallOver: "Fall", drape: "Suspension", wheel: "Clock", comb: "Combing", warp: "Scale", peelOff: "PeelOff", flip: "Flip", gallery: "Gallery", switch: "Switch", prism: "Prism", doors: "Doors" }, zy = { mainSeqStepChange: "mainSeqStepChange", mainSeqStateChange: "mainSeqStateChange", interactiveSeqStateChange: "interactiveSeqStateChange", interactiveSeqAction: "interactiveSeqAction", mainSeqStepStart: "mainSeqStepStart", mainSeqStepEnd: "mainSeqStepEnd", slideChange: "slideChange", renderStart: "renderStart", renderEnd: "renderEnd", hyperlinkTrigger: "hyperlinkTrigger", animateStart: "animateStart", animateEnd: "animateEnd", mediaSeek: "mediaSeek", mediaPlay: "mediaPlay", mediaPause: "mediaPause", mediaStop: "mediaStop", requestNextSlide: "requestNextSlide", requestPrevSlide: "requestPrevSlide", requestGotoSlide: "requestGotoSlide", requestOpenUrl: "requestOpenUrl", userInput: "userInput", fullscreenChange: "fullscreenChange", changeLocalFullscreenState: "changeLocalFullscreenState" };
      class Vy extends Za.a {
        constructor(t2, e2 = {}) {
          super(), this.errorChannel = new Za.a(), this.transactionPlayer = null, this.isForward = true, this.drawCall = 0, this.scale = 1, this._isPaused = false, this.maxResolution = new Lh.g(0, 0), this.isNVIDIA = false, this.fps = new bm(), this.designWidth = 0, this.designHeight = 0, this.currentIndex = 0, this.slideCount = 0, this.runtime = { drawCall: 0, fps: 0 }, this.globalEventHub = new Za.a(), this.globalVideoBackground = new Jd(), this.globalVideoSprite = new ep(), this.onMousemoveTimeout = null, this.cacheFunctionMap = /* @__PURE__ */ new Map(), this.isPlayerPaused = () => this._isPaused, this.onWebGLLost = () => {
            this.errorChannel.emit("error", new Tm(gm.CanvasCrash, "webgl context lost."));
          }, this.fullscreenOnMousemove = ({ index: t3, targetId: e3 }) => {
            this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: t3, targetId: e3, status: true }), this.onMousemoveTimeout && clearTimeout(this.onMousemoveTimeout), this.onMousemoveTimeout = setTimeout(() => {
              this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: t3, targetId: e3, status: false });
            }, a_.hoverHiddeDelay);
          }, this.fullscreenOnMouseleave = ({ index: t3, targetId: e3 }) => {
            this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: t3, targetId: e3, status: false });
          }, this.calculateFullscreenVideoPosition = (t3) => {
            const { width: e3, height: i3 } = t3, { designWidth: n3, designHeight: r2 } = this, o2 = Math.min(n3 / e3, r2 / i3);
            return { x: (n3 - e3 * o2) / 2, y: (r2 - i3 * o2) / 2, width: e3 * o2, height: i3 * o2 };
          }, this.onRequestFullscreenVideo = (t3) => {
            const { texture: e3, index: i3, targetId: n3 } = t3;
            if (i3 !== this.currentIndex) return void e3.destroy(false);
            this.onRequestCancelFullscreenVideo(), this.globalVideoBackground.width = this.designWidth, this.globalVideoBackground.height = this.designHeight, this.globalVideoBackground.beginFill(0, 1), this.globalVideoBackground.drawRect(0, 0, this.designWidth, this.designHeight), this.globalVideoBackground.endFill(), this.globalVideoBackground.interactive = true, this.app.stage.addChild(this.globalVideoBackground);
            const { x: r2, y: o2, width: s2, height: a2 } = this.calculateFullscreenVideoPosition(e3);
            this.globalVideoSprite.texture = e3, this.globalVideoSprite.width = s2, this.globalVideoSprite.height = a2, this.globalVideoSprite.position.x = r2, this.globalVideoSprite.position.y = o2, this.globalVideoBackground.addChild(this.globalVideoSprite), this.globalEventHub.emit("onFullscreenChange", { status: true, targetId: n3, slideIndex: this.currentIndex }), this.clearFullscreenEventListenersWithAppView();
            const l2 = { handleEvent: () => {
              var t4;
              null === (t4 = this.currentStage) || void 0 === t4 || t4.ctx.eventHub.emit(zy.userInput);
            } };
            if (this.app.view.addEventListener("pointerdown", l2, false), this.cacheFunctionMap.set("pointerdown", l2), r_.isDesktop()) {
              const t4 = { handleEvent: () => {
                this.fullscreenOnMouseleave({ index: i3, targetId: n3 });
              } };
              this.app.view.addEventListener("mouseout", t4, false);
              const e4 = { handleEvent: () => {
                this.globalEventHub.emit("controllerShowStatusChange", { slideIndex: i3, targetId: n3, status: true });
              } };
              this.app.view.addEventListener("mouseover", e4, false);
              const r3 = { handleEvent: () => {
                this.fullscreenOnMousemove({ index: i3, targetId: n3 });
              } };
              this.app.view.addEventListener("mousemove", r3, false), this.cacheFunctionMap.set("mouseover", e4), this.cacheFunctionMap.set("mousemove", r3), this.cacheFunctionMap.set("mouseout", t4);
            } else {
              const t4 = { handleEvent: () => {
                this.fullscreenOnMousemove({ index: i3, targetId: n3 });
              } };
              this.app.view.addEventListener("touchstart", t4, false), this.cacheFunctionMap.set("touchstart", t4);
            }
          }, this.onRequestCancelFullscreenVideo = (t3 = false) => {
            var e3, i3;
            this.globalVideoSprite.texture.destroy(false);
            try {
              this.globalVideoBackground.removeChild(this.globalVideoSprite);
            } catch (t4) {
              this.logger.error("removeChild error: PPTPlayer:1057", this.taskId);
            }
            try {
              this.app.stage.removeChild(this.globalVideoBackground);
            } catch (t4) {
              this.logger.error("removeChild error: PPTPlayer:1062", this.taskId);
            }
            this.globalEventHub.emit("onFullscreenChange", { status: false, slideIndex: this.currentIndex, targetId: null === (e3 = this.currentStage) || void 0 === e3 ? void 0 : e3.ctx.latestChangeFullscreenTargetId }), this.clearFullscreenEventListenersWithAppView(), t3 && this.emit(zy.changeLocalFullscreenState, { status: false, slideIndex: this.currentIndex, targetId: null === (i3 = this.currentStage) || void 0 === i3 ? void 0 : i3.ctx.latestChangeFullscreenTargetId });
          }, this.logger = t2.logger, this.tracker = t2.tracker, this.mode = t2.mode, this.volumeAdjuster = t2.volumeAdjuster, this.localStorage = new By(this.logger), this.cachedExtract = new ky(this.localStorage), this.config = { minFPS: $a()(e2.minFPS) ? 30 : e2.minFPS, maxFPS: $a()(e2.maxFPS) ? 40 : e2.maxFPS, resolution: $a()(e2.resolution) ? 1 : e2.resolution, autoFPS: !$a()(e2.autoFPS) && e2.autoFPS, autoResolution: !$a()(e2.autoResolution) && e2.autoResolution, transactionBgColor: $a()(e2.transactionBgColor) ? 0 : e2.transactionBgColor, maxResolutionLevel: this.getMaxResolution(e2.maxResolutionLevel), forceCanvas: !$a()(e2.forceCanvas) && e2.forceCanvas, enableNvidiaDetect: !$a()(e2.enableNvidiaDetect) && e2.enableNvidiaDetect }, this.updateMaxResolutionLevel(this.config.maxResolutionLevel), this.loader = new Lm(this.localStorage, t2.useLocalCache, this.logger, this.tracker, t2.resourceTimeout, t2.loadDelegate, t2.urlInterrupter);
          const i2 = Ph.isWebGLSupported();
          this.app = new Xh({ antialias: true, autoDensity: false, backgroundColor: 16777215, forceCanvas: this.config.forceCanvas || !i2 }), globalThis.__PIXI_APP__ = this.app, this.tracker({ name: "slidePlayerCreate", result: "", reason: "", payload: { webgl: i2, resolution: this.config.resolution, minFPS: this.config.minFPS, maxFPS: this.config.maxFPS, maxResolutionLevel: this.config.maxResolutionLevel, forceCanvas: this.config.forceCanvas } }), this.updateConfig(this.config), this.app.ticker.maxFPS = 60, this.app.ticker.minFPS = this.config.minFPS, this.app.ticker.maxFPS = this.config.maxFPS, this.app.view.style.zIndex = "1", this.app.stage.sortableChildren = true;
          const n2 = this.app.renderer;
          if (n2.gl) {
            const { drawElements: t3 } = n2.gl, e3 = n2.gl.getExtension("WEBGL_debug_renderer_info"), i3 = n2.gl.getParameter(e3.UNMASKED_RENDERER_WEBGL);
            /nvidia/i.test(i3) && this.config.enableNvidiaDetect && (this.isNVIDIA = true), n2.gl.drawElements = (...e4) => {
              t3.call(n2.gl, ...e4), this.drawCall += 1;
            };
          }
          this.fps.on("update", (t3) => {
            if (t3 < this.config.minFPS) {
              if (this.config.autoResolution) {
                const t4 = 0.7 * this.scale, e3 = this.app.renderer.resolution, i3 = Math.max(t4, e3 - 0.1);
                i3 >= t4 && this.updateResolution(i3);
              }
            } else if (t3 > this.config.maxFPS && this.config.autoResolution) {
              const t4 = this.scale * this.config.resolution, e3 = this.app.renderer.resolution, i3 = Math.min(t4, e3 + 0.1);
              i3 <= this.config.resolution && this.updateResolution(i3);
            }
          }), this.app.ticker.add(() => {
            this.runtime.drawCall = this.drawCall, this.runtime.fps = Math.floor(this.app.ticker.minFPS), this.drawCall = 0;
          }, null, Dh.c.LOW), this.clock = new Fm(this.app.ticker), this.objPoolGroup = Mm(), this.stagePool = new Dy(this.loader, this.mode, this.app.renderer, this.app.ticker, this.app.view, this.clock, this.objPoolGroup, this.errorChannel, this.localStorage, this.logger, t2.loadDelegate, t2.urlInterrupter, this.isPlayerPaused, this.maxResolution, this.volumeAdjuster, this.config.forceCanvas, this.globalEventHub), this.app.view.addEventListener("webglcontextlost", this.onWebGLLost);
          try {
            this.config.forceCanvas || (this.transactionPlayer = new Ih());
          } catch (t3) {
            /Error creating WebGL context/.test(t3.message) ? this.errorChannel.emit("error", new Tm(gm.CanvasCrash, "webgl context lost.")) : this.errorChannel.emit("error", new Tm(gm.RuntimeWarn, t3.message));
          }
          this.globalEventHub.on("requestFullscreen", this.onRequestFullscreenVideo), this.globalEventHub.on("requestCancelFullscreen", this.onRequestCancelFullscreenVideo);
        }
        get view() {
          return this.app.renderer ? this.app.view : null;
        }
        get nextSlideIndex() {
          var t2;
          return (null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.json.nextIndex) ? this.currentStage.json.nextIndex : this.currentIndex + 1;
        }
        get prevSlideIndex() {
          var t2;
          return (null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.json.prevIndex) ? this.currentStage.json.prevIndex : this.currentIndex - 1;
        }
        getMaxResolution(t2) {
          return !$a()(t2) && Number.isInteger(t2) ? (t2 < 1 && (t2 = 1), t2 > 4 && (t2 = 4), t2) : Vy.platform.isAndroid() || Vy.platform.isIOS() ? 2 : 4;
        }
        updateMaxResolutionLevel(t2) {
          t2 < 0 && (t2 = 0), t2 > 4 && (t2 = 4);
          const e2 = [640, 960, 1280, 1920, 3200][t2], i2 = [360, 540, 720, 1080, 1800][t2];
          this.maxResolution.set(e2, i2);
        }
        updateConfig(t2) {
          $a()(t2.maxFPS) || $a()(t2.minFPS) || (this.config.maxFPS = t2.maxFPS, this.app.ticker.maxFPS = t2.maxFPS, this.config.minFPS = t2.minFPS, this.app.ticker.minFPS = t2.minFPS), $a()(t2.resolution) || (this.config.resolution = t2.resolution, this.updateResolution(this.scale * this.config.resolution)), $a()(t2.autoFPS) || (this.config.autoFPS = t2.autoFPS), $a()(t2.autoResolution) || (this.config.autoResolution = t2.autoResolution), $a()(t2.transactionBgColor) || (this.config.transactionBgColor = t2.transactionBgColor), this.taskId && this.logger.info("ppt player update config: " + JSON.stringify(this.config), this.taskId), $a()(t2.maxResolutionLevel) || (this.config.maxResolutionLevel = t2.maxResolutionLevel, this.updateMaxResolutionLevel(this.config.maxResolutionLevel));
        }
        preload(t2) {
          return Hy(this, void 0, void 0, function* () {
            t2 < 1 || t2 > this.slideCount || (this.logger.info(`preload slide ${t2} begin`, this.taskId), yield this.stagePool.preload(t2), this.logger.info(`preload slide ${t2} end`, this.taskId));
          });
        }
        setResourceData(t2, e2) {
          this.logger.info("ppt player init config: " + JSON.stringify(this.config), t2), this.logger.info("set resource to " + e2, t2), this.taskId = t2, this.url = e2, this.stagePool.setResourceData(t2, e2), this.localStorage.attachTaskId(t2), this.loader.attachTaskId(t2);
        }
        setInteractive(t2) {
          this.app.stage.interactive = t2, this.app.stage.interactiveChildren = t2;
        }
        translateEvent(t2, e2) {
          e2.forEach((e3) => {
            t2.on(e3, (...t3) => {
              var i2, n2, r2, o2;
              e3 === zy.requestGotoSlide && t3[0] !== this.currentIndex && (null === (n2 = null === (i2 = this.currentStage) || void 0 === i2 ? void 0 : i2.timing) || void 0 === n2 || n2.setMainSeqStep(0, "start"), null === (o2 = null === (r2 = this.currentStage) || void 0 === r2 ? void 0 : r2.timing) || void 0 === o2 || o2.destroy()), this.emit(e3, ...t3);
            });
          });
        }
        renderSlide(t2) {
          var e2, i2, n2;
          return Hy(this, void 0, void 0, function* () {
            if (this._isPaused) return void this.logger.info("ppt play prevent render slide with paused state", this.taskId);
            const r2 = this.currentIndex, o2 = Date.now();
            this.logger.info("render slide " + t2, this.taskId), this.emit(zy.renderStart, t2);
            const s2 = yield this.stagePool.getStage(t2), a2 = `snapshot-${t2}-${this.isForward ? "start" : "end"}`, l2 = yield this.localStorage.getItem(a2);
            if (!s2) return;
            s2.ctx.isRendering = true, this.translateEvent(s2.ctx.eventHub, [zy.mainSeqStepChange, zy.mainSeqStateChange, zy.hyperlinkTrigger, zy.interactiveSeqAction, zy.mainSeqStepStart, zy.mainSeqStepEnd, zy.animateStart, zy.animateEnd, zy.mediaPlay, zy.mediaPause, zy.mediaSeek, zy.mediaStop, zy.requestGotoSlide, zy.requestOpenUrl, zy.requestNextSlide, zy.requestPrevSlide, zy.interactiveSeqStateChange, zy.userInput, zy.fullscreenChange, zy.changeLocalFullscreenState]), this.currentIndex = Number(t2);
            const { width: h2, height: u2, slideCount: c2 } = s2.json;
            this.slideCount = c2, this.designWidth = h2, this.designHeight = u2, null === (e2 = this.currentStage) || void 0 === e2 || e2.clearOnSlideChange();
            const d2 = this.currentStage;
            this.currentStage = s2, s2.initOnReuse(), s2.createTiming(), s2.container.visible = true, s2.collectMainSeqStartValue(), this.isForward ? s2.setMainSeqStep(0, "start") : s2.setMainSeqStep(-1, "end"), this.onRequestCancelFullscreenVideo(true);
            let p2 = false;
            if (Ph.isWebGLSupported() && !this.config.forceCanvas && s2.json.transition && s2.json.transition.type && this.app.stage.children.length > 0 && this.view && d2) {
              let { transition: t3 } = s2.json;
              !this.isForward && (null == d2 ? void 0 : d2.json.transition) && (t3 = d2.json.transition);
              const e3 = this.getTransactionTexture(d2, this.view, null, null);
              this.initTransactionPlayer(t3), null === (i2 = this.transactionPlayer) || void 0 === i2 || i2.setPrevTexture(e3), p2 = true;
            }
            if (this.app.stage.addChild(s2.container), this.updateResolution(this.config.resolution * this.scale), d2) {
              d2.clearOnTransactionEnd();
              try {
                this.app.stage.removeChild(d2.container);
              } catch (t3) {
                this.logger.error("removeChild error: PPTPlayer:622", this.taskId);
              }
            }
            if (s2.json.transition && s2.json.transition.type && this.app.stage.children.length > 0 && this.view && this.transactionPlayer && p2) {
              const t3 = yield this.getTransactionTexture(s2, this.view, a2, l2);
              this.transactionPlayer.setNextTexture(t3), yield this.transactionPlayer.play();
              const e3 = this.transactionPlayer.renderer.domElement;
              if (this.view.parentElement && e3) try {
                this.view.parentElement.removeChild(e3);
              } catch (t4) {
                this.logger.error("removeChild error: PPTPlayer:637", this.taskId);
              }
              null === (n2 = this.transactionPlayer) || void 0 === n2 || n2.dispose();
            }
            this.isForward ? yield s2.startTiming() : s2.setMainSeqApplied(), s2.ctx.slideScopeEventHub.emit("slide-render", s2.ctx.slideIndex), this.emit(zy.renderEnd, t2), this.emit(zy.slideChange, t2), s2.ctx.isRendering = false, this.preload(t2 + 1).catch((e3) => {
              this.errorChannel.emit("error", Tm.transform(e3), t2 + 1);
            }), this.preload(t2 - 1).catch((e3) => {
              this.errorChannel.emit("error", Tm.transform(e3), t2 - 1);
            }), this.logger.info(`render slide ${t2} done, time: ${Date.now() - o2}ms`, this.taskId), this.tracker({ name: "slidePageChange", reason: "", result: "", payload: { duration: Date.now() - o2, from: r2, to: t2 } });
          });
        }
        getTransactionTexture(t2, e2, i2, n2) {
          const r2 = Vh.p.create({ width: t2.json.width, height: t2.json.height, resolution: 1 });
          this.app.renderer.render(t2.container, { renderTexture: r2 });
          const o2 = this.cachedExtract.canvas(r2, this.app.renderer, n2, i2);
          return new b(o2);
        }
        renderToBase64(t2, e2, i2) {
          return Hy(this, void 0, void 0, function* () {
            const n2 = yield this.stagePool.getStage(t2);
            if (n2) {
              const { width: r2, height: o2 } = n2.json;
              this.designWidth = r2, this.designHeight = o2;
              const s2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: e2 });
              n2.container.visible = true, this.app.renderer.render(n2.container, { renderTexture: s2 });
              const a2 = this.app.renderer.plugins.extract.base64(s2, i2);
              return this.stagePool.destroyStageByIndex(t2), a2;
            }
            return "__null__";
          });
        }
        renderMainSeqToBase64(t2, e2, i2) {
          return Hy(this, void 0, void 0, function* () {
            const n2 = [], r2 = yield this.stagePool.getStage(t2);
            if (r2.createTiming(), r2) {
              const { width: t3, height: o2 } = r2.json;
              this.designWidth = t3, this.designHeight = o2;
              const s2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: e2 });
              r2.container.visible = true;
              const a2 = r2.mainSeqLength();
              r2.setMainSeqStep(0, "start"), this.app.renderer.render(r2.container, { renderTexture: s2 });
              const l2 = this.app.renderer.plugins.extract.base64(s2, i2);
              n2.push(l2);
              for (let t4 = 0; t4 < a2; t4 += 1) {
                r2.setMainSeqStep(t4, "end"), this.app.renderer.render(r2.container, { renderTexture: s2 });
                const e3 = this.app.renderer.plugins.extract.base64(s2, i2);
                n2.push(e3);
              }
            }
            return n2;
          });
        }
        snapshotWithTimingEnd(t2) {
          return Hy(this, void 0, void 0, function* () {
            const e2 = yield this.stagePool.getStage(t2);
            if (e2) {
              const { width: i2, height: n2 } = e2.json;
              this.designWidth = i2, this.designHeight = n2;
              const r2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: 1 });
              e2.container.visible = true, e2.initOnReuse(), e2.createTiming(), e2.collectMainSeqStartValue(), e2.setMainSeqStep(-1, "end"), this.app.renderer.render(e2.container, { renderTexture: r2 });
              const o2 = this.app.renderer.plugins.extract.base64(r2, "image/png");
              return t2 !== this.currentIndex && this.stagePool.destroyStageByIndex(t2), o2;
            }
            return null;
          });
        }
        getBase64(t2) {
          if (!t2.container.transform) return null;
          const e2 = Vh.p.create({ width: this.designWidth, height: this.designHeight, resolution: 1 });
          this.app.renderer.render(t2.container, { renderTexture: e2 });
          const i2 = this.app.renderer.plugins.extract.base64(e2, "image/jpeg");
          return e2.destroy(true), i2;
        }
        initTransactionPlayer(t2) {
          var e2, i2, n2, r2, o2;
          const s2 = null === (e2 = this.view) || void 0 === e2 ? void 0 : e2.parentElement;
          if (this.view && s2 && jy[t2.type] && this.transactionPlayer) {
            const e3 = null === (i2 = this.transactionPlayer) || void 0 === i2 ? void 0 : i2.renderer.domElement;
            this.transactionPlayer.initPlayer({ reverse: !this.isForward, stageWidth: this.view.width, stageHeight: this.view.height, presetType: jy[t2.type], duration: null === (r2 = null === (n2 = this.currentStage) || void 0 === n2 ? void 0 : n2.json.transition) || void 0 === r2 ? void 0 : r2.dur, delay: 0, clearColor: this.config.transactionBgColor, maxFPS: Math.ceil(null !== (o2 = this.config.maxFPS) && void 0 !== o2 ? o2 : 60), options: t2.options }), e3 && (e3.style.position = "absolute", e3.style.zIndex = "9", e3.style.left = "0", e3.style.top = "0", e3.style.width = this.view.style.width, e3.style.height = this.view.style.height), s2.appendChild(e3);
          }
        }
        scaleView(t2, e2, i2) {
          var n2;
          this.view && (this.view.style.width = Math.floor(this.designWidth * t2) + "px", this.view.style.height = Math.floor(this.designHeight * t2) + "px");
          const r2 = null === (n2 = this.transactionPlayer) || void 0 === n2 ? void 0 : n2.renderer.domElement;
          if (r2 && this.view && (r2.style.width = this.view.style.width, r2.style.height = this.view.style.height), e2) {
            this.scale = t2;
            const e3 = this.scale * this.config.resolution;
            this.updateResolution(e3, i2);
          }
        }
        updateResolution(t2, e2) {
          this.app.ticker.addOnce(() => {
            let i2 = r_.isDesktop() ? t2 : 1;
            for (; i2 * this.designWidth > this.maxResolution.x || i2 * this.designHeight > this.maxResolution.y; ) i2 -= 0.1;
            this.app.renderer.resolution = i2, this.app.renderer.plugins.interaction.resolution = this.app.renderer.resolution, this.app.renderer.resize(this.designWidth, this.designHeight), Ka()(e2) && e2();
          });
        }
        nextStep(t2, e2) {
          var i2;
          if (this._isPaused) this.logger.info("ppt play prevent next step with paused state", this.taskId);
          else {
            this.logger.info("ppt play trigger next step", this.taskId);
            try {
              this.onRequestCancelFullscreenVideo(true), null === (i2 = this.currentStage) || void 0 === i2 || i2.nextStep(t2, e2);
            } catch (t3) {
              this.errorChannel.emit("error", Tm.transform(t3), this.currentIndex);
            }
          }
        }
        prevStep(t2 = false) {
          var e2;
          if (this._isPaused) this.logger.info("ppt play prevent prev step with paused state", this.taskId);
          else {
            this.logger.info("ppt play trigger prev step", this.taskId);
            try {
              this.onRequestCancelFullscreenVideo(true), null === (e2 = this.currentStage) || void 0 === e2 || e2.prevStep(t2);
            } catch (t3) {
              this.errorChannel.emit("error", Tm.transform(t3), this.currentIndex);
            }
          }
        }
        mainSeqLength() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.mainSeqLength()) && void 0 !== e2 ? e2 : 0;
        }
        mainSeqStep() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.mainSeqStep()) && void 0 !== e2 ? e2 : 0;
        }
        setMainSeqStep(t2, e2) {
          var i2;
          null === (i2 = this.currentStage) || void 0 === i2 || i2.setMainSeqStep(t2, e2);
        }
        mainSeqState() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.mainSeqState()) && void 0 !== e2 ? e2 : null;
        }
        mainSeqHasNextStep() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.mainSeqHasNextStep()) && void 0 !== e2 && e2;
        }
        mainSeqHasPrevStep() {
          var t2, e2;
          return null !== (e2 = null === (t2 = this.currentStage) || void 0 === t2 ? void 0 : t2.mainSeqHasPrevStep()) && void 0 !== e2 && e2;
        }
        nextTick(t2) {
          this.app.ticker.addOnce(() => {
            t2();
          }, Dh.c.LOW);
        }
        applyInteractiveAction(t2) {
          var e2;
          null === (e2 = this.currentStage) || void 0 === e2 || e2.applyInteractiveAction(t2);
        }
        seekInteractiveSeqToEnd(t2) {
          var e2;
          null === (e2 = this.currentStage) || void 0 === e2 || e2.seekInteractiveSeqToEnd(t2);
        }
        setInteractiveSeqState(t2, e2, i2) {
          var n2;
          null === (n2 = this.currentStage) || void 0 === n2 || n2.setInteractiveSeqState(t2, e2, i2);
        }
        setMediaState(t2, e2, i2) {
          var n2;
          return Hy(this, void 0, void 0, function* () {
            yield null === (n2 = this.currentStage) || void 0 === n2 ? void 0 : n2.setMediaState(t2, e2, i2);
          });
        }
        setMediaCurrentTime(t2, e2) {
          var i2;
          null === (i2 = this.currentStage) || void 0 === i2 || i2.setMediaCurrentTime(t2, e2);
        }
        pause() {
          var t2;
          this.app.ticker.stop(), null === (t2 = this.currentStage) || void 0 === t2 || t2.ctx.activeMedia.forEach((t3) => {
            t3.globalPause();
          }), this._isPaused = true;
        }
        resume() {
          var t2;
          this._isPaused = false, this.app.ticker.start(), null === (t2 = this.currentStage) || void 0 === t2 || t2.ctx.activeMedia.forEach((t3) => {
            t3.globalResume();
          });
        }
        getSnapshot() {
          return this.currentStage && this.getBase64(this.currentStage) || "";
        }
        clearLocalCache() {
          this.localStorage.dispose();
        }
        static clearLocalCache() {
          var t2;
          null === (t2 = By.localCache) || void 0 === t2 || t2.clear().catch(() => {
          });
        }
        clearFullscreenEventListenersWithAppView() {
          ["mousemove", "mouseout", "mouseover", "touchstart", "pointerdown"].forEach((t2) => {
            this.cacheFunctionMap.has(t2) && (this.app.view.removeEventListener(t2, this.cacheFunctionMap.get(t2), false), this.cacheFunctionMap.delete(t2));
          });
        }
        syncFullscreenVideoState(t2) {
          this.globalEventHub.emit("syncFullscreenVideoState", t2);
        }
        destroy() {
          var t2, e2;
          try {
            this.app.view.removeEventListener("webglcontextlost", this.onWebGLLost), this.app.renderer.filter.texturePool.clear(true), qm.collectObjectByGroup(this.objPoolGroup), Zm.collectObjectByGroup(this.objPoolGroup), null === (t2 = this.transactionPlayer) || void 0 === t2 || t2.destroy(), this.loader.destroy(), this.fps.destroy(), this.stagePool.destroyAllStage(), this.stagePool.destroy(), this.app.renderer.gl.getExtension("WEBGL_lose_context").loseContext(), this.app.destroy(true, { children: true, texture: true, baseTexture: true }), null === (e2 = Ny.worker) || void 0 === e2 || e2.terminate(), this.tracker({ name: "slidePlayerDestroy", result: "", reason: "", payload: {} });
          } catch (t3) {
          }
        }
      }
      Vy.platform = r_, Vy.RtcAudioClazz = null;
      var Xy = /* @__PURE__ */ new Map();
      var Wy, Yy = i(136), qy = i.n(Yy), Zy = i(49), Jy = i.n(Zy), Ky = i(50), Qy = i.n(Ky), $y = [], tx = "ResizeObserver loop completed with undelivered notifications.";
      !function(t2) {
        t2.BORDER_BOX = "border-box", t2.CONTENT_BOX = "content-box", t2.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
      }(Wy || (Wy = {}));
      var ex, ix = function(t2) {
        return Object.freeze(t2);
      }, nx = function(t2, e2) {
        this.inlineSize = t2, this.blockSize = e2, ix(this);
      }, rx = function() {
        function t2(t3, e2, i2, n2) {
          return this.x = t3, this.y = e2, this.width = i2, this.height = n2, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ix(this);
        }
        return t2.prototype.toJSON = function() {
          var t3 = this;
          return { x: t3.x, y: t3.y, top: t3.top, right: t3.right, bottom: t3.bottom, left: t3.left, width: t3.width, height: t3.height };
        }, t2.fromRect = function(e2) {
          return new t2(e2.x, e2.y, e2.width, e2.height);
        }, t2;
      }(), ox = function(t2) {
        return t2 instanceof SVGElement && "getBBox" in t2;
      }, sx = function(t2) {
        if (ox(t2)) {
          var e2 = t2.getBBox(), i2 = e2.width, n2 = e2.height;
          return !i2 && !n2;
        }
        var r2 = t2, o2 = r2.offsetWidth, s2 = r2.offsetHeight;
        return !(o2 || s2 || t2.getClientRects().length);
      }, ax = function(t2) {
        var e2;
        if (t2 instanceof Element) return true;
        var i2 = null === (e2 = null == t2 ? void 0 : t2.ownerDocument) || void 0 === e2 ? void 0 : e2.defaultView;
        return !!(i2 && t2 instanceof i2.Element);
      }, lx = "undefined" != typeof window ? window : {}, hx = /* @__PURE__ */ new WeakMap(), ux = /auto|scroll/, cx = /^tb|vertical/, dx = /msie|trident/i.test(lx.navigator && lx.navigator.userAgent), px = function(t2) {
        return parseFloat(t2 || "0");
      }, fx = function(t2, e2, i2) {
        return void 0 === t2 && (t2 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = false), new nx((i2 ? e2 : t2) || 0, (i2 ? t2 : e2) || 0);
      }, mx = ix({ devicePixelContentBoxSize: fx(), borderBoxSize: fx(), contentBoxSize: fx(), contentRect: new rx(0, 0, 0, 0) }), gx = function(t2, e2) {
        if (void 0 === e2 && (e2 = false), hx.has(t2) && !e2) return hx.get(t2);
        if (sx(t2)) return hx.set(t2, mx), mx;
        var i2 = getComputedStyle(t2), n2 = ox(t2) && t2.ownerSVGElement && t2.getBBox(), r2 = !dx && "border-box" === i2.boxSizing, o2 = cx.test(i2.writingMode || ""), s2 = !n2 && ux.test(i2.overflowY || ""), a2 = !n2 && ux.test(i2.overflowX || ""), l2 = n2 ? 0 : px(i2.paddingTop), h2 = n2 ? 0 : px(i2.paddingRight), u2 = n2 ? 0 : px(i2.paddingBottom), c2 = n2 ? 0 : px(i2.paddingLeft), d2 = n2 ? 0 : px(i2.borderTopWidth), p2 = n2 ? 0 : px(i2.borderRightWidth), f2 = n2 ? 0 : px(i2.borderBottomWidth), m2 = c2 + h2, g2 = l2 + u2, v2 = (n2 ? 0 : px(i2.borderLeftWidth)) + p2, _2 = d2 + f2, y2 = a2 ? t2.offsetHeight - _2 - t2.clientHeight : 0, x2 = s2 ? t2.offsetWidth - v2 - t2.clientWidth : 0, b2 = r2 ? m2 + v2 : 0, T2 = r2 ? g2 + _2 : 0, E2 = n2 ? n2.width : px(i2.width) - b2 - x2, S2 = n2 ? n2.height : px(i2.height) - T2 - y2, w2 = E2 + m2 + x2 + v2, A2 = S2 + g2 + y2 + _2, M2 = ix({ devicePixelContentBoxSize: fx(Math.round(E2 * devicePixelRatio), Math.round(S2 * devicePixelRatio), o2), borderBoxSize: fx(w2, A2, o2), contentBoxSize: fx(E2, S2, o2), contentRect: new rx(c2, l2, E2, S2) });
        return hx.set(t2, M2), M2;
      }, vx = function(t2, e2, i2) {
        var n2 = gx(t2, i2), r2 = n2.borderBoxSize, o2 = n2.contentBoxSize, s2 = n2.devicePixelContentBoxSize;
        switch (e2) {
          case Wy.DEVICE_PIXEL_CONTENT_BOX:
            return s2;
          case Wy.BORDER_BOX:
            return r2;
          default:
            return o2;
        }
      }, _x = function(t2) {
        var e2 = gx(t2);
        this.target = t2, this.contentRect = e2.contentRect, this.borderBoxSize = ix([e2.borderBoxSize]), this.contentBoxSize = ix([e2.contentBoxSize]), this.devicePixelContentBoxSize = ix([e2.devicePixelContentBoxSize]);
      }, yx = function(t2) {
        if (sx(t2)) return 1 / 0;
        for (var e2 = 0, i2 = t2.parentNode; i2; ) e2 += 1, i2 = i2.parentNode;
        return e2;
      }, xx = function() {
        var t2 = 1 / 0, e2 = [];
        $y.forEach(function(i3) {
          if (0 !== i3.activeTargets.length) {
            var n3 = [];
            i3.activeTargets.forEach(function(e3) {
              var i4 = new _x(e3.target), r2 = yx(e3.target);
              n3.push(i4), e3.lastReportedSize = vx(e3.target, e3.observedBox), r2 < t2 && (t2 = r2);
            }), e2.push(function() {
              i3.callback.call(i3.observer, n3, i3.observer);
            }), i3.activeTargets.splice(0, i3.activeTargets.length);
          }
        });
        for (var i2 = 0, n2 = e2; i2 < n2.length; i2++) {
          (0, n2[i2])();
        }
        return t2;
      }, bx = function(t2) {
        $y.forEach(function(e2) {
          e2.activeTargets.splice(0, e2.activeTargets.length), e2.skippedTargets.splice(0, e2.skippedTargets.length), e2.observationTargets.forEach(function(i2) {
            i2.isActive() && (yx(i2.target) > t2 ? e2.activeTargets.push(i2) : e2.skippedTargets.push(i2));
          });
        });
      }, Tx = function() {
        var t2, e2 = 0;
        for (bx(e2); $y.some(function(t3) {
          return t3.activeTargets.length > 0;
        }); ) e2 = xx(), bx(e2);
        return $y.some(function(t3) {
          return t3.skippedTargets.length > 0;
        }) && ("function" == typeof ErrorEvent ? t2 = new ErrorEvent("error", { message: tx }) : ((t2 = document.createEvent("Event")).initEvent("error", false, false), t2.message = tx), window.dispatchEvent(t2)), e2 > 0;
      }, Ex = [], Sx = function(t2) {
        if (!ex) {
          var e2 = 0, i2 = document.createTextNode("");
          new MutationObserver(function() {
            return Ex.splice(0).forEach(function(t3) {
              return t3();
            });
          }).observe(i2, { characterData: true }), ex = function() {
            i2.textContent = "".concat(e2 ? e2-- : e2++);
          };
        }
        Ex.push(t2), ex();
      }, wx = 0, Ax = { attributes: true, characterData: true, childList: true, subtree: true }, Mx = ["resize", "load", "transitionend", "animationend", "animationstart", "animationiteration", "keyup", "keydown", "mouseup", "mousedown", "mouseover", "mouseout", "blur", "focus"], Cx = function(t2) {
        return void 0 === t2 && (t2 = 0), Date.now() + t2;
      }, Rx = false, Ix = new (function() {
        function t2() {
          var t3 = this;
          this.stopped = true, this.listener = function() {
            return t3.schedule();
          };
        }
        return t2.prototype.run = function(t3) {
          var e2 = this;
          if (void 0 === t3 && (t3 = 250), !Rx) {
            Rx = true;
            var i2, n2 = Cx(t3);
            i2 = function() {
              var i3 = false;
              try {
                i3 = Tx();
              } finally {
                if (Rx = false, t3 = n2 - Cx(), !wx) return;
                i3 ? e2.run(1e3) : t3 > 0 ? e2.run(t3) : e2.start();
              }
            }, Sx(function() {
              requestAnimationFrame(i2);
            });
          }
        }, t2.prototype.schedule = function() {
          this.stop(), this.run();
        }, t2.prototype.observe = function() {
          var t3 = this, e2 = function() {
            return t3.observer && t3.observer.observe(document.body, Ax);
          };
          document.body ? e2() : lx.addEventListener("DOMContentLoaded", e2);
        }, t2.prototype.start = function() {
          var t3 = this;
          this.stopped && (this.stopped = false, this.observer = new MutationObserver(this.listener), this.observe(), Mx.forEach(function(e2) {
            return lx.addEventListener(e2, t3.listener, true);
          }));
        }, t2.prototype.stop = function() {
          var t3 = this;
          this.stopped || (this.observer && this.observer.disconnect(), Mx.forEach(function(e2) {
            return lx.removeEventListener(e2, t3.listener, true);
          }), this.stopped = true);
        }, t2;
      }())(), Px = function(t2) {
        !wx && t2 > 0 && Ix.start(), !(wx += t2) && Ix.stop();
      }, Ox = function() {
        function t2(t3, e2) {
          this.target = t3, this.observedBox = e2 || Wy.CONTENT_BOX, this.lastReportedSize = { inlineSize: 0, blockSize: 0 };
        }
        return t2.prototype.isActive = function() {
          var t3, e2 = vx(this.target, this.observedBox, true);
          return t3 = this.target, ox(t3) || function(t4) {
            switch (t4.tagName) {
              case "INPUT":
                if ("image" !== t4.type) break;
              case "VIDEO":
              case "AUDIO":
              case "EMBED":
              case "OBJECT":
              case "CANVAS":
              case "IFRAME":
              case "IMG":
                return true;
            }
            return false;
          }(t3) || "inline" !== getComputedStyle(t3).display || (this.lastReportedSize = e2), this.lastReportedSize.inlineSize !== e2.inlineSize || this.lastReportedSize.blockSize !== e2.blockSize;
        }, t2;
      }(), Nx = function(t2, e2) {
        this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t2, this.callback = e2;
      }, Lx = /* @__PURE__ */ new WeakMap(), Dx = function(t2, e2) {
        for (var i2 = 0; i2 < t2.length; i2 += 1) if (t2[i2].target === e2) return i2;
        return -1;
      }, Fx = function() {
        function t2() {
        }
        return t2.connect = function(t3, e2) {
          var i2 = new Nx(t3, e2);
          Lx.set(t3, i2);
        }, t2.observe = function(t3, e2, i2) {
          var n2 = Lx.get(t3), r2 = 0 === n2.observationTargets.length;
          Dx(n2.observationTargets, e2) < 0 && (r2 && $y.push(n2), n2.observationTargets.push(new Ox(e2, i2 && i2.box)), Px(1), Ix.schedule());
        }, t2.unobserve = function(t3, e2) {
          var i2 = Lx.get(t3), n2 = Dx(i2.observationTargets, e2), r2 = 1 === i2.observationTargets.length;
          n2 >= 0 && (r2 && $y.splice($y.indexOf(i2), 1), i2.observationTargets.splice(n2, 1), Px(-1));
        }, t2.disconnect = function(t3) {
          var e2 = this, i2 = Lx.get(t3);
          i2.observationTargets.slice().forEach(function(i3) {
            return e2.unobserve(t3, i3.target);
          }), i2.activeTargets.splice(0, i2.activeTargets.length);
        }, t2;
      }(), Bx = function() {
        function t2(t3) {
          if (0 === arguments.length) throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
          if ("function" != typeof t3) throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
          Fx.connect(this, t3);
        }
        return t2.prototype.observe = function(t3, e2) {
          if (0 === arguments.length) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
          if (!ax(t3)) throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
          Fx.observe(this, t3, e2);
        }, t2.prototype.unobserve = function(t3) {
          if (0 === arguments.length) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
          if (!ax(t3)) throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
          Fx.unobserve(this, t3);
        }, t2.prototype.disconnect = function() {
          Fx.disconnect(this);
        }, t2.toString = function() {
          return "function ResizeObserver () { [polyfill code] }";
        }, t2;
      }(), Ux = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, kx = function(t2, e2) {
        var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
          if (1 & r2[0]) throw r2[1];
          return r2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (i2) throw new TypeError("Generator is already executing.");
              for (; s2; ) try {
                if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done) return r2;
                switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                  case 0:
                  case 1:
                    r2 = o4;
                    break;
                  case 4:
                    return s2.label++, { value: o4[1], done: false };
                  case 5:
                    s2.label++, n2 = o4[1], o4 = [0];
                    continue;
                  case 7:
                    o4 = s2.ops.pop(), s2.trys.pop();
                    continue;
                  default:
                    if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                      s2 = 0;
                      continue;
                    }
                    if (3 === o4[0] && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                      s2.label = o4[1];
                      break;
                    }
                    if (6 === o4[0] && s2.label < r2[1]) {
                      s2.label = r2[1], r2 = o4;
                      break;
                    }
                    if (r2 && s2.label < r2[2]) {
                      s2.label = r2[2], s2.ops.push(o4);
                      break;
                    }
                    r2[2] && s2.ops.pop(), s2.trys.pop();
                    continue;
                }
                o4 = e2.call(t2, s2);
              } catch (t3) {
                o4 = [6, t3], n2 = 0;
              } finally {
                i2 = r2 = 0;
              }
              if (5 & o4[0]) throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, Gx = function() {
        function t2(t3, e2, i2, n2, r2) {
          this.state = "idle", this.index = -1, this.slideIndex = -1, this.fn = i2, this.index = t3, this.slideIndex = e2, this.eventHub = n2, this.id = r2;
        }
        return t2.prototype.apply = function() {
          return Ux(this, void 0, void 0, function() {
            var t3;
            return kx(this, function(e2) {
              switch (e2.label) {
                case 0:
                  this.eventHub.emit("task-start", this), e2.label = 1;
                case 1:
                  return e2.trys.push([1, 3, , 4]), this.state = "start", [4, this.fn()];
                case 2:
                  return e2.sent(), this.state = "end", this.eventHub.emit("task-end", this), [3, 4];
                case 3:
                  return t3 = e2.sent(), this.eventHub.emit("task-error", { task: this, error: t3 }), [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        }, t2;
      }(), Hx = function() {
        function t2() {
          var t3 = this;
          this.eventHub = new Za.a(), this.tasks = [], this.index = 0, this.eventHub.on("task-end", function(e2) {
            var i2, n2 = t3.tasks.findIndex(function(t4) {
              return t4.index === e2.index;
            }), r2 = n2 + 1;
            r2 >= 0 && (null === (i2 = t3.tasks[r2]) || void 0 === i2 || i2.apply()), n2 >= 0 && (t3.tasks.splice(n2, 1), t3.replaceIdleTask()), t3.eventHub.emit("task-end-" + e2.id);
          }), this.eventHub.on("task-error", function(e2) {
            var i2 = e2.task, n2 = t3.tasks.findIndex(function(t4) {
              return t4.index === i2.index;
            });
            n2 >= 0 && (t3.tasks.splice(n2, 1), t3.replaceIdleTask());
          });
        }
        return t2.prototype.replaceIdleTask = function() {
          for (var t3, e2 = this, i2 = /* @__PURE__ */ new Set(), n2 = 0, r2 = this.tasks.length; n2 < r2; n2++) "idle" === this.tasks[n2].state && "idle" === (null === (t3 = this.tasks[n2 + 1]) || void 0 === t3 ? void 0 : t3.state) && i2.add(n2);
          Array.from(i2).forEach(function(t4) {
            e2.tasks.splice(t4, 1);
          });
        }, t2.prototype.addTask = function(t3, e2, i2) {
          var n2 = new Gx(this.index++, e2, t3, this.eventHub, i2);
          this.tasks.push(n2), this.tasks.sort(function(t4, e3) {
            return t4.index - e3.index;
          }), this.replaceIdleTask(), 1 === this.tasks.length && n2.apply();
        }, t2.prototype.hasStartTask = function() {
          return this.tasks.some(function(t3) {
            return "start" === t3.state;
          });
        }, t2.prototype.destroy = function() {
          this.eventHub.removeAllListeners();
        }, t2;
      }();
      function jx(t2, e2) {
        var i2 = t2.__state.conversionName.toString(), n2 = Math.round(t2.r), r2 = Math.round(t2.g), o2 = Math.round(t2.b), s2 = t2.a, a2 = Math.round(t2.h), l2 = t2.s.toFixed(1), h2 = t2.v.toFixed(1);
        if (e2 || "THREE_CHAR_HEX" === i2 || "SIX_CHAR_HEX" === i2) {
          for (var u2 = t2.hex.toString(16); u2.length < 6; ) u2 = "0" + u2;
          return "#" + u2;
        }
        return "CSS_RGB" === i2 ? "rgb(" + n2 + "," + r2 + "," + o2 + ")" : "CSS_RGBA" === i2 ? "rgba(" + n2 + "," + r2 + "," + o2 + "," + s2 + ")" : "HEX" === i2 ? "0x" + t2.hex.toString(16) : "RGB_ARRAY" === i2 ? "[" + n2 + "," + r2 + "," + o2 + "]" : "RGBA_ARRAY" === i2 ? "[" + n2 + "," + r2 + "," + o2 + "," + s2 + "]" : "RGB_OBJ" === i2 ? "{r:" + n2 + ",g:" + r2 + ",b:" + o2 + "}" : "RGBA_OBJ" === i2 ? "{r:" + n2 + ",g:" + r2 + ",b:" + o2 + ",a:" + s2 + "}" : "HSV_OBJ" === i2 ? "{h:" + a2 + ",s:" + l2 + ",v:" + h2 + "}" : "HSVA_OBJ" === i2 ? "{h:" + a2 + ",s:" + l2 + ",v:" + h2 + ",a:" + s2 + "}" : "unknown format";
      }
      var zx = Array.prototype.forEach, Vx = Array.prototype.slice, Xx = { BREAK: {}, extend: function(t2) {
        return this.each(Vx.call(arguments, 1), function(e2) {
          (this.isObject(e2) ? Object.keys(e2) : []).forEach(function(i2) {
            this.isUndefined(e2[i2]) || (t2[i2] = e2[i2]);
          }.bind(this));
        }, this), t2;
      }, defaults: function(t2) {
        return this.each(Vx.call(arguments, 1), function(e2) {
          (this.isObject(e2) ? Object.keys(e2) : []).forEach(function(i2) {
            this.isUndefined(t2[i2]) && (t2[i2] = e2[i2]);
          }.bind(this));
        }, this), t2;
      }, compose: function() {
        var t2 = Vx.call(arguments);
        return function() {
          for (var e2 = Vx.call(arguments), i2 = t2.length - 1; i2 >= 0; i2--) e2 = [t2[i2].apply(this, e2)];
          return e2[0];
        };
      }, each: function(t2, e2, i2) {
        if (t2) {
          if (zx && t2.forEach && t2.forEach === zx) t2.forEach(e2, i2);
          else if (t2.length === t2.length + 0) {
            var n2, r2 = void 0;
            for (r2 = 0, n2 = t2.length; r2 < n2; r2++) if (r2 in t2 && e2.call(i2, t2[r2], r2) === this.BREAK) return;
          } else for (var o2 in t2) if (e2.call(i2, t2[o2], o2) === this.BREAK) return;
        }
      }, defer: function(t2) {
        setTimeout(t2, 0);
      }, debounce: function(t2, e2, i2) {
        var n2 = void 0;
        return function() {
          var r2 = this, o2 = arguments;
          function s2() {
            n2 = null, i2 || t2.apply(r2, o2);
          }
          var a2 = i2 || !n2;
          clearTimeout(n2), n2 = setTimeout(s2, e2), a2 && t2.apply(r2, o2);
        };
      }, toArray: function(t2) {
        return t2.toArray ? t2.toArray() : Vx.call(t2);
      }, isUndefined: function(t2) {
        return void 0 === t2;
      }, isNull: function(t2) {
        return null === t2;
      }, isNaN: function(t2) {
        function e2(e3) {
          return t2.apply(this, arguments);
        }
        return e2.toString = function() {
          return t2.toString();
        }, e2;
      }(function(t2) {
        return isNaN(t2);
      }), isArray: Array.isArray || function(t2) {
        return t2.constructor === Array;
      }, isObject: function(t2) {
        return t2 === Object(t2);
      }, isNumber: function(t2) {
        return t2 === t2 + 0;
      }, isString: function(t2) {
        return t2 === t2 + "";
      }, isBoolean: function(t2) {
        return false === t2 || true === t2;
      }, isFunction: function(t2) {
        return t2 instanceof Function;
      } }, Wx = [{ litmus: Xx.isString, conversions: { THREE_CHAR_HEX: { read: function(t2) {
        var e2 = t2.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
        return null !== e2 && { space: "HEX", hex: parseInt("0x" + e2[1].toString() + e2[1].toString() + e2[2].toString() + e2[2].toString() + e2[3].toString() + e2[3].toString(), 0) };
      }, write: jx }, SIX_CHAR_HEX: { read: function(t2) {
        var e2 = t2.match(/^#([A-F0-9]{6})$/i);
        return null !== e2 && { space: "HEX", hex: parseInt("0x" + e2[1].toString(), 0) };
      }, write: jx }, CSS_RGB: { read: function(t2) {
        var e2 = t2.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        return null !== e2 && { space: "RGB", r: parseFloat(e2[1]), g: parseFloat(e2[2]), b: parseFloat(e2[3]) };
      }, write: jx }, CSS_RGBA: { read: function(t2) {
        var e2 = t2.match(/^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
        return null !== e2 && { space: "RGB", r: parseFloat(e2[1]), g: parseFloat(e2[2]), b: parseFloat(e2[3]), a: parseFloat(e2[4]) };
      }, write: jx } } }, { litmus: Xx.isNumber, conversions: { HEX: { read: function(t2) {
        return { space: "HEX", hex: t2, conversionName: "HEX" };
      }, write: function(t2) {
        return t2.hex;
      } } } }, { litmus: Xx.isArray, conversions: { RGB_ARRAY: { read: function(t2) {
        return 3 === t2.length && { space: "RGB", r: t2[0], g: t2[1], b: t2[2] };
      }, write: function(t2) {
        return [t2.r, t2.g, t2.b];
      } }, RGBA_ARRAY: { read: function(t2) {
        return 4 === t2.length && { space: "RGB", r: t2[0], g: t2[1], b: t2[2], a: t2[3] };
      }, write: function(t2) {
        return [t2.r, t2.g, t2.b, t2.a];
      } } } }, { litmus: Xx.isObject, conversions: { RGBA_OBJ: { read: function(t2) {
        return !!(Xx.isNumber(t2.r) && Xx.isNumber(t2.g) && Xx.isNumber(t2.b) && Xx.isNumber(t2.a)) && { space: "RGB", r: t2.r, g: t2.g, b: t2.b, a: t2.a };
      }, write: function(t2) {
        return { r: t2.r, g: t2.g, b: t2.b, a: t2.a };
      } }, RGB_OBJ: { read: function(t2) {
        return !!(Xx.isNumber(t2.r) && Xx.isNumber(t2.g) && Xx.isNumber(t2.b)) && { space: "RGB", r: t2.r, g: t2.g, b: t2.b };
      }, write: function(t2) {
        return { r: t2.r, g: t2.g, b: t2.b };
      } }, HSVA_OBJ: { read: function(t2) {
        return !!(Xx.isNumber(t2.h) && Xx.isNumber(t2.s) && Xx.isNumber(t2.v) && Xx.isNumber(t2.a)) && { space: "HSV", h: t2.h, s: t2.s, v: t2.v, a: t2.a };
      }, write: function(t2) {
        return { h: t2.h, s: t2.s, v: t2.v, a: t2.a };
      } }, HSV_OBJ: { read: function(t2) {
        return !!(Xx.isNumber(t2.h) && Xx.isNumber(t2.s) && Xx.isNumber(t2.v)) && { space: "HSV", h: t2.h, s: t2.s, v: t2.v };
      }, write: function(t2) {
        return { h: t2.h, s: t2.s, v: t2.v };
      } } } }], Yx = void 0, qx = void 0, Zx = function() {
        qx = false;
        var t2 = arguments.length > 1 ? Xx.toArray(arguments) : arguments[0];
        return Xx.each(Wx, function(e2) {
          if (e2.litmus(t2)) return Xx.each(e2.conversions, function(e3, i2) {
            if (Yx = e3.read(t2), false === qx && false !== Yx) return qx = Yx, Yx.conversionName = i2, Yx.conversion = e3, Xx.BREAK;
          }), Xx.BREAK;
        }), qx;
      }, Jx = void 0, Kx = { hsv_to_rgb: function(t2, e2, i2) {
        var n2 = Math.floor(t2 / 60) % 6, r2 = t2 / 60 - Math.floor(t2 / 60), o2 = i2 * (1 - e2), s2 = i2 * (1 - r2 * e2), a2 = i2 * (1 - (1 - r2) * e2), l2 = [[i2, a2, o2], [s2, i2, o2], [o2, i2, a2], [o2, s2, i2], [a2, o2, i2], [i2, o2, s2]][n2];
        return { r: 255 * l2[0], g: 255 * l2[1], b: 255 * l2[2] };
      }, rgb_to_hsv: function(t2, e2, i2) {
        var n2 = Math.min(t2, e2, i2), r2 = Math.max(t2, e2, i2), o2 = r2 - n2, s2 = void 0;
        return 0 === r2 ? { h: NaN, s: 0, v: 0 } : (s2 = t2 === r2 ? (e2 - i2) / o2 : e2 === r2 ? 2 + (i2 - t2) / o2 : 4 + (t2 - e2) / o2, (s2 /= 6) < 0 && (s2 += 1), { h: 360 * s2, s: o2 / r2, v: r2 / 255 });
      }, rgb_to_hex: function(t2, e2, i2) {
        var n2 = this.hex_with_component(0, 2, t2);
        return n2 = this.hex_with_component(n2, 1, e2), n2 = this.hex_with_component(n2, 0, i2);
      }, component_from_hex: function(t2, e2) {
        return t2 >> 8 * e2 & 255;
      }, hex_with_component: function(t2, e2, i2) {
        return i2 << (Jx = 8 * e2) | t2 & ~(255 << Jx);
      } }, Qx = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t2) {
        return typeof t2;
      } : function(t2) {
        return t2 && "function" == typeof Symbol && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
      }, $x = function(t2, e2) {
        if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
      }, tb = /* @__PURE__ */ function() {
        function t2(t3, e2) {
          for (var i2 = 0; i2 < e2.length; i2++) {
            var n2 = e2[i2];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
          }
        }
        return function(e2, i2, n2) {
          return i2 && t2(e2.prototype, i2), n2 && t2(e2, n2), e2;
        };
      }(), eb = function t2(e2, i2, n2) {
        null === e2 && (e2 = Function.prototype);
        var r2 = Object.getOwnPropertyDescriptor(e2, i2);
        if (void 0 === r2) {
          var o2 = Object.getPrototypeOf(e2);
          return null === o2 ? void 0 : t2(o2, i2, n2);
        }
        if ("value" in r2) return r2.value;
        var s2 = r2.get;
        return void 0 !== s2 ? s2.call(n2) : void 0;
      }, ib = function(t2, e2) {
        if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function, not " + typeof e2);
        t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, enumerable: false, writable: true, configurable: true } }), e2 && (Object.setPrototypeOf ? Object.setPrototypeOf(t2, e2) : t2.__proto__ = e2);
      }, nb = function(t2, e2) {
        if (!t2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e2 || "object" != typeof e2 && "function" != typeof e2 ? t2 : e2;
      }, rb = function() {
        function t2() {
          if ($x(this, t2), this.__state = Zx.apply(this, arguments), false === this.__state) throw new Error("Failed to interpret color arguments");
          this.__state.a = this.__state.a || 1;
        }
        return tb(t2, [{ key: "toString", value: function() {
          return jx(this);
        } }, { key: "toHexString", value: function() {
          return jx(this, true);
        } }, { key: "toOriginal", value: function() {
          return this.__state.conversion.write(this);
        } }]), t2;
      }();
      function ob(t2, e2, i2) {
        Object.defineProperty(t2, e2, { get: function() {
          return "RGB" === this.__state.space || rb.recalculateRGB(this, e2, i2), this.__state[e2];
        }, set: function(t3) {
          "RGB" !== this.__state.space && (rb.recalculateRGB(this, e2, i2), this.__state.space = "RGB"), this.__state[e2] = t3;
        } });
      }
      function sb(t2, e2) {
        Object.defineProperty(t2, e2, { get: function() {
          return "HSV" === this.__state.space || rb.recalculateHSV(this), this.__state[e2];
        }, set: function(t3) {
          "HSV" !== this.__state.space && (rb.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e2] = t3;
        } });
      }
      rb.recalculateRGB = function(t2, e2, i2) {
        if ("HEX" === t2.__state.space) t2.__state[e2] = Kx.component_from_hex(t2.__state.hex, i2);
        else {
          if ("HSV" !== t2.__state.space) throw new Error("Corrupted color state");
          Xx.extend(t2.__state, Kx.hsv_to_rgb(t2.__state.h, t2.__state.s, t2.__state.v));
        }
      }, rb.recalculateHSV = function(t2) {
        var e2 = Kx.rgb_to_hsv(t2.r, t2.g, t2.b);
        Xx.extend(t2.__state, { s: e2.s, v: e2.v }), Xx.isNaN(e2.h) ? Xx.isUndefined(t2.__state.h) && (t2.__state.h = 0) : t2.__state.h = e2.h;
      }, rb.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], ob(rb.prototype, "r", 2), ob(rb.prototype, "g", 1), ob(rb.prototype, "b", 0), sb(rb.prototype, "h"), sb(rb.prototype, "s"), sb(rb.prototype, "v"), Object.defineProperty(rb.prototype, "a", { get: function() {
        return this.__state.a;
      }, set: function(t2) {
        this.__state.a = t2;
      } }), Object.defineProperty(rb.prototype, "hex", { get: function() {
        return "HEX" !== this.__state.space && (this.__state.hex = Kx.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex;
      }, set: function(t2) {
        this.__state.space = "HEX", this.__state.hex = t2;
      } });
      var ab = function() {
        function t2(e2, i2) {
          $x(this, t2), this.initialValue = e2[i2], this.domElement = document.createElement("div"), this.object = e2, this.property = i2, this.__onChange = void 0, this.__onFinishChange = void 0;
        }
        return tb(t2, [{ key: "onChange", value: function(t3) {
          return this.__onChange = t3, this;
        } }, { key: "onFinishChange", value: function(t3) {
          return this.__onFinishChange = t3, this;
        } }, { key: "setValue", value: function(t3) {
          return this.object[this.property] = t3, this.__onChange && this.__onChange.call(this, t3), this.updateDisplay(), this;
        } }, { key: "getValue", value: function() {
          return this.object[this.property];
        } }, { key: "updateDisplay", value: function() {
          return this;
        } }, { key: "isModified", value: function() {
          return this.initialValue !== this.getValue();
        } }]), t2;
      }(), lb = {};
      Xx.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, function(t2, e2) {
        Xx.each(t2, function(t3) {
          lb[t3] = e2;
        });
      });
      var hb = /(\d+(\.\d+)?)px/;
      function ub(t2) {
        if ("0" === t2 || Xx.isUndefined(t2)) return 0;
        var e2 = t2.match(hb);
        return Xx.isNull(e2) ? 0 : parseFloat(e2[1]);
      }
      var cb = { makeSelectable: function(t2, e2) {
        void 0 !== t2 && void 0 !== t2.style && (t2.onselectstart = e2 ? function() {
          return false;
        } : function() {
        }, t2.style.MozUserSelect = e2 ? "auto" : "none", t2.style.KhtmlUserSelect = e2 ? "auto" : "none", t2.unselectable = e2 ? "on" : "off");
      }, makeFullscreen: function(t2, e2, i2) {
        var n2 = i2, r2 = e2;
        Xx.isUndefined(r2) && (r2 = true), Xx.isUndefined(n2) && (n2 = true), t2.style.position = "absolute", r2 && (t2.style.left = 0, t2.style.right = 0), n2 && (t2.style.top = 0, t2.style.bottom = 0);
      }, fakeEvent: function(t2, e2, i2, n2) {
        var r2 = i2 || {}, o2 = lb[e2];
        if (!o2) throw new Error("Event type " + e2 + " not supported.");
        var s2 = document.createEvent(o2);
        switch (o2) {
          case "MouseEvents":
            var a2 = r2.x || r2.clientX || 0, l2 = r2.y || r2.clientY || 0;
            s2.initMouseEvent(e2, r2.bubbles || false, r2.cancelable || true, window, r2.clickCount || 1, 0, 0, a2, l2, false, false, false, false, 0, null);
            break;
          case "KeyboardEvents":
            var h2 = s2.initKeyboardEvent || s2.initKeyEvent;
            Xx.defaults(r2, { cancelable: true, ctrlKey: false, altKey: false, shiftKey: false, metaKey: false, keyCode: void 0, charCode: void 0 }), h2(e2, r2.bubbles || false, r2.cancelable, window, r2.ctrlKey, r2.altKey, r2.shiftKey, r2.metaKey, r2.keyCode, r2.charCode);
            break;
          default:
            s2.initEvent(e2, r2.bubbles || false, r2.cancelable || true);
        }
        Xx.defaults(s2, n2), t2.dispatchEvent(s2);
      }, bind: function(t2, e2, i2, n2) {
        var r2 = n2 || false;
        return t2.addEventListener ? t2.addEventListener(e2, i2, r2) : t2.attachEvent && t2.attachEvent("on" + e2, i2), cb;
      }, unbind: function(t2, e2, i2, n2) {
        var r2 = n2 || false;
        return t2.removeEventListener ? t2.removeEventListener(e2, i2, r2) : t2.detachEvent && t2.detachEvent("on" + e2, i2), cb;
      }, addClass: function(t2, e2) {
        if (void 0 === t2.className) t2.className = e2;
        else if (t2.className !== e2) {
          var i2 = t2.className.split(/ +/);
          -1 === i2.indexOf(e2) && (i2.push(e2), t2.className = i2.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""));
        }
        return cb;
      }, removeClass: function(t2, e2) {
        if (e2) if (t2.className === e2) t2.removeAttribute("class");
        else {
          var i2 = t2.className.split(/ +/), n2 = i2.indexOf(e2);
          -1 !== n2 && (i2.splice(n2, 1), t2.className = i2.join(" "));
        }
        else t2.className = void 0;
        return cb;
      }, hasClass: function(t2, e2) {
        return new RegExp("(?:^|\\s+)" + e2 + "(?:\\s+|$)").test(t2.className) || false;
      }, getWidth: function(t2) {
        var e2 = getComputedStyle(t2);
        return ub(e2["border-left-width"]) + ub(e2["border-right-width"]) + ub(e2["padding-left"]) + ub(e2["padding-right"]) + ub(e2.width);
      }, getHeight: function(t2) {
        var e2 = getComputedStyle(t2);
        return ub(e2["border-top-width"]) + ub(e2["border-bottom-width"]) + ub(e2["padding-top"]) + ub(e2["padding-bottom"]) + ub(e2.height);
      }, getOffset: function(t2) {
        var e2 = t2, i2 = { left: 0, top: 0 };
        if (e2.offsetParent) do {
          i2.left += e2.offsetLeft, i2.top += e2.offsetTop, e2 = e2.offsetParent;
        } while (e2);
        return i2;
      }, isActive: function(t2) {
        return t2 === document.activeElement && (t2.type || t2.href);
      } }, db = function(t2) {
        function e2(t3, i2) {
          $x(this, e2);
          var n2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), r2 = n2;
          return n2.__prev = n2.getValue(), n2.__checkbox = document.createElement("input"), n2.__checkbox.setAttribute("type", "checkbox"), cb.bind(n2.__checkbox, "change", function() {
            r2.setValue(!r2.__prev);
          }, false), n2.domElement.appendChild(n2.__checkbox), n2.updateDisplay(), n2;
        }
        return ib(e2, t2), tb(e2, [{ key: "setValue", value: function(t3) {
          var i2 = eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "setValue", this).call(this, t3);
          return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i2;
        } }, { key: "updateDisplay", value: function() {
          return true === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = true, this.__prev = true) : (this.__checkbox.checked = false, this.__prev = false), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
        } }]), e2;
      }(ab), pb = function(t2) {
        function e2(t3, i2, n2) {
          $x(this, e2);
          var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), o2 = n2, s2 = r2;
          if (r2.__select = document.createElement("select"), Xx.isArray(o2)) {
            var a2 = {};
            Xx.each(o2, function(t4) {
              a2[t4] = t4;
            }), o2 = a2;
          }
          return Xx.each(o2, function(t4, e3) {
            var i3 = document.createElement("option");
            i3.innerHTML = e3, i3.setAttribute("value", t4), s2.__select.appendChild(i3);
          }), r2.updateDisplay(), cb.bind(r2.__select, "change", function() {
            var t4 = this.options[this.selectedIndex].value;
            s2.setValue(t4);
          }), r2.domElement.appendChild(r2.__select), r2;
        }
        return ib(e2, t2), tb(e2, [{ key: "setValue", value: function(t3) {
          var i2 = eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "setValue", this).call(this, t3);
          return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i2;
        } }, { key: "updateDisplay", value: function() {
          return cb.isActive(this.__select) ? this : (this.__select.value = this.getValue(), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this));
        } }]), e2;
      }(ab), fb = function(t2) {
        function e2(t3, i2) {
          $x(this, e2);
          var n2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), r2 = n2;
          function o2() {
            r2.setValue(r2.__input.value);
          }
          return n2.__input = document.createElement("input"), n2.__input.setAttribute("type", "text"), cb.bind(n2.__input, "keyup", o2), cb.bind(n2.__input, "change", o2), cb.bind(n2.__input, "blur", function() {
            r2.__onFinishChange && r2.__onFinishChange.call(r2, r2.getValue());
          }), cb.bind(n2.__input, "keydown", function(t4) {
            13 === t4.keyCode && this.blur();
          }), n2.updateDisplay(), n2.domElement.appendChild(n2.__input), n2;
        }
        return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
          return cb.isActive(this.__input) || (this.__input.value = this.getValue()), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
        } }]), e2;
      }(ab);
      function mb(t2) {
        var e2 = t2.toString();
        return e2.indexOf(".") > -1 ? e2.length - e2.indexOf(".") - 1 : 0;
      }
      var gb = function(t2) {
        function e2(t3, i2, n2) {
          $x(this, e2);
          var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), o2 = n2 || {};
          return r2.__min = o2.min, r2.__max = o2.max, r2.__step = o2.step, Xx.isUndefined(r2.__step) ? 0 === r2.initialValue ? r2.__impliedStep = 1 : r2.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r2.initialValue)) / Math.LN10)) / 10 : r2.__impliedStep = r2.__step, r2.__precision = mb(r2.__impliedStep), r2;
        }
        return ib(e2, t2), tb(e2, [{ key: "setValue", value: function(t3) {
          var i2 = t3;
          return void 0 !== this.__min && i2 < this.__min ? i2 = this.__min : void 0 !== this.__max && i2 > this.__max && (i2 = this.__max), void 0 !== this.__step && i2 % this.__step != 0 && (i2 = Math.round(i2 / this.__step) * this.__step), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "setValue", this).call(this, i2);
        } }, { key: "min", value: function(t3) {
          return this.__min = t3, this;
        } }, { key: "max", value: function(t3) {
          return this.__max = t3, this;
        } }, { key: "step", value: function(t3) {
          return this.__step = t3, this.__impliedStep = t3, this.__precision = mb(t3), this;
        } }]), e2;
      }(ab);
      var vb = function(t2) {
        function e2(t3, i2, n2) {
          $x(this, e2);
          var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2, n2));
          r2.__truncationSuspended = false;
          var o2 = r2, s2 = void 0;
          function a2() {
            o2.__onFinishChange && o2.__onFinishChange.call(o2, o2.getValue());
          }
          function l2(t4) {
            var e3 = s2 - t4.clientY;
            o2.setValue(o2.getValue() + e3 * o2.__impliedStep), s2 = t4.clientY;
          }
          function h2() {
            cb.unbind(window, "mousemove", l2), cb.unbind(window, "mouseup", h2), a2();
          }
          return r2.__input = document.createElement("input"), r2.__input.setAttribute("type", "text"), cb.bind(r2.__input, "change", function() {
            var t4 = parseFloat(o2.__input.value);
            Xx.isNaN(t4) || o2.setValue(t4);
          }), cb.bind(r2.__input, "blur", function() {
            a2();
          }), cb.bind(r2.__input, "mousedown", function(t4) {
            cb.bind(window, "mousemove", l2), cb.bind(window, "mouseup", h2), s2 = t4.clientY;
          }), cb.bind(r2.__input, "keydown", function(t4) {
            13 === t4.keyCode && (o2.__truncationSuspended = true, this.blur(), o2.__truncationSuspended = false, a2());
          }), r2.updateDisplay(), r2.domElement.appendChild(r2.__input), r2;
        }
        return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
          var t3, i2, n2;
          return this.__input.value = this.__truncationSuspended ? this.getValue() : (t3 = this.getValue(), i2 = this.__precision, n2 = Math.pow(10, i2), Math.round(t3 * n2) / n2), eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
        } }]), e2;
      }(gb);
      function _b(t2, e2, i2, n2, r2) {
        return n2 + (t2 - e2) / (i2 - e2) * (r2 - n2);
      }
      var yb = function(t2) {
        function e2(t3, i2, n2, r2, o2) {
          $x(this, e2);
          var s2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2, { min: n2, max: r2, step: o2 })), a2 = s2;
          function l2(t4) {
            t4.preventDefault();
            var e3 = a2.__background.getBoundingClientRect();
            return a2.setValue(_b(t4.clientX, e3.left, e3.right, a2.__min, a2.__max)), false;
          }
          function h2() {
            cb.unbind(window, "mousemove", l2), cb.unbind(window, "mouseup", h2), a2.__onFinishChange && a2.__onFinishChange.call(a2, a2.getValue());
          }
          function u2(t4) {
            var e3 = t4.touches[0].clientX, i3 = a2.__background.getBoundingClientRect();
            a2.setValue(_b(e3, i3.left, i3.right, a2.__min, a2.__max));
          }
          function c2() {
            cb.unbind(window, "touchmove", u2), cb.unbind(window, "touchend", c2), a2.__onFinishChange && a2.__onFinishChange.call(a2, a2.getValue());
          }
          return s2.__background = document.createElement("div"), s2.__foreground = document.createElement("div"), cb.bind(s2.__background, "mousedown", function(t4) {
            document.activeElement.blur(), cb.bind(window, "mousemove", l2), cb.bind(window, "mouseup", h2), l2(t4);
          }), cb.bind(s2.__background, "touchstart", function(t4) {
            if (1 !== t4.touches.length) return;
            cb.bind(window, "touchmove", u2), cb.bind(window, "touchend", c2), u2(t4);
          }), cb.addClass(s2.__background, "slider"), cb.addClass(s2.__foreground, "slider-fg"), s2.updateDisplay(), s2.__background.appendChild(s2.__foreground), s2.domElement.appendChild(s2.__background), s2;
        }
        return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
          var t3 = (this.getValue() - this.__min) / (this.__max - this.__min);
          return this.__foreground.style.width = 100 * t3 + "%", eb(e2.prototype.__proto__ || Object.getPrototypeOf(e2.prototype), "updateDisplay", this).call(this);
        } }]), e2;
      }(gb), xb = function(t2) {
        function e2(t3, i2, n2) {
          $x(this, e2);
          var r2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2)), o2 = r2;
          return r2.__button = document.createElement("div"), r2.__button.innerHTML = void 0 === n2 ? "Fire" : n2, cb.bind(r2.__button, "click", function(t4) {
            return t4.preventDefault(), o2.fire(), false;
          }), cb.addClass(r2.__button, "button"), r2.domElement.appendChild(r2.__button), r2;
        }
        return ib(e2, t2), tb(e2, [{ key: "fire", value: function() {
          this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue());
        } }]), e2;
      }(ab), bb = function(t2) {
        function e2(t3, i2) {
          $x(this, e2);
          var n2 = nb(this, (e2.__proto__ || Object.getPrototypeOf(e2)).call(this, t3, i2));
          n2.__color = new rb(n2.getValue()), n2.__temp = new rb(0);
          var r2 = n2;
          n2.domElement = document.createElement("div"), cb.makeSelectable(n2.domElement, false), n2.__selector = document.createElement("div"), n2.__selector.className = "selector", n2.__saturation_field = document.createElement("div"), n2.__saturation_field.className = "saturation-field", n2.__field_knob = document.createElement("div"), n2.__field_knob.className = "field-knob", n2.__field_knob_border = "2px solid ", n2.__hue_knob = document.createElement("div"), n2.__hue_knob.className = "hue-knob", n2.__hue_field = document.createElement("div"), n2.__hue_field.className = "hue-field", n2.__input = document.createElement("input"), n2.__input.type = "text", n2.__input_textShadow = "0 1px 1px ", cb.bind(n2.__input, "keydown", function(t4) {
            13 === t4.keyCode && c2.call(this);
          }), cb.bind(n2.__input, "blur", c2), cb.bind(n2.__selector, "mousedown", function() {
            cb.addClass(this, "drag").bind(window, "mouseup", function() {
              cb.removeClass(r2.__selector, "drag");
            });
          }), cb.bind(n2.__selector, "touchstart", function() {
            cb.addClass(this, "drag").bind(window, "touchend", function() {
              cb.removeClass(r2.__selector, "drag");
            });
          });
          var o2, s2 = document.createElement("div");
          function a2(t4) {
            p2(t4), cb.bind(window, "mousemove", p2), cb.bind(window, "touchmove", p2), cb.bind(window, "mouseup", h2), cb.bind(window, "touchend", h2);
          }
          function l2(t4) {
            f2(t4), cb.bind(window, "mousemove", f2), cb.bind(window, "touchmove", f2), cb.bind(window, "mouseup", u2), cb.bind(window, "touchend", u2);
          }
          function h2() {
            cb.unbind(window, "mousemove", p2), cb.unbind(window, "touchmove", p2), cb.unbind(window, "mouseup", h2), cb.unbind(window, "touchend", h2), d2();
          }
          function u2() {
            cb.unbind(window, "mousemove", f2), cb.unbind(window, "touchmove", f2), cb.unbind(window, "mouseup", u2), cb.unbind(window, "touchend", u2), d2();
          }
          function c2() {
            var t4 = Zx(this.value);
            false !== t4 ? (r2.__color.__state = t4, r2.setValue(r2.__color.toOriginal())) : this.value = r2.__color.toString();
          }
          function d2() {
            r2.__onFinishChange && r2.__onFinishChange.call(r2, r2.__color.toOriginal());
          }
          function p2(t4) {
            -1 === t4.type.indexOf("touch") && t4.preventDefault();
            var e3 = r2.__saturation_field.getBoundingClientRect(), i3 = t4.touches && t4.touches[0] || t4, n3 = i3.clientX, o3 = i3.clientY, s3 = (n3 - e3.left) / (e3.right - e3.left), a3 = 1 - (o3 - e3.top) / (e3.bottom - e3.top);
            return a3 > 1 ? a3 = 1 : a3 < 0 && (a3 = 0), s3 > 1 ? s3 = 1 : s3 < 0 && (s3 = 0), r2.__color.v = a3, r2.__color.s = s3, r2.setValue(r2.__color.toOriginal()), false;
          }
          function f2(t4) {
            -1 === t4.type.indexOf("touch") && t4.preventDefault();
            var e3 = r2.__hue_field.getBoundingClientRect(), i3 = 1 - ((t4.touches && t4.touches[0] || t4).clientY - e3.top) / (e3.bottom - e3.top);
            return i3 > 1 ? i3 = 1 : i3 < 0 && (i3 = 0), r2.__color.h = 360 * i3, r2.setValue(r2.__color.toOriginal()), false;
          }
          return Xx.extend(n2.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), Xx.extend(n2.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: n2.__field_knob_border + (n2.__color.v < 0.5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), Xx.extend(n2.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), Xx.extend(n2.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), Xx.extend(s2.style, { width: "100%", height: "100%", background: "none" }), Eb(s2, "top", "rgba(0,0,0,0)", "#000"), Xx.extend(n2.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (o2 = n2.__hue_field).style.background = "", o2.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", o2.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o2.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o2.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", o2.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", Xx.extend(n2.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: n2.__input_textShadow + "rgba(0,0,0,0.7)" }), cb.bind(n2.__saturation_field, "mousedown", a2), cb.bind(n2.__saturation_field, "touchstart", a2), cb.bind(n2.__field_knob, "mousedown", a2), cb.bind(n2.__field_knob, "touchstart", a2), cb.bind(n2.__hue_field, "mousedown", l2), cb.bind(n2.__hue_field, "touchstart", l2), n2.__saturation_field.appendChild(s2), n2.__selector.appendChild(n2.__field_knob), n2.__selector.appendChild(n2.__saturation_field), n2.__selector.appendChild(n2.__hue_field), n2.__hue_field.appendChild(n2.__hue_knob), n2.domElement.appendChild(n2.__input), n2.domElement.appendChild(n2.__selector), n2.updateDisplay(), n2;
        }
        return ib(e2, t2), tb(e2, [{ key: "updateDisplay", value: function() {
          var t3 = Zx(this.getValue());
          if (false !== t3) {
            var e3 = false;
            Xx.each(rb.COMPONENTS, function(i3) {
              if (!Xx.isUndefined(t3[i3]) && !Xx.isUndefined(this.__color.__state[i3]) && t3[i3] !== this.__color.__state[i3]) return e3 = true, {};
            }, this), e3 && Xx.extend(this.__color.__state, t3);
          }
          Xx.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
          var i2 = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0, n2 = 255 - i2;
          Xx.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + i2 + "," + i2 + "," + i2 + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Eb(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), Xx.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + i2 + "," + i2 + "," + i2 + ")", textShadow: this.__input_textShadow + "rgba(" + n2 + "," + n2 + "," + n2 + ",.7)" });
        } }]), e2;
      }(ab), Tb = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
      function Eb(t2, e2, i2, n2) {
        t2.style.background = "", Xx.each(Tb, function(r2) {
          t2.style.cssText += "background: " + r2 + "linear-gradient(" + e2 + ", " + i2 + " 0%, " + n2 + " 100%); ";
        });
      }
      var Sb = function(t2, e2) {
        var i2 = e2 || document, n2 = document.createElement("style");
        n2.type = "text/css", n2.innerHTML = t2;
        var r2 = i2.getElementsByTagName("head")[0];
        try {
          r2.appendChild(n2);
        } catch (t3) {
        }
      }, wb = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`, Ab = function(t2, e2) {
        var i2 = t2[e2];
        return Xx.isArray(arguments[2]) || Xx.isObject(arguments[2]) ? new pb(t2, e2, arguments[2]) : Xx.isNumber(i2) ? Xx.isNumber(arguments[2]) && Xx.isNumber(arguments[3]) ? Xx.isNumber(arguments[4]) ? new yb(t2, e2, arguments[2], arguments[3], arguments[4]) : new yb(t2, e2, arguments[2], arguments[3]) : Xx.isNumber(arguments[4]) ? new vb(t2, e2, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new vb(t2, e2, { min: arguments[2], max: arguments[3] }) : Xx.isString(i2) ? new fb(t2, e2) : Xx.isFunction(i2) ? new xb(t2, e2, "") : Xx.isBoolean(i2) ? new db(t2, e2) : null;
      };
      var Mb = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t2) {
        setTimeout(t2, 1e3 / 60);
      }, Cb = function() {
        function t2() {
          $x(this, t2), this.backgroundElement = document.createElement("div"), Xx.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), cb.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), Xx.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
          var e2 = this;
          cb.bind(this.backgroundElement, "click", function() {
            e2.hide();
          });
        }
        return tb(t2, [{ key: "show", value: function() {
          var t3 = this;
          this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), Xx.defer(function() {
            t3.backgroundElement.style.opacity = 1, t3.domElement.style.opacity = 1, t3.domElement.style.webkitTransform = "scale(1)";
          });
        } }, { key: "hide", value: function() {
          var t3 = this, e2 = function e3() {
            t3.domElement.style.display = "none", t3.backgroundElement.style.display = "none", cb.unbind(t3.domElement, "webkitTransitionEnd", e3), cb.unbind(t3.domElement, "transitionend", e3), cb.unbind(t3.domElement, "oTransitionEnd", e3);
          };
          cb.bind(this.domElement, "webkitTransitionEnd", e2), cb.bind(this.domElement, "transitionend", e2), cb.bind(this.domElement, "oTransitionEnd", e2), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)";
        } }, { key: "layout", value: function() {
          this.domElement.style.left = window.innerWidth / 2 - cb.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - cb.getHeight(this.domElement) / 2 + "px";
        } }]), t2;
      }();
      Sb(function(t2) {
        if (t2 && "undefined" != typeof window) {
          var e2 = document.createElement("style");
          return e2.setAttribute("type", "text/css"), e2.innerHTML = t2, document.head.appendChild(e2), t2;
        }
      }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
      var Rb = function() {
        try {
          return !!window.localStorage;
        } catch (t2) {
          return false;
        }
      }(), Ib = void 0, Pb = true, Ob = void 0, Nb = false, Lb = [], Db = function t2(e2) {
        var i2 = this, n2 = e2 || {};
        this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), cb.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n2 = Xx.defaults(n2, { closeOnTop: false, autoPlace: true, width: t2.DEFAULT_WIDTH }), n2 = Xx.defaults(n2, { resizable: n2.autoPlace, hideable: n2.autoPlace }), Xx.isUndefined(n2.load) ? n2.load = { preset: "Default" } : n2.preset && (n2.load.preset = n2.preset), Xx.isUndefined(n2.parent) && n2.hideable && Lb.push(this), n2.resizable = Xx.isUndefined(n2.parent) && n2.resizable, n2.autoPlace && Xx.isUndefined(n2.scrollable) && (n2.scrollable = true);
        var r2, o2 = Rb && "true" === localStorage.getItem(Hb(this, "isLocal")), s2 = void 0, a2 = void 0;
        if (Object.defineProperties(this, { parent: { get: function() {
          return n2.parent;
        } }, scrollable: { get: function() {
          return n2.scrollable;
        } }, autoPlace: { get: function() {
          return n2.autoPlace;
        } }, closeOnTop: { get: function() {
          return n2.closeOnTop;
        } }, preset: { get: function() {
          return i2.parent ? i2.getRoot().preset : n2.load.preset;
        }, set: function(t3) {
          i2.parent ? i2.getRoot().preset = t3 : n2.load.preset = t3, function(t4) {
            for (var e3 = 0; e3 < t4.__preset_select.length; e3++) t4.__preset_select[e3].value === t4.preset && (t4.__preset_select.selectedIndex = e3);
          }(this), i2.revert();
        } }, width: { get: function() {
          return n2.width;
        }, set: function(t3) {
          n2.width = t3, Wb(i2, t3);
        } }, name: { get: function() {
          return n2.name;
        }, set: function(t3) {
          n2.name = t3, a2 && (a2.innerHTML = n2.name);
        } }, closed: { get: function() {
          return n2.closed;
        }, set: function(e3) {
          n2.closed = e3, n2.closed ? cb.addClass(i2.__ul, t2.CLASS_CLOSED) : cb.removeClass(i2.__ul, t2.CLASS_CLOSED), this.onResize(), i2.__closeButton && (i2.__closeButton.innerHTML = e3 ? t2.TEXT_OPEN : t2.TEXT_CLOSED);
        } }, load: { get: function() {
          return n2.load;
        } }, useLocalStorage: { get: function() {
          return o2;
        }, set: function(t3) {
          Rb && (o2 = t3, t3 ? cb.bind(window, "unload", s2) : cb.unbind(window, "unload", s2), localStorage.setItem(Hb(i2, "isLocal"), t3));
        } } }), Xx.isUndefined(n2.parent)) {
          if (this.closed = n2.closed || false, cb.addClass(this.domElement, t2.CLASS_MAIN), cb.makeSelectable(this.domElement, false), Rb && o2) {
            i2.useLocalStorage = true;
            var l2 = localStorage.getItem(Hb(this, "gui"));
            l2 && (n2.load = JSON.parse(l2));
          }
          this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t2.TEXT_CLOSED, cb.addClass(this.__closeButton, t2.CLASS_CLOSE_BUTTON), n2.closeOnTop ? (cb.addClass(this.__closeButton, t2.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (cb.addClass(this.__closeButton, t2.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), cb.bind(this.__closeButton, "click", function() {
            i2.closed = !i2.closed;
          });
        } else {
          void 0 === n2.closed && (n2.closed = true);
          var h2 = document.createTextNode(n2.name);
          cb.addClass(h2, "controller-name"), a2 = Fb(i2, h2);
          cb.addClass(this.__ul, t2.CLASS_CLOSED), cb.addClass(a2, "title"), cb.bind(a2, "click", function(t3) {
            return t3.preventDefault(), i2.closed = !i2.closed, false;
          }), n2.closed || (this.closed = false);
        }
        n2.autoPlace && (Xx.isUndefined(n2.parent) && (Pb && (Ob = document.createElement("div"), cb.addClass(Ob, "dg"), cb.addClass(Ob, t2.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(Ob), Pb = false), Ob.appendChild(this.domElement), cb.addClass(this.domElement, t2.CLASS_AUTO_PLACE)), this.parent || Wb(i2, n2.width)), this.__resizeHandler = function() {
          i2.onResizeDebounced();
        }, cb.bind(window, "resize", this.__resizeHandler), cb.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), cb.bind(this.__ul, "transitionend", this.__resizeHandler), cb.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n2.resizable && Xb(this), s2 = function() {
          Rb && "true" === localStorage.getItem(Hb(i2, "isLocal")) && localStorage.setItem(Hb(i2, "gui"), JSON.stringify(i2.getSaveObject()));
        }, this.saveToLocalStorageIfPossible = s2, n2.parent || ((r2 = i2.getRoot()).width += 1, Xx.defer(function() {
          r2.width -= 1;
        }));
      };
      function Fb(t2, e2, i2) {
        var n2 = document.createElement("li");
        return e2 && n2.appendChild(e2), i2 ? t2.__ul.insertBefore(n2, i2) : t2.__ul.appendChild(n2), t2.onResize(), n2;
      }
      function Bb(t2) {
        cb.unbind(window, "resize", t2.__resizeHandler), t2.saveToLocalStorageIfPossible && cb.unbind(window, "unload", t2.saveToLocalStorageIfPossible);
      }
      function Ub(t2, e2) {
        var i2 = t2.__preset_select[t2.__preset_select.selectedIndex];
        i2.innerHTML = e2 ? i2.value + "*" : i2.value;
      }
      function kb(t2, e2) {
        var i2 = t2.getRoot(), n2 = i2.__rememberedObjects.indexOf(e2.object);
        if (-1 !== n2) {
          var r2 = i2.__rememberedObjectIndecesToControllers[n2];
          if (void 0 === r2 && (r2 = {}, i2.__rememberedObjectIndecesToControllers[n2] = r2), r2[e2.property] = e2, i2.load && i2.load.remembered) {
            var o2 = i2.load.remembered, s2 = void 0;
            if (o2[t2.preset]) s2 = o2[t2.preset];
            else {
              if (!o2.Default) return;
              s2 = o2.Default;
            }
            if (s2[n2] && void 0 !== s2[n2][e2.property]) {
              var a2 = s2[n2][e2.property];
              e2.initialValue = a2, e2.setValue(a2);
            }
          }
        }
      }
      function Gb(t2, e2, i2, n2) {
        if (void 0 === e2[i2]) throw new Error('Object "' + e2 + '" has no property "' + i2 + '"');
        var r2 = void 0;
        if (n2.color) r2 = new bb(e2, i2);
        else {
          var o2 = [e2, i2].concat(n2.factoryArgs);
          r2 = Ab.apply(t2, o2);
        }
        n2.before instanceof ab && (n2.before = n2.before.__li), kb(t2, r2), cb.addClass(r2.domElement, "c");
        var s2 = document.createElement("span");
        cb.addClass(s2, "property-name"), s2.innerHTML = r2.property;
        var a2 = document.createElement("div");
        a2.appendChild(s2), a2.appendChild(r2.domElement);
        var l2 = Fb(t2, a2, n2.before);
        return cb.addClass(l2, Db.CLASS_CONTROLLER_ROW), r2 instanceof bb ? cb.addClass(l2, "color") : cb.addClass(l2, Qx(r2.getValue())), function(t3, e3, i3) {
          if (i3.__li = e3, i3.__gui = t3, Xx.extend(i3, { options: function(e4) {
            if (arguments.length > 1) {
              var n4 = i3.__li.nextElementSibling;
              return i3.remove(), Gb(t3, i3.object, i3.property, { before: n4, factoryArgs: [Xx.toArray(arguments)] });
            }
            if (Xx.isArray(e4) || Xx.isObject(e4)) {
              var r4 = i3.__li.nextElementSibling;
              return i3.remove(), Gb(t3, i3.object, i3.property, { before: r4, factoryArgs: [e4] });
            }
          }, name: function(t4) {
            return i3.__li.firstElementChild.firstElementChild.innerHTML = t4, i3;
          }, listen: function() {
            return i3.__gui.listen(i3), i3;
          }, remove: function() {
            return i3.__gui.remove(i3), i3;
          } }), i3 instanceof yb) {
            var n3 = new vb(i3.object, i3.property, { min: i3.__min, max: i3.__max, step: i3.__step });
            Xx.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(t4) {
              var e4 = i3[t4], r4 = n3[t4];
              i3[t4] = n3[t4] = function() {
                var t5 = Array.prototype.slice.call(arguments);
                return r4.apply(n3, t5), e4.apply(i3, t5);
              };
            }), cb.addClass(e3, "has-slider"), i3.domElement.insertBefore(n3.domElement, i3.domElement.firstElementChild);
          } else if (i3 instanceof vb) {
            var r3 = function(e4) {
              if (Xx.isNumber(i3.__min) && Xx.isNumber(i3.__max)) {
                var n4 = i3.__li.firstElementChild.firstElementChild.innerHTML, r4 = i3.__gui.__listening.indexOf(i3) > -1;
                i3.remove();
                var o3 = Gb(t3, i3.object, i3.property, { before: i3.__li.nextElementSibling, factoryArgs: [i3.__min, i3.__max, i3.__step] });
                return o3.name(n4), r4 && o3.listen(), o3;
              }
              return e4;
            };
            i3.min = Xx.compose(r3, i3.min), i3.max = Xx.compose(r3, i3.max);
          } else i3 instanceof db ? (cb.bind(e3, "click", function() {
            cb.fakeEvent(i3.__checkbox, "click");
          }), cb.bind(i3.__checkbox, "click", function(t4) {
            t4.stopPropagation();
          })) : i3 instanceof xb ? (cb.bind(e3, "click", function() {
            cb.fakeEvent(i3.__button, "click");
          }), cb.bind(e3, "mouseover", function() {
            cb.addClass(i3.__button, "hover");
          }), cb.bind(e3, "mouseout", function() {
            cb.removeClass(i3.__button, "hover");
          })) : i3 instanceof bb && (cb.addClass(e3, "color"), i3.updateDisplay = Xx.compose(function(t4) {
            return e3.style.borderLeftColor = i3.__color.toString(), t4;
          }, i3.updateDisplay), i3.updateDisplay());
          i3.setValue = Xx.compose(function(e4) {
            return t3.getRoot().__preset_select && i3.isModified() && Ub(t3.getRoot(), true), e4;
          }, i3.setValue);
        }(t2, l2, r2), t2.__controllers.push(r2), r2;
      }
      function Hb(t2, e2) {
        return document.location.href + "." + e2;
      }
      function jb(t2, e2, i2) {
        var n2 = document.createElement("option");
        n2.innerHTML = e2, n2.value = e2, t2.__preset_select.appendChild(n2), i2 && (t2.__preset_select.selectedIndex = t2.__preset_select.length - 1);
      }
      function zb(t2, e2) {
        e2.style.display = t2.useLocalStorage ? "block" : "none";
      }
      function Vb(t2) {
        var e2 = t2.__save_row = document.createElement("li");
        cb.addClass(t2.domElement, "has-save"), t2.__ul.insertBefore(e2, t2.__ul.firstChild), cb.addClass(e2, "save-row");
        var i2 = document.createElement("span");
        i2.innerHTML = "&nbsp;", cb.addClass(i2, "button gears");
        var n2 = document.createElement("span");
        n2.innerHTML = "Save", cb.addClass(n2, "button"), cb.addClass(n2, "save");
        var r2 = document.createElement("span");
        r2.innerHTML = "New", cb.addClass(r2, "button"), cb.addClass(r2, "save-as");
        var o2 = document.createElement("span");
        o2.innerHTML = "Revert", cb.addClass(o2, "button"), cb.addClass(o2, "revert");
        var s2 = t2.__preset_select = document.createElement("select");
        if (t2.load && t2.load.remembered ? Xx.each(t2.load.remembered, function(e3, i3) {
          jb(t2, i3, i3 === t2.preset);
        }) : jb(t2, "Default", false), cb.bind(s2, "change", function() {
          for (var e3 = 0; e3 < t2.__preset_select.length; e3++) t2.__preset_select[e3].innerHTML = t2.__preset_select[e3].value;
          t2.preset = this.value;
        }), e2.appendChild(s2), e2.appendChild(i2), e2.appendChild(n2), e2.appendChild(r2), e2.appendChild(o2), Rb) {
          var a2 = document.getElementById("dg-local-explain"), l2 = document.getElementById("dg-local-storage");
          document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(Hb(0, "isLocal")) && l2.setAttribute("checked", "checked"), zb(t2, a2), cb.bind(l2, "change", function() {
            t2.useLocalStorage = !t2.useLocalStorage, zb(t2, a2);
          });
        }
        var h2 = document.getElementById("dg-new-constructor");
        cb.bind(h2, "keydown", function(t3) {
          !t3.metaKey || 67 !== t3.which && 67 !== t3.keyCode || Ib.hide();
        }), cb.bind(i2, "click", function() {
          h2.innerHTML = JSON.stringify(t2.getSaveObject(), void 0, 2), Ib.show(), h2.focus(), h2.select();
        }), cb.bind(n2, "click", function() {
          t2.save();
        }), cb.bind(r2, "click", function() {
          var e3 = prompt("Enter a new preset name.");
          e3 && t2.saveAs(e3);
        }), cb.bind(o2, "click", function() {
          t2.revert();
        });
      }
      function Xb(t2) {
        var e2 = void 0;
        function i2(i3) {
          return i3.preventDefault(), t2.width += e2 - i3.clientX, t2.onResize(), e2 = i3.clientX, false;
        }
        function n2() {
          cb.removeClass(t2.__closeButton, Db.CLASS_DRAG), cb.unbind(window, "mousemove", i2), cb.unbind(window, "mouseup", n2);
        }
        function r2(r3) {
          return r3.preventDefault(), e2 = r3.clientX, cb.addClass(t2.__closeButton, Db.CLASS_DRAG), cb.bind(window, "mousemove", i2), cb.bind(window, "mouseup", n2), false;
        }
        t2.__resize_handle = document.createElement("div"), Xx.extend(t2.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), cb.bind(t2.__resize_handle, "mousedown", r2), cb.bind(t2.__closeButton, "mousedown", r2), t2.domElement.insertBefore(t2.__resize_handle, t2.domElement.firstElementChild);
      }
      function Wb(t2, e2) {
        t2.domElement.style.width = e2 + "px", t2.__save_row && t2.autoPlace && (t2.__save_row.style.width = e2 + "px"), t2.__closeButton && (t2.__closeButton.style.width = e2 + "px");
      }
      function Yb(t2, e2) {
        var i2 = {};
        return Xx.each(t2.__rememberedObjects, function(n2, r2) {
          var o2 = {}, s2 = t2.__rememberedObjectIndecesToControllers[r2];
          Xx.each(s2, function(t3, i3) {
            o2[i3] = e2 ? t3.initialValue : t3.getValue();
          }), i2[r2] = o2;
        }), i2;
      }
      Db.toggleHide = function() {
        Nb = !Nb, Xx.each(Lb, function(t2) {
          t2.domElement.style.display = Nb ? "none" : "";
        });
      }, Db.CLASS_AUTO_PLACE = "a", Db.CLASS_AUTO_PLACE_CONTAINER = "ac", Db.CLASS_MAIN = "main", Db.CLASS_CONTROLLER_ROW = "cr", Db.CLASS_TOO_TALL = "taller-than-window", Db.CLASS_CLOSED = "closed", Db.CLASS_CLOSE_BUTTON = "close-button", Db.CLASS_CLOSE_TOP = "close-top", Db.CLASS_CLOSE_BOTTOM = "close-bottom", Db.CLASS_DRAG = "drag", Db.DEFAULT_WIDTH = 245, Db.TEXT_CLOSED = "Close Controls", Db.TEXT_OPEN = "Open Controls", Db._keydownHandler = function(t2) {
        "text" === document.activeElement.type || 72 !== t2.which && 72 !== t2.keyCode || Db.toggleHide();
      }, cb.bind(window, "keydown", Db._keydownHandler, false), Xx.extend(Db.prototype, { add: function(t2, e2) {
        return Gb(this, t2, e2, { factoryArgs: Array.prototype.slice.call(arguments, 2) });
      }, addColor: function(t2, e2) {
        return Gb(this, t2, e2, { color: true });
      }, remove: function(t2) {
        this.__ul.removeChild(t2.__li), this.__controllers.splice(this.__controllers.indexOf(t2), 1);
        var e2 = this;
        Xx.defer(function() {
          e2.onResize();
        });
      }, destroy: function() {
        if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
        this.autoPlace && Ob.removeChild(this.domElement);
        var t2 = this;
        Xx.each(this.__folders, function(e2) {
          t2.removeFolder(e2);
        }), cb.unbind(window, "keydown", Db._keydownHandler, false), Bb(this);
      }, addFolder: function(t2) {
        if (void 0 !== this.__folders[t2]) throw new Error('You already have a folder in this GUI by the name "' + t2 + '"');
        var e2 = { name: t2, parent: this };
        e2.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t2] && (e2.closed = this.load.folders[t2].closed, e2.load = this.load.folders[t2]);
        var i2 = new Db(e2);
        this.__folders[t2] = i2;
        var n2 = Fb(this, i2.domElement);
        return cb.addClass(n2, "folder"), i2;
      }, removeFolder: function(t2) {
        this.__ul.removeChild(t2.domElement.parentElement), delete this.__folders[t2.name], this.load && this.load.folders && this.load.folders[t2.name] && delete this.load.folders[t2.name], Bb(t2);
        var e2 = this;
        Xx.each(t2.__folders, function(e3) {
          t2.removeFolder(e3);
        }), Xx.defer(function() {
          e2.onResize();
        });
      }, open: function() {
        this.closed = false;
      }, close: function() {
        this.closed = true;
      }, hide: function() {
        this.domElement.style.display = "none";
      }, show: function() {
        this.domElement.style.display = "";
      }, onResize: function() {
        var t2 = this.getRoot();
        if (t2.scrollable) {
          var e2 = cb.getOffset(t2.__ul).top, i2 = 0;
          Xx.each(t2.__ul.childNodes, function(e3) {
            t2.autoPlace && e3 === t2.__save_row || (i2 += cb.getHeight(e3));
          }), window.innerHeight - e2 - 20 < i2 ? (cb.addClass(t2.domElement, Db.CLASS_TOO_TALL), t2.__ul.style.height = window.innerHeight - e2 - 20 + "px") : (cb.removeClass(t2.domElement, Db.CLASS_TOO_TALL), t2.__ul.style.height = "auto");
        }
        t2.__resize_handle && Xx.defer(function() {
          t2.__resize_handle.style.height = t2.__ul.offsetHeight + "px";
        }), t2.__closeButton && (t2.__closeButton.style.width = t2.width + "px");
      }, onResizeDebounced: Xx.debounce(function() {
        this.onResize();
      }, 50), remember: function() {
        if (Xx.isUndefined(Ib) && ((Ib = new Cb()).domElement.innerHTML = wb), this.parent) throw new Error("You can only call remember on a top level GUI.");
        var t2 = this;
        Xx.each(Array.prototype.slice.call(arguments), function(e2) {
          0 === t2.__rememberedObjects.length && Vb(t2), -1 === t2.__rememberedObjects.indexOf(e2) && t2.__rememberedObjects.push(e2);
        }), this.autoPlace && Wb(this, this.width);
      }, getRoot: function() {
        for (var t2 = this; t2.parent; ) t2 = t2.parent;
        return t2;
      }, getSaveObject: function() {
        var t2 = this.load;
        return t2.closed = this.closed, this.__rememberedObjects.length > 0 && (t2.preset = this.preset, t2.remembered || (t2.remembered = {}), t2.remembered[this.preset] = Yb(this)), t2.folders = {}, Xx.each(this.__folders, function(e2, i2) {
          t2.folders[i2] = e2.getSaveObject();
        }), t2;
      }, save: function() {
        this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = Yb(this), Ub(this, false), this.saveToLocalStorageIfPossible();
      }, saveAs: function(t2) {
        this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = Yb(this, true)), this.load.remembered[t2] = Yb(this), this.preset = t2, jb(this, t2, true), this.saveToLocalStorageIfPossible();
      }, revert: function(t2) {
        Xx.each(this.__controllers, function(e2) {
          this.getRoot().load.remembered ? kb(t2 || this.getRoot(), e2) : e2.setValue(e2.initialValue), e2.__onFinishChange && e2.__onFinishChange.call(e2, e2.getValue());
        }, this), Xx.each(this.__folders, function(t3) {
          t3.revert(t3);
        }), t2 || Ub(this.getRoot(), false);
      }, listen: function(t2) {
        var e2 = 0 === this.__listening.length;
        this.__listening.push(t2), e2 && function t3(e3) {
          0 !== e3.length && Mb.call(window, function() {
            t3(e3);
          });
          Xx.each(e3, function(t4) {
            t4.updateDisplay();
          });
        }(this.__listening);
      }, updateDisplay: function() {
        Xx.each(this.__controllers, function(t2) {
          t2.updateDisplay();
        }), Xx.each(this.__folders, function(t2) {
          t2.updateDisplay();
        });
      } });
      var qb = Db, Zb = function() {
        function t2(t3) {
          this.player = t3;
        }
        return Object.defineProperty(t2.prototype, "frameRate", { get: function() {
          return this.player.fps.value;
        }, set: function(t3) {
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "drawFrames", { get: function() {
          return this.player.runtime.fps;
        }, set: function(t3) {
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "drawCall", { get: function() {
          return this.player.runtime.drawCall;
        }, set: function(t3) {
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "resolution", { get: function() {
          return this.player.config.resolution;
        }, set: function(t3) {
          this.player.updateConfig({ resolution: t3 });
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "size", { get: function() {
          var t3, e2;
          return (null === (t3 = this.player.view) || void 0 === t3 ? void 0 : t3.width) + "*" + (null === (e2 = this.player.view) || void 0 === e2 ? void 0 : e2.height);
        }, set: function(t3) {
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "minFPS", { get: function() {
          return this.player.config.minFPS;
        }, set: function(t3) {
          this.player.updateConfig({ minFPS: t3, maxFPS: this.player.config.maxFPS });
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "maxFPS", { get: function() {
          return this.player.config.maxFPS;
        }, set: function(t3) {
          this.player.updateConfig({ maxFPS: t3, minFPS: this.player.config.minFPS });
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "autoResolution", { get: function() {
          return this.player.config.autoResolution;
        }, set: function(t3) {
          this.player.updateConfig({ autoResolution: t3 });
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "autoFPS", { get: function() {
          return this.player.config.autoFPS;
        }, set: function(t3) {
          this.player.updateConfig({ autoFPS: t3 });
        }, enumerable: false, configurable: true }), Object.defineProperty(t2.prototype, "backgroundColor", { get: function() {
          return this.player.config.transactionBgColor;
        }, set: function(t3) {
          this.player.updateConfig({ transactionBgColor: t3 });
        }, enumerable: false, configurable: true }), t2;
      }(), Jb = function() {
        function t2(t3, e2) {
          var i2;
          this.config = new Zb(t3), this.anchor = e2, i2 = this.createControllerGUI(), this.gui = i2[0], this.controller = i2[1], this.createStats();
        }
        return t2.prototype.createStats = function() {
          var t3 = this;
          this.stateId = setInterval(function() {
            t3.controller.frameRate.updateDisplay(), t3.controller.size.updateDisplay(), t3.controller.minFPS.updateDisplay(), t3.controller.drawFrames.updateDisplay(), t3.controller.maxFPS.updateDisplay(), t3.controller.resolution.updateDisplay(), t3.controller.autoFps.updateDisplay(), t3.controller.autoResolution.updateDisplay(), t3.controller.drawCall.updateDisplay();
          }, 16);
        }, t2.prototype.createControllerGUI = function() {
          var t3 = new qb({ autoPlace: true, closed: true });
          t3.domElement.style.opacity = ".6", t3.domElement.style.transformOrigin = "100% 0", t3.domElement.style.transform = "scale(1)", this.anchor.appendChild(t3.domElement), t3.domElement.style.position = "absolute", t3.domElement.style.right = "0", t3.domElement.style.top = "0", t3.domElement.style.zIndex = "2";
          var e2 = { frameRate: t3.add(this.config, "frameRate"), drawFrames: t3.add(this.config, "drawFrames"), drawCall: t3.add(this.config, "drawCall"), size: t3.add(this.config, "size"), minFPS: t3.add(this.config, "minFPS", 0, 60), maxFPS: t3.add(this.config, "maxFPS", 0, 60), resolution: t3.add(this.config, "resolution", 0.5, 8, 0.5), autoResolution: t3.add(this.config, "autoResolution"), autoFps: t3.add(this.config, "autoFPS"), transactionBgColor: t3.addColor(this.config, "backgroundColor") };
          return [t3, e2];
        }, t2.prototype.destroy = function() {
          try {
            window.clearInterval(this.stateId), this.anchor.removeChild(this.gui.domElement), this.gui.destroy();
          } catch (t3) {
          }
        }, t2;
      }(), Kb = function() {
        function t2(t3) {
          var e2 = this;
          this.tasks = [], this.isDestroy = false, this.isScheduling = false, this.schedule = function() {
            e2.isScheduling = true;
            var t4 = e2.tasks.shift();
            t4 && !e2.isDestroy && e2.fn(t4).then(function() {
              e2.tasks.length > 0 ? window.requestAnimationFrame(e2.schedule) : e2.isScheduling = false;
            });
          }, this.fn = t3;
        }
        return t2.prototype.destroy = function() {
          this.isDestroy = true;
        }, t2.prototype.addTask = function(t3) {
          this.tasks.push(t3), this.isScheduling || this.schedule();
        }, t2;
      }(), Qb = function() {
        function t2(t3) {
          this.autoUnlock = /* @__PURE__ */ Object.create(null), this.locks = /* @__PURE__ */ Object.create(null), this.available = false, this.available = t3;
        }
        return t2.prototype.addLock = function(t3, e2) {
          var i2 = this;
          this.available && (this.locks[t3] = e2, this.autoUnlock[t3] = window.setTimeout(function() {
            delete i2.locks[t3];
          }, 3e3));
        }, t2.prototype.unlock = function(t3, e2) {
          this.available && e2 && this.locks[t3] && this.locks[t3] === e2 && (window.clearTimeout(this.autoUnlock[t3]), delete this.locks[t3]);
        }, t2.prototype.isLocked = function(t3) {
          return !!this.available && !!this.locks[t3];
        }, t2;
      }(), $b = function() {
        function t2() {
          var t3 = this;
          this.tasks = [], this.isDestroy = false, this.isScheduling = false, this.schedule = function() {
            t3.isScheduling = true;
            var e2 = t3.tasks.shift();
            e2 && !t3.isDestroy && (e2.status = "running", e2.fn.apply(null).then(function() {
              t3.tasks.length > 0 ? window.requestAnimationFrame(t3.schedule) : t3.isScheduling = false;
            }).catch(function() {
              t3.tasks.length > 0 ? window.requestAnimationFrame(t3.schedule) : t3.isScheduling = false;
            }));
          };
        }
        return t2.prototype.getRunningTask = function() {
          return this.tasks[0] && "running" === this.tasks[0].status ? this.tasks[0] : null;
        }, t2.prototype.addTask = function(t3, e2) {
          var i2 = { type: t3, status: "wait", fn: e2 }, n2 = this.getRunningTask();
          n2 && t3 === n2.type || (this.tasks = this.tasks.filter(function(e3) {
            return e3.type !== t3;
          }), this.tasks.push(i2), this.isScheduling || this.schedule());
        }, t2.prototype.destroy = function() {
          this.isDestroy = true;
        }, t2;
      }(), tT = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, eT = function(t2, e2) {
        var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
          if (1 & r2[0]) throw r2[1];
          return r2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (i2) throw new TypeError("Generator is already executing.");
              for (; s2; ) try {
                if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done) return r2;
                switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                  case 0:
                  case 1:
                    r2 = o4;
                    break;
                  case 4:
                    return s2.label++, { value: o4[1], done: false };
                  case 5:
                    s2.label++, n2 = o4[1], o4 = [0];
                    continue;
                  case 7:
                    o4 = s2.ops.pop(), s2.trys.pop();
                    continue;
                  default:
                    if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                      s2 = 0;
                      continue;
                    }
                    if (3 === o4[0] && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                      s2.label = o4[1];
                      break;
                    }
                    if (6 === o4[0] && s2.label < r2[1]) {
                      s2.label = r2[1], r2 = o4;
                      break;
                    }
                    if (r2 && s2.label < r2[2]) {
                      s2.label = r2[2], s2.ops.push(o4);
                      break;
                    }
                    r2[2] && s2.ops.pop(), s2.trys.pop();
                    continue;
                }
                o4 = e2.call(t2, s2);
              } catch (t3) {
                o4 = [6, t3], n2 = 0;
              } finally {
                i2 = r2 = 0;
              }
              if (5 & o4[0]) throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, iT = function() {
        function t2() {
          var t3 = this;
          this.logList = [], this.checkTimer = null, this.retryTimes = 0, this.enable = false, this.uploadLoggerGlobalEvent = function(e2) {
            "@slide/_upload_log_" === e2.data.type && t3.start();
          }, this.config = { checkTime: 3e3, buffer: 300 }, window.addEventListener("message", this.uploadLoggerGlobalEvent), this.start();
        }
        return t2.prototype.start = function() {
          return tT(this, void 0, void 0, function() {
            var t3 = this;
            return eT(this, function(e2) {
              return clearInterval(this.checkTimer), this.checkTimer = setInterval(function() {
                return tT(t3, void 0, void 0, function() {
                  return eT(this, function(t4) {
                    switch (t4.label) {
                      case 0:
                        return [4, this.uploadLog()];
                      case 1:
                        return t4.sent(), [2];
                    }
                  });
                });
              }, this.config.checkTime), [2];
            });
          });
        }, t2.prototype.pause = function() {
          clearInterval(this.checkTimer);
        }, t2.prototype.addLog = function(t3, e2, i2, n2) {
          this.logList.push({ level: e2, taskId: i2, message: t3, randomId: n2 });
        }, t2.prototype.destroy = function() {
          clearInterval(this.checkTimer), window.removeEventListener("message", this.uploadLoggerGlobalEvent);
        }, t2.prototype.uploadLog = function(t3) {
          return void 0 === t3 && (t3 = false), tT(this, void 0, void 0, function() {
            var e2, i2, n2, r2 = this;
            return eT(this, function(o2) {
              switch (o2.label) {
                case 0:
                  if (!(this.logList.length >= this.config.buffer || t3)) return [2];
                  e2 = this.logList.splice(0), i2 = function() {
                    r2.logList = e2.concat(r2.logList), r2.retryTimes > 3 && r2.pause(), r2.retryTimes += 1;
                  }, o2.label = 1;
                case 1:
                  return o2.trys.push([1, 3, , 4]), [4, fetch("https://netless-ppt-plugin-dev.cn-hangzhou.log.aliyuncs.com/logstores/netless-ppt-plugin-dev/track", { method: "POST", headers: { "x-log-apiversion": "0.6.0", "Content-Type": "application/json", Accept: "*/*" }, body: JSON.stringify({ __topic__: "netless-ppt-plugin-dev", __source__: "netless-ppt-plugin-dev", __logs__: e2 }) })];
                case 2:
                  return o2.sent().ok ? this.retryTimes = 0 : i2(), [3, 4];
                case 3:
                  return n2 = o2.sent(), console.warn(n2), i2(), [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        }, t2.prototype.setEnable = function(t3) {
          this.enable !== t3 && (t3 ? this.start() : this.pause());
        }, t2;
      }(), nT = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, rT = function(t2, e2) {
        var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
          if (1 & r2[0]) throw r2[1];
          return r2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (i2) throw new TypeError("Generator is already executing.");
              for (; s2; ) try {
                if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done) return r2;
                switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                  case 0:
                  case 1:
                    r2 = o4;
                    break;
                  case 4:
                    return s2.label++, { value: o4[1], done: false };
                  case 5:
                    s2.label++, n2 = o4[1], o4 = [0];
                    continue;
                  case 7:
                    o4 = s2.ops.pop(), s2.trys.pop();
                    continue;
                  default:
                    if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                      s2 = 0;
                      continue;
                    }
                    if (3 === o4[0] && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                      s2.label = o4[1];
                      break;
                    }
                    if (6 === o4[0] && s2.label < r2[1]) {
                      s2.label = r2[1], r2 = o4;
                      break;
                    }
                    if (r2 && s2.label < r2[2]) {
                      s2.label = r2[2], s2.ops.push(o4);
                      break;
                    }
                    r2[2] && s2.ops.pop(), s2.trys.pop();
                    continue;
                }
                o4 = e2.call(t2, s2);
              } catch (t3) {
                o4 = [6, t3], n2 = 0;
              } finally {
                i2 = r2 = 0;
              }
              if (5 & o4[0]) throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      };
      function oT(t2, e2, i2, n2) {
        return nT(this, void 0, void 0, function() {
          var r2, o2, s2, a2;
          return rT(this, function(l2) {
            switch (l2.label) {
              case 0:
                return r2 = document.createElement("div"), (o2 = new _T({ anchor: r2, renderOptions: { minFPS: 1, maxFPS: 1, resolution: 1, maxResolutionLevel: i2 }, mode: "local", interactive: false, useLocalCache: true })).setResource(t2, e2), [4, o2.getSlideCountAsync()];
              case 1:
                s2 = l2.sent(), a2 = 1, l2.label = 2;
              case 2:
                return a2 <= s2 ? [4, o2.player.stagePool.preload(a2, true)] : [3, 5];
              case 3:
                l2.sent(), n2(Math.round(a2 / s2 * 100) / 100), l2.label = 4;
              case 4:
                return a2++, [3, 2];
              case 5:
                return o2.destroy(), [2];
            }
          });
        });
      }
      var sT = /* @__PURE__ */ function() {
        var t2 = function(e2, i2) {
          return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, e3) {
            t3.__proto__ = e3;
          } || function(t3, e3) {
            for (var i3 in e3) Object.prototype.hasOwnProperty.call(e3, i3) && (t3[i3] = e3[i3]);
          })(e2, i2);
        };
        return function(e2, i2) {
          if ("function" != typeof i2 && null !== i2) throw new TypeError("Class extends value " + String(i2) + " is not a constructor or null");
          function n2() {
            this.constructor = e2;
          }
          t2(e2, i2), e2.prototype = null === i2 ? Object.create(i2) : (n2.prototype = i2.prototype, new n2());
        };
      }(), aT = function() {
        return (aT = Object.assign || function(t2) {
          for (var e2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) for (var r2 in e2 = arguments[i2]) Object.prototype.hasOwnProperty.call(e2, r2) && (t2[r2] = e2[r2]);
          return t2;
        }).apply(this, arguments);
      }, lT = function(t2, e2, i2, n2) {
        var r2, o2 = arguments.length, s2 = o2 < 3 ? e2 : null === n2 ? n2 = Object.getOwnPropertyDescriptor(e2, i2) : n2;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s2 = Reflect.decorate(t2, e2, i2, n2);
        else for (var a2 = t2.length - 1; a2 >= 0; a2--) (r2 = t2[a2]) && (s2 = (o2 < 3 ? r2(s2) : o2 > 3 ? r2(e2, i2, s2) : r2(e2, i2)) || s2);
        return o2 > 3 && s2 && Object.defineProperty(e2, i2, s2), s2;
      }, hT = function(t2, e2, i2, n2) {
        return new (i2 || (i2 = Promise))(function(r2, o2) {
          function s2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function a2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              o2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? r2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2(function(t4) {
              t4(e3);
            })).then(s2, a2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      }, uT = function(t2, e2) {
        var i2, n2, r2, o2, s2 = { label: 0, sent: function() {
          if (1 & r2[0]) throw r2[1];
          return r2[1];
        }, trys: [], ops: [] };
        return o2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (o2[Symbol.iterator] = function() {
          return this;
        }), o2;
        function a2(o3) {
          return function(a3) {
            return function(o4) {
              if (i2) throw new TypeError("Generator is already executing.");
              for (; s2; ) try {
                if (i2 = 1, n2 && (r2 = 2 & o4[0] ? n2.return : o4[0] ? n2.throw || ((r2 = n2.return) && r2.call(n2), 0) : n2.next) && !(r2 = r2.call(n2, o4[1])).done) return r2;
                switch (n2 = 0, r2 && (o4 = [2 & o4[0], r2.value]), o4[0]) {
                  case 0:
                  case 1:
                    r2 = o4;
                    break;
                  case 4:
                    return s2.label++, { value: o4[1], done: false };
                  case 5:
                    s2.label++, n2 = o4[1], o4 = [0];
                    continue;
                  case 7:
                    o4 = s2.ops.pop(), s2.trys.pop();
                    continue;
                  default:
                    if (!(r2 = s2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== o4[0] && 2 !== o4[0])) {
                      s2 = 0;
                      continue;
                    }
                    if (3 === o4[0] && (!r2 || o4[1] > r2[0] && o4[1] < r2[3])) {
                      s2.label = o4[1];
                      break;
                    }
                    if (6 === o4[0] && s2.label < r2[1]) {
                      s2.label = r2[1], r2 = o4;
                      break;
                    }
                    if (r2 && s2.label < r2[2]) {
                      s2.label = r2[2], s2.ops.push(o4);
                      break;
                    }
                    r2[2] && s2.ops.pop(), s2.trys.pop();
                    continue;
                }
                o4 = e2.call(t2, s2);
              } catch (t3) {
                o4 = [6, t3], n2 = 0;
              } finally {
                i2 = r2 = 0;
              }
              if (5 & o4[0]) throw o4[1];
              return { value: o4[0] ? o4[1] : void 0, done: true };
            }([o3, a3]);
          };
        }
      }, cT = window.ResizeObserver || Bx, dT = function(t2) {
        return new Promise(function(e2) {
          return setTimeout(e2, t2);
        });
      };
      function pT(t2, e2) {
        return hT(this, void 0, void 0, function() {
          var i2;
          return uT(this, function(n2) {
            switch (n2.label) {
              case 0:
                i2 = Date.now(), n2.label = 1;
              case 1:
                return !t2() && Date.now() - i2 < e2 ? [4, dT(50)] : [3, 3];
              case 2:
                return n2.sent(), i2 = Date.now(), [3, 1];
              case 3:
                return [2];
            }
          });
        });
      }
      var fT = { syncDispatch: "syncDispatch", syncReceive: "syncReceive", syncEventLag: "syncEventLag", renderStart: "renderStart", renderEnd: "renderEnd", renderError: "renderError", slideChange: "slideChange", mainSeqStepStart: "mainSeqStepStart", mainSeqStepEnd: "mainSeqStepEnd", animateStart: "animateStart", animateEnd: "animateEnd", stateChange: "stateChange", slideStepEnd: "slideEnd", slideStepStart: "slideStart" }, mT = { taskId: "", url: "", currentSlideIndex: -1, mainSeqStep: -1, mainSeqState: null, mediaState: /* @__PURE__ */ Object.create(null), interactiveSeqState: /* @__PURE__ */ Object.create(null) }, gT = "";
      try {
        gT = "1.4.2-alpha.0";
      } catch (t2) {
        gT = "dev";
      }
      var vT = null;
      try {
        (vT = o.createInstance({ name: "__slide_local_log__", driver: o.INDEXEDDB, version: 1 })).ready(function(t2) {
        }).catch(function(t2) {
        });
      } catch (t2) {
      }
      var _T = function(t2) {
        function e2(i3) {
          var n3 = t2.call(this) || this;
          return n3.iosResetCache = [], n3.needClearCacheImage = false, n3.version = gT, n3.__slideState = Qy()(mT), n3.userInputTime = 0, n3.isSyncingSlideState = false, n3.frozenTaskManager = new $b(), n3.randomId = r(), n3.resize = false, n3.isAnimating = false, n3.renderingTaskManager = new Hx(), n3.isLoading = false, n3.interactive = true, n3.renderingIndex = 0, n3.frameWidth = 1, n3.frameHeight = 1, n3.frame = document.createElement("div"), n3.canvasContainer = document.createElement("div"), n3.medianController = document.createElement("div"), n3.frameResizeObserver = new cT(function() {
            return n3.frameResizeHandler();
          }), n3.timestamp = function() {
            return Date.now();
          }, n3.mode = "local", n3.enableGlobalClick = false, n3.lastEmitedState = null, n3.playerController = null, n3.isInitResized = false, n3.cacheImage = document.createElement("img"), n3.isTouchStart = false, n3.touchStartId = void 0, n3.taskId = "", n3.volumeAdjuster = new Gy(), n3.designWidth = 0, n3.designHeight = 0, n3._slideCount = 0, n3._dispatchIncrId = 0, n3._receiveIncrId = 0, n3._updateVolumeByStaticAdjuster = function(t3) {
            n3.volumeAdjuster.volume = t3;
          }, n3.recoverHandler = function(t3) {
            if ("@slide/_recover_" === t3.data.type && t3.data.slideId === n3.randomId) {
              var e3 = t3.data, i4 = e3.recoverBy, r2 = e3.payload;
              if (!r2) return;
              "renderOtherPage" === i4 && r2.slideIndex ? n3.doRenderSlide(r2.slideIndex).catch(function(t4) {
                n3.logger.error(t4, n3.taskId);
              }) : "reloadCurrentPage" === i4 && n3.doRenderSlide(n3.renderingIndex).catch(function(t4) {
                n3.logger.error(t4, n3.taskId);
              });
            }
          }, n3.userInputHandle = function() {
            n3.userInputTime = Date.now();
          }, n3.handleViewClick = function() {
            setTimeout(function() {
              var t3 = Date.now();
              Math.abs(t3 - n3.userInputTime) > 500 && n3.enableGlobalClick && n3.nextStep();
            });
          }, n3.handleViewTouchStart = function() {
            window.clearTimeout(n3.touchStartId), n3.isTouchStart = true, n3.touchStartId = setTimeout(function() {
              n3.isTouchStart = false;
            }, 350);
          }, n3.handleViewTouchEnd = function() {
            n3.isTouchStart && (n3.isTouchStart = false, n3.handleViewClick());
          }, n3.handleSlideRef = function() {
            console.log(n3), window.__slide = n3;
          }, n3.receiveSyncHandler = function(t3) {
            return hT(n3, void 0, void 0, function() {
              var e3, i4, n4, r2, o2, s2 = this;
              return uT(this, function(a2) {
                switch (a2.label) {
                  case 0:
                    return Vm()(t3.incrId) && (t3.incrId && t3.incrId - this._receiveIncrId != 1 && this.emit(fT.syncEventLag), this._receiveIncrId = t3.incrId || 0), this.logger.info("sync receive " + JSON.stringify(t3), this.taskId), "nextStep" !== t3.type ? [3, 1] : (this.mainSeqStep !== t3.next - 1 && this.mainSeqStep + 1 !== this.mainSeqLength && this.player ? (this.setMainSeqStep(t3.next, "start"), this.player.nextTick(function() {
                      s2.doNextStep(true, t3.clientId || "");
                    })) : this.doNextStep(true, t3.clientId || ""), [3, 6]);
                  case 1:
                    return "prevStep" !== t3.type ? [3, 2] : (0 === this.mainSeqStep && "idle" === this.mainSeqState || this.mainSeqStep === t3.next + 1 || this.mainSeqStep + 1 === this.mainSeqLength ? this.doPrevStep(true) : (this.setMainSeqStep(t3.next + 1, "start"), null === (e3 = this.player) || void 0 === e3 || e3.nextTick(function() {
                      s2.doPrevStep(true);
                    })), [3, 6]);
                  case 2:
                    return "interactiveAnim" !== t3.type ? [3, 3] : (this.player ? this.player.applyInteractiveAction(t3.action) : this.__slideState.interactiveSeqState[t3.seqId] ? this.__slideState.interactiveSeqState[t3.seqId].step += 1 : this.__slideState.interactiveSeqState[t3.seqId] = { step: 0, state: "end" }, [3, 6]);
                  case 3:
                    return "renderSlide" !== t3.type ? [3, 5] : [4, this.doRenderSlide(t3.index, t3.isForward)];
                  case 4:
                    return a2.sent(), [3, 6];
                  case 5:
                    "mediaPlay" === t3.type ? (null === (i4 = this.player) || void 0 === i4 || i4.setMediaState(t3.id, true), this.__slideState.mediaState[t3.id] = t3.state) : "mediaPause" === t3.type ? (null === (n4 = this.player) || void 0 === n4 || n4.setMediaState(t3.id, false), this.__slideState.mediaState[t3.id] = t3.state) : "mediaSeek" === t3.type ? (null === (r2 = this.player) || void 0 === r2 || r2.setMediaCurrentTime(t3.id, t3.time), this.__slideState.mediaState[t3.id] = t3.state) : "mediaFullscreen" === t3.type && (t3.targetId && this.__slideState.mediaState[t3.targetId] ? this.__slideState.mediaState[t3.targetId].fullscreen = t3.state : this.__slideState.mediaState[t3.targetId] = { fullscreen: t3.state, type: "pause", time: 0 }, null === (o2 = this.player) || void 0 === o2 || o2.syncFullscreenVideoState({ targetId: t3.targetId, state: t3.state, slideIndex: t3.slideIndex })), a2.label = 6;
                  case 6:
                    return [2];
                }
              });
            });
          }, n3.handlePrevSlide = function(t3) {
            return void 0 === t3 && (t3 = false), hT(n3, void 0, void 0, function() {
              var e3, i4;
              return uT(this, function(n4) {
                return this.player ? ((e3 = this.player.prevSlideIndex) >= 1 && ((null === (i4 = this.config.navigatorDelegate) || void 0 === i4 ? void 0 : i4.gotoPage) ? this.config.navigatorDelegate.gotoPage(e3) : t3 ? this.doRenderSlide(e3, false) : this.renderSlide(e3, false)), [2]) : [2];
              });
            });
          }, n3.handleNextSlide = function(t3) {
            return void 0 === t3 && (t3 = false), hT(n3, void 0, void 0, function() {
              var e3, i4;
              return uT(this, function(n4) {
                return this.player ? ((e3 = this.player.nextSlideIndex) <= this.slideCount && ((null === (i4 = this.config.navigatorDelegate) || void 0 === i4 ? void 0 : i4.gotoPage) ? this.config.navigatorDelegate.gotoPage(e3) : t3 ? this.doRenderSlide(e3, true) : this.renderSlide(e3, true)), [2]) : [2];
              });
            });
          }, n3.handleGotoSlide = function(t3) {
            if (t3 <= n3.slideCount && t3 >= 1) {
              var e3 = n3.slideState.currentSlideIndex <= t3;
              n3.renderSlide(t3, e3);
            } else -1 === t3 && n3.renderSlide(n3.slideCount, true);
          }, e2.instances.push(n3), n3.config = n3.initSlideConfig(i3), n3.tracker = function(t3) {
            i3.whiteTracker && i3.whiteTracker.commit({ name: t3.name, reason: t3.reason, result: t3.result, payload: aT(aT({}, t3.payload), { slideId: n3.randomId, taskId: n3.taskId }) }, { slideVersion: n3.version || "" });
          }, e2.trackLogger.setEnable(!!n3.config.enableTracking), n3.logger = { info: function(t3, i4) {
            var r2;
            e2.appendLogString("INFO - " + (/* @__PURE__ */ new Date()).toISOString() + " - {" + n3.randomId + "}[" + i4 + "] " + t3 + "\n"), e2.trackLogger.addLog(t3, "info", i4, n3.randomId);
            var o2 = null === (r2 = n3.config.logger) || void 0 === r2 ? void 0 : r2.info;
            o2 && o2("[" + i4 + "] " + t3);
          }, warn: function(t3, i4) {
            var r2;
            e2.appendLogString("WARN - " + (/* @__PURE__ */ new Date()).toISOString() + " - {" + n3.randomId + "}[" + i4 + "] " + t3 + "\n"), e2.trackLogger.addLog(t3, "warn", i4, n3.randomId);
            var o2 = null === (r2 = n3.config.logger) || void 0 === r2 ? void 0 : r2.warn;
            o2 && o2("[" + i4 + "] " + t3);
          }, error: function(t3, i4) {
            var r2;
            e2.appendLogString("ERROR - " + (/* @__PURE__ */ new Date()).toISOString() + " - {" + n3.randomId + "}[" + i4 + "] " + t3 + "\n"), e2.trackLogger.addLog(t3, "error", i4, n3.randomId);
            var o2 = null === (r2 = n3.config.logger) || void 0 === r2 ? void 0 : r2.error;
            o2 && o2("[" + i4 + "] " + t3);
          } }, n3.logger.info("new slide with clientId: " + n3.config.clientId + ", version: " + n3.version, n3.taskId), n3.tracker({ name: "initSlide", result: "", reason: "", payload: { taskId: n3.taskId } }), n3.anchor = n3.config.anchor, n3.syncQueue = new Kb(n3.receiveSyncHandler), n3.lock = new Qb("interactive" === n3.mode), n3.cacheImage.style.position = "absolute", n3.cacheImage.style.zIndex = "100", n3.setMedianControllerAttribute(), n3.canvasContainer.style.position = "relative", n3.canvasContainer.style.fontSize = "0", n3.canvasContainer.appendChild(n3.medianController), n3.frame.appendChild(n3.canvasContainer), n3.frameResizeObserver.observe(n3.frame), n3.on(fT.syncReceive, function(t3) {
            n3.lock.unlock(t3.type, t3.uuid), n3.syncQueue.addTask(t3);
          }), n3.renderingTaskManager.eventHub.on("task-error", function(t3) {
            var e3 = t3.error, i4 = t3.task, r2 = Tm.transform(e3);
            r2.errorType === gm.RuntimeWarn ? n3.logger.warn(r2.message, n3.taskId) : n3.logger.error(r2.message, n3.taskId), n3.isLoading = false, n3.reportError(r2, i4.slideIndex);
          }), window.addEventListener("__slide_ref__", n3.handleSlideRef), n3.resizeView = Jy()(n3.resizeView.bind(n3), 50), n3.player = n3.initPlayer(n3.config), n3.config.controller && n3.createController(), n3.player.view && n3.canvasContainer.appendChild(n3.player.view), n3.handleViewClick = Jy()(n3.handleViewClick, 300), n3.player.errorChannel.on("error", function(t3, e3) {
            var i4 = Tm.transform(t3);
            i4.errorType === gm.RuntimeWarn ? n3.logger.warn(i4.message, n3.taskId) : n3.logger.error(i4.message, n3.taskId), n3.isLoading = false, n3.reportError(t3, e3), n3.tracker({ name: "slideError", reason: i4.errorMsg, result: "", payload: { code: i4.errorType } });
          }), window.addEventListener("message", n3.recoverHandler), e2.volumeAdjuster.on("update", n3._updateVolumeByStaticAdjuster), n3.volumeAdjuster.volume = e2.volumeAdjuster.volume, n3;
        }
        var i2, n2;
        return sT(e2, t2), e2.flushLog = function(t3) {
          return void 0 === t3 && (t3 = false), hT(this, void 0, void 0, function() {
            return uT(this, function(i3) {
              switch (i3.label) {
                case 0:
                  if (!(e2._tempLog.length > 131072 || t3 && e2._tempLog.length > 0)) return [3, 5];
                  i3.label = 1;
                case 1:
                  return i3.trys.push([1, 3, , 4]), [4, null == vT ? void 0 : vT.setItem("run_time_log_" + e2._tempLogIndex, e2._tempLog)];
                case 2:
                  return i3.sent(), [3, 4];
                case 3:
                  return i3.sent(), [3, 4];
                case 4:
                  e2._tempLog = "", e2._tempLogIndex += 1, i3.label = 5;
                case 5:
                  return [2];
              }
            });
          });
        }, e2.stopRemoteLog = function() {
          e2.remoteLogAddress = null;
        }, e2.startRemoteLog = function(t3) {
          return hT(this, void 0, void 0, function() {
            var i3, n3, r2, o2, s2;
            return uT(this, function(a2) {
              switch (a2.label) {
                case 0:
                  return e2.remoteLogAddress = t3, [4, e2.flushLog(true)];
                case 1:
                  if (a2.sent(), !vT) return [3, 13];
                  i3 = [], a2.label = 2;
                case 2:
                  return a2.trys.push([2, 4, , 5]), [4, vT.keys()];
                case 3:
                  return i3 = (a2.sent() || []).sort(function(t4, e3) {
                    return parseInt(t4.replace("run_time_log_", "")) - parseInt(e3.replace("run_time_log_", ""));
                  }), [3, 5];
                case 4:
                  return a2.sent(), [3, 5];
                case 5:
                  n3 = 0, r2 = i3, a2.label = 6;
                case 6:
                  if (!(n3 < r2.length)) return [3, 13];
                  o2 = r2[n3], o2.replace("run_time_log_", ""), s2 = "", a2.label = 7;
                case 7:
                  return a2.trys.push([7, 9, , 10]), [4, vT.getItem(o2)];
                case 8:
                  return s2 = a2.sent() || "", [3, 10];
                case 9:
                  return a2.sent(), [3, 10];
                case 10:
                  return [4, fetch(e2.remoteLogAddress + "/logs", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ log: s2 }) })];
                case 11:
                  a2.sent(), a2.label = 12;
                case 12:
                  return n3++, [3, 6];
                case 13:
                  return [2];
              }
            });
          });
        }, e2.appendLogString = function(t3) {
          e2._tempLog += t3, e2.remoteLogAddress && fetch(e2.remoteLogAddress + "/logs", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ log: t3 }) }).catch(function() {
          });
        }, Object.defineProperty(e2.prototype, "dispatchIncrId", { get: function() {
          return this._dispatchIncrId++;
        }, enumerable: false, configurable: true }), e2.prototype.reportError = function(t3, i3) {
          this.emit(fT.renderError, { error: t3, index: i3 }), window.postMessage({ type: "@slide/_error_", errorType: t3.errorType, errorMsg: t3.errorMsg, slideId: this.randomId, slideIndex: i3, customMessage: "@slide/_error_" }, "*"), e2.trackLogger.uploadLog(true);
        }, e2.prototype.initSlideConfig = function(t3) {
          return t3.timestamp && (this.timestamp = t3.timestamp), t3.rtcAudio && (Vy.RtcAudioClazz = t3.rtcAudio), this.mode = t3.mode, this.anchor = t3.anchor, this.anchor.appendChild(this.frame), this.enableGlobalClick = !$a()(t3.enableGlobalClick) && t3.enableGlobalClick, this.resize = t3.resize || false, this.interactive = t3.interactive, this.frame.style.cssText = t3.fixedFrameSize ? "width:" + t3.fixedFrameSize.width + "px;height:" + t3.fixedFrameSize.height + "px;" : "width:100%;height:100%", this.frame.style.cssText += "display:flex;justify-content:center;align-items:center;visibility:hidden;position:relative;z-index:1;", t3.fixedFrameSize && (this.frameWidth = t3.fixedFrameSize.width, this.frameHeight = t3.fixedFrameSize.height), t3;
        }, e2.prototype.initPlayer = function(t3) {
          var e3, i3, n3, r2 = this, o2 = new Vy({ mode: this.mode, useLocalCache: !!$a()(this.config.useLocalCache) || this.config.useLocalCache, logger: this.logger, resourceTimeout: $a()(this.config.resourceTimeout) ? 15e3 : this.config.resourceTimeout, loadDelegate: this.config.loaderDelegate, volumeAdjuster: this.volumeAdjuster, urlInterrupter: this.config.urlInterrupter, tracker: this.tracker }, t3.renderOptions);
          return o2.setInteractive(this.interactive), o2.updateConfig(t3.renderOptions || {}), o2.on(zy.renderStart, function(t4) {
            r2.isLoading = true, r2.emit(fT.renderStart, t4), window.postMessage({ type: "@slide/_render_start_", taskId: r2.taskId, index: t4 }, "*");
          }), o2.on(zy.renderEnd, function(t4) {
            r2.isLoading = false, r2.player && (r2.designHeight = r2.player.designHeight, r2.designWidth = r2.player.designWidth, r2.cacheImage.style.width = r2.player.designWidth + "px", r2.cacheImage.style.height = r2.player.designHeight + "px", r2._slideCount = r2.player.slideCount), r2.emit(fT.renderEnd, t4), window.postMessage({ type: "@slide/_render_end_", taskId: r2.taskId, index: t4 }, "*");
          }), o2.on(zy.slideChange, function(t4) {
            r2.__slideState.currentSlideIndex = t4, r2.emitStateChange(), r2.emit(fT.slideChange, t4);
          }), o2.on(zy.mainSeqStateChange, function(t4) {
            r2.__slideState.mainSeqState = t4, r2.emitStateChange();
          }), o2.on(zy.mainSeqStepChange, function(t4) {
            r2.__slideState.mainSeqStep = t4, r2.emitStateChange();
          }), o2.on(zy.interactiveSeqStateChange, function(t4) {
            var e4 = t4.id, i4 = t4.state;
            r2.__slideState.interactiveSeqState[e4] = i4, r2.emitStateChange();
          }), o2.on(zy.animateStart, function() {
            true !== r2.isAnimating && (r2.isAnimating = true, r2.emit(fT.animateStart));
          }), o2.on(zy.animateEnd, function() {
            false !== r2.isAnimating && (r2.isAnimating = false, r2.emit(fT.animateEnd));
          }), o2.on(zy.interactiveSeqAction, function(t4) {
            var e4 = t4.action, i4 = t4.seqId;
            r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "interactiveAnim", action: e4, seqId: i4 }), r2.emitStateChange();
          }), o2.on(zy.mainSeqStepStart, function(t4) {
            r2.emit(fT.mainSeqStepStart, t4);
          }), o2.on(zy.mainSeqStepEnd, function(t4) {
            r2.emit(fT.mainSeqStepEnd, t4);
          }), o2.on(zy.mediaPlay, function(t4) {
            var e4, i4 = null !== (e4 = r2.__slideState.mediaState[t4.id]) && void 0 !== e4 ? e4 : {};
            i4.type = "play", i4.time = r2.timestamp() - 1e3 * t4.time, r2.__slideState.mediaState[t4.id] = i4, t4._stateOnly ? "interactive" === r2.config.mode && r2.receiveSyncHandler({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPlay", id: t4.id, state: i4 }).catch(function(t5) {
              r2.logger.error(null == t5 ? void 0 : t5.message, r2.taskId);
            }) : r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPlay", id: t4.id, state: i4 }), r2.emitStateChange();
          }), o2.on(zy.mediaStop, function(t4) {
            delete r2.__slideState.mediaState[t4.id], r2.emitStateChange();
          }), o2.on(zy.mediaPause, function(t4) {
            var e4, i4 = null !== (e4 = r2.__slideState.mediaState[t4.id]) && void 0 !== e4 ? e4 : {};
            i4.type = "pause", i4.time = t4.time, r2.__slideState.mediaState[t4.id] = i4, t4._stateOnly ? "interactive" === r2.config.mode && r2.receiveSyncHandler({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPause", id: t4.id, state: i4 }).catch(function(t5) {
              r2.logger.error(null == t5 ? void 0 : t5.message, r2.taskId);
            }) : r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaPause", id: t4.id, state: i4 }), r2.emitStateChange();
          }), o2.on(zy.mediaSeek, function(t4) {
            var e4, i4 = null !== (e4 = r2.__slideState.mediaState[t4.id]) && void 0 !== e4 ? e4 : {};
            t4.isPlaying ? (i4.type = "play", i4.time = r2.timestamp() - 1e3 * t4.time) : (i4.type = "pause", i4.time = t4.time), r2.__slideState.mediaState[t4.id] = i4, r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaSeek", id: t4.id, time: t4.time, state: i4 }), r2.emitStateChange();
          }), o2.on(zy.requestPrevSlide, function(t4) {
            r2.handlePrevSlide(t4);
          }), o2.on(zy.requestNextSlide, function(t4) {
            r2.handleNextSlide(t4);
          }), o2.on(zy.requestGotoSlide, function(t4) {
            var e4;
            (null === (e4 = r2.config.navigatorDelegate) || void 0 === e4 ? void 0 : e4.gotoPage) ? r2.config.navigatorDelegate.gotoPage(t4) : r2.handleGotoSlide(t4);
          }), o2.on(zy.requestOpenUrl, function(t4) {
            var e4;
            console.log(r2.config.navigatorDelegate), (null === (e4 = r2.config.navigatorDelegate) || void 0 === e4 ? void 0 : e4.openUrl) && r2.config.navigatorDelegate.openUrl(t4);
          }), o2.on(zy.fullscreenChange, function(t4) {
            var e4, i4 = t4.targetId, n4 = t4.state;
            r2.emitSyncDispatch({ slideIndex: r2.__slideState.currentSlideIndex, type: "mediaFullscreen", targetId: i4, state: n4 });
            var o3 = null !== (e4 = r2.__slideState.mediaState[i4]) && void 0 !== e4 ? e4 : {};
            o3.fullscreen = n4, r2.__slideState.mediaState[i4] = o3, r2.emitStateChange();
          }), o2.on(zy.changeLocalFullscreenState, function(t4) {
            t4.slideIndex === r2.__slideState.currentSlideIndex ? (t4.targetId && r2.__slideState.mediaState[t4.targetId] && (r2.__slideState.mediaState[t4.targetId].fullscreen = t4.status), r2.emitStateChange()) : r2.logger.info("event slideIndex: " + t4.slideIndex + ", current slideIndex: " + r2.__slideState.currentSlideIndex, r2.taskId);
          }), null === (e3 = o2.view) || void 0 === e3 || e3.addEventListener("touchend", this.handleViewTouchEnd), null === (i3 = o2.view) || void 0 === i3 || i3.addEventListener("touchstart", this.handleViewTouchStart), null === (n3 = o2.view) || void 0 === n3 || n3.addEventListener("click", this.handleViewClick), o2.on(zy.userInput, this.userInputHandle), o2;
        }, e2.prototype.createController = function() {
          this.player && (this.playerController = new Jb(this.player, this.frame));
        }, e2.prototype.setMedianControllerAttribute = function() {
          this.medianController.className = "median-container", this.medianController.style.position = "absolute", this.medianController.style.left = "0", this.medianController.style.top = "0", this.medianController.style.zIndex = "2", this.medianController.style.fontSize = "16px";
        }, e2.prototype.frameResizeHandler = function() {
          if (!this.config.fixedFrameSize) {
            var t3 = this.frame.getBoundingClientRect(), e3 = t3.width, i3 = t3.height;
            this.frameWidth = e3, this.frameHeight = i3, this.resizeView();
          }
        }, e2.prototype.updateFixedFrameSize = function(t3, e3, i3) {
          this.config.fixedFrameSize && (this.frameWidth = t3, this.frameHeight = e3, this.frame.style.width = t3 + "px", this.frame.style.height = e3 + "px", this.resizeView(i3));
        }, e2.prototype.resizeView = function(t3) {
          var e3, i3, n3 = this, r2 = this.width, o2 = this.height;
          if (r2 > 0 && o2 > 0) {
            var s2 = this.frameWidth / r2, a2 = s2 * o2;
            a2 > this.frameHeight && (s2 *= this.frameHeight / a2), null === (e3 = this.player) || void 0 === e3 || e3.scaleView(s2, this.resize, t3), this.cacheImage.style.transform = "scale(" + s2 + ")", this.medianController.style.transform = "scale(" + s2 + ")", this.medianController.setAttribute("data-scale", s2.toString()), this.isInitResized || (this.isInitResized = true, null === (i3 = this.player) || void 0 === i3 || i3.clock.setTimeout(function() {
              n3.frame.style.visibility = "visible";
            }, 32));
          }
        }, e2.prototype.setSlideState = function(t3) {
          var e3, i3, n3;
          return hT(this, void 0, void 0, function() {
            var r2, o2 = this;
            return uT(this, function(s2) {
              switch (s2.label) {
                case 0:
                  return this.isSyncingSlideState = true, this.logger.info("stateChange receive " + JSON.stringify(t3), this.taskId), t3.taskId && t3.taskId !== this.__slideState.taskId && (this.__slideState.taskId = t3.taskId, null === (e3 = this.player) || void 0 === e3 || e3.setResourceData(t3.taskId, this.__slideState.url)), t3.url && t3.url !== this.__slideState.url && (this.__slideState.url = t3.url, null === (i3 = this.player) || void 0 === i3 || i3.setResourceData(this.__slideState.taskId, t3.url)), Number.isInteger(t3.currentSlideIndex) && t3.currentSlideIndex !== this.__slideState.currentSlideIndex ? (this.__slideState.currentSlideIndex = t3.currentSlideIndex, [4, this.doRenderSlide(t3.currentSlideIndex)]) : [3, 2];
                case 1:
                  s2.sent(), s2.label = 2;
                case 2:
                  return [4, null === (n3 = this.player) || void 0 === n3 ? void 0 : n3.clock.waitUntil(function() {
                    var e4, i4;
                    return (null === (e4 = o2.player) || void 0 === e4 ? void 0 : e4.currentIndex) === t3.currentSlideIndex && (null === (i4 = o2.player) || void 0 === i4 ? void 0 : i4.currentStage);
                  }, 3e3)];
                case 3:
                  return s2.sent(), r2 = false, Number.isInteger(t3.mainSeqStep) && t3.mainSeqStep !== this.__slideState.mainSeqStep && (r2 = true, this.__slideState.mainSeqStep = t3.mainSeqStep), t3.mainSeqState && t3.mainSeqState !== this.__slideState.mainSeqState && (r2 = true, this.__slideState.mainSeqState = t3.mainSeqState), r2 && this.setMainSeqStep(this.__slideState.mainSeqStep, "idle" === this.__slideState.mainSeqState ? "start" : "end"), t3.interactiveSeqState && (this.initInteractiveSeq(t3), this.__slideState.interactiveSeqState = t3.interactiveSeqState), [4, dT(1500)];
                case 4:
                  return s2.sent(), t3.mediaState && (this.initMedia(t3), this.__slideState.mediaState = t3.mediaState), this.isSyncingSlideState = false, [2];
              }
            });
          });
        }, e2.prototype.initInteractiveSeq = function(t3) {
          var e3;
          for (var i3 in t3.interactiveSeqState) {
            var n3 = t3.interactiveSeqState[i3];
            null === (e3 = this.player) || void 0 === e3 || e3.setInteractiveSeqState(i3, n3.step, "idle" === n3.state ? "start" : "end");
          }
        }, e2.prototype.initMedia = function(t3) {
          var e3, i3, n3;
          for (var r2 in t3.mediaState) {
            var o2 = t3.mediaState[r2], s2 = this.__slideState.mediaState[r2];
            if (null === (e3 = this.player) || void 0 === e3 || e3.syncFullscreenVideoState({ targetId: r2, state: !!o2.fullscreen, slideIndex: this.slideState.currentSlideIndex }), !s2 || o2.type !== s2.type || o2.time !== s2.time) if ("play" === o2.type) {
              var a2 = (this.timestamp() - o2.time) / 1e3;
              null === (i3 = this.player) || void 0 === i3 || i3.setMediaState(r2, true, a2);
            } else null === (n3 = this.player) || void 0 === n3 || n3.setMediaState(r2, false, o2.time);
          }
        }, Object.defineProperty(e2.prototype, "slideCount", { get: function() {
          return this._slideCount;
        }, enumerable: false, configurable: true }), e2.prototype.getSizeAsync = function() {
          return hT(this, void 0, void 0, function() {
            var t3;
            return uT(this, function(e3) {
              switch (e3.label) {
                case 0:
                  if (this.width > 0 && this.height > 0) return [2, [this.width, this.height]];
                  e3.label = 1;
                case 1:
                  return e3.trys.push([1, 4, , 5]), [4, fetch(this.__slideState.url + "/" + this.__slideState.taskId + "/jsonOutput/slide-1.json")];
                case 2:
                  return [4, e3.sent().json()];
                case 3:
                  return [2, [(t3 = e3.sent()).width, t3.height]];
                case 4:
                  return e3.sent(), [2, [0, 0]];
                case 5:
                  return [2];
              }
            });
          });
        }, e2.prototype.getSlideCountAsync = function() {
          return hT(this, void 0, void 0, function() {
            return uT(this, function(t3) {
              switch (t3.label) {
                case 0:
                  if (this._slideCount > 0) return [2, this._slideCount];
                  t3.label = 1;
                case 1:
                  return t3.trys.push([1, 4, , 5]), [4, fetch(this.__slideState.url + "/" + this.__slideState.taskId + "/jsonOutput/slide-1.json")];
                case 2:
                  return [4, t3.sent().json()];
                case 3:
                  return [2, t3.sent().slideCount];
                case 4:
                  return t3.sent(), [2, 0];
                case 5:
                  return [2];
              }
            });
          });
        }, Object.defineProperty(e2.prototype, "slideState", { get: function() {
          return this.__slideState.mainSeqState = this.mainSeqState, this.__slideState.mainSeqStep = this.mainSeqStep, JSON.parse(JSON.stringify(this.__slideState));
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mainSeqLength", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.mainSeqLength()) || 0;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mainSeqStep", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.mainSeqStep()) || 0;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "mainSeqState", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.mainSeqState()) || null;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "renderOptions", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.config) || null;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "drawCall", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.runtime.drawCall) || 0;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "renderFps", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.runtime.fps) || 0;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "runtimeFps", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.fps.value) || 0;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "view", { get: function() {
          var t3;
          return (null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.view) || null;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "width", { get: function() {
          return this.designWidth;
        }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "height", { get: function() {
          return this.designHeight;
        }, enumerable: false, configurable: true }), e2.prototype.updateRenderOption = function(t3) {
          this.player && (this.player.updateConfig(t3), this.renderOptions && (this.config.renderOptions = this.renderOptions));
        }, e2.prototype.setResource = function(t3, e3) {
          var i3;
          this.taskId = t3, null === (i3 = this.player) || void 0 === i3 || i3.setResourceData(t3, e3), this.__slideState.taskId = t3, this.__slideState.url = e3, this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "setResource", taskId: t3, url: e3 });
        }, e2.prototype._renderSlide = function(t3) {
          var e3;
          return hT(this, void 0, void 0, function() {
            var i3 = this;
            return uT(this, function(n3) {
              switch (n3.label) {
                case 0:
                  return this.renderingIndex = t3, this.player && t3 === this.player.currentIndex ? [2] : ((Vy.platform.isIOS() || Vy.platform.isAndroid()) && this.iosResetCache.indexOf(t3) < 0 && this.iosResetCache.push(t3), [4, null === (e3 = this.player) || void 0 === e3 ? void 0 : e3.renderSlide(t3)]);
                case 1:
                  return n3.sent(), this.__slideState.currentSlideIndex = t3, this.resizeView(), this.__slideState.interactiveSeqState = {}, this.__slideState.mediaState = {}, this.emitStateChange(), setTimeout(function() {
                    var t4, e4;
                    if ("hidden" === (null === (e4 = null === (t4 = i3.player) || void 0 === t4 ? void 0 : t4.view) || void 0 === e4 ? void 0 : e4.style.visibility) && (i3.player.view.style.visibility = "visible"), "hidden" === i3.frame.style.visibility && (i3.frame.style.visibility = "visible"), i3.needClearCacheImage) try {
                      i3.frame.removeChild(i3.cacheImage);
                    } catch (t5) {
                      i3.logger.error("removeChild error Slide.ts:1553", i3.taskId);
                    }
                  }, 100), [2];
              }
            });
          });
        }, e2.prototype.renderSlide = function(t3, e3) {
          if (void 0 === e3 && (e3 = true), this.player) {
            var i3 = Number(t3);
            (i3 !== this.player.currentIndex || this.renderingTaskManager.hasStartTask()) && (i3 > this.slideCount && this.slideCount > 0 || this.poseRenderSlide(i3, e3));
          }
        }, e2.prototype.needCreateNewPlayer = function() {
          var t3 = Vy.platform.isLowGpuMemory() ? 15 : 30;
          return (Vy.platform.isIOS() || Vy.platform.isAndroid()) && this.iosResetCache.length > t3;
        }, e2.prototype.poseRenderSlide = function(t3, e3) {
          "interactive" === this.mode ? this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "renderSlide", index: t3, isForward: e3 }) : "sync" === this.mode ? (this.doRenderSlide(t3, e3), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "renderSlide", index: t3, isForward: e3 })) : this.doRenderSlide(t3, e3);
        }, e2.prototype.doRenderSlide = function(t3, e3) {
          var i3, n3, r2, o2 = this;
          if (void 0 === e3 && (e3 = true), !this.player) return Promise.resolve();
          if (this.needCreateNewPlayer() && (this.iosResetCache = [], this.iosNewPlayer = this.initPlayer(this.config), this.iosNewPlayer.setResourceData(this.__slideState.taskId, this.__slideState.url)), this.iosNewPlayer) {
            var s2 = this.player.getSnapshot();
            this.cacheImage.src = s2, this.frame.appendChild(this.cacheImage), this.player.destroy(), null === (i3 = this.playerController) || void 0 === i3 || i3.destroy(), this.player = this.iosNewPlayer, this.iosNewPlayer = void 0, (null === (n3 = this.config) || void 0 === n3 ? void 0 : n3.controller) && this.createController(), this.needClearCacheImage = true, (null === (r2 = null == this ? void 0 : this.player) || void 0 === r2 ? void 0 : r2.view) && (this.player.view.style.visibility = "hidden", this.canvasContainer.appendChild(this.player.view));
          }
          var a2 = Math.random().toString(32).substr(2);
          return this.player.isForward = e3, this.renderingTaskManager.addTask(function() {
            return o2._renderSlide(t3);
          }, t3, a2), new Promise(function(t4) {
            o2.renderingTaskManager.eventHub.once("task-end-" + a2, t4);
          });
        }, e2.prototype.getSnapshot = function() {
          var t3, e3;
          return null !== (e3 = null === (t3 = this.player) || void 0 === t3 ? void 0 : t3.getSnapshot()) && void 0 !== e3 ? e3 : null;
        }, e2.prototype.nextStep = function() {
          !this.isLoading && this.player && this.interactive ? (this.hasNextStep() || this.emit(fT.slideStepEnd), this.player.mainSeqHasNextStep() ? "interactive" === this.mode ? this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "nextStep", next: this.player.mainSeqStep() + 1 }) : "sync" === this.mode ? (this.doNextStep(false, ""), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "nextStep", next: this.player.mainSeqStep() })) : this.doNextStep(false, "") : this.handleNextSlide()) : this.logger.info("prevent nextStep. isLoading: " + this.isLoading + ", player: " + !!this.player + ", interactive: " + this.interactive, this.taskId);
        }, e2.prototype.doNextStep = function(t3, e3) {
          if (this.player) {
            var i3 = !this.config.clientId || e3 === this.config.clientId;
            this.player.nextStep(t3, i3);
            var n3 = this.player.mainSeqStep();
            this.__slideState.mainSeqStep = n3, this.emitStateChange();
          }
        }, e2.prototype.prevStep = function() {
          !this.isLoading && this.player && this.interactive ? (this.hasPrevStep() || this.emit(fT.slideStepStart), this.player.mainSeqHasPrevStep() ? "interactive" === this.mode ? this.emitSyncDispatch({ type: "prevStep", slideIndex: this.__slideState.currentSlideIndex, next: this.player.mainSeqStep() - 1 }) : "sync" === this.mode ? (this.doPrevStep(), this.emitSyncDispatch({ slideIndex: this.__slideState.currentSlideIndex, type: "prevStep", next: this.player.mainSeqStep() })) : this.doPrevStep() : this.handlePrevSlide()) : this.logger.info("prevent nextStep. isLoading: " + this.isLoading + ", player: " + this.player + ", interactive: " + this.interactive, this.taskId);
        }, e2.prototype.doPrevStep = function(t3) {
          if (void 0 === t3 && (t3 = false), this.player) {
            this.player.prevStep(t3);
            var e3 = this.player.mainSeqStep();
            this.__slideState.mainSeqStep = e3, this.emitStateChange();
          }
        }, e2.prototype.isSlideStateReady = function(t3) {
          return t3.taskId.length > 0 && t3.url.length > 0 && t3.currentSlideIndex > 0;
        }, e2.prototype.emitStateChange = function() {
          if ("local" !== this.mode && !this.isSyncingSlideState) {
            var t3 = this.slideState;
            !qy()(this.lastEmitedState, t3) && this.isSlideStateReady(t3) && (this.lastEmitedState = t3, this.emit(fT.stateChange, t3), this.logger.info("stateChange dispatch " + JSON.stringify(this.slideState), this.taskId));
          }
        }, e2.prototype.emitSyncDispatch = function(t3) {
          if (!this.lock.isLocked(t3.type)) {
            var e3 = Math.random().toString(32).substr(2);
            this.lock.addLock(t3.type, e3);
            var i3 = aT(aT({}, t3), { uuid: e3, clientId: this.config.clientId });
            "sync" === this.config.mode && (i3.incrId = this.dispatchIncrId), this.emit(fT.syncDispatch, i3), this.logger.info("sync dispatch " + JSON.stringify(i3), this.taskId);
          }
        }, e2.prototype.setMainSeqStep = function(t3, e3) {
          var i3;
          null === (i3 = this.player) || void 0 === i3 || i3.setMainSeqStep(t3, e3);
        }, e2.prototype.setInteractive = function(t3) {
          var e3;
          this.interactive = t3, null === (e3 = this.player) || void 0 === e3 || e3.setInteractive(t3);
        }, e2.prototype.pause = function() {
          var t3;
          null === (t3 = this.player) || void 0 === t3 || t3.pause();
        }, e2.prototype.resume = function() {
          var t3;
          null === (t3 = this.player) || void 0 === t3 || t3.resume();
        }, e2.prototype._doFrozen = function() {
          var t3;
          return hT(this, void 0, void 0, function() {
            var e3, i3, n3, r2 = this;
            return uT(this, function(o2) {
              switch (o2.label) {
                case 0:
                  return this.logger.info("frozen with player[" + !!this.player + "]", this.taskId), this.tracker({ name: "frozenSlide", reason: "", result: "", payload: { taskId: this.taskId } }), this.view && this.player ? [4, this.player.clock.waitUntil(function() {
                    return !r2.isLoading;
                  }, 6e4)] : [3, 2];
                case 1:
                  for (i3 in o2.sent(), e3 = this.player.getSnapshot() || "", this.cacheImage.src = e3, this.frame.appendChild(this.cacheImage), this.player.destroy(), null === (t3 = this.playerController) || void 0 === t3 || t3.destroy(), this.player = void 0, this.__slideState.mediaState) n3 = this.__slideState.mediaState[i3], this.__slideState.mediaState[i3] = aT(aT({}, n3), { frozenTime: this.timestamp() });
                  o2.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        }, e2.prototype.frozen = function() {
          var t3 = this;
          this.frozenTaskManager.addTask("frozen", function() {
            return t3._doFrozen();
          });
        }, e2.prototype._doRelease = function() {
          var t3, e3;
          return hT(this, void 0, void 0, function() {
            var i3, n3, r2, o2;
            return uT(this, function(s2) {
              switch (s2.label) {
                case 0:
                  if (this.logger.info("do release slide", this.taskId), this.tracker({ name: "releaseSlide", reason: "", result: "", payload: { taskId: this.taskId } }), this.player) return [2];
                  for (n3 in this.player = this.initPlayer(this.config), (null === (t3 = this.config) || void 0 === t3 ? void 0 : t3.controller) && this.createController(), this.player.view && (this.canvasContainer.appendChild(this.player.view), this.player.view.style.visibility = "hidden"), i3 = this.__slideState, this.__slideState = Qy()(mT), i3.mediaState) "play" === (r2 = i3.mediaState[n3]).type && (o2 = Math.max(null !== (e3 = r2.frozenTime) && void 0 !== e3 ? e3 : 0, r2.time), r2.time = this.timestamp() - (o2 - r2.time), r2.frozenTime = void 0);
                  return [4, this.setSlideState(i3)];
                case 1:
                  return s2.sent(), [4, this.player.clock.delay(333)];
                case 2:
                  s2.sent(), this.player.view && (this.player.view.style.visibility = "visible");
                  try {
                    this.frame.removeChild(this.cacheImage);
                  } catch (t4) {
                    this.logger.error("removeChild error Slide.ts:1934", this.taskId);
                  }
                  return [2];
              }
            });
          });
        }, e2.prototype.release = function() {
          var t3 = this;
          this.frozenTaskManager.addTask("release", function() {
            return t3._doRelease();
          });
        }, e2.prototype._doDestroy = function() {
          var t3, i3, n3, r2, o2 = this;
          this.logger.info("do destroy slide", this.taskId), this.tracker({ name: "destroySlide", reason: "", result: "", payload: { taskId: this.taskId } });
          var s2 = e2.instances.findIndex(function(t4) {
            return t4.randomId === o2.randomId;
          });
          if (s2 >= 0 && e2.instances.splice(s2, 1), this.playerController && this.playerController.destroy(), this.frameResizeObserver.disconnect(), null === (t3 = this.player) || void 0 === t3 || t3.removeAllListeners(), null === (i3 = this.player) || void 0 === i3 || i3.destroy(), null === (n3 = this.player) || void 0 === n3 || n3.removeAllListeners(), this.logger = { warn: function() {
            return {};
          }, info: function() {
            return {};
          }, error: function() {
            return {};
          } }, this.syncQueue.destroy(), this.renderingTaskManager.destroy(), this.frozenTaskManager.destroy(), window.removeEventListener("__slide_ref__", this.handleSlideRef), window.removeEventListener("message", this.recoverHandler), this.removeAllListeners(), null === (r2 = this.player) || void 0 === r2 ? void 0 : r2.view) try {
            this.anchor.removeChild(this.player.view);
          } catch (t4) {
            this.logger.error("removeChild error Slide.ts:1982", this.taskId);
          }
          try {
            this.anchor.removeChild(this.frame);
          } catch (t4) {
            this.logger.error("removeChild error Slide.ts:1988", this.taskId);
          }
          e2.volumeAdjuster.off("update", this._updateVolumeByStaticAdjuster);
        }, e2.prototype.waitLoadEnd = function() {
          return hT(this, void 0, void 0, function() {
            var t3;
            return uT(this, function(e3) {
              switch (e3.label) {
                case 0:
                  t3 = 0, e3.label = 1;
                case 1:
                  return this.isLoading && t3 < 10 ? [4, dT(100)] : [3, 3];
                case 2:
                  return e3.sent(), t3 += 1, [3, 1];
                case 3:
                  return [2];
              }
            });
          });
        }, e2.prototype.preload = function(t3) {
          return this.player ? this.player.preload(t3) : Promise.resolve();
        }, e2.prototype.destroy = function() {
          var t3 = this;
          this.logger.info("pre destroy slide", ""), this.isLoading ? this.waitLoadEnd().then(function() {
            t3._doDestroy();
          }) : this._doDestroy();
        }, e2.prototype.clearSlideCache = function() {
          var t3;
          null === (t3 = this.player) || void 0 === t3 || t3.clearLocalCache();
        }, e2.prototype.hasNextStep = function() {
          if (!this.player) return false;
          var t3 = this.player.currentIndex === this.slideCount, e3 = 0 === this.mainSeqLength || this.mainSeqStep >= this.mainSeqLength - 1, i3 = "end" === this.mainSeqState || "running" === this.mainSeqState || null == this.mainSeqState;
          return !(t3 && e3 && i3);
        }, e2.prototype.hasPrevStep = function() {
          if (!this.player) return false;
          var t3 = 1 === this.player.currentIndex, e3 = 0 === this.mainSeqLength || 0 === this.mainSeqStep, i3 = "idle" === this.mainSeqState || null === this.mainSeqState;
          return !(t3 && e3 && i3);
        }, e2.prototype.snapshot = function() {
          return hT(this, void 0, void 0, function() {
            return uT(this, function(t3) {
              return this.player ? [2, this.player.getSnapshot()] : [2, null];
            });
          });
        }, e2.prototype.snapshotWithTimingEnd = function(t3) {
          return hT(this, void 0, void 0, function() {
            return uT(this, function(e3) {
              return this.player ? [2, this.player.snapshotWithTimingEnd(t3)] : [2, null];
            });
          });
        }, e2.prototype.updateGlobalVolume = function(t3) {
          this.volumeAdjuster.volume = t3;
        }, e2.prototype.getGlobalVolume = function() {
          return this.volumeAdjuster.volume;
        }, e2.clearLocalCache = function() {
          Vy.clearLocalCache();
        }, e2.disposeLocalCache = function() {
        }, i2 = e2, e2.preloadResource = oT, e2.instances = [], e2._tempFrozenIds = [], e2._tempLog = "", e2._tempLogIndex = 1, e2.remoteLogAddress = null, e2.usePlugin = function(t3) {
          t3.context({ logger: { info: function(t4) {
            e2.appendLogString("INFO - " + (/* @__PURE__ */ new Date()).toISOString() + " - " + t4 + "\n");
          }, warn: function(t4) {
            e2.appendLogString("WARN - " + (/* @__PURE__ */ new Date()).toISOString() + " - " + t4 + "\n");
          }, error: function(t4) {
            e2.appendLogString("ERROR - " + (/* @__PURE__ */ new Date()).toISOString() + " - " + t4 + "\n");
          } } }), function(t4) {
            var e3 = Xy.get(t4.hookPoint) || [];
            e3.push(t4), Xy.set(t4.hookPoint, e3);
          }(t3);
        }, e2.volumeAdjuster = new Gy(), e2.trackLogger = new iT(), e2.handleFrozenAllSlide = function() {
          e2.instances.forEach(function(t3) {
            t3.player && (e2._tempFrozenIds.push(t3.randomId), t3.frozen());
          });
        }, e2.handleReleaseAllSlide = function() {
          e2._tempFrozenIds.forEach(function(t3) {
            var i3 = e2.instances.find(function(e3) {
              return e3.randomId === t3;
            });
            i3 && i3.release();
          }), e2._tempFrozenIds = [];
        }, e2.handleLogReport = function(t3) {
          return hT(void 0, void 0, void 0, function() {
            var n3, r2, o2, s2, a2, l2;
            return uT(i2, function(i3) {
              switch (i3.label) {
                case 0:
                  return [4, e2.flushLog(true)];
                case 1:
                  if (i3.sent(), !vT) return [3, 12];
                  n3 = [], i3.label = 2;
                case 2:
                  return i3.trys.push([2, 4, , 5]), [4, vT.keys()];
                case 3:
                  return n3 = (i3.sent() || []).sort(function(t4, e3) {
                    return parseInt(t4.replace("run_time_log_", "")) - parseInt(e3.replace("run_time_log_", ""));
                  }), [3, 5];
                case 4:
                  return i3.sent(), [3, 5];
                case 5:
                  if (0 === n3.length) return window.postMessage({ type: "@slide/_report_log_", log: "", index: 1, total: 1, customMessage: "@slide/_report_log_", sessionId: t3 }, "*"), [2];
                  r2 = 0, o2 = n3, i3.label = 6;
                case 6:
                  if (!(r2 < o2.length)) return [3, 12];
                  s2 = o2[r2], a2 = s2.replace("run_time_log_", ""), l2 = "", i3.label = 7;
                case 7:
                  return i3.trys.push([7, 9, , 10]), [4, vT.getItem(s2)];
                case 8:
                  return l2 = i3.sent() || "", [3, 10];
                case 9:
                  return i3.sent(), [3, 10];
                case 10:
                  window.postMessage({ type: "@slide/_report_log_", log: l2, index: parseInt(a2, 10), total: n3.length, customMessage: "@slide/_report_log_", sessionId: t3 }, "*"), i3.label = 11;
                case 11:
                  return r2++, [3, 6];
                case 12:
                  return [2];
              }
            });
          });
        }, e2.handleLogDownload = function() {
          return hT(void 0, void 0, void 0, function() {
            var t3, n3, r2, o2, s2, a2, l2;
            return uT(i2, function(i3) {
              switch (i3.label) {
                case 0:
                  return i3.trys.push([0, 7, , 8]), [4, e2.flushLog(true)];
                case 1:
                  return i3.sent(), t3 = "", vT ? [4, vT.keys()] : [3, 6];
                case 2:
                  n3 = (i3.sent() || []).sort(function(t4, e3) {
                    return parseInt(t4.replace("run_time_log_", "")) - parseInt(e3.replace("run_time_log_", ""));
                  }), r2 = 0, o2 = n3, i3.label = 3;
                case 3:
                  return r2 < o2.length ? (s2 = o2[r2], a2 = t3, [4, vT.getItem(s2)]) : [3, 6];
                case 4:
                  t3 = a2 + (i3.sent() || ""), i3.label = 5;
                case 5:
                  return r2++, [3, 3];
                case 6:
                  return (l2 = document.createElement("a")).setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(t3)), l2.setAttribute("download", "slide_log"), l2.style.display = "none", document.body.appendChild(l2), l2.click(), document.body.removeChild(l2), [3, 8];
                case 7:
                  return i3.sent(), [3, 8];
                case 8:
                  return [2];
              }
            });
          });
        }, lT([(n2 = "Slide.initConfig", function(t3, e3, i3) {
          var r2 = i3.value;
          i3.value = function() {
            for (var t4 = [], e4 = 0; e4 < arguments.length; e4++) t4[e4] = arguments[e4];
            for (var i4 = Xy.get(n2) || [], o2 = t4, s2 = 0, a2 = i4; s2 < a2.length; s2++) {
              var l2 = a2[s2];
              try {
                o2 = l2.before(o2);
              } catch (t5) {
              }
              if (!Array.isArray(o2) || o2.length !== t4.length) throw new Error("plugin before hook return invalid args");
            }
            for (var h2 = r2.bind(this).apply(void 0, o2), u2 = 0, c2 = i4.reverse(); u2 < c2.length; u2++) {
              l2 = c2[u2];
              try {
                h2 = l2.after(h2);
              } catch (t5) {
              }
              if (!h2) throw new Error("plugin after hook return undefined result");
            }
            return h2;
          };
        })], e2.prototype, "initSlideConfig", null), e2;
      }(Za.a);
      null == vT || vT.clear().catch(function() {
      }), window.addEventListener("__slide_log__", _T.handleLogDownload), window.addEventListener("message", function(t2) {
        if ("@slide/_request_log_" === t2.data.type) _T.handleLogReport(t2.data.sessionId).catch(function() {
        });
        else if ("@slide/_request_frozen_" === t2.data.type) _T.handleFrozenAllSlide();
        else if ("@slide/_request_release_" === t2.data.type) _T.handleReleaseAllSlide();
        else if ("@slide/_update_volume_" === t2.data.type) {
          var e2 = 0.5;
          try {
            e2 = parseFloat(t2.data.volume.toString());
          } catch (t3) {
          }
          _T.volumeAdjuster.volume = e2;
        } else "@slide/_get_volume_" === t2.data.type ? window.postMessage({ type: "@slide/_report_volume_", volume: _T.volumeAdjuster.volume, customMessage: "@slide/_report_volume_" }, "*") : "@slide/_preload_slide_" === t2.data.type && _T.preloadResource(t2.data.taskId, t2.data.prefix, t2.data.maxResolutionLevel, function(e3) {
          window.postMessage({ type: "@slide/_preload_slide_progress_", taskId: t2.data.taskId, progress: e3 }, "*");
        }).catch(function(e3) {
          window.postMessage({ type: "@slide/_preload_slide_error_", taskId: t2.data.taskId, error: e3 }, "*");
        });
      }), window.setInterval(function() {
        _T.flushLog().catch(function() {
        });
      }, 2e3);
    }]);
  }
});

// render.ts
var import_slide = __toESM(require_Slide());
var render_default = {
  setup(dom, ctx) {
    console.log("setup");
    const disposer = ctx.events.on("message", (message) => {
      console.log("payload", message.payload);
      if (Object.keys(message.payload).length === 0) {
        return () => {
          disposer();
        };
      }
      const anchor = document.createElement("div");
      anchor.style.height = "400px";
      dom.appendChild(anchor);
      const slide = new import_slide.Slide({
        anchor,
        mode: "local",
        interactive: true,
        logger: console
      });
      slide.setResource(message.payload.uuid, message.payload.prefix);
      const pageCountEl = document.createElement("span");
      let currentIndex = 1;
      slide.renderSlide(currentIndex);
      slide.on("renderEnd", async (index) => {
        currentIndex = index;
        pageCountEl.textContent = `${index} / ${await slide.getSlideCountAsync()}`;
      });
      console.log(slide);
      window.slide = slide;
      const controllerContainer = document.createElement("div");
      const prevStepButton = document.createElement("button");
      prevStepButton.textContent = "<";
      prevStepButton.addEventListener("click", () => slide.prevStep());
      const nextStepButton = document.createElement("button");
      nextStepButton.textContent = ">";
      nextStepButton.addEventListener("click", () => slide.nextStep());
      const prevPageButton = document.createElement("button");
      prevPageButton.textContent = "<<";
      prevPageButton.addEventListener("click", () => slide.renderSlide(currentIndex - 1));
      const nextPageButton = document.createElement("button");
      nextPageButton.textContent = ">>";
      nextPageButton.addEventListener("click", () => slide.renderSlide(currentIndex + 1));
      controllerContainer.append(prevPageButton, prevStepButton, pageCountEl, nextStepButton, nextPageButton);
      controllerContainer.style.display = "flex";
      controllerContainer.style.width = "50%";
      controllerContainer.style.transform = "translate(50%, 0)";
      controllerContainer.style.justifyContent = "space-between";
      controllerContainer.style.alignItems = "center";
      dom.appendChild(controllerContainer);
      return () => {
        disposer();
        slide.destroy();
        dom.removeChild(anchor);
        dom.removeChild(controllerContainer);
        prevStepButton.removeEventListener("click", () => slide.prevStep());
        nextStepButton.removeEventListener("click", () => slide.nextStep());
      };
    });
  }
};
export {
  render_default as default
};
/*! Bundled license information:

@netless/slide/lib/Slide.js:
  (*!
   * @pixi/constants - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/constants is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/math - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/math is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/core - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/core is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
  (*!
   * @pixi/settings - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/settings is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/display - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/display is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/ticker - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/ticker is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/runner - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/runner is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/utils - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/utils is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*!
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   * @pixi/polyfill - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/polyfill is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
  (**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
  (*!
   * @pixi/extract - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/compressed-textures - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/compressed-textures is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/prepare - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/prepare is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/filter-displacement - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/filter-displacement is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * pixi.js - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * pixi.js is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/canvas-sprite - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-sprite is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/canvas-extract - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-extract is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
  (*!
   * @pixi/canvas-sprite-tiling - v6.4.2
   * Compiled Thu, 02 Jun 2022 15:39:26 UTC
   *
   * @pixi/canvas-sprite-tiling is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
*/
